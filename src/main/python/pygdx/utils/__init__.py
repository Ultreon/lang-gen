from __future__ import annotations
from overload import overload


 
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Keys
_Keys = _ObjectLongMap_Keys.Keys
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.ObjectLongMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap$Keys.hasNext()"""
        return bool._wrap(super(Keys, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def iterator(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectLongMap$Keys<K> com.badlogic.gdx.utils.ObjectLongMap$Keys.iterator()"""
        return 'Keys'._wrap(super(Keys, self).iterator())

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectLongMap$Keys.toArray(com.badlogic.gdx.utils.Array<K>)"""
        return 'Array'._wrap(super(_Keys, self).toArray(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.ObjectLongMap$Keys.next()"""
        return object._wrap(super(Keys, self).next())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: 'ObjectLongMap'):
        """public com.badlogic.gdx.utils.ObjectLongMap$Keys(com.badlogic.gdx.utils.ObjectLongMap<K>)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectLongMap$Keys.toArray()"""
        return 'Array'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectLongMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Keys
_Keys = _ObjectLongMap_Keys.Keys
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.ObjectLongMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap$Keys.hasNext()"""
        return bool._wrap(super(Keys, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def iterator(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectLongMap$Keys<K> com.badlogic.gdx.utils.ObjectLongMap$Keys.iterator()"""
        return 'Keys'._wrap(super(Keys, self).iterator())

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectLongMap$Keys.toArray(com.badlogic.gdx.utils.Array<K>)"""
        return 'Array'._wrap(super(_Keys, self).toArray(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.ObjectLongMap$Keys.next()"""
        return object._wrap(super(Keys, self).next())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: 'ObjectLongMap'):
        """public com.badlogic.gdx.utils.ObjectLongMap$Keys(com.badlogic.gdx.utils.ObjectLongMap<K>)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectLongMap$Keys.toArray()"""
        return 'Array'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectLongMap$Keys 
 
 
# CLASS: com.badlogic.gdx.utils.PerformanceCounter
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.Float as _float
import com.badlogic.gdx.utils.StringBuilder as _StringBuilder
_StringBuilder = _StringBuilder
import java.lang.String as _string
import com.badlogic.gdx.utils.PerformanceCounter as _PerformanceCounter
_PerformanceCounter = _PerformanceCounter
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class PerformanceCounter():
    """com.badlogic.gdx.utils.PerformanceCounter"""
 
    @staticmethod
    def _wrap(java_value: _PerformanceCounter) -> 'PerformanceCounter':
        return PerformanceCounter(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PerformanceCounter):
        """
        Dynamic initializer for PerformanceCounter.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PerformanceCounter__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PerformanceCounter__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, arg0: str, arg1: int):
        """public com.badlogic.gdx.utils.PerformanceCounter(java.lang.String,int)"""
        val = _PerformanceCounter(arg0, _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def __init__(self, arg0: str):
        """public com.badlogic.gdx.utils.PerformanceCounter(java.lang.String)"""
        val = _PerformanceCounter(arg0)
        self.__wrapper = val

    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.PerformanceCounter.reset()"""
        super(PerformanceCounter, self).reset()

    @overload
    def toString(self, arg0: 'StringBuilder') -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.PerformanceCounter.toString(com.badlogic.gdx.utils.StringBuilder)"""
        return 'StringBuilder'._wrap(super(_PerformanceCounter, self).toString(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def tick(self):
        """public void com.badlogic.gdx.utils.PerformanceCounter.tick()"""
        super(PerformanceCounter, self).tick()

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def start(self):
        """public void com.badlogic.gdx.utils.PerformanceCounter.start()"""
        super(PerformanceCounter, self).start()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def tick(self, arg0: float):
        """public void com.badlogic.gdx.utils.PerformanceCounter.tick(float)"""
        super(_PerformanceCounter, self).tick(_float.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def stop(self):
        """public void com.badlogic.gdx.utils.PerformanceCounter.stop()"""
        super(PerformanceCounter, self).stop()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.PerformanceCounter.toString()"""
        return str._wrap(super(PerformanceCounter, self).toString())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.CharArray
from builtins import str
import java.lang.Character as _char
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import com.badlogic.gdx.utils.CharArray as _CharArray
_CharArray = _CharArray
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class CharArray():
    """com.badlogic.gdx.utils.CharArray"""
 
    @staticmethod
    def _wrap(java_value: _CharArray) -> 'CharArray':
        return CharArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _CharArray):
        """
        Dynamic initializer for CharArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_CharArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_CharArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.CharArray.truncate(int)"""
        super(_CharArray, self).truncate(_int.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.CharArray()"""
        val = _CharArray()
        self.__wrapper = val

    @overload
    def mul(self, arg0: str):
        """public void com.badlogic.gdx.utils.CharArray.mul(char)"""
        super(_CharArray, self).mul(_char.valueOf(arg0))

    @overload
    def __init__(self, arg0: 'char'):
        """public com.badlogic.gdx.utils.CharArray(char[])"""
        val = _CharArray(arg0)
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def incr(self, arg0: str):
        """public void com.badlogic.gdx.utils.CharArray.incr(char)"""
        super(_CharArray, self).incr(_char.valueOf(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.CharArray(int)"""
        val = _CharArray(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.CharArray.swap(int,int)"""
        super(_CharArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.CharArray.shuffle()"""
        super(CharArray, self).shuffle()

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.CharArray.notEmpty()"""
        return bool._wrap(super(CharArray, self).notEmpty())

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.CharArray.isEmpty()"""
        return bool._wrap(super(CharArray, self).isEmpty())

    @overload
    def indexOf(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.CharArray.indexOf(char)"""
        return int._wrap(super(_CharArray, self).indexOf(_char.valueOf(arg0)))

    @overload
    def __init__(self, arg0: bool, arg1: 'char', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.CharArray(boolean,char[],int,int)"""
        val = _CharArray(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @overload
    def add(self, arg0: str, arg1: str, arg2: str):
        """public void com.badlogic.gdx.utils.CharArray.add(char,char,char)"""
        super(_CharArray, self).add(_char.valueOf(arg0), _char.valueOf(arg1), _char.valueOf(arg2))

    @overload
    def mul(self, arg0: int, arg1: str):
        """public void com.badlogic.gdx.utils.CharArray.mul(int,char)"""
        super(_CharArray, self).mul(_int.valueOf(arg0), _char.valueOf(arg1))

    @overload
    def contains(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.CharArray.contains(char)"""
        return bool._wrap(super(_CharArray, self).contains(_char.valueOf(arg0)))

    @overload
    def removeValue(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.CharArray.removeValue(char)"""
        return bool._wrap(super(_CharArray, self).removeValue(_char.valueOf(arg0)))

    @overload
    def random(self) -> str:
        """public char com.badlogic.gdx.utils.CharArray.random()"""
        return str._wrap(super(CharArray, self).random())

    @overload
    def incr(self, arg0: int, arg1: str):
        """public void com.badlogic.gdx.utils.CharArray.incr(int,char)"""
        super(_CharArray, self).incr(_int.valueOf(arg0), _char.valueOf(arg1))

    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.CharArray.sort()"""
        super(CharArray, self).sort()

    @overload
    def first(self) -> str:
        """public char com.badlogic.gdx.utils.CharArray.first()"""
        return str._wrap(super(CharArray, self).first())

    @staticmethod
    @overload
    def with(*arg0: str) -> 'CharArray':
        """public static com.badlogic.gdx.utils.CharArray com.badlogic.gdx.utils.CharArray.with(char...)"""
        return CharArray._wrap(_CharArray.with(arg0))

    @overload
    def removeAll(self, arg0: 'CharArray') -> bool:
        """public boolean com.badlogic.gdx.utils.CharArray.removeAll(com.badlogic.gdx.utils.CharArray)"""
        return bool._wrap(super(_CharArray, self).removeAll(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.CharArray.removeRange(int,int)"""
        super(_CharArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def pop(self) -> str:
        """public char com.badlogic.gdx.utils.CharArray.pop()"""
        return str._wrap(super(CharArray, self).pop())

    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.CharArray.insertRange(int,int)"""
        super(_CharArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.CharArray.hashCode()"""
        return int._wrap(super(CharArray, self).hashCode())

    @overload
    def add(self, arg0: str, arg1: str, arg2: str, arg3: str):
        """public void com.badlogic.gdx.utils.CharArray.add(char,char,char,char)"""
        super(_CharArray, self).add(_char.valueOf(arg0), _char.valueOf(arg1), _char.valueOf(arg2), _char.valueOf(arg3))

    @overload
    def insert(self, arg0: int, arg1: str):
        """public void com.badlogic.gdx.utils.CharArray.insert(int,char)"""
        super(_CharArray, self).insert(_int.valueOf(arg0), _char.valueOf(arg1))

    @overload
    def addAll(self, arg0: 'CharArray'):
        """public void com.badlogic.gdx.utils.CharArray.addAll(com.badlogic.gdx.utils.CharArray)"""
        super(_CharArray, self).addAll(arg0)

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.CharArray.clear()"""
        super(CharArray, self).clear()

    @overload
    def peek(self) -> str:
        """public char com.badlogic.gdx.utils.CharArray.peek()"""
        return str._wrap(super(CharArray, self).peek())

    @overload
    def ensureCapacity(self, arg0: int) -> List[str]:
        """public char[] com.badlogic.gdx.utils.CharArray.ensureCapacity(int)"""
        return List[str]._wrap(super(_CharArray, self).ensureCapacity(_int.valueOf(arg0)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.CharArray.toString()"""
        return str._wrap(super(CharArray, self).toString())

    @overload
    def toArray(self) -> List[str]:
        """public char[] com.badlogic.gdx.utils.CharArray.toArray()"""
        return List[str]._wrap(super(CharArray, self).toArray())

    @overload
    def addAll(self, *arg0: str):
        """public void com.badlogic.gdx.utils.CharArray.addAll(char...)"""
        super(_CharArray, self).addAll(arg0)

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.CharArray.toString(java.lang.String)"""
        return str._wrap(super(_CharArray, self).toString(arg0))

    @overload
    def removeIndex(self, arg0: int) -> str:
        """public char com.badlogic.gdx.utils.CharArray.removeIndex(int)"""
        return str._wrap(super(_CharArray, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.CharArray.reverse()"""
        super(CharArray, self).reverse()

    @overload
    def __init__(self, arg0: 'CharArray'):
        """public com.badlogic.gdx.utils.CharArray(com.badlogic.gdx.utils.CharArray)"""
        val = _CharArray(arg0)
        self.__wrapper = val

    @overload
    def set(self, arg0: int, arg1: str):
        """public void com.badlogic.gdx.utils.CharArray.set(int,char)"""
        super(_CharArray, self).set(_int.valueOf(arg0), _char.valueOf(arg1))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.CharArray()"""
        val = _CharArray()
        self.__wrapper = val

    @overload
    def setSize(self, arg0: int) -> List[str]:
        """public char[] com.badlogic.gdx.utils.CharArray.setSize(int)"""
        return List[str]._wrap(super(_CharArray, self).setSize(_int.valueOf(arg0)))

    @overload
    def addAll(self, arg0: 'CharArray', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.CharArray.addAll(com.badlogic.gdx.utils.CharArray,int,int)"""
        super(_CharArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.CharArray.equals(java.lang.Object)"""
        return bool._wrap(super(_CharArray, self).equals(arg0))

    @overload
    def get(self, arg0: int) -> str:
        """public char com.badlogic.gdx.utils.CharArray.get(int)"""
        return str._wrap(super(_CharArray, self).get(_int.valueOf(arg0)))

    @overload
    def shrink(self) -> List[str]:
        """public char[] com.badlogic.gdx.utils.CharArray.shrink()"""
        return List[str]._wrap(super(CharArray, self).shrink())

    @overload
    def add(self, arg0: str):
        """public void com.badlogic.gdx.utils.CharArray.add(char)"""
        super(_CharArray, self).add(_char.valueOf(arg0))

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.CharArray(boolean,int)"""
        val = _CharArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def lastIndexOf(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.CharArray.lastIndexOf(char)"""
        return int._wrap(super(_CharArray, self).lastIndexOf(_char.valueOf(arg0)))

    @overload
    def add(self, arg0: str, arg1: str):
        """public void com.badlogic.gdx.utils.CharArray.add(char,char)"""
        super(_CharArray, self).add(_char.valueOf(arg0), _char.valueOf(arg1))

    @overload
    def addAll(self, arg0: 'char', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.CharArray.addAll(char[],int,int)"""
        super(_CharArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2)) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectMap$Entry
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entry
_Entry = _ObjectMap_Entry.Entry
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entry():
    """com.badlogic.gdx.utils.ObjectMap.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectMap$Entry.toString()"""
        return str._wrap(super(Entry, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.UBJsonWriter
from builtins import str
import java.lang.Character as _char
import java.lang.Double as _double
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import float
import java.lang.String as _String
_String = _String
import java.lang.Short as _short
import java.lang.Float as _float
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.io.OutputStream as OutputStream
import java.lang.Byte as _byte
from builtins import bool
import java.lang.Long as _long
import com.badlogic.gdx.utils.UBJsonWriter as _UBJsonWriter
_UBJsonWriter = _UBJsonWriter
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class UBJsonWriter():
    """com.badlogic.gdx.utils.UBJsonWriter"""
 
    @staticmethod
    def _wrap(java_value: _UBJsonWriter) -> 'UBJsonWriter':
        return UBJsonWriter(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _UBJsonWriter):
        """
        Dynamic initializer for UBJsonWriter.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_UBJsonWriter__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_UBJsonWriter__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def set(self, arg0: str, arg1: 'float') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,float[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @overload
    def value(self, arg0: int) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(byte) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(_byte.valueOf(arg0)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def value(self, arg0: object) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(java.lang.Object) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def value(self, arg0: 'long') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(long[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def set(self, arg0: str, arg1: 'long') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,long[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @overload
    def value(self, arg0: int) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(int) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(_int.valueOf(arg0)))

    @overload
    def array(self, arg0: str) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.array(java.lang.String) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).array(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def set(self, arg0: str, arg1: 'double') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,double[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @overload
    def set(self, arg0: str, arg1: int) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,long) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, _long.valueOf(arg1)))

    @overload
    def value(self, arg0: int) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(short) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(_short.valueOf(arg0)))

    @overload
    def array(self) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.array() throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(UBJsonWriter, self).array())

    @overload
    def set(self, arg0: str, arg1: int) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,byte) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, _byte.valueOf(arg1)))

    @overload
    def value(self, arg0: 'JsonValue') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(com.badlogic.gdx.utils.JsonValue) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @overload
    def set(self, arg0: str, arg1: int) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,int) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, _int.valueOf(arg1)))

    @overload
    def pop(self) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.pop() throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(UBJsonWriter, self).pop())

    @overload
    def set(self, arg0: str, arg1: float) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,float) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, _float.valueOf(arg1)))

    @overload
    def value(self, arg0: str) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(java.lang.String) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def value(self, arg0: 'boolean') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(boolean[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def set(self, arg0: str, arg1: 'short') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,short[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @overload
    def set(self, arg0: str, arg1: str) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,char) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, _char.valueOf(arg1)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def value(self, arg0: 'short') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(short[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def value(self) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value() throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(UBJsonWriter, self).value())

    @overload
    def value(self, arg0: str) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(char) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(_char.valueOf(arg0)))

    @override
    @overload
    def close(self):
        """public void com.badlogic.gdx.utils.UBJsonWriter.close() throws java.io.IOException"""
        super(UBJsonWriter, self).close()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def set(self, arg0: str, arg1: 'String') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,java.lang.String[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def value(self, arg0: int) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(long) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(_long.valueOf(arg0)))

    @overload
    def set(self, arg0: str, arg1: int) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,short) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, _short.valueOf(arg1)))

    @overload
    def set(self, arg0: str, arg1: str) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,java.lang.String) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @overload
    def set(self, arg0: str, arg1: bytes) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,byte[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, bytes))

    @overload
    def value(self, arg0: 'float') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(float[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def set(self, arg0: str, arg1: 'boolean') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,boolean[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @overload
    def value(self, arg0: 'char') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(char[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def set(self, arg0: str, arg1: 'char') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,char[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @overload
    def set(self, arg0: str, arg1: float) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,double) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, _double.valueOf(arg1)))

    @overload
    def value(self, arg0: float) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(double) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(_double.valueOf(arg0)))

    @overload
    def value(self, arg0: 'double') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(double[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def set(self, arg0: str) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0))

    @overload
    def set(self, arg0: str, arg1: bool) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,boolean) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, _boolean.valueOf(arg1)))

    @overload
    def value(self, arg0: bytes) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(byte[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(bytes))

    @overload
    def flush(self):
        """public void com.badlogic.gdx.utils.UBJsonWriter.flush() throws java.io.IOException"""
        super(UBJsonWriter, self).flush()

    @overload
    def set(self, arg0: str, arg1: 'int') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.set(java.lang.String,int[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).set(arg0, arg1))

    @overload
    def name(self, arg0: str) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.name(java.lang.String) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).name(arg0))

    @overload
    def __init__(self, arg0: 'OutputStream'):
        """public com.badlogic.gdx.utils.UBJsonWriter(java.io.OutputStream)"""
        val = _UBJsonWriter(arg0)
        self.__wrapper = val

    @overload
    def value(self, arg0: 'int') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(int[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def value(self, arg0: 'String') -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(java.lang.String[]) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(arg0))

    @overload
    def value(self, arg0: bool) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(boolean) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(_boolean.valueOf(arg0)))

    @overload
    def object(self) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.object() throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(UBJsonWriter, self).object())

    @overload
    def value(self, arg0: float) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.value(float) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).value(_float.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def object(self, arg0: str) -> 'UBJsonWriter':
        """public com.badlogic.gdx.utils.UBJsonWriter com.badlogic.gdx.utils.UBJsonWriter.object(java.lang.String) throws java.io.IOException"""
        return 'UBJsonWriter'._wrap(super(_UBJsonWriter, self).object(arg0)) 
 
 
# CLASS: com.badlogic.gdx.utils.LongMap$Entries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.LongMap as _LongMap_Entries
_Entries = _LongMap_Entries.Entries
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import com.badlogic.gdx.utils.LongMap as _LongMap_Entry
_Entry = _LongMap_Entry.Entry
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.LongMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LongMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.LongMap$Entry<V> com.badlogic.gdx.utils.LongMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.LongMap$Entry<V>> com.badlogic.gdx.utils.LongMap$Entries.iterator()"""
        return 'Iterator'._wrap(super(Entries, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'LongMap'):
        """public com.badlogic.gdx.utils.LongMap$Entries(com.badlogic.gdx.utils.LongMap)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.LongQueue
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.String as _string
import java.lang.Integer as _int
import com.badlogic.gdx.utils.LongQueue as _LongQueue
_LongQueue = _LongQueue
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class LongQueue():
    """com.badlogic.gdx.utils.LongQueue"""
 
    @staticmethod
    def _wrap(java_value: _LongQueue) -> 'LongQueue':
        return LongQueue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _LongQueue):
        """
        Dynamic initializer for LongQueue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_LongQueue__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_LongQueue__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.LongQueue.toString(java.lang.String)"""
        return str._wrap(super(_LongQueue, self).toString(arg0))

    @overload
    def addLast(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongQueue.addLast(long)"""
        super(_LongQueue, self).addLast(_long.valueOf(arg0))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LongQueue.isEmpty()"""
        return bool._wrap(super(LongQueue, self).isEmpty())

    @overload
    def get(self, arg0: int) -> int:
        """public long com.badlogic.gdx.utils.LongQueue.get(int)"""
        return int._wrap(super(_LongQueue, self).get(_int.valueOf(arg0)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def removeIndex(self, arg0: int) -> int:
        """public long com.badlogic.gdx.utils.LongQueue.removeIndex(int)"""
        return int._wrap(super(_LongQueue, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def removeFirst(self) -> int:
        """public long com.badlogic.gdx.utils.LongQueue.removeFirst()"""
        return int._wrap(super(LongQueue, self).removeFirst())

    @overload
    def indexOf(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.LongQueue.indexOf(long)"""
        return int._wrap(super(_LongQueue, self).indexOf(_long.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addFirst(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongQueue.addFirst(long)"""
        super(_LongQueue, self).addFirst(_long.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.LongQueue()"""
        val = _LongQueue()
        self.__wrapper = val

    @overload
    def removeValue(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.LongQueue.removeValue(long)"""
        return bool._wrap(super(_LongQueue, self).removeValue(_long.valueOf(arg0)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.LongQueue.toString()"""
        return str._wrap(super(LongQueue, self).toString())

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.LongQueue.clear()"""
        super(LongQueue, self).clear()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.LongQueue.equals(java.lang.Object)"""
        return bool._wrap(super(_LongQueue, self).equals(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.LongQueue(int)"""
        val = _LongQueue(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def first(self) -> int:
        """public long com.badlogic.gdx.utils.LongQueue.first()"""
        return int._wrap(super(LongQueue, self).first())

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LongQueue.notEmpty()"""
        return bool._wrap(super(LongQueue, self).notEmpty())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.LongQueue()"""
        val = _LongQueue()
        self.__wrapper = val

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongQueue.ensureCapacity(int)"""
        super(_LongQueue, self).ensureCapacity(_int.valueOf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.LongQueue.hashCode()"""
        return int._wrap(super(LongQueue, self).hashCode())

    @overload
    def last(self) -> int:
        """public long com.badlogic.gdx.utils.LongQueue.last()"""
        return int._wrap(super(LongQueue, self).last())

    @overload
    def removeLast(self) -> int:
        """public long com.badlogic.gdx.utils.LongQueue.removeLast()"""
        return int._wrap(super(LongQueue, self).removeLast())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.badlogic.gdx.utils.StreamUtils
import com.badlogic.gdx.utils.StreamUtils as _StreamUtils
_StreamUtils = _StreamUtils
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.io.Closeable as Closeable
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.String as _string
import java.lang.Integer as _int
import java.io.OutputStream as OutputStream
import java.io.InputStream as InputStream
import java.nio.ByteBuffer as ByteBuffer
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StreamUtils():
    """com.badlogic.gdx.utils.StreamUtils"""
 
    @staticmethod
    def _wrap(java_value: _StreamUtils) -> 'StreamUtils':
        return StreamUtils(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StreamUtils):
        """
        Dynamic initializer for StreamUtils.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StreamUtils__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StreamUtils__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copyStream(arg0: 'InputStream', arg1: 'OutputStream'):
        """public static void com.badlogic.gdx.utils.StreamUtils.copyStream(java.io.InputStream,java.io.OutputStream) throws java.io.IOException"""
        _StreamUtils.copyStream(arg0, arg1)

    @staticmethod
    @overload
    def closeQuietly(arg0: 'Closeable'):
        """public static void com.badlogic.gdx.utils.StreamUtils.closeQuietly(java.io.Closeable)"""
        _StreamUtils.closeQuietly(arg0)

    @staticmethod
    @overload
    def copyStream(arg0: 'InputStream', arg1: 'ByteBuffer'):
        """public static void com.badlogic.gdx.utils.StreamUtils.copyStream(java.io.InputStream,java.nio.ByteBuffer) throws java.io.IOException"""
        _StreamUtils.copyStream(arg0, arg1)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def copyStream(arg0: 'InputStream', arg1: 'OutputStream', arg2: int):
        """public static void com.badlogic.gdx.utils.StreamUtils.copyStream(java.io.InputStream,java.io.OutputStream,int) throws java.io.IOException"""
        _StreamUtils.copyStream(arg0, arg1, _int.valueOf(arg2))

    @staticmethod
    @overload
    def copyStreamToString(arg0: 'InputStream', arg1: int) -> str:
        """public static java.lang.String com.badlogic.gdx.utils.StreamUtils.copyStreamToString(java.io.InputStream,int) throws java.io.IOException"""
        return str._wrap(_StreamUtils.copyStreamToString(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def copyStreamToString(arg0: 'InputStream', arg1: int, arg2: str) -> str:
        """public static java.lang.String com.badlogic.gdx.utils.StreamUtils.copyStreamToString(java.io.InputStream,int,java.lang.String) throws java.io.IOException"""
        return str._wrap(_StreamUtils.copyStreamToString(arg0, _int.valueOf(arg1), arg2))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def copyStreamToString(arg0: 'InputStream') -> str:
        """public static java.lang.String com.badlogic.gdx.utils.StreamUtils.copyStreamToString(java.io.InputStream) throws java.io.IOException"""
        return str._wrap(_StreamUtils.copyStreamToString(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def copyStream(arg0: 'InputStream', arg1: 'ByteBuffer', arg2: bytes) -> int:
        """public static int com.badlogic.gdx.utils.StreamUtils.copyStream(java.io.InputStream,java.nio.ByteBuffer,byte[]) throws java.io.IOException"""
        return int._wrap(_StreamUtils.copyStream(arg0, arg1, bytes))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def copyStream(arg0: 'InputStream', arg1: 'OutputStream', arg2: bytes):
        """public static void com.badlogic.gdx.utils.StreamUtils.copyStream(java.io.InputStream,java.io.OutputStream,byte[]) throws java.io.IOException"""
        _StreamUtils.copyStream(arg0, arg1, bytes)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def copyStreamToByteArray(arg0: 'InputStream', arg1: int) -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.StreamUtils.copyStreamToByteArray(java.io.InputStream,int) throws java.io.IOException"""
        return List[int]._wrap(_StreamUtils.copyStreamToByteArray(arg0, _int.valueOf(arg1)))

    @staticmethod
    @overload
    def copyStream(arg0: 'InputStream', arg1: 'ByteBuffer', arg2: int):
        """public static void com.badlogic.gdx.utils.StreamUtils.copyStream(java.io.InputStream,java.nio.ByteBuffer,int) throws java.io.IOException"""
        _StreamUtils.copyStream(arg0, arg1, _int.valueOf(arg2))

    @staticmethod
    @overload
    def copyStreamToByteArray(arg0: 'InputStream') -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.StreamUtils.copyStreamToByteArray(java.io.InputStream) throws java.io.IOException"""
        return List[int]._wrap(_StreamUtils.copyStreamToByteArray(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.StreamUtils()"""
        val = _StreamUtils()
        self.__wrapper = val

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.StreamUtils()"""
        val = _StreamUtils()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectIntMap$Entry
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap_Entry
_Entry = _ObjectIntMap_Entry.Entry
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entry():
    """com.badlogic.gdx.utils.ObjectIntMap.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectIntMap$Entry.toString()"""
        return str._wrap(super(Entry, self).toString())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectIntMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectIntMap$Entry()"""
        val = _Entry()
        self.__wrapper = val 
 
 
# CLASS: com.badlogic.gdx.utils.IdentityMap
from builtins import str
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Values
_Values = _ObjectMap_Values.Values
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap
_ObjectMap = _ObjectMap
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entries
_Entries = _ObjectMap_Entries.Entries
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Keys
_Keys = _ObjectMap_Keys.Keys
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import java.lang.Long as _long
import com.badlogic.gdx.utils.IdentityMap as _IdentityMap
_IdentityMap = _IdentityMap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class IdentityMap():
    """com.badlogic.gdx.utils.IdentityMap"""
 
    @staticmethod
    def _wrap(java_value: _IdentityMap) -> 'IdentityMap':
        return IdentityMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _IdentityMap):
        """
        Dynamic initializer for IdentityMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_IdentityMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_IdentityMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, arg0: 'IdentityMap'):
        """public com.badlogic.gdx.utils.IdentityMap(com.badlogic.gdx.utils.IdentityMap<K, V>)"""
        val = _IdentityMap(arg0)
        self.__wrapper = val

    @override
    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectMap$Values<V> com.badlogic.gdx.utils.ObjectMap.values()"""
        return 'Values'._wrap(super(ObjectMap, self).values())

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.IdentityMap(int,float)"""
        val = _IdentityMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IdentityMap()"""
        val = _IdentityMap()
        self.__wrapper = val

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IdentityMap()"""
        val = _IdentityMap()
        self.__wrapper = val

    @override
    @overload
    def putAll(self, arg0: 'ObjectMap'):
        """public void com.badlogic.gdx.utils.ObjectMap.putAll(com.badlogic.gdx.utils.ObjectMap<? extends K, ? extends V>)"""
        super(_ObjectMap, self).putAll(arg0)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def containsValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.containsValue(java.lang.Object,boolean)"""
        return bool._wrap(super(_ObjectMap, self).containsValue(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectMap$Keys<K> com.badlogic.gdx.utils.ObjectMap.keys()"""
        return 'Keys'._wrap(super(ObjectMap, self).keys())

    @override
    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectMap$Entries<K, V> com.badlogic.gdx.utils.ObjectMap.entries()"""
        return 'Entries'._wrap(super(ObjectMap, self).entries())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.IdentityMap(int)"""
        val = _IdentityMap(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectMap$Entries<K, V> com.badlogic.gdx.utils.ObjectMap.iterator()"""
        return 'Entries'._wrap(super(ObjectMap, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectMap.toString(java.lang.String)"""
        return str._wrap(super(_ObjectMap, self).toString(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectMap.toString()"""
        return str._wrap(super(ObjectMap, self).toString())

    @override
    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectMap.shrink(int)"""
        super(_ObjectMap, self).shrink(_int.valueOf(arg0))

    @overload
    def get(self, arg0: object) -> object:
        """public <T extends K> V com.badlogic.gdx.utils.ObjectMap.get(T)"""
        return object._wrap(super(_ObjectMap, self).get(arg0))

    @overload
    def containsKey(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.containsKey(K)"""
        return bool._wrap(super(_ObjectMap, self).containsKey(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def get(self, arg0: object, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.ObjectMap.get(K,V)"""
        return object._wrap(super(_ObjectMap, self).get(arg0, arg1))

    @override
    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.notEmpty()"""
        return bool._wrap(super(ObjectMap, self).notEmpty())

    @override
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ObjectMap.clear()"""
        super(ObjectMap, self).clear()

    @override
    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectMap.clear(int)"""
        super(_ObjectMap, self).clear(_int.valueOf(arg0))

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_ObjectMap, self).equalsIdentity(arg0))

    @override
    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectMap.ensureCapacity(int)"""
        super(_ObjectMap, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ObjectMap, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.IdentityMap.hashCode()"""
        return int._wrap(super(IdentityMap, self).hashCode())

    @overload
    def put(self, arg0: object, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.ObjectMap.put(K,V)"""
        return object._wrap(super(_ObjectMap, self).put(arg0, arg1))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def findKey(self, arg0: object, arg1: bool) -> object:
        """public K com.badlogic.gdx.utils.ObjectMap.findKey(java.lang.Object,boolean)"""
        return object._wrap(super(_ObjectMap, self).findKey(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def remove(self, arg0: object) -> object:
        """public V com.badlogic.gdx.utils.ObjectMap.remove(K)"""
        return object._wrap(super(_ObjectMap, self).remove(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.isEmpty()"""
        return bool._wrap(super(ObjectMap, self).isEmpty())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.IntFloatMap$Values
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap_Values
_Values = _IntFloatMap_Values.Values
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import float
import com.badlogic.gdx.utils.FloatArray as _FloatArray
_FloatArray = _FloatArray
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.IntFloatMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntFloatMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: 'IntFloatMap'):
        """public com.badlogic.gdx.utils.IntFloatMap$Values(com.badlogic.gdx.utils.IntFloatMap)"""
        val = _Values(arg0)
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def toArray(self, arg0: 'FloatArray') -> 'FloatArray':
        """public com.badlogic.gdx.utils.FloatArray com.badlogic.gdx.utils.IntFloatMap$Values.toArray(com.badlogic.gdx.utils.FloatArray)"""
        return 'FloatArray'._wrap(super(_Values, self).toArray(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def toArray(self) -> 'FloatArray':
        """public com.badlogic.gdx.utils.FloatArray com.badlogic.gdx.utils.IntFloatMap$Values.toArray()"""
        return 'FloatArray'._wrap(super(Values, self).toArray())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def next(self) -> float:
        """public float com.badlogic.gdx.utils.IntFloatMap$Values.next()"""
        return float._wrap(super(Values, self).next())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def iterator(self) -> 'Values':
        """public com.badlogic.gdx.utils.IntFloatMap$Values com.badlogic.gdx.utils.IntFloatMap$Values.iterator()"""
        return 'Values'._wrap(super(Values, self).iterator())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.LongMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.LongMap as _LongMap_Entries
_Entries = _LongMap_Entries.Entries
import com.badlogic.gdx.utils.LongMap as _LongMap_Keys
_Keys = _LongMap_Keys.Keys
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import com.badlogic.gdx.utils.LongMap as _LongMap_Values
_Values = _LongMap_Values.Values
import java.lang.Float as _float
import com.badlogic.gdx.utils.LongMap as _LongMap
_LongMap = _LongMap
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class LongMap():
    """com.badlogic.gdx.utils.LongMap"""
 
    @staticmethod
    def _wrap(java_value: _LongMap) -> 'LongMap':
        return LongMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _LongMap):
        """
        Dynamic initializer for LongMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_LongMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_LongMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def remove(self, arg0: int) -> object:
        """public V com.badlogic.gdx.utils.LongMap.remove(long)"""
        return object._wrap(super(_LongMap, self).remove(_long.valueOf(arg0)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.LongMap.equals(java.lang.Object)"""
        return bool._wrap(super(_LongMap, self).equals(arg0))

    @overload
    def put(self, arg0: int, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.LongMap.put(long,V)"""
        return object._wrap(super(_LongMap, self).put(_long.valueOf(arg0), arg1))

    @overload
    def putAll(self, arg0: 'LongMap'):
        """public void com.badlogic.gdx.utils.LongMap.putAll(com.badlogic.gdx.utils.LongMap<? extends V>)"""
        super(_LongMap, self).putAll(arg0)

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongMap.shrink(int)"""
        super(_LongMap, self).shrink(_int.valueOf(arg0))

    @overload
    def findKey(self, arg0: object, arg1: bool, arg2: int) -> int:
        """public long com.badlogic.gdx.utils.LongMap.findKey(java.lang.Object,boolean,long)"""
        return int._wrap(super(_LongMap, self).findKey(arg0, _boolean.valueOf(arg1), _long.valueOf(arg2)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.LongMap$Keys com.badlogic.gdx.utils.LongMap.keys()"""
        return 'Keys'._wrap(super(LongMap, self).keys())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.LongMap.toString()"""
        return str._wrap(super(LongMap, self).toString())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.LongMap()"""
        val = _LongMap()
        self.__wrapper = val

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.LongMap$Entry<V>> com.badlogic.gdx.utils.LongMap.iterator()"""
        return 'Iterator'._wrap(super(LongMap, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.LongMap.clear()"""
        super(LongMap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongMap.clear(int)"""
        super(_LongMap, self).clear(_int.valueOf(arg0))

    @overload
    def get(self, arg0: int) -> object:
        """public V com.badlogic.gdx.utils.LongMap.get(long)"""
        return object._wrap(super(_LongMap, self).get(_long.valueOf(arg0)))

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.LongMap$Entries<V> com.badlogic.gdx.utils.LongMap.entries()"""
        return 'Entries'._wrap(super(LongMap, self).entries())

    @overload
    def get(self, arg0: int, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.LongMap.get(long,V)"""
        return object._wrap(super(_LongMap, self).get(_long.valueOf(arg0), arg1))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.LongMap()"""
        val = _LongMap()
        self.__wrapper = val

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.LongMap(int)"""
        val = _LongMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.LongMap.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_LongMap, self).equalsIdentity(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.LongMap.hashCode()"""
        return int._wrap(super(LongMap, self).hashCode())

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongMap.ensureCapacity(int)"""
        super(_LongMap, self).ensureCapacity(_int.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.LongMap(int,float)"""
        val = _LongMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LongMap.isEmpty()"""
        return bool._wrap(super(LongMap, self).isEmpty())

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LongMap.notEmpty()"""
        return bool._wrap(super(LongMap, self).notEmpty())

    @overload
    def __init__(self, arg0: 'LongMap'):
        """public com.badlogic.gdx.utils.LongMap(com.badlogic.gdx.utils.LongMap<? extends V>)"""
        val = _LongMap(arg0)
        self.__wrapper = val

    @overload
    def containsValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.LongMap.containsValue(java.lang.Object,boolean)"""
        return bool._wrap(super(_LongMap, self).containsValue(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.LongMap$Values<V> com.badlogic.gdx.utils.LongMap.values()"""
        return 'Values'._wrap(super(LongMap, self).values())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsKey(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.LongMap.containsKey(long)"""
        return bool._wrap(super(_LongMap, self).containsKey(_long.valueOf(arg0)))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.JsonValue$JsonIterator
import com.badlogic.gdx.utils.JsonValue as _JsonValue_JsonIterator
_JsonIterator = _JsonValue_JsonIterator.JsonIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.badlogic.gdx.utils.JsonValue as _JsonValue
_JsonValue = _JsonValue
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class JsonIterator():
    """com.badlogic.gdx.utils.JsonValue.JsonIterator"""
 
    @staticmethod
    def _wrap(java_value: _JsonIterator) -> 'JsonIterator':
        return JsonIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _JsonIterator):
        """
        Dynamic initializer for JsonIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_JsonIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_JsonIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.JsonValue$JsonIterator.remove()"""
        super(JsonIterator, self).remove()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def next(self) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue$JsonIterator.next()"""
        return 'JsonValue'._wrap(super(JsonIterator, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.JsonValue> com.badlogic.gdx.utils.JsonValue$JsonIterator.iterator()"""
        return 'Iterator'._wrap(super(JsonIterator, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue$JsonIterator.hasNext()"""
        return bool._wrap(super(JsonIterator, self).hasNext())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self, arg0: 'JsonValue'):
        """public com.badlogic.gdx.utils.JsonValue$JsonIterator(com.badlogic.gdx.utils.JsonValue)"""
        val = _JsonIterator(arg0)
        self.__wrapper = val 
 
 
# CLASS: com.badlogic.gdx.utils.Pool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.Pool as _Pool
_Pool = _Pool
from builtins import object
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Pool():
    """com.badlogic.gdx.utils.Pool"""
 
    @staticmethod
    def _wrap(java_value: _Pool) -> 'Pool':
        return Pool(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Pool):
        """
        Dynamic initializer for Pool.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Pool__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Pool__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.Pool.clear()"""
        super(Pool, self).clear()

    @overload
    def obtain(self) -> object:
        """public T com.badlogic.gdx.utils.Pool.obtain()"""
        return object._wrap(super(Pool, self).obtain())

    @overload
    def free(self, arg0: object):
        """public void com.badlogic.gdx.utils.Pool.free(T)"""
        super(_Pool, self).free(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.Pool(int)"""
        val = _Pool(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def freeAll(self, arg0: 'Array'):
        """public void com.badlogic.gdx.utils.Pool.freeAll(com.badlogic.gdx.utils.Array<T>)"""
        super(_Pool, self).freeAll(arg0)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: int, arg1: int):
        """public com.badlogic.gdx.utils.Pool(int,int)"""
        val = _Pool(_int.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Pool()"""
        val = _Pool()
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Pool()"""
        val = _Pool()
        self.__wrapper = val

    @overload
    def fill(self, arg0: int):
        """public void com.badlogic.gdx.utils.Pool.fill(int)"""
        super(_Pool, self).fill(_int.valueOf(arg0))

    @overload
    def getFree(self) -> int:
        """public int com.badlogic.gdx.utils.Pool.getFree()"""
        return int._wrap(super(Pool, self).getFree())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.I18NBundle
from pyquantum_helper import import_once as _import_once
from builtins import str
import java.util.Locale as Locale
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.I18NBundle as _I18NBundle
_I18NBundle = _I18NBundle
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.Set as _Set
_Set = _Set
import java.lang.String as _string
import java.util.Set as Set
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
try:
    from pygdx import files
except ImportError:
    files = _import_once("pygdx.files")

from builtins import bool
import java.lang.Long as _long
import java.util.Locale as _Locale
_Locale = _Locale
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class I18NBundle():
    """com.badlogic.gdx.utils.I18NBundle"""
 
    @staticmethod
    def _wrap(java_value: _I18NBundle) -> 'I18NBundle':
        return I18NBundle(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _I18NBundle):
        """
        Dynamic initializer for I18NBundle.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_I18NBundle__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_I18NBundle__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def createBundle(arg0: 'FileHandle', arg1: 'Locale', arg2: str) -> 'I18NBundle':
        """public static com.badlogic.gdx.utils.I18NBundle com.badlogic.gdx.utils.I18NBundle.createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale,java.lang.String)"""
        return I18NBundle._wrap(_I18NBundle.createBundle(arg0, arg1, arg2))

    @overload
    def keys(self) -> 'Set':
        """public java.util.Set<java.lang.String> com.badlogic.gdx.utils.I18NBundle.keys()"""
        return 'Set'._wrap(super(I18NBundle, self).keys())

    @staticmethod
    @overload
    def getSimpleFormatter() -> bool:
        """public static boolean com.badlogic.gdx.utils.I18NBundle.getSimpleFormatter()"""
        return bool._wrap(_I18NBundle.getSimpleFormatter())

    @staticmethod
    @overload
    def getExceptionOnMissingKey() -> bool:
        """public static boolean com.badlogic.gdx.utils.I18NBundle.getExceptionOnMissingKey()"""
        return bool._wrap(_I18NBundle.getExceptionOnMissingKey())

    @staticmethod
    @overload
    def createBundle(arg0: 'FileHandle') -> 'I18NBundle':
        """public static com.badlogic.gdx.utils.I18NBundle com.badlogic.gdx.utils.I18NBundle.createBundle(com.badlogic.gdx.files.FileHandle)"""
        return I18NBundle._wrap(_I18NBundle.createBundle(arg0))

    @overload
    def format(self, arg0: str, *arg1: object) -> str:
        """public java.lang.String com.badlogic.gdx.utils.I18NBundle.format(java.lang.String,java.lang.Object...)"""
        return str._wrap(super(_I18NBundle, self).format(arg0, arg1))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def getLocale(self) -> 'Locale':
        """public java.util.Locale com.badlogic.gdx.utils.I18NBundle.getLocale()"""
        return 'Locale'._wrap(super(I18NBundle, self).getLocale())

    @overload
    def debug(self, arg0: str):
        """public void com.badlogic.gdx.utils.I18NBundle.debug(java.lang.String)"""
        super(_I18NBundle, self).debug(arg0)

    @staticmethod
    @overload
    def setExceptionOnMissingKey(arg0: bool):
        """public static void com.badlogic.gdx.utils.I18NBundle.setExceptionOnMissingKey(boolean)"""
        _I18NBundle.setExceptionOnMissingKey(_boolean.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def setSimpleFormatter(arg0: bool):
        """public static void com.badlogic.gdx.utils.I18NBundle.setSimpleFormatter(boolean)"""
        _I18NBundle.setSimpleFormatter(_boolean.valueOf(arg0))

    @staticmethod
    @overload
    def createBundle(arg0: 'FileHandle', arg1: str) -> 'I18NBundle':
        """public static com.badlogic.gdx.utils.I18NBundle com.badlogic.gdx.utils.I18NBundle.createBundle(com.badlogic.gdx.files.FileHandle,java.lang.String)"""
        return I18NBundle._wrap(_I18NBundle.createBundle(arg0, arg1))

    @overload
    def get(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.I18NBundle.get(java.lang.String)"""
        return str._wrap(super(_I18NBundle, self).get(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def createBundle(arg0: 'FileHandle', arg1: 'Locale') -> 'I18NBundle':
        """public static com.badlogic.gdx.utils.I18NBundle com.badlogic.gdx.utils.I18NBundle.createBundle(com.badlogic.gdx.files.FileHandle,java.util.Locale)"""
        return I18NBundle._wrap(_I18NBundle.createBundle(arg0, arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.I18NBundle()"""
        val = _I18NBundle()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.I18NBundle()"""
        val = _I18NBundle()
        self.__wrapper = val 
 
 
# CLASS: com.badlogic.gdx.utils.Disposable
from abc import abstractmethod, ABC
import com.badlogic.gdx.utils.Disposable as _Disposable
_Disposable = _Disposable
 
class Disposable():
    """com.badlogic.gdx.utils.Disposable"""
 
    @staticmethod
    def _wrap(java_value: _Disposable) -> 'Disposable':
        return Disposable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Disposable):
        """
        Dynamic initializer for Disposable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Disposable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Disposable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def dispose(self, ):
        """public abstract void com.badlogic.gdx.utils.Disposable.dispose()"""
        pass 
 
 
# CLASS: com.badlogic.gdx.utils.SortedIntList$Node
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.SortedIntList as _SortedIntList_Node
_Node = _SortedIntList_Node.Node
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Node():
    """com.badlogic.gdx.utils.SortedIntList.Node"""
 
    @staticmethod
    def _wrap(java_value: _Node) -> 'Node':
        return Node(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Node):
        """
        Dynamic initializer for Node.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Node__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Node__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.SortedIntList$Node()"""
        val = _Node()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.SortedIntList$Node()"""
        val = _Node()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Queue$QueueIterator
from builtins import str
import com.badlogic.gdx.utils.Queue as _Queue_QueueIterator
_QueueIterator = _Queue_QueueIterator.QueueIterator
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class QueueIterator():
    """com.badlogic.gdx.utils.Queue.QueueIterator"""
 
    @staticmethod
    def _wrap(java_value: _QueueIterator) -> 'QueueIterator':
        return QueueIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _QueueIterator):
        """
        Dynamic initializer for QueueIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_QueueIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_QueueIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: 'Queue', arg1: bool):
        """public com.badlogic.gdx.utils.Queue$QueueIterator(com.badlogic.gdx.utils.Queue<T>,boolean)"""
        val = _QueueIterator(arg0, _boolean.valueOf(arg1))
        self.__wrapper = val

    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.Queue$QueueIterator.reset()"""
        super(QueueIterator, self).reset()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def next(self) -> object:
        """public T com.badlogic.gdx.utils.Queue$QueueIterator.next()"""
        return object._wrap(super(QueueIterator, self).next())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<T> com.badlogic.gdx.utils.Queue$QueueIterator.iterator()"""
        return 'Iterator'._wrap(super(QueueIterator, self).iterator())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.Queue$QueueIterator.remove()"""
        super(QueueIterator, self).remove()

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Queue$QueueIterator.hasNext()"""
        return bool._wrap(super(QueueIterator, self).hasNext())

    @overload
    def __init__(self, arg0: 'Queue'):
        """public com.badlogic.gdx.utils.Queue$QueueIterator(com.badlogic.gdx.utils.Queue<T>)"""
        val = _QueueIterator(arg0)
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.BaseJsonReader
from pyquantum_helper import import_once as _import_once
import com.badlogic.gdx.utils.BaseJsonReader as _BaseJsonReader
_BaseJsonReader = _BaseJsonReader
import java.io.InputStream as InputStream
from abc import abstractmethod, ABC
try:
    from pygdx import files
except ImportError:
    files = _import_once("pygdx.files")

 
class BaseJsonReader():
    """com.badlogic.gdx.utils.BaseJsonReader"""
 
    @staticmethod
    def _wrap(java_value: _BaseJsonReader) -> 'BaseJsonReader':
        return BaseJsonReader(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _BaseJsonReader):
        """
        Dynamic initializer for BaseJsonReader.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_BaseJsonReader__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_BaseJsonReader__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def parse(self, arg0: 'InputStream'):
        """public abstract com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.BaseJsonReader.parse(java.io.InputStream)"""
        pass

    @abstractmethod
    def parse(self, arg0: 'FileHandle'):
        """public abstract com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.BaseJsonReader.parse(com.badlogic.gdx.files.FileHandle)"""
        pass 
 
 
# CLASS: com.badlogic.gdx.utils.Pool$Poolable
import com.badlogic.gdx.utils.Pool as _Pool_Poolable
_Poolable = _Pool_Poolable.Poolable
from abc import abstractmethod, ABC
 
class Poolable():
    """com.badlogic.gdx.utils.Pool.Poolable"""
 
    @staticmethod
    def _wrap(java_value: _Poolable) -> 'Poolable':
        return Poolable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Poolable):
        """
        Dynamic initializer for Poolable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Poolable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Poolable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def reset(self, ):
        """public abstract void com.badlogic.gdx.utils.Pool$Poolable.reset()"""
        pass 
 
 
# CLASS: com.badlogic.gdx.utils.Base64Coder$CharMap
import com.badlogic.gdx.utils.Base64Coder as _Base64Coder_CharMap
_CharMap = _Base64Coder_CharMap.CharMap
from builtins import str
import java.lang.Character as _char
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class CharMap():
    """com.badlogic.gdx.utils.Base64Coder.CharMap"""
 
    @staticmethod
    def _wrap(java_value: _CharMap) -> 'CharMap':
        return CharMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _CharMap):
        """
        Dynamic initializer for CharMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_CharMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_CharMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def getEncodingMap(self) -> List[str]:
        """public char[] com.badlogic.gdx.utils.Base64Coder$CharMap.getEncodingMap()"""
        return List[str]._wrap(super(CharMap, self).getEncodingMap())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: str, arg1: str):
        """public com.badlogic.gdx.utils.Base64Coder$CharMap(char,char)"""
        val = _CharMap(_char.valueOf(arg0), _char.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def getDecodingMap(self) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.Base64Coder$CharMap.getDecodingMap()"""
        return List[int]._wrap(super(CharMap, self).getDecodingMap())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Json$ReadOnlySerializer
from builtins import str
import com.badlogic.gdx.utils.Json as _Json_ReadOnlySerializer
_ReadOnlySerializer = _Json_ReadOnlySerializer.ReadOnlySerializer
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ReadOnlySerializer():
    """com.badlogic.gdx.utils.Json.ReadOnlySerializer"""
 
    @staticmethod
    def _wrap(java_value: _ReadOnlySerializer) -> 'ReadOnlySerializer':
        return ReadOnlySerializer(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ReadOnlySerializer):
        """
        Dynamic initializer for ReadOnlySerializer.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ReadOnlySerializer__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ReadOnlySerializer__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Json$ReadOnlySerializer()"""
        val = _ReadOnlySerializer()
        self.__wrapper = val

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Json$ReadOnlySerializer()"""
        val = _ReadOnlySerializer()
        self.__wrapper = val

    @abstractmethod
    def read(self, arg0: 'Json', arg1: 'JsonValue', arg2: 'Class'):
        """public abstract T com.badlogic.gdx.utils.Json$ReadOnlySerializer.read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class)"""
        pass

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def write(self, arg0: 'Json', arg1: object, arg2: 'Class'):
        """public void com.badlogic.gdx.utils.Json$ReadOnlySerializer.write(com.badlogic.gdx.utils.Json,T,java.lang.Class)"""
        super(_ReadOnlySerializer, self).write(arg0, arg1, arg2)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntIntMap$Entry
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap_Entry
_Entry = _IntIntMap_Entry.Entry
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entry():
    """com.badlogic.gdx.utils.IntIntMap.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntIntMap$Entry.toString()"""
        return str._wrap(super(Entry, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IntIntMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IntIntMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectIntMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap_Keys
_Keys = _ObjectIntMap_Keys.Keys
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.ObjectIntMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectIntMap$Keys.toArray(com.badlogic.gdx.utils.Array<K>)"""
        return 'Array'._wrap(super(_Keys, self).toArray(arg0))

    @override
    @overload
    def iterator(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectIntMap$Keys<K> com.badlogic.gdx.utils.ObjectIntMap$Keys.iterator()"""
        return 'Keys'._wrap(super(Keys, self).iterator())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectIntMap$Keys.toArray()"""
        return 'Array'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.ObjectIntMap$Keys.next()"""
        return object._wrap(super(Keys, self).next())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectIntMap$Keys.hasNext()"""
        return bool._wrap(super(Keys, self).hasNext())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'ObjectIntMap'):
        """public com.badlogic.gdx.utils.ObjectIntMap$Keys(com.badlogic.gdx.utils.ObjectIntMap<K>)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Queue$QueueIterable
from builtins import str
import com.badlogic.gdx.utils.Queue as _Queue_QueueIterable
_QueueIterable = _Queue_QueueIterable.QueueIterable
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class QueueIterable():
    """com.badlogic.gdx.utils.Queue.QueueIterable"""
 
    @staticmethod
    def _wrap(java_value: _QueueIterable) -> 'QueueIterable':
        return QueueIterable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _QueueIterable):
        """
        Dynamic initializer for QueueIterable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_QueueIterable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_QueueIterable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, arg0: 'Queue', arg1: bool):
        """public com.badlogic.gdx.utils.Queue$QueueIterable(com.badlogic.gdx.utils.Queue<T>,boolean)"""
        val = _QueueIterable(arg0, _boolean.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: 'Queue'):
        """public com.badlogic.gdx.utils.Queue$QueueIterable(com.badlogic.gdx.utils.Queue<T>)"""
        val = _QueueIterable(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<T> com.badlogic.gdx.utils.Queue$QueueIterable.iterator()"""
        return 'Iterator'._wrap(super(QueueIterable, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntArray
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import com.badlogic.gdx.utils.IntArray as _IntArray
_IntArray = _IntArray
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class IntArray():
    """com.badlogic.gdx.utils.IntArray"""
 
    @staticmethod
    def _wrap(java_value: _IntArray) -> 'IntArray':
        return IntArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _IntArray):
        """
        Dynamic initializer for IntArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_IntArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_IntArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def get(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.IntArray.get(int)"""
        return int._wrap(super(_IntArray, self).get(_int.valueOf(arg0)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.IntArray.equals(java.lang.Object)"""
        return bool._wrap(super(_IntArray, self).equals(arg0))

    @overload
    def first(self) -> int:
        """public int com.badlogic.gdx.utils.IntArray.first()"""
        return int._wrap(super(IntArray, self).first())

    @overload
    def __init__(self, arg0: 'IntArray'):
        """public com.badlogic.gdx.utils.IntArray(com.badlogic.gdx.utils.IntArray)"""
        val = _IntArray(arg0)
        self.__wrapper = val

    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntArray.insertRange(int,int)"""
        super(_IntArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntArray.toString()"""
        return str._wrap(super(IntArray, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.IntArray(boolean,int)"""
        val = _IntArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.IntArray.hashCode()"""
        return int._wrap(super(IntArray, self).hashCode())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.IntArray(int)"""
        val = _IntArray(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def add(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntArray.add(int)"""
        super(_IntArray, self).add(_int.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def removeValue(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntArray.removeValue(int)"""
        return bool._wrap(super(_IntArray, self).removeValue(_int.valueOf(arg0)))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntArray.notEmpty()"""
        return bool._wrap(super(IntArray, self).notEmpty())

    @overload
    def __init__(self, arg0: bool, arg1: 'int', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.IntArray(boolean,int[],int,int)"""
        val = _IntArray(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @overload
    def add(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntArray.add(int,int)"""
        super(_IntArray, self).add(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def lastIndexOf(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.IntArray.lastIndexOf(int)"""
        return int._wrap(super(_IntArray, self).lastIndexOf(_int.valueOf(arg0)))

    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntArray.removeRange(int,int)"""
        super(_IntArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def contains(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntArray.contains(int)"""
        return bool._wrap(super(_IntArray, self).contains(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'int'):
        """public com.badlogic.gdx.utils.IntArray(int[])"""
        val = _IntArray(arg0)
        self.__wrapper = val

    @overload
    def addAll(self, arg0: 'int', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.IntArray.addAll(int[],int,int)"""
        super(_IntArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IntArray()"""
        val = _IntArray()
        self.__wrapper = val

    @overload
    def addAll(self, *arg0: int):
        """public void com.badlogic.gdx.utils.IntArray.addAll(int...)"""
        super(_IntArray, self).addAll(arg0)

    @overload
    def peek(self) -> int:
        """public int com.badlogic.gdx.utils.IntArray.peek()"""
        return int._wrap(super(IntArray, self).peek())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.IntArray.clear()"""
        super(IntArray, self).clear()

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntArray.isEmpty()"""
        return bool._wrap(super(IntArray, self).isEmpty())

    @overload
    def add(self, arg0: int, arg1: int, arg2: int, arg3: int):
        """public void com.badlogic.gdx.utils.IntArray.add(int,int,int,int)"""
        super(_IntArray, self).add(_int.valueOf(arg0), _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3))

    @overload
    def incr(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntArray.incr(int)"""
        super(_IntArray, self).incr(_int.valueOf(arg0))

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.IntArray.reverse()"""
        super(IntArray, self).reverse()

    @overload
    def ensureCapacity(self, arg0: int) -> List[int]:
        """public int[] com.badlogic.gdx.utils.IntArray.ensureCapacity(int)"""
        return List[int]._wrap(super(_IntArray, self).ensureCapacity(_int.valueOf(arg0)))

    @overload
    def removeAll(self, arg0: 'IntArray') -> bool:
        """public boolean com.badlogic.gdx.utils.IntArray.removeAll(com.badlogic.gdx.utils.IntArray)"""
        return bool._wrap(super(_IntArray, self).removeAll(arg0))

    @overload
    def mul(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntArray.mul(int,int)"""
        super(_IntArray, self).mul(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def toArray(self) -> List[int]:
        """public int[] com.badlogic.gdx.utils.IntArray.toArray()"""
        return List[int]._wrap(super(IntArray, self).toArray())

    @staticmethod
    @overload
    def with(*arg0: int) -> 'IntArray':
        """public static com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntArray.with(int...)"""
        return IntArray._wrap(_IntArray.with(arg0))

    @overload
    def set(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntArray.set(int,int)"""
        super(_IntArray, self).set(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def add(self, arg0: int, arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.IntArray.add(int,int,int)"""
        super(_IntArray, self).add(_int.valueOf(arg0), _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def shrink(self) -> List[int]:
        """public int[] com.badlogic.gdx.utils.IntArray.shrink()"""
        return List[int]._wrap(super(IntArray, self).shrink())

    @overload
    def random(self) -> int:
        """public int com.badlogic.gdx.utils.IntArray.random()"""
        return int._wrap(super(IntArray, self).random())

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntArray.toString(java.lang.String)"""
        return str._wrap(super(_IntArray, self).toString(arg0))

    @overload
    def setSize(self, arg0: int) -> List[int]:
        """public int[] com.badlogic.gdx.utils.IntArray.setSize(int)"""
        return List[int]._wrap(super(_IntArray, self).setSize(_int.valueOf(arg0)))

    @overload
    def addAll(self, arg0: 'IntArray', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.IntArray.addAll(com.badlogic.gdx.utils.IntArray,int,int)"""
        super(_IntArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def pop(self) -> int:
        """public int com.badlogic.gdx.utils.IntArray.pop()"""
        return int._wrap(super(IntArray, self).pop())

    @overload
    def removeIndex(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.IntArray.removeIndex(int)"""
        return int._wrap(super(_IntArray, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def indexOf(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.IntArray.indexOf(int)"""
        return int._wrap(super(_IntArray, self).indexOf(_int.valueOf(arg0)))

    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.IntArray.sort()"""
        super(IntArray, self).sort()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntArray.swap(int,int)"""
        super(_IntArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IntArray()"""
        val = _IntArray()
        self.__wrapper = val

    @overload
    def mul(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntArray.mul(int)"""
        super(_IntArray, self).mul(_int.valueOf(arg0))

    @overload
    def addAll(self, arg0: 'IntArray'):
        """public void com.badlogic.gdx.utils.IntArray.addAll(com.badlogic.gdx.utils.IntArray)"""
        super(_IntArray, self).addAll(arg0)

    @overload
    def incr(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntArray.incr(int,int)"""
        super(_IntArray, self).incr(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.IntArray.shuffle()"""
        super(IntArray, self).shuffle()

    @overload
    def insert(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntArray.insert(int,int)"""
        super(_IntArray, self).insert(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntArray.truncate(int)"""
        super(_IntArray, self).truncate(_int.valueOf(arg0)) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectMap
from builtins import str
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Values
_Values = _ObjectMap_Values.Values
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap
_ObjectMap = _ObjectMap
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entries
_Entries = _ObjectMap_Entries.Entries
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Keys
_Keys = _ObjectMap_Keys.Keys
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ObjectMap():
    """com.badlogic.gdx.utils.ObjectMap"""
 
    @staticmethod
    def _wrap(java_value: _ObjectMap) -> 'ObjectMap':
        return ObjectMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ObjectMap):
        """
        Dynamic initializer for ObjectMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ObjectMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ObjectMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectMap.shrink(int)"""
        super(_ObjectMap, self).shrink(_int.valueOf(arg0))

    @overload
    def __init__(self, arg0: 'ObjectMap'):
        """public com.badlogic.gdx.utils.ObjectMap(com.badlogic.gdx.utils.ObjectMap<? extends K, ? extends V>)"""
        val = _ObjectMap(arg0)
        self.__wrapper = val

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectMap.ensureCapacity(int)"""
        super(_ObjectMap, self).ensureCapacity(_int.valueOf(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.ObjectMap(int)"""
        val = _ObjectMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def containsValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.containsValue(java.lang.Object,boolean)"""
        return bool._wrap(super(_ObjectMap, self).containsValue(arg0, _boolean.valueOf(arg1)))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectMap()"""
        val = _ObjectMap()
        self.__wrapper = val

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectMap$Entries<K, V> com.badlogic.gdx.utils.ObjectMap.iterator()"""
        return 'Entries'._wrap(super(ObjectMap, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectMap.toString(java.lang.String)"""
        return str._wrap(super(_ObjectMap, self).toString(arg0))

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectMap$Values<V> com.badlogic.gdx.utils.ObjectMap.values()"""
        return 'Values'._wrap(super(ObjectMap, self).values())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectMap.toString()"""
        return str._wrap(super(ObjectMap, self).toString())

    @overload
    def get(self, arg0: object) -> object:
        """public <T extends K> V com.badlogic.gdx.utils.ObjectMap.get(T)"""
        return object._wrap(super(_ObjectMap, self).get(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectMap()"""
        val = _ObjectMap()
        self.__wrapper = val

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ObjectMap.clear()"""
        super(ObjectMap, self).clear()

    @overload
    def containsKey(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.containsKey(K)"""
        return bool._wrap(super(_ObjectMap, self).containsKey(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def get(self, arg0: object, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.ObjectMap.get(K,V)"""
        return object._wrap(super(_ObjectMap, self).get(arg0, arg1))

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.ObjectMap(int,float)"""
        val = _ObjectMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectMap.clear(int)"""
        super(_ObjectMap, self).clear(_int.valueOf(arg0))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.isEmpty()"""
        return bool._wrap(super(ObjectMap, self).isEmpty())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ObjectMap.hashCode()"""
        return int._wrap(super(ObjectMap, self).hashCode())

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_ObjectMap, self).equalsIdentity(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ObjectMap, self).equals(arg0))

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectMap$Entries<K, V> com.badlogic.gdx.utils.ObjectMap.entries()"""
        return 'Entries'._wrap(super(ObjectMap, self).entries())

    @overload
    def put(self, arg0: object, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.ObjectMap.put(K,V)"""
        return object._wrap(super(_ObjectMap, self).put(arg0, arg1))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def findKey(self, arg0: object, arg1: bool) -> object:
        """public K com.badlogic.gdx.utils.ObjectMap.findKey(java.lang.Object,boolean)"""
        return object._wrap(super(_ObjectMap, self).findKey(arg0, _boolean.valueOf(arg1)))

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectMap$Keys<K> com.badlogic.gdx.utils.ObjectMap.keys()"""
        return 'Keys'._wrap(super(ObjectMap, self).keys())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def remove(self, arg0: object) -> object:
        """public V com.badlogic.gdx.utils.ObjectMap.remove(K)"""
        return object._wrap(super(_ObjectMap, self).remove(arg0))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.notEmpty()"""
        return bool._wrap(super(ObjectMap, self).notEmpty())

    @overload
    def putAll(self, arg0: 'ObjectMap'):
        """public void com.badlogic.gdx.utils.ObjectMap.putAll(com.badlogic.gdx.utils.ObjectMap<? extends K, ? extends V>)"""
        super(_ObjectMap, self).putAll(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.Scaling
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Scaling as _Scaling
_Scaling = _Scaling
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Scaling():
    """com.badlogic.gdx.utils.Scaling"""
 
    @staticmethod
    def _wrap(java_value: _Scaling) -> 'Scaling':
        return Scaling(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Scaling):
        """
        Dynamic initializer for Scaling.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Scaling__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Scaling__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, arg0: float, arg1: float, arg2: float, arg3: float):
        """public abstract com.badlogic.gdx.math.Vector2 com.badlogic.gdx.utils.Scaling.apply(float,float,float,float)"""
        pass

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Scaling()"""
        val = _Scaling()
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Scaling()"""
        val = _Scaling()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.DataOutput
from builtins import str
import java.lang.Double as _double
from pyquantum_helper import override
import java.io.OutputStream as _OutputStream
_OutputStream = _OutputStream
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.Float as _float
import java.lang.String as _string
import java.io.DataOutputStream as _DataOutputStream
_DataOutputStream = _DataOutputStream
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.io.OutputStream as OutputStream
import com.badlogic.gdx.utils.DataOutput as _DataOutput
_DataOutput = _DataOutput
import java.io.FilterOutputStream as _FilterOutputStream
_FilterOutputStream = _FilterOutputStream
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class DataOutput():
    """com.badlogic.gdx.utils.DataOutput"""
 
    @staticmethod
    def _wrap(java_value: _DataOutput) -> 'DataOutput':
        return DataOutput(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _DataOutput):
        """
        Dynamic initializer for DataOutput.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_DataOutput__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_DataOutput__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def writeFloat(self, arg0: float):
        """public final void java.io.DataOutputStream.writeFloat(float) throws java.io.IOException"""
        super(_DataOutputStream, self).writeFloat(_float.valueOf(arg0))

    @overload
    def writeInt(self, arg0: int, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.DataOutput.writeInt(int,boolean) throws java.io.IOException"""
        return int._wrap(super(_DataOutput, self).writeInt(_int.valueOf(arg0), _boolean.valueOf(arg1)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def write(self, arg0: int):
        """public synchronized void java.io.DataOutputStream.write(int) throws java.io.IOException"""
        super(_DataOutputStream, self).write(_int.valueOf(arg0))

    @override
    @overload
    def size(self) -> int:
        """public final int java.io.DataOutputStream.size()"""
        return int._wrap(super(DataOutputStream, self).size())

    @override
    @overload
    def writeByte(self, arg0: int):
        """public final void java.io.DataOutputStream.writeByte(int) throws java.io.IOException"""
        super(_DataOutputStream, self).writeByte(_int.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def writeChar(self, arg0: int):
        """public final void java.io.DataOutputStream.writeChar(int) throws java.io.IOException"""
        super(_DataOutputStream, self).writeChar(_int.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def writeString(self, arg0: str):
        """public void com.badlogic.gdx.utils.DataOutput.writeString(java.lang.String) throws java.io.IOException"""
        super(_DataOutput, self).writeString(arg0)

    @override
    @overload
    def close(self):
        """public void java.io.FilterOutputStream.close() throws java.io.IOException"""
        super(FilterOutputStream, self).close()

    @override
    @overload
    def write(self, arg0: bytes):
        """public void java.io.FilterOutputStream.write(byte[]) throws java.io.IOException"""
        super(_FilterOutputStream, self).write(bytes)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def writeInt(self, arg0: int):
        """public final void java.io.DataOutputStream.writeInt(int) throws java.io.IOException"""
        super(_DataOutputStream, self).writeInt(_int.valueOf(arg0))

    @overload
    def __init__(self, arg0: 'OutputStream'):
        """public com.badlogic.gdx.utils.DataOutput(java.io.OutputStream)"""
        val = _DataOutput(arg0)
        self.__wrapper = val

    @staticmethod
    @overload
    def nullOutputStream() -> 'OutputStream':
        """public static java.io.OutputStream java.io.OutputStream.nullOutputStream()"""
        return OutputStream._wrap(_OutputStream.nullOutputStream())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def writeDouble(self, arg0: float):
        """public final void java.io.DataOutputStream.writeDouble(double) throws java.io.IOException"""
        super(_DataOutputStream, self).writeDouble(_double.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def writeBoolean(self, arg0: bool):
        """public final void java.io.DataOutputStream.writeBoolean(boolean) throws java.io.IOException"""
        super(_DataOutputStream, self).writeBoolean(_boolean.valueOf(arg0))

    @override
    @overload
    def writeChars(self, arg0: str):
        """public final void java.io.DataOutputStream.writeChars(java.lang.String) throws java.io.IOException"""
        super(_DataOutputStream, self).writeChars(arg0)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def flush(self):
        """public void java.io.DataOutputStream.flush() throws java.io.IOException"""
        super(DataOutputStream, self).flush()

    @override
    @overload
    def write(self, arg0: bytes, arg1: int, arg2: int):
        """public synchronized void java.io.DataOutputStream.write(byte[],int,int) throws java.io.IOException"""
        super(_DataOutputStream, self).write(bytes, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def writeBytes(self, arg0: str):
        """public final void java.io.DataOutputStream.writeBytes(java.lang.String) throws java.io.IOException"""
        super(_DataOutputStream, self).writeBytes(arg0)

    @override
    @overload
    def writeLong(self, arg0: int):
        """public final void java.io.DataOutputStream.writeLong(long) throws java.io.IOException"""
        super(_DataOutputStream, self).writeLong(_long.valueOf(arg0))

    @override
    @overload
    def writeUTF(self, arg0: str):
        """public final void java.io.DataOutputStream.writeUTF(java.lang.String) throws java.io.IOException"""
        super(_DataOutputStream, self).writeUTF(arg0)

    @override
    @overload
    def writeShort(self, arg0: int):
        """public final void java.io.DataOutputStream.writeShort(int) throws java.io.IOException"""
        super(_DataOutputStream, self).writeShort(_int.valueOf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntMap$Values
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.IntMap as _IntMap_Values
_Values = _IntMap_Values.Values
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.IntMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def next(self) -> object:
        """public V com.badlogic.gdx.utils.IntMap$Values.next()"""
        return object._wrap(super(Values, self).next())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<V> com.badlogic.gdx.utils.IntMap$Values.toArray()"""
        return 'Array'._wrap(super(Values, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<V> com.badlogic.gdx.utils.IntMap$Values.iterator()"""
        return 'Iterator'._wrap(super(Values, self).iterator())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def __init__(self, arg0: 'IntMap'):
        """public com.badlogic.gdx.utils.IntMap$Values(com.badlogic.gdx.utils.IntMap<V>)"""
        val = _Values(arg0)
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.PropertiesUtils
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.PropertiesUtils as _PropertiesUtils
_PropertiesUtils = _PropertiesUtils
import java.lang.String as _String
_String = _String
import java.lang.String as _string
import java.lang.Integer as _int
import java.io.Reader as Reader
import java.io.Writer as Writer
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class PropertiesUtils():
    """com.badlogic.gdx.utils.PropertiesUtils"""
 
    @staticmethod
    def _wrap(java_value: _PropertiesUtils) -> 'PropertiesUtils':
        return PropertiesUtils(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PropertiesUtils):
        """
        Dynamic initializer for PropertiesUtils.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PropertiesUtils__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PropertiesUtils__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def store(arg0: 'ObjectMap', arg1: 'Writer', arg2: str):
        """public static void com.badlogic.gdx.utils.PropertiesUtils.store(com.badlogic.gdx.utils.ObjectMap<java.lang.String, java.lang.String>,java.io.Writer,java.lang.String) throws java.io.IOException"""
        _PropertiesUtils.store(arg0, arg1, arg2)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def load(arg0: 'ObjectMap', arg1: 'Reader'):
        """public static void com.badlogic.gdx.utils.PropertiesUtils.load(com.badlogic.gdx.utils.ObjectMap<java.lang.String, java.lang.String>,java.io.Reader) throws java.io.IOException"""
        _PropertiesUtils.load(arg0, arg1)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.PauseableThread
import java.lang.Thread as Thread
import java.lang.StackTraceElement as _StackTraceElement
_StackTraceElement = _StackTraceElement
import java.lang.Thread as _Thread
_Thread = _Thread
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import java.lang.Thread.UncaughtExceptionHandler as UncaughtExceptionHandler
import java.lang.Thread.Builder.OfPlatform as OfPlatform
import java.lang.ClassLoader as _ClassLoader
_ClassLoader = _ClassLoader
import java.lang.Thread.Builder.OfVirtual as OfVirtual
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.ClassLoader as ClassLoader
import com.badlogic.gdx.utils.PauseableThread as _PauseableThread
_PauseableThread = _PauseableThread
from builtins import bool
import java.lang.Thread as _Thread_Builder_OfVirtual
_OfVirtual = _Thread_Builder_OfVirtual.Builder.OfVirtual
import java.lang.Thread.State as State
from builtins import str
import java.lang.Thread as _Thread_Builder_OfPlatform
_OfPlatform = _Thread_Builder_OfPlatform.Builder.OfPlatform
from pyquantum_helper import override
import java.lang.ThreadGroup as _ThreadGroup
_ThreadGroup = _ThreadGroup
import java.lang.Object as _object
import java.lang.Runnable as Runnable
import java.lang.Thread as _Thread_State
_State = _Thread_State.State
import java.time.Duration as Duration
import java.lang.String as _String
_String = _String
import java.lang.StackTraceElement as StackTraceElement
from typing import List
import java.lang.Integer as _int
import java.lang.Thread as _Thread_UncaughtExceptionHandler
_UncaughtExceptionHandler = _Thread_UncaughtExceptionHandler.UncaughtExceptionHandler
import java.lang.ThreadGroup as ThreadGroup
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class PauseableThread():
    """com.badlogic.gdx.utils.PauseableThread"""
 
    @staticmethod
    def _wrap(java_value: _PauseableThread) -> 'PauseableThread':
        return PauseableThread(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PauseableThread):
        """
        Dynamic initializer for PauseableThread.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PauseableThread__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PauseableThread__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def join(self, arg0: int):
        """public final void java.lang.Thread.join(long) throws java.lang.InterruptedException"""
        super(_Thread, self).join(_long.valueOf(arg0))

    @staticmethod
    @overload
    def sleep(arg0: int, arg1: int):
        """public static void java.lang.Thread.sleep(long,int) throws java.lang.InterruptedException"""
        _Thread.sleep(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def setName(self, arg0: str):
        """public final synchronized void java.lang.Thread.setName(java.lang.String)"""
        super(_Thread, self).setName(arg0)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def isAlive(self) -> bool:
        """public final boolean java.lang.Thread.isAlive()"""
        return bool._wrap(super(Thread, self).isAlive())

    @staticmethod
    @overload
    def holdsLock(arg0: object) -> bool:
        """public static native boolean java.lang.Thread.holdsLock(java.lang.Object)"""
        return bool._wrap(_Thread.holdsLock(arg0))

    @overload
    def onPause(self):
        """public void com.badlogic.gdx.utils.PauseableThread.onPause()"""
        super(PauseableThread, self).onPause()

    @overload
    def onResume(self):
        """public void com.badlogic.gdx.utils.PauseableThread.onResume()"""
        super(PauseableThread, self).onResume()

    @staticmethod
    @overload
    def ofPlatform() -> 'OfPlatform.Thread$Builder$OfPlatform':
        """public static java.lang.Thread$Builder$OfPlatform java.lang.Thread.ofPlatform()"""
        return OfPlatform.Thread$Builder$OfPlatform._wrap(_Thread.ofPlatform())

    @override
    @overload
    def getThreadGroup(self) -> 'ThreadGroup':
        """public final java.lang.ThreadGroup java.lang.Thread.getThreadGroup()"""
        return 'ThreadGroup'._wrap(super(Thread, self).getThreadGroup())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def currentThread() -> 'Thread':
        """public static native java.lang.Thread java.lang.Thread.currentThread()"""
        return Thread._wrap(_Thread.currentThread())

    @override
    @overload
    def join(self):
        """public final void java.lang.Thread.join() throws java.lang.InterruptedException"""
        super(Thread, self).join()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def startVirtualThread(arg0: 'Runnable') -> 'Thread':
        """public static java.lang.Thread java.lang.Thread.startVirtualThread(java.lang.Runnable)"""
        return Thread._wrap(_Thread.startVirtualThread(arg0))

    @override
    @overload
    def resume(self):
        """public final void java.lang.Thread.resume()"""
        super(Thread, self).resume()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def checkAccess(self):
        """public final void java.lang.Thread.checkAccess()"""
        super(Thread, self).checkAccess()

    @override
    @overload
    def getState(self) -> 'State.Thread$State':
        """public java.lang.Thread$State java.lang.Thread.getState()"""
        return 'State.Thread$State'._wrap(super(Thread, self).getState())

        @staticmethod
        @overload
        def dumpStack():
            """public static void java.lang.Thread.dumpStack()"""
            _Thread.dumpStack()

    @override
    @overload
    def getUncaughtExceptionHandler(self) -> 'UncaughtExceptionHandler.Thread$UncaughtExceptionHandler':
        """public java.lang.Thread$UncaughtExceptionHandler java.lang.Thread.getUncaughtExceptionHandler()"""
        return 'UncaughtExceptionHandler.Thread$UncaughtExceptionHandler'._wrap(super(Thread, self).getUncaughtExceptionHandler())

    @override
    @overload
    def isVirtual(self) -> bool:
        """public final boolean java.lang.Thread.isVirtual()"""
        return bool._wrap(super(Thread, self).isVirtual())

    @staticmethod
    @overload
    def setDefaultUncaughtExceptionHandler(arg0: 'UncaughtExceptionHandler'):
        """public static void java.lang.Thread.setDefaultUncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler)"""
        _Thread.setDefaultUncaughtExceptionHandler(arg0)

        @staticmethod
        @overload
        def yield():
            """public static void java.lang.Thread.yield()"""
            _Thread.yield()

    @staticmethod
    @overload
    def sleep(arg0: int):
        """public static void java.lang.Thread.sleep(long) throws java.lang.InterruptedException"""
        _Thread.sleep(_long.valueOf(arg0))

    @override
    @overload
    def getContextClassLoader(self) -> 'ClassLoader':
        """public java.lang.ClassLoader java.lang.Thread.getContextClassLoader()"""
        return 'ClassLoader'._wrap(super(Thread, self).getContextClassLoader())

    @overload
    def __init__(self, arg0: 'Runnable'):
        """public com.badlogic.gdx.utils.PauseableThread(java.lang.Runnable)"""
        val = _PauseableThread(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def getDefaultUncaughtExceptionHandler() -> 'UncaughtExceptionHandler.Thread$UncaughtExceptionHandler':
        """public static java.lang.Thread$UncaughtExceptionHandler java.lang.Thread.getDefaultUncaughtExceptionHandler()"""
        return UncaughtExceptionHandler.Thread$UncaughtExceptionHandler._wrap(_Thread.getDefaultUncaughtExceptionHandler())

    @override
    @overload
    def join(self, arg0: int, arg1: int):
        """public final void java.lang.Thread.join(long,int) throws java.lang.InterruptedException"""
        super(_Thread, self).join(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def isPaused(self) -> bool:
        """public boolean com.badlogic.gdx.utils.PauseableThread.isPaused()"""
        return bool._wrap(super(PauseableThread, self).isPaused())

    @staticmethod
    @overload
    def ofVirtual() -> 'OfVirtual.Thread$Builder$OfVirtual':
        """public static java.lang.Thread$Builder$OfVirtual java.lang.Thread.ofVirtual()"""
        return OfVirtual.Thread$Builder$OfVirtual._wrap(_Thread.ofVirtual())

    @override
    @overload
    def start(self):
        """public void java.lang.Thread.start()"""
        super(Thread, self).start()

    @override
    @overload
    def isInterrupted(self) -> bool:
        """public boolean java.lang.Thread.isInterrupted()"""
        return bool._wrap(super(Thread, self).isInterrupted())

    @overload
    def join(self, arg0: 'Duration') -> bool:
        """public final boolean java.lang.Thread.join(java.time.Duration) throws java.lang.InterruptedException"""
        return bool._wrap(super(_Thread, self).join(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Thread.toString()"""
        return str._wrap(super(Thread, self).toString())

    @override
    @overload
    def suspend(self):
        """public final void java.lang.Thread.suspend()"""
        super(Thread, self).suspend()

    @override
    @overload
    def setDaemon(self, arg0: bool):
        """public final void java.lang.Thread.setDaemon(boolean)"""
        super(_Thread, self).setDaemon(_boolean.valueOf(arg0))

    @staticmethod
    @overload
    def activeCount() -> int:
        """public static int java.lang.Thread.activeCount()"""
        return int._wrap(_Thread.activeCount())

    @overload
    def stopThread(self):
        """public void com.badlogic.gdx.utils.PauseableThread.stopThread()"""
        super(PauseableThread, self).stopThread()

    @override
    @overload
    def getName(self) -> str:
        """public final java.lang.String java.lang.Thread.getName()"""
        return str._wrap(super(Thread, self).getName())

    @override
    @overload
    def setUncaughtExceptionHandler(self, arg0: 'UncaughtExceptionHandler'):
        """public void java.lang.Thread.setUncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler)"""
        super(_Thread, self).setUncaughtExceptionHandler(arg0)

    @override
    @overload
    def setContextClassLoader(self, arg0: 'ClassLoader'):
        """public void java.lang.Thread.setContextClassLoader(java.lang.ClassLoader)"""
        super(_Thread, self).setContextClassLoader(arg0)

    @override
    @overload
    def getId(self) -> int:
        """public long java.lang.Thread.getId()"""
        return int._wrap(super(Thread, self).getId())

    @override
    @overload
    def isDaemon(self) -> bool:
        """public final boolean java.lang.Thread.isDaemon()"""
        return bool._wrap(super(Thread, self).isDaemon())

    @staticmethod
    @overload
    def getAllStackTraces() -> 'Map':
        """public static java.util.Map<java.lang.Thread, java.lang.StackTraceElement[]> java.lang.Thread.getAllStackTraces()"""
        return Map._wrap(_Thread.getAllStackTraces())

    @override
    @overload
    def interrupt(self):
        """public void java.lang.Thread.interrupt()"""
        super(Thread, self).interrupt()

    @staticmethod
    @overload
    def sleep(arg0: 'Duration'):
        """public static void java.lang.Thread.sleep(java.time.Duration) throws java.lang.InterruptedException"""
        _Thread.sleep(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def countStackFrames(self) -> int:
        """public int java.lang.Thread.countStackFrames()"""
        return int._wrap(super(Thread, self).countStackFrames())

    @override
    @overload
    def stop(self):
        """public final void java.lang.Thread.stop()"""
        super(Thread, self).stop()

    @override
    @overload
    def getPriority(self) -> int:
        """public final int java.lang.Thread.getPriority()"""
        return int._wrap(super(Thread, self).getPriority())

    @override
    @overload
    def setPriority(self, arg0: int):
        """public final void java.lang.Thread.setPriority(int)"""
        super(_Thread, self).setPriority(_int.valueOf(arg0))

    @override
    @overload
    def getStackTrace(self) -> List['StackTraceElement']:
        """public java.lang.StackTraceElement[] java.lang.Thread.getStackTrace()"""
        return List['StackTraceElement']._wrap(super(Thread, self).getStackTrace())

        @staticmethod
        @overload
        def onSpinWait():
            """public static void java.lang.Thread.onSpinWait()"""
            _Thread.onSpinWait()

    @staticmethod
    @overload
    def interrupted() -> bool:
        """public static boolean java.lang.Thread.interrupted()"""
        return bool._wrap(_Thread.interrupted())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def enumerate(arg0: 'Thread') -> int:
        """public static int java.lang.Thread.enumerate(java.lang.Thread[])"""
        return int._wrap(_Thread.enumerate(arg0))

    @override
    @overload
    def threadId(self) -> int:
        """public final long java.lang.Thread.threadId()"""
        return int._wrap(super(Thread, self).threadId())

    @override
    @overload
    def run(self):
        """public void com.badlogic.gdx.utils.PauseableThread.run()"""
        super(PauseableThread, self).run() 
 
 
# CLASS: com.badlogic.gdx.utils.JsonWriter$OutputType
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.Enum as Enum
import java.lang.String as _string
import java.lang.Enum as _Enum
_Enum = _Enum
import java.lang.Integer as _int
import com.badlogic.gdx.utils.JsonWriter as _JsonWriter_OutputType
_OutputType = _JsonWriter_OutputType.OutputType
import java.util.Optional as _Optional
_Optional = _Optional
import java.util.Optional as Optional
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class OutputType():
    """com.badlogic.gdx.utils.JsonWriter.OutputType"""
 
    @staticmethod
    def _wrap(java_value: _OutputType) -> 'OutputType':
        return OutputType(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _OutputType):
        """
        Dynamic initializer for OutputType.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_OutputType__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_OutputType__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hashCode(self) -> int:
        """public final int java.lang.Enum.hashCode()"""
        return int._wrap(super(Enum, self).hashCode())

    @staticmethod
    @overload
    def valueOf(arg0: 'Class', arg1: str) -> 'Enum':
        """public static <T extends java.lang.Enum<T>> T java.lang.Enum.valueOf(java.lang.Class<T>,java.lang.String)"""
        return Enum._wrap(_Enum.valueOf(arg0, arg1))

    @staticmethod
    @overload
    def valueOf(arg0: str) -> 'OutputType':
        """public static com.badlogic.gdx.utils.JsonWriter$OutputType com.badlogic.gdx.utils.JsonWriter$OutputType.valueOf(java.lang.String)"""
        return OutputType._wrap(_OutputType.valueOf(arg0))

    @override
    @overload
    def name(self) -> str:
        """public final java.lang.String java.lang.Enum.name()"""
        return str._wrap(super(Enum, self).name())

    @override
    @overload
    def describeConstable(self) -> 'Optional':
        """public final java.util.Optional<java.lang.Enum$EnumDesc<E>> java.lang.Enum.describeConstable()"""
        return 'Optional'._wrap(super(Enum, self).describeConstable())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Enum.toString()"""
        return str._wrap(super(Enum, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def ordinal(self) -> int:
        """public final int java.lang.Enum.ordinal()"""
        return int._wrap(super(Enum, self).ordinal())

    @overload
    def quoteValue(self, arg0: object) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonWriter$OutputType.quoteValue(java.lang.Object)"""
        return str._wrap(super(_OutputType, self).quoteValue(arg0))

    @overload
    def quoteName(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonWriter$OutputType.quoteName(java.lang.String)"""
        return str._wrap(super(_OutputType, self).quoteName(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def getDeclaringClass(self) -> 'type.Class':
        """public final java.lang.Class<E> java.lang.Enum.getDeclaringClass()"""
        return 'type.Class'._wrap(super(Enum, self).getDeclaringClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, arg0: object) -> bool:
        """public final boolean java.lang.Enum.equals(java.lang.Object)"""
        return bool._wrap(super(_Enum, self).equals(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def values() -> List['OutputType']:
        """public static com.badlogic.gdx.utils.JsonWriter$OutputType[] com.badlogic.gdx.utils.JsonWriter$OutputType.values()"""
        return List[OutputType]._wrap(_OutputType.values())

    @overload
    def compareTo(self, arg0: 'Enum') -> int:
        """public final int java.lang.Enum.compareTo(E)"""
        return int._wrap(super(_Enum, self).compareTo(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.badlogic.gdx.utils.Pools
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import com.badlogic.gdx.utils.Pools as _Pools
_Pools = _Pools
from builtins import type
import java.lang.Object as _object
import com.badlogic.gdx.utils.Pool as _Pool
_Pool = _Pool
from builtins import object
import java.lang.String as _String
_String = _String
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Pools():
    """com.badlogic.gdx.utils.Pools"""
 
    @staticmethod
    def _wrap(java_value: _Pools) -> 'Pools':
        return Pools(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Pools):
        """
        Dynamic initializer for Pools.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Pools__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Pools__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def freeAll(arg0: 'Array', arg1: bool):
        """public static void com.badlogic.gdx.utils.Pools.freeAll(com.badlogic.gdx.utils.Array,boolean)"""
        _Pools.freeAll(arg0, _boolean.valueOf(arg1))

    @staticmethod
    @overload
    def free(arg0: object):
        """public static void com.badlogic.gdx.utils.Pools.free(java.lang.Object)"""
        _Pools.free(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def set(arg0: 'Class', arg1: 'Pool'):
        """public static <T> void com.badlogic.gdx.utils.Pools.set(java.lang.Class<T>,com.badlogic.gdx.utils.Pool<T>)"""
        _Pools.set(arg0, arg1)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def freeAll(arg0: 'Array'):
        """public static void com.badlogic.gdx.utils.Pools.freeAll(com.badlogic.gdx.utils.Array)"""
        _Pools.freeAll(arg0)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def get(arg0: 'Class', arg1: int) -> 'Pool':
        """public static <T> com.badlogic.gdx.utils.Pool<T> com.badlogic.gdx.utils.Pools.get(java.lang.Class<T>,int)"""
        return Pool._wrap(_Pools.get(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def obtain(arg0: 'Class') -> object:
        """public static <T> T com.badlogic.gdx.utils.Pools.obtain(java.lang.Class<T>)"""
        return object._wrap(_Pools.obtain(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def get(arg0: 'Class') -> 'Pool':
        """public static <T> com.badlogic.gdx.utils.Pool<T> com.badlogic.gdx.utils.Pools.get(java.lang.Class<T>)"""
        return Pool._wrap(_Pools.get(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntIntMap
from builtins import str
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap_Entries
_Entries = _IntIntMap_Entries.Entries
from pyquantum_helper import override
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap_Values
_Values = _IntIntMap_Values.Values
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap
_IntIntMap = _IntIntMap
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap_Keys
_Keys = _IntIntMap_Keys.Keys
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class IntIntMap():
    """com.badlogic.gdx.utils.IntIntMap"""
 
    @staticmethod
    def _wrap(java_value: _IntIntMap) -> 'IntIntMap':
        return IntIntMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _IntIntMap):
        """
        Dynamic initializer for IntIntMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_IntIntMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_IntIntMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def remove(self, arg0: int, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.IntIntMap.remove(int,int)"""
        return int._wrap(super(_IntIntMap, self).remove(_int.valueOf(arg0), _int.valueOf(arg1)))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.IntIntMap.hashCode()"""
        return int._wrap(super(IntIntMap, self).hashCode())

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntIntMap.notEmpty()"""
        return bool._wrap(super(IntIntMap, self).notEmpty())

    @overload
    def __init__(self, arg0: 'IntIntMap'):
        """public com.badlogic.gdx.utils.IntIntMap(com.badlogic.gdx.utils.IntIntMap)"""
        val = _IntIntMap(arg0)
        self.__wrapper = val

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IntIntMap()"""
        val = _IntIntMap()
        self.__wrapper = val

    @overload
    def getAndIncrement(self, arg0: int, arg1: int, arg2: int) -> int:
        """public int com.badlogic.gdx.utils.IntIntMap.getAndIncrement(int,int,int)"""
        return int._wrap(super(_IntIntMap, self).getAndIncrement(_int.valueOf(arg0), _int.valueOf(arg1), _int.valueOf(arg2)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.IntIntMap$Entries com.badlogic.gdx.utils.IntIntMap.entries()"""
        return 'Entries'._wrap(super(IntIntMap, self).entries())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.IntIntMap$Entry> com.badlogic.gdx.utils.IntIntMap.iterator()"""
        return 'Iterator'._wrap(super(IntIntMap, self).iterator())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.IntIntMap.equals(java.lang.Object)"""
        return bool._wrap(super(_IntIntMap, self).equals(arg0))

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.IntIntMap$Keys com.badlogic.gdx.utils.IntIntMap.keys()"""
        return 'Keys'._wrap(super(IntIntMap, self).keys())

    @overload
    def containsKey(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntIntMap.containsKey(int)"""
        return bool._wrap(super(_IntIntMap, self).containsKey(_int.valueOf(arg0)))

    @overload
    def get(self, arg0: int, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.IntIntMap.get(int,int)"""
        return int._wrap(super(_IntIntMap, self).get(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.IntIntMap.clear()"""
        super(IntIntMap, self).clear()

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.IntIntMap(int)"""
        val = _IntIntMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.IntIntMap(int,float)"""
        val = _IntIntMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @overload
    def put(self, arg0: int, arg1: int, arg2: int) -> int:
        """public int com.badlogic.gdx.utils.IntIntMap.put(int,int,int)"""
        return int._wrap(super(_IntIntMap, self).put(_int.valueOf(arg0), _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def containsValue(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntIntMap.containsValue(int)"""
        return bool._wrap(super(_IntIntMap, self).containsValue(_int.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IntIntMap()"""
        val = _IntIntMap()
        self.__wrapper = val

    @overload
    def putAll(self, arg0: 'IntIntMap'):
        """public void com.badlogic.gdx.utils.IntIntMap.putAll(com.badlogic.gdx.utils.IntIntMap)"""
        super(_IntIntMap, self).putAll(arg0)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntIntMap.toString()"""
        return str._wrap(super(IntIntMap, self).toString())

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.IntIntMap$Values com.badlogic.gdx.utils.IntIntMap.values()"""
        return 'Values'._wrap(super(IntIntMap, self).values())

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntIntMap.isEmpty()"""
        return bool._wrap(super(IntIntMap, self).isEmpty())

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntIntMap.ensureCapacity(int)"""
        super(_IntIntMap, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntIntMap.shrink(int)"""
        super(_IntIntMap, self).shrink(_int.valueOf(arg0))

    @overload
    def findKey(self, arg0: int, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.IntIntMap.findKey(int,int)"""
        return int._wrap(super(_IntIntMap, self).findKey(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntIntMap.clear(int)"""
        super(_IntIntMap, self).clear(_int.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def put(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.IntIntMap.put(int,int)"""
        super(_IntIntMap, self).put(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectFloatMap$Entries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap_Entries
_Entries = _ObjectFloatMap_Entries.Entries
import java.util.function.Consumer as Consumer
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap_Entry
_Entry = _ObjectFloatMap_Entry.Entry
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.ObjectFloatMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.ObjectFloatMap$Entry<K> com.badlogic.gdx.utils.ObjectFloatMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'ObjectFloatMap'):
        """public com.badlogic.gdx.utils.ObjectFloatMap$Entries(com.badlogic.gdx.utils.ObjectFloatMap<K>)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectFloatMap$Entries<K> com.badlogic.gdx.utils.ObjectFloatMap$Entries.iterator()"""
        return 'Entries'._wrap(super(Entries, self).iterator())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.GdxNativesLoader
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from builtins import bool
import com.badlogic.gdx.utils.GdxNativesLoader as _GdxNativesLoader
_GdxNativesLoader = _GdxNativesLoader
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class GdxNativesLoader():
    """com.badlogic.gdx.utils.GdxNativesLoader"""
 
    @staticmethod
    def _wrap(java_value: _GdxNativesLoader) -> 'GdxNativesLoader':
        return GdxNativesLoader(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _GdxNativesLoader):
        """
        Dynamic initializer for GdxNativesLoader.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_GdxNativesLoader__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_GdxNativesLoader__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.GdxNativesLoader()"""
        val = _GdxNativesLoader()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.GdxNativesLoader()"""
        val = _GdxNativesLoader()
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

        @staticmethod
        @overload
        def load():
            """public static synchronized void com.badlogic.gdx.utils.GdxNativesLoader.load()"""
            _GdxNativesLoader.load()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectIntMap$Entries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap_Entry
_Entry = _ObjectIntMap_Entry.Entry
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap_Entries
_Entries = _ObjectIntMap_Entries.Entries
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.ObjectIntMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.ObjectIntMap$Entry<K> com.badlogic.gdx.utils.ObjectIntMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectIntMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def __init__(self, arg0: 'ObjectIntMap'):
        """public com.badlogic.gdx.utils.ObjectIntMap$Entries(com.badlogic.gdx.utils.ObjectIntMap<K>)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectIntMap$Entries<K> com.badlogic.gdx.utils.ObjectIntMap$Entries.iterator()"""
        return 'Entries'._wrap(super(Entries, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.IntArray as _IntArray
_IntArray = _IntArray
import java.lang.Integer as _int
import com.badlogic.gdx.utils.IntMap as _IntMap_Keys
_Keys = _IntMap_Keys.Keys
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.IntMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def toArray(self, arg0: 'IntArray') -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntMap$Keys.toArray(com.badlogic.gdx.utils.IntArray)"""
        return 'IntArray'._wrap(super(_Keys, self).toArray(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: 'IntMap'):
        """public com.badlogic.gdx.utils.IntMap$Keys(com.badlogic.gdx.utils.IntMap)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def toArray(self) -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntMap$Keys.toArray()"""
        return 'IntArray'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def next(self) -> int:
        """public int com.badlogic.gdx.utils.IntMap$Keys.next()"""
        return int._wrap(super(Keys, self).next())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.Float as _float
import java.lang.Integer as _int
import com.badlogic.gdx.utils.IntSet as _IntSet
_IntSet = _IntSet
from builtins import bool
import com.badlogic.gdx.utils.IntSet as _IntSet_IntSetIterator
_IntSetIterator = _IntSet_IntSetIterator.IntSetIterator
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class IntSet():
    """com.badlogic.gdx.utils.IntSet"""
 
    @staticmethod
    def _wrap(java_value: _IntSet) -> 'IntSet':
        return IntSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _IntSet):
        """
        Dynamic initializer for IntSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_IntSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_IntSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.IntSet.hashCode()"""
        return int._wrap(super(IntSet, self).hashCode())

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntSet.isEmpty()"""
        return bool._wrap(super(IntSet, self).isEmpty())

    @overload
    def first(self) -> int:
        """public int com.badlogic.gdx.utils.IntSet.first()"""
        return int._wrap(super(IntSet, self).first())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntSet.toString()"""
        return str._wrap(super(IntSet, self).toString())

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.IntSet.clear()"""
        super(IntSet, self).clear()

    @overload
    def addAll(self, arg0: 'IntArray'):
        """public void com.badlogic.gdx.utils.IntSet.addAll(com.badlogic.gdx.utils.IntArray)"""
        super(_IntSet, self).addAll(arg0)

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntSet.ensureCapacity(int)"""
        super(_IntSet, self).ensureCapacity(_int.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IntSet()"""
        val = _IntSet()
        self.__wrapper = val

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntSet.shrink(int)"""
        super(_IntSet, self).shrink(_int.valueOf(arg0))

    @overload
    def add(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntSet.add(int)"""
        return bool._wrap(super(_IntSet, self).add(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def with(*arg0: int) -> 'IntSet':
        """public static com.badlogic.gdx.utils.IntSet com.badlogic.gdx.utils.IntSet.with(int...)"""
        return IntSet._wrap(_IntSet.with(arg0))

    @overload
    def remove(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntSet.remove(int)"""
        return bool._wrap(super(_IntSet, self).remove(_int.valueOf(arg0)))

    @overload
    def iterator(self) -> 'IntSetIterator':
        """public com.badlogic.gdx.utils.IntSet$IntSetIterator com.badlogic.gdx.utils.IntSet.iterator()"""
        return 'IntSetIterator'._wrap(super(IntSet, self).iterator())

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntSet.clear(int)"""
        super(_IntSet, self).clear(_int.valueOf(arg0))

    @overload
    def addAll(self, arg0: 'IntArray', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.IntSet.addAll(com.badlogic.gdx.utils.IntArray,int,int)"""
        super(_IntSet, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def addAll(self, arg0: 'IntSet'):
        """public void com.badlogic.gdx.utils.IntSet.addAll(com.badlogic.gdx.utils.IntSet)"""
        super(_IntSet, self).addAll(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def contains(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntSet.contains(int)"""
        return bool._wrap(super(_IntSet, self).contains(_int.valueOf(arg0)))

    @overload
    def addAll(self, *arg0: int):
        """public void com.badlogic.gdx.utils.IntSet.addAll(int...)"""
        super(_IntSet, self).addAll(arg0)

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.IntSet(int)"""
        val = _IntSet(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntSet.notEmpty()"""
        return bool._wrap(super(IntSet, self).notEmpty())

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.IntSet(int,float)"""
        val = _IntSet(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @overload
    def addAll(self, arg0: 'int', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.IntSet.addAll(int[],int,int)"""
        super(_IntSet, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IntSet()"""
        val = _IntSet()
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'IntSet'):
        """public com.badlogic.gdx.utils.IntSet(com.badlogic.gdx.utils.IntSet)"""
        val = _IntSet(arg0)
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.IntSet.equals(java.lang.Object)"""
        return bool._wrap(super(_IntSet, self).equals(arg0)) 
 
 
# CLASS: com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import com.badlogic.gdx.utils.ObjectSet as _ObjectSet_ObjectSetIterator
_ObjectSetIterator = _ObjectSet_ObjectSetIterator.ObjectSetIterator
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import com.badlogic.gdx.utils.OrderedSet as _OrderedSet_OrderedSetIterator
_OrderedSetIterator = _OrderedSet_OrderedSetIterator.OrderedSetIterator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class OrderedSetIterator():
    """com.badlogic.gdx.utils.OrderedSet.OrderedSetIterator"""
 
    @staticmethod
    def _wrap(java_value: _OrderedSetIterator) -> 'OrderedSetIterator':
        return OrderedSetIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _OrderedSetIterator):
        """
        Dynamic initializer for OrderedSetIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_OrderedSetIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_OrderedSetIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator.reset()"""
        super(OrderedSetIterator, self).reset()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator.remove()"""
        super(OrderedSetIterator, self).remove()

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def iterator(self) -> 'ObjectSetIterator':
        """public com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator<K> com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.iterator()"""
        return 'ObjectSetIterator'._wrap(super(ObjectSetIterator, self).iterator())

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator.toArray(com.badlogic.gdx.utils.Array<K>)"""
        return 'Array'._wrap(super(_OrderedSetIterator, self).toArray(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator.next()"""
        return object._wrap(super(OrderedSetIterator, self).next())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def __init__(self, arg0: 'OrderedSet'):
        """public com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator(com.badlogic.gdx.utils.OrderedSet<K>)"""
        val = _OrderedSetIterator(arg0)
        self.__wrapper = val

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.hasNext()"""
        return bool._wrap(super(ObjectSetIterator, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator.toArray()"""
        return 'Array'._wrap(super(OrderedSetIterator, self).toArray())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ReflectionPool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.Pool as _Pool
_Pool = _Pool
import com.badlogic.gdx.utils.ReflectionPool as _ReflectionPool
_ReflectionPool = _ReflectionPool
from builtins import object
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ReflectionPool():
    """com.badlogic.gdx.utils.ReflectionPool"""
 
    @staticmethod
    def _wrap(java_value: _ReflectionPool) -> 'ReflectionPool':
        return ReflectionPool(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ReflectionPool):
        """
        Dynamic initializer for ReflectionPool.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ReflectionPool__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ReflectionPool__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def fill(self, arg0: int):
        """public void com.badlogic.gdx.utils.Pool.fill(int)"""
        super(_Pool, self).fill(_int.valueOf(arg0))

    @override
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.Pool.clear()"""
        super(Pool, self).clear()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: 'Class'):
        """public com.badlogic.gdx.utils.ReflectionPool(java.lang.Class<T>)"""
        val = _ReflectionPool(arg0)
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def freeAll(self, arg0: 'Array'):
        """public void com.badlogic.gdx.utils.Pool.freeAll(com.badlogic.gdx.utils.Array<T>)"""
        super(_Pool, self).freeAll(arg0)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: 'Class', arg1: int):
        """public com.badlogic.gdx.utils.ReflectionPool(java.lang.Class<T>,int)"""
        val = _ReflectionPool(arg0, _int.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: 'Class', arg1: int, arg2: int):
        """public com.badlogic.gdx.utils.ReflectionPool(java.lang.Class<T>,int,int)"""
        val = _ReflectionPool(arg0, _int.valueOf(arg1), _int.valueOf(arg2))
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def free(self, arg0: object):
        """public void com.badlogic.gdx.utils.Pool.free(T)"""
        super(_Pool, self).free(arg0)

    @override
    @overload
    def obtain(self) -> object:
        """public T com.badlogic.gdx.utils.Pool.obtain()"""
        return object._wrap(super(Pool, self).obtain())

    @override
    @overload
    def getFree(self) -> int:
        """public int com.badlogic.gdx.utils.Pool.getFree()"""
        return int._wrap(super(Pool, self).getFree())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.QuadTreeFloat
from pyquantum_helper import import_once as _import_once
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import com.badlogic.gdx.utils.QuadTreeFloat as _QuadTreeFloat
_QuadTreeFloat = _QuadTreeFloat
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.Float as _float
import java.lang.Integer as _int
try:
    from pygdx import math
except ImportError:
    math = _import_once("pygdx.math")

from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class QuadTreeFloat():
    """com.badlogic.gdx.utils.QuadTreeFloat"""
 
    @staticmethod
    def _wrap(java_value: _QuadTreeFloat) -> 'QuadTreeFloat':
        return QuadTreeFloat(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _QuadTreeFloat):
        """
        Dynamic initializer for QuadTreeFloat.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_QuadTreeFloat__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_QuadTreeFloat__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def query(self, arg0: 'Rectangle', arg1: 'FloatArray'):
        """public void com.badlogic.gdx.utils.QuadTreeFloat.query(com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.utils.FloatArray)"""
        super(_QuadTreeFloat, self).query(arg0, arg1)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def add(self, arg0: float, arg1: float, arg2: float):
        """public void com.badlogic.gdx.utils.QuadTreeFloat.add(float,float,float)"""
        super(_QuadTreeFloat, self).add(_float.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.QuadTreeFloat()"""
        val = _QuadTreeFloat()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.QuadTreeFloat.reset()"""
        super(QuadTreeFloat, self).reset()

    @overload
    def query(self, arg0: float, arg1: float, arg2: float, arg3: 'FloatArray'):
        """public void com.badlogic.gdx.utils.QuadTreeFloat.query(float,float,float,com.badlogic.gdx.utils.FloatArray)"""
        super(_QuadTreeFloat, self).query(_float.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2), arg3)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: int, arg1: int):
        """public com.badlogic.gdx.utils.QuadTreeFloat(int,int)"""
        val = _QuadTreeFloat(_int.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def nearest(self, arg0: float, arg1: float, arg2: 'FloatArray') -> bool:
        """public boolean com.badlogic.gdx.utils.QuadTreeFloat.nearest(float,float,com.badlogic.gdx.utils.FloatArray)"""
        return bool._wrap(super(_QuadTreeFloat, self).nearest(_float.valueOf(arg0), _float.valueOf(arg1), arg2))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def setBounds(self, arg0: float, arg1: float, arg2: float, arg3: float):
        """public void com.badlogic.gdx.utils.QuadTreeFloat.setBounds(float,float,float,float)"""
        super(_QuadTreeFloat, self).setBounds(_float.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2), _float.valueOf(arg3))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.QuadTreeFloat()"""
        val = _QuadTreeFloat()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.DataInput
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.io.DataInputStream as _DataInputStream
_DataInputStream = _DataInputStream
import java.lang.Object as _object
from builtins import type
from builtins import float
import java.io.FilterInputStream as _FilterInputStream
_FilterInputStream = _FilterInputStream
import java.lang.String as _String
_String = _String
import java.io.DataInput as DataInput
from typing import List
import java.io.InputStream as _InputStream
_InputStream = _InputStream
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.io.OutputStream as OutputStream
import java.io.InputStream as InputStream
from builtins import bool
import java.lang.Long as _long
import com.badlogic.gdx.utils.DataInput as _DataInput
_DataInput = _DataInput
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class DataInput():
    """com.badlogic.gdx.utils.DataInput"""
 
    @staticmethod
    def _wrap(java_value: _DataInput) -> 'DataInput':
        return DataInput(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _DataInput):
        """
        Dynamic initializer for DataInput.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_DataInput__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_DataInput__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def transferTo(self, arg0: 'OutputStream') -> int:
        """public long java.io.InputStream.transferTo(java.io.OutputStream) throws java.io.IOException"""
        return int._wrap(super(_InputStream, self).transferTo(arg0))

    @override
    @overload
    def readUTF(self) -> str:
        """public final java.lang.String java.io.DataInputStream.readUTF() throws java.io.IOException"""
        return str._wrap(super(DataInputStream, self).readUTF())

    @override
    @overload
    def available(self) -> int:
        """public int java.io.FilterInputStream.available() throws java.io.IOException"""
        return int._wrap(super(FilterInputStream, self).available())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def markSupported(self) -> bool:
        """public boolean java.io.FilterInputStream.markSupported()"""
        return bool._wrap(super(FilterInputStream, self).markSupported())

    @overload
    def readInt(self, arg0: bool) -> int:
        """public int com.badlogic.gdx.utils.DataInput.readInt(boolean) throws java.io.IOException"""
        return int._wrap(super(_DataInput, self).readInt(_boolean.valueOf(arg0)))

    @overload
    def readString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.DataInput.readString() throws java.io.IOException"""
        return str._wrap(super(DataInput, self).readString())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def readAllBytes(self) -> List[int]:
        """public byte[] java.io.InputStream.readAllBytes() throws java.io.IOException"""
        return List[int]._wrap(super(InputStream, self).readAllBytes())

    @overload
    def read(self, arg0: bytes) -> int:
        """public final int java.io.DataInputStream.read(byte[]) throws java.io.IOException"""
        return int._wrap(super(_DataInputStream, self).read(bytes))

    @override
    @overload
    def readLong(self) -> int:
        """public final long java.io.DataInputStream.readLong() throws java.io.IOException"""
        return int._wrap(super(DataInputStream, self).readLong())

    @overload
    def skip(self, arg0: int) -> int:
        """public long java.io.FilterInputStream.skip(long) throws java.io.IOException"""
        return int._wrap(super(_FilterInputStream, self).skip(_long.valueOf(arg0)))

    @override
    @overload
    def readFully(self, arg0: bytes, arg1: int, arg2: int):
        """public final void java.io.DataInputStream.readFully(byte[],int,int) throws java.io.IOException"""
        super(_DataInputStream, self).readFully(bytes, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def readBoolean(self) -> bool:
        """public final boolean java.io.DataInputStream.readBoolean() throws java.io.IOException"""
        return bool._wrap(super(DataInputStream, self).readBoolean())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def skipNBytes(self, arg0: int):
        """public void java.io.InputStream.skipNBytes(long) throws java.io.IOException"""
        super(_InputStream, self).skipNBytes(_long.valueOf(arg0))

    @override
    @overload
    def reset(self):
        """public void java.io.FilterInputStream.reset() throws java.io.IOException"""
        super(FilterInputStream, self).reset()

    @override
    @overload
    def readLine(self) -> str:
        """public final java.lang.String java.io.DataInputStream.readLine() throws java.io.IOException"""
        return str._wrap(super(DataInputStream, self).readLine())

    @override
    @overload
    def mark(self, arg0: int):
        """public void java.io.FilterInputStream.mark(int)"""
        super(_FilterInputStream, self).mark(_int.valueOf(arg0))

    @override
    @overload
    def readFully(self, arg0: bytes):
        """public final void java.io.DataInputStream.readFully(byte[]) throws java.io.IOException"""
        super(_DataInputStream, self).readFully(bytes)

    @overload
    def skipBytes(self, arg0: int) -> int:
        """public final int java.io.DataInputStream.skipBytes(int) throws java.io.IOException"""
        return int._wrap(super(_DataInputStream, self).skipBytes(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'InputStream'):
        """public com.badlogic.gdx.utils.DataInput(java.io.InputStream)"""
        val = _DataInput(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def readUTF(arg0: 'DataInput') -> str:
        """public static final java.lang.String java.io.DataInputStream.readUTF(java.io.DataInput) throws java.io.IOException"""
        return str._wrap(_DataInputStream.readUTF(arg0))

    @override
    @overload
    def readByte(self) -> int:
        """public final byte java.io.DataInputStream.readByte() throws java.io.IOException"""
        return int._wrap(super(DataInputStream, self).readByte())

    @override
    @overload
    def readUnsignedShort(self) -> int:
        """public final int java.io.DataInputStream.readUnsignedShort() throws java.io.IOException"""
        return int._wrap(super(DataInputStream, self).readUnsignedShort())

    @staticmethod
    @overload
    def nullInputStream() -> 'InputStream':
        """public static java.io.InputStream java.io.InputStream.nullInputStream()"""
        return InputStream._wrap(_InputStream.nullInputStream())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def read(self, arg0: bytes, arg1: int, arg2: int) -> int:
        """public final int java.io.DataInputStream.read(byte[],int,int) throws java.io.IOException"""
        return int._wrap(super(_DataInputStream, self).read(bytes, _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def readNBytes(self, arg0: bytes, arg1: int, arg2: int) -> int:
        """public int java.io.InputStream.readNBytes(byte[],int,int) throws java.io.IOException"""
        return int._wrap(super(_InputStream, self).readNBytes(bytes, _int.valueOf(arg1), _int.valueOf(arg2)))

    @override
    @overload
    def close(self):
        """public void java.io.FilterInputStream.close() throws java.io.IOException"""
        super(FilterInputStream, self).close()

    @override
    @overload
    def readInt(self) -> int:
        """public final int java.io.DataInputStream.readInt() throws java.io.IOException"""
        return int._wrap(super(DataInputStream, self).readInt())

    @override
    @overload
    def readFloat(self) -> float:
        """public final float java.io.DataInputStream.readFloat() throws java.io.IOException"""
        return float._wrap(super(DataInputStream, self).readFloat())

    @override
    @overload
    def read(self) -> int:
        """public int java.io.FilterInputStream.read() throws java.io.IOException"""
        return int._wrap(super(FilterInputStream, self).read())

    @override
    @overload
    def readChar(self) -> str:
        """public final char java.io.DataInputStream.readChar() throws java.io.IOException"""
        return str._wrap(super(DataInputStream, self).readChar())

    @override
    @overload
    def readShort(self) -> int:
        """public final short java.io.DataInputStream.readShort() throws java.io.IOException"""
        return int._wrap(super(DataInputStream, self).readShort())

    @overload
    def readNBytes(self, arg0: int) -> List[int]:
        """public byte[] java.io.InputStream.readNBytes(int) throws java.io.IOException"""
        return List[int]._wrap(super(_InputStream, self).readNBytes(_int.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def readDouble(self) -> float:
        """public final double java.io.DataInputStream.readDouble() throws java.io.IOException"""
        return float._wrap(super(DataInputStream, self).readDouble())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def readUnsignedByte(self) -> int:
        """public final int java.io.DataInputStream.readUnsignedByte() throws java.io.IOException"""
        return int._wrap(super(DataInputStream, self).readUnsignedByte())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.LongMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.LongMap as _LongMap_Keys
_Keys = _LongMap_Keys.Keys
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.LongArray as _LongArray
_LongArray = _LongArray
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.LongMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def toArray(self, arg0: 'LongArray') -> 'LongArray':
        """public com.badlogic.gdx.utils.LongArray com.badlogic.gdx.utils.LongMap$Keys.toArray(com.badlogic.gdx.utils.LongArray)"""
        return 'LongArray'._wrap(super(_Keys, self).toArray(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: 'LongMap'):
        """public com.badlogic.gdx.utils.LongMap$Keys(com.badlogic.gdx.utils.LongMap)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def next(self) -> int:
        """public long com.badlogic.gdx.utils.LongMap$Keys.next()"""
        return int._wrap(super(Keys, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def toArray(self) -> 'LongArray':
        """public com.badlogic.gdx.utils.LongArray com.badlogic.gdx.utils.LongMap$Keys.toArray()"""
        return 'LongArray'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectLongMap
from builtins import str
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Values
_Values = _ObjectLongMap_Values.Values
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Keys
_Keys = _ObjectLongMap_Keys.Keys
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap
_ObjectLongMap = _ObjectLongMap
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Entries
_Entries = _ObjectLongMap_Entries.Entries
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ObjectLongMap():
    """com.badlogic.gdx.utils.ObjectLongMap"""
 
    @staticmethod
    def _wrap(java_value: _ObjectLongMap) -> 'ObjectLongMap':
        return ObjectLongMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ObjectLongMap):
        """
        Dynamic initializer for ObjectLongMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ObjectLongMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ObjectLongMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def remove(self, arg0: object, arg1: int) -> int:
        """public long com.badlogic.gdx.utils.ObjectLongMap.remove(K,long)"""
        return int._wrap(super(_ObjectLongMap, self).remove(arg0, _long.valueOf(arg1)))

    @overload
    def getAndIncrement(self, arg0: object, arg1: int, arg2: int) -> int:
        """public long com.badlogic.gdx.utils.ObjectLongMap.getAndIncrement(K,long,long)"""
        return int._wrap(super(_ObjectLongMap, self).getAndIncrement(arg0, _long.valueOf(arg1), _long.valueOf(arg2)))

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectLongMap$Keys<K> com.badlogic.gdx.utils.ObjectLongMap.keys()"""
        return 'Keys'._wrap(super(ObjectLongMap, self).keys())

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectLongMap.clear(int)"""
        super(_ObjectLongMap, self).clear(_int.valueOf(arg0))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap.notEmpty()"""
        return bool._wrap(super(ObjectLongMap, self).notEmpty())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectLongMap()"""
        val = _ObjectLongMap()
        self.__wrapper = val

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectLongMap$Entries<K> com.badlogic.gdx.utils.ObjectLongMap.entries()"""
        return 'Entries'._wrap(super(ObjectLongMap, self).entries())

    @overload
    def putAll(self, arg0: 'ObjectLongMap'):
        """public void com.badlogic.gdx.utils.ObjectLongMap.putAll(com.badlogic.gdx.utils.ObjectLongMap<? extends K>)"""
        super(_ObjectLongMap, self).putAll(arg0)

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectLongMap.toString()"""
        return str._wrap(super(ObjectLongMap, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.ObjectLongMap(int)"""
        val = _ObjectLongMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectLongMap.shrink(int)"""
        super(_ObjectLongMap, self).shrink(_int.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ObjectLongMap.clear()"""
        super(ObjectLongMap, self).clear()

    @overload
    def containsKey(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap.containsKey(K)"""
        return bool._wrap(super(_ObjectLongMap, self).containsKey(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ObjectLongMap, self).equals(arg0))

    @overload
    def put(self, arg0: object, arg1: int):
        """public void com.badlogic.gdx.utils.ObjectLongMap.put(K,long)"""
        super(_ObjectLongMap, self).put(arg0, _long.valueOf(arg1))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectLongMap$Values com.badlogic.gdx.utils.ObjectLongMap.values()"""
        return 'Values'._wrap(super(ObjectLongMap, self).values())

    @overload
    def get(self, arg0: object, arg1: int) -> int:
        """public long com.badlogic.gdx.utils.ObjectLongMap.get(K,long)"""
        return int._wrap(super(_ObjectLongMap, self).get(arg0, _long.valueOf(arg1)))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap.isEmpty()"""
        return bool._wrap(super(ObjectLongMap, self).isEmpty())

    @overload
    def containsValue(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap.containsValue(long)"""
        return bool._wrap(super(_ObjectLongMap, self).containsValue(_long.valueOf(arg0)))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectLongMap()"""
        val = _ObjectLongMap()
        self.__wrapper = val

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectLongMap$Entries<K> com.badlogic.gdx.utils.ObjectLongMap.iterator()"""
        return 'Entries'._wrap(super(ObjectLongMap, self).iterator())

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectLongMap.ensureCapacity(int)"""
        super(_ObjectLongMap, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def put(self, arg0: object, arg1: int, arg2: int) -> int:
        """public long com.badlogic.gdx.utils.ObjectLongMap.put(K,long,long)"""
        return int._wrap(super(_ObjectLongMap, self).put(arg0, _long.valueOf(arg1), _long.valueOf(arg2)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectLongMap.toString(java.lang.String)"""
        return str._wrap(super(_ObjectLongMap, self).toString(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ObjectLongMap.hashCode()"""
        return int._wrap(super(ObjectLongMap, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'ObjectLongMap'):
        """public com.badlogic.gdx.utils.ObjectLongMap(com.badlogic.gdx.utils.ObjectLongMap<? extends K>)"""
        val = _ObjectLongMap(arg0)
        self.__wrapper = val

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.ObjectLongMap(int,float)"""
        val = _ObjectLongMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def findKey(self, arg0: int) -> object:
        """public K com.badlogic.gdx.utils.ObjectLongMap.findKey(long)"""
        return object._wrap(super(_ObjectLongMap, self).findKey(_long.valueOf(arg0))) 
 
 
# CLASS: com.badlogic.gdx.utils.JsonValue$ValueType
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.Enum as Enum
import java.lang.String as _string
import com.badlogic.gdx.utils.JsonValue as _JsonValue_ValueType
_ValueType = _JsonValue_ValueType.ValueType
import java.lang.Enum as _Enum
_Enum = _Enum
import java.lang.Integer as _int
import java.util.Optional as _Optional
_Optional = _Optional
import java.util.Optional as Optional
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ValueType():
    """com.badlogic.gdx.utils.JsonValue.ValueType"""
 
    @staticmethod
    def _wrap(java_value: _ValueType) -> 'ValueType':
        return ValueType(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ValueType):
        """
        Dynamic initializer for ValueType.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ValueType__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ValueType__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hashCode(self) -> int:
        """public final int java.lang.Enum.hashCode()"""
        return int._wrap(super(Enum, self).hashCode())

    @staticmethod
    @overload
    def valueOf(arg0: 'Class', arg1: str) -> 'Enum':
        """public static <T extends java.lang.Enum<T>> T java.lang.Enum.valueOf(java.lang.Class<T>,java.lang.String)"""
        return Enum._wrap(_Enum.valueOf(arg0, arg1))

    @staticmethod
    @overload
    def values() -> List['ValueType']:
        """public static com.badlogic.gdx.utils.JsonValue$ValueType[] com.badlogic.gdx.utils.JsonValue$ValueType.values()"""
        return List[ValueType]._wrap(_ValueType.values())

    @override
    @overload
    def name(self) -> str:
        """public final java.lang.String java.lang.Enum.name()"""
        return str._wrap(super(Enum, self).name())

    @override
    @overload
    def describeConstable(self) -> 'Optional':
        """public final java.util.Optional<java.lang.Enum$EnumDesc<E>> java.lang.Enum.describeConstable()"""
        return 'Optional'._wrap(super(Enum, self).describeConstable())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Enum.toString()"""
        return str._wrap(super(Enum, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def ordinal(self) -> int:
        """public final int java.lang.Enum.ordinal()"""
        return int._wrap(super(Enum, self).ordinal())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def getDeclaringClass(self) -> 'type.Class':
        """public final java.lang.Class<E> java.lang.Enum.getDeclaringClass()"""
        return 'type.Class'._wrap(super(Enum, self).getDeclaringClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, arg0: object) -> bool:
        """public final boolean java.lang.Enum.equals(java.lang.Object)"""
        return bool._wrap(super(_Enum, self).equals(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def compareTo(self, arg0: 'Enum') -> int:
        """public final int java.lang.Enum.compareTo(E)"""
        return int._wrap(super(_Enum, self).compareTo(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def valueOf(arg0: str) -> 'ValueType':
        """public static com.badlogic.gdx.utils.JsonValue$ValueType com.badlogic.gdx.utils.JsonValue$ValueType.valueOf(java.lang.String)"""
        return ValueType._wrap(_ValueType.valueOf(arg0)) 
 
 
# CLASS: com.badlogic.gdx.utils.SortedIntList$Iterator
from builtins import str
import com.badlogic.gdx.utils.SortedIntList as _SortedIntList_Iterator
_Iterator = _SortedIntList_Iterator.Iterator
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.SortedIntList as _SortedIntList_Node
_Node = _SortedIntList_Node.Node
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.lang.Integer as _int
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Iterator():
    """com.badlogic.gdx.utils.SortedIntList.Iterator"""
 
    @staticmethod
    def _wrap(java_value: _Iterator) -> 'Iterator':
        return Iterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Iterator):
        """
        Dynamic initializer for Iterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Iterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Iterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.SortedIntList$Iterator.remove()"""
        super(Iterator, self).remove()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def __init__(self, arg0: 'SortedIntList'):
        """public com.badlogic.gdx.utils.SortedIntList$Iterator(com.badlogic.gdx.utils.SortedIntList)"""
        val = _Iterator(arg0)
        self.__wrapper = val

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.SortedIntList$Iterator.hasNext()"""
        return bool._wrap(super(Iterator, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def reset(self) -> 'Iterator':
        """public com.badlogic.gdx.utils.SortedIntList<E>$Iterator com.badlogic.gdx.utils.SortedIntList$Iterator.reset()"""
        return 'Iterator'._wrap(super(Iterator, self).reset())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def next(self) -> 'Node':
        """public com.badlogic.gdx.utils.SortedIntList$Node<E> com.badlogic.gdx.utils.SortedIntList$Iterator.next()"""
        return 'Node'._wrap(super(Iterator, self).next())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Keys
_Keys = _ObjectMap_Keys.Keys
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.ObjectMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.ObjectMap$Keys.next()"""
        return object._wrap(super(Keys, self).next())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectMap$Keys.toArray(com.badlogic.gdx.utils.Array<K>)"""
        return 'Array'._wrap(super(_Keys, self).toArray(arg0))

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectMap$Keys.toArray()"""
        return 'Array'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def __init__(self, arg0: 'ObjectMap'):
        """public com.badlogic.gdx.utils.ObjectMap$Keys(com.badlogic.gdx.utils.ObjectMap<K, ?>)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap$Keys.hasNext()"""
        return bool._wrap(super(Keys, self).hasNext())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def iterator(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectMap$Keys<K> com.badlogic.gdx.utils.ObjectMap$Keys.iterator()"""
        return 'Keys'._wrap(super(Keys, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntIntMap$Values
from builtins import str
from pyquantum_helper import override
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap_Values
_Values = _IntIntMap_Values.Values
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.IntArray as _IntArray
_IntArray = _IntArray
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.IntIntMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def iterator(self) -> 'Values':
        """public com.badlogic.gdx.utils.IntIntMap$Values com.badlogic.gdx.utils.IntIntMap$Values.iterator()"""
        return 'Values'._wrap(super(Values, self).iterator())

    @overload
    def toArray(self, arg0: 'IntArray') -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntIntMap$Values.toArray(com.badlogic.gdx.utils.IntArray)"""
        return 'IntArray'._wrap(super(_Values, self).toArray(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: 'IntIntMap'):
        """public com.badlogic.gdx.utils.IntIntMap$Values(com.badlogic.gdx.utils.IntIntMap)"""
        val = _Values(arg0)
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def toArray(self) -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntIntMap$Values.toArray()"""
        return 'IntArray'._wrap(super(Values, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntIntMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def next(self) -> int:
        """public int com.badlogic.gdx.utils.IntIntMap$Values.next()"""
        return int._wrap(super(Values, self).next())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.SnapshotArray
from builtins import str
import com.badlogic.gdx.utils.Array as _Array_ArrayIterator
_ArrayIterator = _Array_ArrayIterator.ArrayIterator
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
from typing import List
import java.util.function.Consumer as Consumer
import java.util.Comparator as Comparator
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.SnapshotArray as _SnapshotArray
_SnapshotArray = _SnapshotArray
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class SnapshotArray():
    """com.badlogic.gdx.utils.SnapshotArray"""
 
    @staticmethod
    def _wrap(java_value: _SnapshotArray) -> 'SnapshotArray':
        return SnapshotArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SnapshotArray):
        """
        Dynamic initializer for SnapshotArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SnapshotArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SnapshotArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, arg0: 'Class'):
        """public com.badlogic.gdx.utils.SnapshotArray(java.lang.Class)"""
        val = _SnapshotArray(arg0)
        self.__wrapper = val

    @override
    @overload
    def toArray(self) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.toArray()"""
        return List[object]._wrap(super(Array, self).toArray())

    @override
    @overload
    def iterator(self) -> 'ArrayIterator':
        """public com.badlogic.gdx.utils.Array$ArrayIterator<T> com.badlogic.gdx.utils.Array.iterator()"""
        return 'ArrayIterator'._wrap(super(Array, self).iterator())

    @override
    @overload
    def shrink(self) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.shrink()"""
        return List[object]._wrap(super(Array, self).shrink())

    @overload
    def __init__(self, arg0: 'Array'):
        """public com.badlogic.gdx.utils.SnapshotArray(com.badlogic.gdx.utils.Array)"""
        val = _SnapshotArray(arg0)
        self.__wrapper = val

    @override
    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.SnapshotArray.sort()"""
        super(SnapshotArray, self).sort()

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.SnapshotArray.insertRange(int,int)"""
        super(_SnapshotArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.SnapshotArray(boolean,int)"""
        val = _SnapshotArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def begin(self) -> List[object]:
        """public T[] com.badlogic.gdx.utils.SnapshotArray.begin()"""
        return List[object]._wrap(super(SnapshotArray, self).begin())

    @overload
    def selectRankedIndex(self, arg0: 'Comparator', arg1: int) -> int:
        """public int com.badlogic.gdx.utils.Array.selectRankedIndex(java.util.Comparator<T>,int)"""
        return int._wrap(super(_Array, self).selectRankedIndex(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, arg0: 'Object'):
        """public com.badlogic.gdx.utils.SnapshotArray(T[])"""
        val = _SnapshotArray(arg0)
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def sort(self, arg0: 'Comparator'):
        """public void com.badlogic.gdx.utils.SnapshotArray.sort(java.util.Comparator<? super T>)"""
        super(_SnapshotArray, self).sort(arg0)

    @override
    @overload
    def addAll(self, arg0: 'Array', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.Array.addAll(com.badlogic.gdx.utils.Array<? extends T>,int,int)"""
        super(_Array, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def containsAny(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.containsAny(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_Array, self).containsAny(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def add(self, arg0: object):
        """public void com.badlogic.gdx.utils.Array.add(T)"""
        super(_Array, self).add(arg0)

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.SnapshotArray(int)"""
        val = _SnapshotArray(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def removeIndex(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.SnapshotArray.removeIndex(int)"""
        return object._wrap(super(_SnapshotArray, self).removeIndex(_int.valueOf(arg0)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Array.toString()"""
        return str._wrap(super(Array, self).toString())

    @overload
    def get(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.Array.get(int)"""
        return object._wrap(super(_Array, self).get(_int.valueOf(arg0)))

    @override
    @overload
    def addAll(self, arg0: 'Array'):
        """public void com.badlogic.gdx.utils.Array.addAll(com.badlogic.gdx.utils.Array<? extends T>)"""
        super(_Array, self).addAll(arg0)

    @override
    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.notEmpty()"""
        return bool._wrap(super(Array, self).notEmpty())

    @override
    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.SnapshotArray.shuffle()"""
        super(SnapshotArray, self).shuffle()

    @override
    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.SnapshotArray.truncate(int)"""
        super(_SnapshotArray, self).truncate(_int.valueOf(arg0))

    @override
    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.SnapshotArray.swap(int,int)"""
        super(_SnapshotArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def removeValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.SnapshotArray.removeValue(T,boolean)"""
        return bool._wrap(super(_SnapshotArray, self).removeValue(arg0, _boolean.valueOf(arg1)))

    @overload
    def end(self):
        """public void com.badlogic.gdx.utils.SnapshotArray.end()"""
        super(SnapshotArray, self).end()

    @override
    @overload
    def pop(self) -> object:
        """public T com.badlogic.gdx.utils.SnapshotArray.pop()"""
        return object._wrap(super(SnapshotArray, self).pop())

    @override
    @overload
    def addAll(self, *arg0: object):
        """public void com.badlogic.gdx.utils.Array.addAll(T...)"""
        super(_Array, self).addAll(arg0)

    @override
    @overload
    def insert(self, arg0: int, arg1: object):
        """public void com.badlogic.gdx.utils.SnapshotArray.insert(int,T)"""
        super(_SnapshotArray, self).insert(_int.valueOf(arg0), arg1)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.SnapshotArray()"""
        val = _SnapshotArray()
        self.__wrapper = val

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.SnapshotArray()"""
        val = _SnapshotArray()
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.Array.hashCode()"""
        return int._wrap(super(Array, self).hashCode())

    @override
    @overload
    def add(self, arg0: object, arg1: object, arg2: object, arg3: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T,T,T)"""
        super(_Array, self).add(arg0, arg1, arg2, arg3)

    @overload
    def __init__(self, arg0: bool, arg1: 'Object', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.SnapshotArray(boolean,T[],int,int)"""
        val = _SnapshotArray(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.isEmpty()"""
        return bool._wrap(super(Array, self).isEmpty())

    @overload
    def toArray(self, arg0: 'Class') -> List[object]:
        """public <V> V[] com.badlogic.gdx.utils.Array.toArray(java.lang.Class<V>)"""
        return List[object]._wrap(super(_Array, self).toArray(arg0))

    @override
    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.SnapshotArray.reverse()"""
        super(SnapshotArray, self).reverse()

    @overload
    def lastIndexOf(self, arg0: object, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.Array.lastIndexOf(T,boolean)"""
        return int._wrap(super(_Array, self).lastIndexOf(arg0, _boolean.valueOf(arg1)))

    @staticmethod
    @overload
    def with(*arg0: object) -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.with(T...)"""
        return Array._wrap(_Array.with(arg0))

    @override
    @overload
    def first(self) -> object:
        """public T com.badlogic.gdx.utils.Array.first()"""
        return object._wrap(super(Array, self).first())

    @override
    @overload
    def random(self) -> object:
        """public T com.badlogic.gdx.utils.Array.random()"""
        return object._wrap(super(Array, self).random())

    @overload
    def select(self, arg0: 'Predicate') -> 'Iterable':
        """public java.lang.Iterable<T> com.badlogic.gdx.utils.Array.select(com.badlogic.gdx.utils.Predicate<T>)"""
        return 'Iterable'._wrap(super(_Array, self).select(arg0))

    @overload
    def selectRanked(self, arg0: 'Comparator', arg1: int) -> object:
        """public T com.badlogic.gdx.utils.Array.selectRanked(java.util.Comparator<T>,int)"""
        return object._wrap(super(_Array, self).selectRanked(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def add(self, arg0: object, arg1: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T)"""
        super(_Array, self).add(arg0, arg1)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.equals(java.lang.Object)"""
        return bool._wrap(super(_Array, self).equals(arg0))

    @staticmethod
    @overload
    def with(*arg0: object) -> 'SnapshotArray':
        """public static <T> com.badlogic.gdx.utils.SnapshotArray<T> com.badlogic.gdx.utils.SnapshotArray.with(T...)"""
        return SnapshotArray._wrap(_SnapshotArray.with(arg0))

    @override
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.SnapshotArray.clear()"""
        super(SnapshotArray, self).clear()

    @overload
    def contains(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.contains(T,boolean)"""
        return bool._wrap(super(_Array, self).contains(arg0, _boolean.valueOf(arg1)))

    @staticmethod
    @overload
    def of(arg0: 'Class') -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.of(java.lang.Class<T>)"""
        return Array._wrap(_Array.of(arg0))

    @overload
    def indexOf(self, arg0: object, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.Array.indexOf(T,boolean)"""
        return int._wrap(super(_Array, self).indexOf(arg0, _boolean.valueOf(arg1)))

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_Array, self).equalsIdentity(arg0))

    @overload
    def __init__(self, arg0: bool, arg1: int, arg2: 'Class'):
        """public com.badlogic.gdx.utils.SnapshotArray(boolean,int,java.lang.Class)"""
        val = _SnapshotArray(_boolean.valueOf(arg0), _int.valueOf(arg1), arg2)
        self.__wrapper = val

    @override
    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.SnapshotArray.removeRange(int,int)"""
        super(_SnapshotArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Array.toString(java.lang.String)"""
        return str._wrap(super(_Array, self).toString(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def removeAll(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.SnapshotArray.removeAll(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_SnapshotArray, self).removeAll(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def set(self, arg0: int, arg1: object):
        """public void com.badlogic.gdx.utils.SnapshotArray.set(int,T)"""
        super(_SnapshotArray, self).set(_int.valueOf(arg0), arg1)

    @overload
    def ensureCapacity(self, arg0: int) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.ensureCapacity(int)"""
        return List[object]._wrap(super(_Array, self).ensureCapacity(_int.valueOf(arg0)))

    @override
    @overload
    def addAll(self, arg0: 'Object', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.Array.addAll(T[],int,int)"""
        super(_Array, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def setSize(self, arg0: int) -> List[object]:
        """public T[] com.badlogic.gdx.utils.SnapshotArray.setSize(int)"""
        return List[object]._wrap(super(_SnapshotArray, self).setSize(_int.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def add(self, arg0: object, arg1: object, arg2: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T,T)"""
        super(_Array, self).add(arg0, arg1, arg2)

    @staticmethod
    @overload
    def of(arg0: bool, arg1: int, arg2: 'Class') -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.of(boolean,int,java.lang.Class<T>)"""
        return Array._wrap(_Array.of(_boolean.valueOf(arg0), _int.valueOf(arg1), arg2))

    @overload
    def containsAll(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.containsAll(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_Array, self).containsAll(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def peek(self) -> object:
        """public T com.badlogic.gdx.utils.Array.peek()"""
        return object._wrap(super(Array, self).peek()) 
 
 
# CLASS: com.badlogic.gdx.utils.Collections
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.Collections as _Collections
_Collections = _Collections
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Collections():
    """com.badlogic.gdx.utils.Collections"""
 
    @staticmethod
    def _wrap(java_value: _Collections) -> 'Collections':
        return Collections(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Collections):
        """
        Dynamic initializer for Collections.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Collections__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Collections__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Collections()"""
        val = _Collections()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Collections()"""
        val = _Collections()
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectMap$Values
from builtins import str
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Values
_Values = _ObjectMap_Values.Values
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.ObjectMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, arg0: 'ObjectMap'):
        """public com.badlogic.gdx.utils.ObjectMap$Values(com.badlogic.gdx.utils.ObjectMap<?, V>)"""
        val = _Values(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<V> com.badlogic.gdx.utils.ObjectMap$Values.toArray()"""
        return 'Array'._wrap(super(Values, self).toArray())

    @override
    @overload
    def next(self) -> object:
        """public V com.badlogic.gdx.utils.ObjectMap$Values.next()"""
        return object._wrap(super(Values, self).next())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<V> com.badlogic.gdx.utils.ObjectMap$Values.toArray(com.badlogic.gdx.utils.Array<V>)"""
        return 'Array'._wrap(super(_Values, self).toArray(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def iterator(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectMap$Values<V> com.badlogic.gdx.utils.ObjectMap$Values.iterator()"""
        return 'Values'._wrap(super(Values, self).iterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectIntMap$Values
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap_Values
_Values = _ObjectIntMap_Values.Values
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.IntArray as _IntArray
_IntArray = _IntArray
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.ObjectIntMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def next(self) -> int:
        """public int com.badlogic.gdx.utils.ObjectIntMap$Values.next()"""
        return int._wrap(super(Values, self).next())

    @overload
    def __init__(self, arg0: 'ObjectIntMap'):
        """public com.badlogic.gdx.utils.ObjectIntMap$Values(com.badlogic.gdx.utils.ObjectIntMap<?>)"""
        val = _Values(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def toArray(self, arg0: 'IntArray') -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.ObjectIntMap$Values.toArray(com.badlogic.gdx.utils.IntArray)"""
        return 'IntArray'._wrap(super(_Values, self).toArray(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectIntMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def iterator(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectIntMap$Values com.badlogic.gdx.utils.ObjectIntMap$Values.iterator()"""
        return 'Values'._wrap(super(Values, self).iterator())

    @overload
    def toArray(self) -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.ObjectIntMap$Values.toArray()"""
        return 'IntArray'._wrap(super(Values, self).toArray())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ArrayMap
from builtins import str
import com.badlogic.gdx.utils.ArrayMap as _ArrayMap
_ArrayMap = _ArrayMap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.ArrayMap as _ArrayMap_Keys
_Keys = _ArrayMap_Keys.Keys
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.ArrayMap as _ArrayMap_Values
_Values = _ArrayMap_Values.Values
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.badlogic.gdx.utils.ArrayMap as _ArrayMap_Entries
_Entries = _ArrayMap_Entries.Entries
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ArrayMap():
    """com.badlogic.gdx.utils.ArrayMap"""
 
    @staticmethod
    def _wrap(java_value: _ArrayMap) -> 'ArrayMap':
        return ArrayMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ArrayMap):
        """
        Dynamic initializer for ArrayMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ArrayMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ArrayMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def get(self, arg0: object) -> object:
        """public V com.badlogic.gdx.utils.ArrayMap.get(K)"""
        return object._wrap(super(_ArrayMap, self).get(arg0))

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.ArrayMap(boolean,int)"""
        val = _ArrayMap(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def putAll(self, arg0: 'ArrayMap', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ArrayMap.putAll(com.badlogic.gdx.utils.ArrayMap<? extends K, ? extends V>,int,int)"""
        super(_ArrayMap, self).putAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap.notEmpty()"""
        return bool._wrap(super(ArrayMap, self).notEmpty())

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.ArrayMap$Values<V> com.badlogic.gdx.utils.ArrayMap.values()"""
        return 'Values'._wrap(super(ArrayMap, self).values())

    @overload
    def removeKey(self, arg0: object) -> object:
        """public V com.badlogic.gdx.utils.ArrayMap.removeKey(K)"""
        return object._wrap(super(_ArrayMap, self).removeKey(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.ArrayMap(int)"""
        val = _ArrayMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ArrayMap.ensureCapacity(int)"""
        super(_ArrayMap, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_ArrayMap, self).equalsIdentity(arg0))

    @overload
    def __init__(self, arg0: 'Class', arg1: 'Class'):
        """public com.badlogic.gdx.utils.ArrayMap(java.lang.Class,java.lang.Class)"""
        val = _ArrayMap(arg0, arg1)
        self.__wrapper = val

    @overload
    def getKeyAt(self, arg0: int) -> object:
        """public K com.badlogic.gdx.utils.ArrayMap.getKeyAt(int)"""
        return object._wrap(super(_ArrayMap, self).getKeyAt(_int.valueOf(arg0)))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ArrayMap()"""
        val = _ArrayMap()
        self.__wrapper = val

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.ObjectMap$Entry<K, V>> com.badlogic.gdx.utils.ArrayMap.iterator()"""
        return 'Iterator'._wrap(super(ArrayMap, self).iterator())

    @overload
    def containsValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap.containsValue(V,boolean)"""
        return bool._wrap(super(_ArrayMap, self).containsValue(arg0, _boolean.valueOf(arg1)))

    @overload
    def getValueAt(self, arg0: int) -> object:
        """public V com.badlogic.gdx.utils.ArrayMap.getValueAt(int)"""
        return object._wrap(super(_ArrayMap, self).getValueAt(_int.valueOf(arg0)))

    @overload
    def removeValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap.removeValue(V,boolean)"""
        return bool._wrap(super(_ArrayMap, self).removeValue(arg0, _boolean.valueOf(arg1)))

    @overload
    def insert(self, arg0: int, arg1: object, arg2: object):
        """public void com.badlogic.gdx.utils.ArrayMap.insert(int,K,V)"""
        super(_ArrayMap, self).insert(_int.valueOf(arg0), arg1, arg2)

    @overload
    def shrink(self):
        """public void com.badlogic.gdx.utils.ArrayMap.shrink()"""
        super(ArrayMap, self).shrink()

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.ArrayMap.clear(int)"""
        super(_ArrayMap, self).clear(_int.valueOf(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ArrayMap, self).equals(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def peekKey(self) -> object:
        """public K com.badlogic.gdx.utils.ArrayMap.peekKey()"""
        return object._wrap(super(ArrayMap, self).peekKey())

    @overload
    def __init__(self, arg0: 'ArrayMap'):
        """public com.badlogic.gdx.utils.ArrayMap(com.badlogic.gdx.utils.ArrayMap)"""
        val = _ArrayMap(arg0)
        self.__wrapper = val

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ArrayMap.clear()"""
        super(ArrayMap, self).clear()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ArrayMap.toString()"""
        return str._wrap(super(ArrayMap, self).toString())

    @overload
    def setValue(self, arg0: int, arg1: object):
        """public void com.badlogic.gdx.utils.ArrayMap.setValue(int,V)"""
        super(_ArrayMap, self).setValue(_int.valueOf(arg0), arg1)

    @overload
    def setKey(self, arg0: int, arg1: object):
        """public void com.badlogic.gdx.utils.ArrayMap.setKey(int,K)"""
        super(_ArrayMap, self).setKey(_int.valueOf(arg0), arg1)

    @overload
    def put(self, arg0: object, arg1: object) -> int:
        """public int com.badlogic.gdx.utils.ArrayMap.put(K,V)"""
        return int._wrap(super(_ArrayMap, self).put(arg0, arg1))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap.isEmpty()"""
        return bool._wrap(super(ArrayMap, self).isEmpty())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ArrayMap.hashCode()"""
        return int._wrap(super(ArrayMap, self).hashCode())

    @overload
    def containsKey(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap.containsKey(K)"""
        return bool._wrap(super(_ArrayMap, self).containsKey(arg0))

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.ArrayMap.reverse()"""
        super(ArrayMap, self).reverse()

    @overload
    def getKey(self, arg0: object, arg1: bool) -> object:
        """public K com.badlogic.gdx.utils.ArrayMap.getKey(V,boolean)"""
        return object._wrap(super(_ArrayMap, self).getKey(arg0, _boolean.valueOf(arg1)))

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.ArrayMap.shuffle()"""
        super(ArrayMap, self).shuffle()

    @overload
    def put(self, arg0: object, arg1: object, arg2: int) -> int:
        """public int com.badlogic.gdx.utils.ArrayMap.put(K,V,int)"""
        return int._wrap(super(_ArrayMap, self).put(arg0, arg1, _int.valueOf(arg2)))

    @overload
    def indexOfKey(self, arg0: object) -> int:
        """public int com.badlogic.gdx.utils.ArrayMap.indexOfKey(K)"""
        return int._wrap(super(_ArrayMap, self).indexOfKey(arg0))

    @overload
    def firstKey(self) -> object:
        """public K com.badlogic.gdx.utils.ArrayMap.firstKey()"""
        return object._wrap(super(ArrayMap, self).firstKey())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ArrayMap()"""
        val = _ArrayMap()
        self.__wrapper = val

    @overload
    def firstValue(self) -> object:
        """public V com.badlogic.gdx.utils.ArrayMap.firstValue()"""
        return object._wrap(super(ArrayMap, self).firstValue())

    @overload
    def removeIndex(self, arg0: int):
        """public void com.badlogic.gdx.utils.ArrayMap.removeIndex(int)"""
        super(_ArrayMap, self).removeIndex(_int.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def indexOfValue(self, arg0: object, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.ArrayMap.indexOfValue(V,boolean)"""
        return int._wrap(super(_ArrayMap, self).indexOfValue(arg0, _boolean.valueOf(arg1)))

    @overload
    def __init__(self, arg0: bool, arg1: int, arg2: 'Class', arg3: 'Class'):
        """public com.badlogic.gdx.utils.ArrayMap(boolean,int,java.lang.Class,java.lang.Class)"""
        val = _ArrayMap(_boolean.valueOf(arg0), _int.valueOf(arg1), arg2, arg3)
        self.__wrapper = val

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ArrayMap$Entries<K, V> com.badlogic.gdx.utils.ArrayMap.entries()"""
        return 'Entries'._wrap(super(ArrayMap, self).entries())

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ArrayMap$Keys<K> com.badlogic.gdx.utils.ArrayMap.keys()"""
        return 'Keys'._wrap(super(ArrayMap, self).keys())

    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.ArrayMap.truncate(int)"""
        super(_ArrayMap, self).truncate(_int.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def peekValue(self) -> object:
        """public V com.badlogic.gdx.utils.ArrayMap.peekValue()"""
        return object._wrap(super(ArrayMap, self).peekValue())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def get(self, arg0: object, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.ArrayMap.get(K,V)"""
        return object._wrap(super(_ArrayMap, self).get(arg0, arg1))

    @overload
    def putAll(self, arg0: 'ArrayMap'):
        """public void com.badlogic.gdx.utils.ArrayMap.putAll(com.badlogic.gdx.utils.ArrayMap<? extends K, ? extends V>)"""
        super(_ArrayMap, self).putAll(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.BinaryHeap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.BinaryHeap as _BinaryHeap_Node
_Node = _BinaryHeap_Node.Node
import java.lang.Float as _float
import java.lang.Boolean as _boolean
import com.badlogic.gdx.utils.BinaryHeap as _BinaryHeap
_BinaryHeap = _BinaryHeap
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class BinaryHeap():
    """com.badlogic.gdx.utils.BinaryHeap"""
 
    @staticmethod
    def _wrap(java_value: _BinaryHeap) -> 'BinaryHeap':
        return BinaryHeap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _BinaryHeap):
        """
        Dynamic initializer for BinaryHeap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_BinaryHeap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_BinaryHeap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.BinaryHeap.isEmpty()"""
        return bool._wrap(super(BinaryHeap, self).isEmpty())

    @overload
    def __init__(self, arg0: int, arg1: bool):
        """public com.badlogic.gdx.utils.BinaryHeap(int,boolean)"""
        val = _BinaryHeap(_int.valueOf(arg0), _boolean.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.BinaryHeap.hashCode()"""
        return int._wrap(super(BinaryHeap, self).hashCode())

    @overload
    def add(self, arg0: 'Node', arg1: float) -> 'Node':
        """public T com.badlogic.gdx.utils.BinaryHeap.add(T,float)"""
        return 'Node'._wrap(super(_BinaryHeap, self).add(arg0, _float.valueOf(arg1)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def add(self, arg0: 'Node') -> 'Node':
        """public T com.badlogic.gdx.utils.BinaryHeap.add(T)"""
        return 'Node'._wrap(super(_BinaryHeap, self).add(arg0))

    @overload
    def peek(self) -> 'Node':
        """public T com.badlogic.gdx.utils.BinaryHeap.peek()"""
        return 'Node'._wrap(super(BinaryHeap, self).peek())

    @overload
    def pop(self) -> 'Node':
        """public T com.badlogic.gdx.utils.BinaryHeap.pop()"""
        return 'Node'._wrap(super(BinaryHeap, self).pop())

    @overload
    def setValue(self, arg0: 'Node', arg1: float):
        """public void com.badlogic.gdx.utils.BinaryHeap.setValue(T,float)"""
        super(_BinaryHeap, self).setValue(arg0, _float.valueOf(arg1))

    @overload
    def contains(self, arg0: 'Node', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.BinaryHeap.contains(T,boolean)"""
        return bool._wrap(super(_BinaryHeap, self).contains(arg0, _boolean.valueOf(arg1)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.BinaryHeap.equals(java.lang.Object)"""
        return bool._wrap(super(_BinaryHeap, self).equals(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.BinaryHeap.clear()"""
        super(BinaryHeap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def remove(self, arg0: 'Node') -> 'Node':
        """public T com.badlogic.gdx.utils.BinaryHeap.remove(T)"""
        return 'Node'._wrap(super(_BinaryHeap, self).remove(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.BinaryHeap.toString()"""
        return str._wrap(super(BinaryHeap, self).toString())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.BinaryHeap()"""
        val = _BinaryHeap()
        self.__wrapper = val

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.BinaryHeap()"""
        val = _BinaryHeap()
        self.__wrapper = val

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.BinaryHeap.notEmpty()"""
        return bool._wrap(super(BinaryHeap, self).notEmpty()) 
 
 
# CLASS: com.badlogic.gdx.utils.LittleEndianInputStream
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.LittleEndianInputStream as _LittleEndianInputStream
_LittleEndianInputStream = _LittleEndianInputStream
from builtins import float
import java.io.FilterInputStream as _FilterInputStream
_FilterInputStream = _FilterInputStream
import java.lang.String as _String
_String = _String
from typing import List
import java.io.InputStream as _InputStream
_InputStream = _InputStream
import java.lang.Integer as _int
import java.io.OutputStream as OutputStream
import java.io.InputStream as InputStream
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class LittleEndianInputStream():
    """com.badlogic.gdx.utils.LittleEndianInputStream"""
 
    @staticmethod
    def _wrap(java_value: _LittleEndianInputStream) -> 'LittleEndianInputStream':
        return LittleEndianInputStream(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _LittleEndianInputStream):
        """
        Dynamic initializer for LittleEndianInputStream.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_LittleEndianInputStream__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_LittleEndianInputStream__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def readChar(self) -> str:
        """public char com.badlogic.gdx.utils.LittleEndianInputStream.readChar() throws java.io.IOException"""
        return str._wrap(super(LittleEndianInputStream, self).readChar())

    @override
    @overload
    def readFully(self, arg0: bytes):
        """public void com.badlogic.gdx.utils.LittleEndianInputStream.readFully(byte[]) throws java.io.IOException"""
        super(_LittleEndianInputStream, self).readFully(bytes)

    @override
    @overload
    def readBoolean(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LittleEndianInputStream.readBoolean() throws java.io.IOException"""
        return bool._wrap(super(LittleEndianInputStream, self).readBoolean())

    @overload
    def __init__(self, arg0: 'InputStream'):
        """public com.badlogic.gdx.utils.LittleEndianInputStream(java.io.InputStream)"""
        val = _LittleEndianInputStream(arg0)
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def transferTo(self, arg0: 'OutputStream') -> int:
        """public long java.io.InputStream.transferTo(java.io.OutputStream) throws java.io.IOException"""
        return int._wrap(super(_InputStream, self).transferTo(arg0))

    @override
    @overload
    def available(self) -> int:
        """public int java.io.FilterInputStream.available() throws java.io.IOException"""
        return int._wrap(super(FilterInputStream, self).available())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def readUnsignedShort(self) -> int:
        """public int com.badlogic.gdx.utils.LittleEndianInputStream.readUnsignedShort() throws java.io.IOException"""
        return int._wrap(super(LittleEndianInputStream, self).readUnsignedShort())

    @override
    @overload
    def markSupported(self) -> bool:
        """public boolean java.io.FilterInputStream.markSupported()"""
        return bool._wrap(super(FilterInputStream, self).markSupported())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def readAllBytes(self) -> List[int]:
        """public byte[] java.io.InputStream.readAllBytes() throws java.io.IOException"""
        return List[int]._wrap(super(InputStream, self).readAllBytes())

    @overload
    def read(self, arg0: bytes) -> int:
        """public int java.io.FilterInputStream.read(byte[]) throws java.io.IOException"""
        return int._wrap(super(_FilterInputStream, self).read(bytes))

    @overload
    def skip(self, arg0: int) -> int:
        """public long java.io.FilterInputStream.skip(long) throws java.io.IOException"""
        return int._wrap(super(_FilterInputStream, self).skip(_long.valueOf(arg0)))

    @override
    @overload
    def readShort(self) -> int:
        """public short com.badlogic.gdx.utils.LittleEndianInputStream.readShort() throws java.io.IOException"""
        return int._wrap(super(LittleEndianInputStream, self).readShort())

    @override
    @overload
    def readLine(self) -> str:
        """public final java.lang.String com.badlogic.gdx.utils.LittleEndianInputStream.readLine() throws java.io.IOException"""
        return str._wrap(super(LittleEndianInputStream, self).readLine())

    @override
    @overload
    def readByte(self) -> int:
        """public byte com.badlogic.gdx.utils.LittleEndianInputStream.readByte() throws java.io.IOException"""
        return int._wrap(super(LittleEndianInputStream, self).readByte())

    @overload
    def skipBytes(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.LittleEndianInputStream.skipBytes(int) throws java.io.IOException"""
        return int._wrap(super(_LittleEndianInputStream, self).skipBytes(_int.valueOf(arg0)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def skipNBytes(self, arg0: int):
        """public void java.io.InputStream.skipNBytes(long) throws java.io.IOException"""
        super(_InputStream, self).skipNBytes(_long.valueOf(arg0))

    @override
    @overload
    def reset(self):
        """public void java.io.FilterInputStream.reset() throws java.io.IOException"""
        super(FilterInputStream, self).reset()

    @override
    @overload
    def readFully(self, arg0: bytes, arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.LittleEndianInputStream.readFully(byte[],int,int) throws java.io.IOException"""
        super(_LittleEndianInputStream, self).readFully(bytes, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def mark(self, arg0: int):
        """public void java.io.FilterInputStream.mark(int)"""
        super(_FilterInputStream, self).mark(_int.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def readDouble(self) -> float:
        """public double com.badlogic.gdx.utils.LittleEndianInputStream.readDouble() throws java.io.IOException"""
        return float._wrap(super(LittleEndianInputStream, self).readDouble())

    @overload
    def read(self, arg0: bytes, arg1: int, arg2: int) -> int:
        """public int java.io.FilterInputStream.read(byte[],int,int) throws java.io.IOException"""
        return int._wrap(super(_FilterInputStream, self).read(bytes, _int.valueOf(arg1), _int.valueOf(arg2)))

    @staticmethod
    @overload
    def nullInputStream() -> 'InputStream':
        """public static java.io.InputStream java.io.InputStream.nullInputStream()"""
        return InputStream._wrap(_InputStream.nullInputStream())

    @override
    @overload
    def readInt(self) -> int:
        """public int com.badlogic.gdx.utils.LittleEndianInputStream.readInt() throws java.io.IOException"""
        return int._wrap(super(LittleEndianInputStream, self).readInt())

    @override
    @overload
    def readLong(self) -> int:
        """public long com.badlogic.gdx.utils.LittleEndianInputStream.readLong() throws java.io.IOException"""
        return int._wrap(super(LittleEndianInputStream, self).readLong())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def readFloat(self) -> float:
        """public float com.badlogic.gdx.utils.LittleEndianInputStream.readFloat() throws java.io.IOException"""
        return float._wrap(super(LittleEndianInputStream, self).readFloat())

    @overload
    def readNBytes(self, arg0: bytes, arg1: int, arg2: int) -> int:
        """public int java.io.InputStream.readNBytes(byte[],int,int) throws java.io.IOException"""
        return int._wrap(super(_InputStream, self).readNBytes(bytes, _int.valueOf(arg1), _int.valueOf(arg2)))

    @override
    @overload
    def close(self):
        """public void java.io.FilterInputStream.close() throws java.io.IOException"""
        super(FilterInputStream, self).close()

    @override
    @overload
    def read(self) -> int:
        """public int java.io.FilterInputStream.read() throws java.io.IOException"""
        return int._wrap(super(FilterInputStream, self).read())

    @overload
    def readNBytes(self, arg0: int) -> List[int]:
        """public byte[] java.io.InputStream.readNBytes(int) throws java.io.IOException"""
        return List[int]._wrap(super(_InputStream, self).readNBytes(_int.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def readUnsignedByte(self) -> int:
        """public int com.badlogic.gdx.utils.LittleEndianInputStream.readUnsignedByte() throws java.io.IOException"""
        return int._wrap(super(LittleEndianInputStream, self).readUnsignedByte())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def readUTF(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.LittleEndianInputStream.readUTF() throws java.io.IOException"""
        return str._wrap(super(LittleEndianInputStream, self).readUTF())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.BufferUtils
from pyquantum_helper import import_once as _import_once
import java.lang.Object as _Object
_Object = _Object
import java.nio.IntBuffer as IntBuffer
from builtins import type
import java.nio.LongBuffer as _LongBuffer
_LongBuffer = _LongBuffer
import java.nio.FloatBuffer as _FloatBuffer
_FloatBuffer = _FloatBuffer
import java.nio.ShortBuffer as ShortBuffer
import java.nio.FloatBuffer as FloatBuffer
import java.nio.DoubleBuffer as _DoubleBuffer
_DoubleBuffer = _DoubleBuffer
import java.nio.CharBuffer as _CharBuffer
_CharBuffer = _CharBuffer
import java.nio.CharBuffer as CharBuffer
try:
    from pygdx import math
except ImportError:
    math = _import_once("pygdx.math")

import java.nio.ShortBuffer as _ShortBuffer
_ShortBuffer = _ShortBuffer
from builtins import bool
from builtins import str
import java.nio.DoubleBuffer as DoubleBuffer
from pyquantum_helper import override
import java.lang.Object as _object
import java.nio.ByteBuffer as _ByteBuffer
_ByteBuffer = _ByteBuffer
from builtins import float
import java.nio.LongBuffer as LongBuffer
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.BufferUtils as _BufferUtils
_BufferUtils = _BufferUtils
import java.lang.Float as _float
import java.lang.Integer as _int
import java.nio.Buffer as Buffer
import java.nio.ByteBuffer as ByteBuffer
import java.nio.IntBuffer as _IntBuffer
_IntBuffer = _IntBuffer
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class BufferUtils():
    """com.badlogic.gdx.utils.BufferUtils"""
 
    @staticmethod
    def _wrap(java_value: _BufferUtils) -> 'BufferUtils':
        return BufferUtils(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _BufferUtils):
        """
        Dynamic initializer for BufferUtils.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_BufferUtils__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_BufferUtils__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copy(arg0: 'int', arg1: int, arg2: int, arg3: 'Buffer'):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(int[],int,int,java.nio.Buffer)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), _int.valueOf(arg2), arg3)

    @staticmethod
    @overload
    def copy(arg0: 'Buffer', arg1: 'Buffer', arg2: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(java.nio.Buffer,java.nio.Buffer,int)"""
        _BufferUtils.copy(arg0, arg1, _int.valueOf(arg2))

    @staticmethod
    @overload
    def newShortBuffer(arg0: int) -> 'ShortBuffer':
        """public static java.nio.ShortBuffer com.badlogic.gdx.utils.BufferUtils.newShortBuffer(int)"""
        return ShortBuffer._wrap(_BufferUtils.newShortBuffer(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def copy(arg0: 'float', arg1: int, arg2: 'Buffer', arg3: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(float[],int,java.nio.Buffer,int)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3))

    @staticmethod
    @overload
    def findFloats(arg0: 'Buffer', arg1: int, arg2: 'float', arg3: int, arg4: float) -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.findFloats(java.nio.Buffer,int,float[],int,float)"""
        return int._wrap(_BufferUtils.findFloats(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3), _float.valueOf(arg4)))

    @staticmethod
    @overload
    def newDoubleBuffer(arg0: int) -> 'DoubleBuffer':
        """public static java.nio.DoubleBuffer com.badlogic.gdx.utils.BufferUtils.newDoubleBuffer(int)"""
        return DoubleBuffer._wrap(_BufferUtils.newDoubleBuffer(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def newLongBuffer(arg0: int) -> 'LongBuffer':
        """public static java.nio.LongBuffer com.badlogic.gdx.utils.BufferUtils.newLongBuffer(int)"""
        return LongBuffer._wrap(_BufferUtils.newLongBuffer(_int.valueOf(arg0)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def findFloats(arg0: 'Buffer', arg1: int, arg2: 'float', arg3: int) -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.findFloats(java.nio.Buffer,int,float[],int)"""
        return int._wrap(_BufferUtils.findFloats(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3)))

    @staticmethod
    @overload
    def newUnsafeByteBuffer(arg0: 'ByteBuffer') -> 'ByteBuffer':
        """public static java.nio.ByteBuffer com.badlogic.gdx.utils.BufferUtils.newUnsafeByteBuffer(java.nio.ByteBuffer)"""
        return ByteBuffer._wrap(_BufferUtils.newUnsafeByteBuffer(arg0))

    @staticmethod
    @overload
    def disposeUnsafeByteBuffer(arg0: 'ByteBuffer'):
        """public static void com.badlogic.gdx.utils.BufferUtils.disposeUnsafeByteBuffer(java.nio.ByteBuffer)"""
        _BufferUtils.disposeUnsafeByteBuffer(arg0)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def copy(arg0: 'int', arg1: int, arg2: 'Buffer', arg3: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(int[],int,java.nio.Buffer,int)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3))

    @staticmethod
    @overload
    def newFloatBuffer(arg0: int) -> 'FloatBuffer':
        """public static java.nio.FloatBuffer com.badlogic.gdx.utils.BufferUtils.newFloatBuffer(int)"""
        return FloatBuffer._wrap(_BufferUtils.newFloatBuffer(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def newByteBuffer(arg0: int) -> 'ByteBuffer':
        """public static java.nio.ByteBuffer com.badlogic.gdx.utils.BufferUtils.newByteBuffer(int)"""
        return ByteBuffer._wrap(_BufferUtils.newByteBuffer(_int.valueOf(arg0)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def newIntBuffer(arg0: int) -> 'IntBuffer':
        """public static java.nio.IntBuffer com.badlogic.gdx.utils.BufferUtils.newIntBuffer(int)"""
        return IntBuffer._wrap(_BufferUtils.newIntBuffer(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def transform(arg0: 'float', arg1: int, arg2: int, arg3: int, arg4: 'Matrix4'):
        """public static void com.badlogic.gdx.utils.BufferUtils.transform(float[],int,int,int,com.badlogic.gdx.math.Matrix4)"""
        _BufferUtils.transform(arg0, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def newUnsafeByteBuffer(arg0: int) -> 'ByteBuffer':
        """public static java.nio.ByteBuffer com.badlogic.gdx.utils.BufferUtils.newUnsafeByteBuffer(int)"""
        return ByteBuffer._wrap(_BufferUtils.newUnsafeByteBuffer(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def copy(arg0: 'double', arg1: int, arg2: 'Buffer', arg3: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(double[],int,java.nio.Buffer,int)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3))

    @staticmethod
    @overload
    def transform(arg0: 'Buffer', arg1: int, arg2: int, arg3: int, arg4: 'Matrix4'):
        """public static void com.badlogic.gdx.utils.BufferUtils.transform(java.nio.Buffer,int,int,int,com.badlogic.gdx.math.Matrix4)"""
        _BufferUtils.transform(arg0, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4)

    @staticmethod
    @overload
    def copy(arg0: bytes, arg1: int, arg2: 'Buffer', arg3: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(byte[],int,java.nio.Buffer,int)"""
        _BufferUtils.copy(bytes, _int.valueOf(arg1), arg2, _int.valueOf(arg3))

    @staticmethod
    @overload
    def copy(arg0: 'float', arg1: 'Buffer', arg2: int, arg3: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(float[],java.nio.Buffer,int,int)"""
        _BufferUtils.copy(arg0, arg1, _int.valueOf(arg2), _int.valueOf(arg3))

    @staticmethod
    @overload
    def findFloats(arg0: 'Buffer', arg1: int, arg2: 'Buffer', arg3: int) -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.findFloats(java.nio.Buffer,int,java.nio.Buffer,int)"""
        return int._wrap(_BufferUtils.findFloats(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def isUnsafeByteBuffer(arg0: 'ByteBuffer') -> bool:
        """public static boolean com.badlogic.gdx.utils.BufferUtils.isUnsafeByteBuffer(java.nio.ByteBuffer)"""
        return bool._wrap(_BufferUtils.isUnsafeByteBuffer(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def transform(arg0: 'float', arg1: int, arg2: int, arg3: int, arg4: 'Matrix3'):
        """public static void com.badlogic.gdx.utils.BufferUtils.transform(float[],int,int,int,com.badlogic.gdx.math.Matrix3)"""
        _BufferUtils.transform(arg0, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4)

    @staticmethod
    @overload
    def transform(arg0: 'float', arg1: int, arg2: int, arg3: int, arg4: 'Matrix3', arg5: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.transform(float[],int,int,int,com.badlogic.gdx.math.Matrix3,int)"""
        _BufferUtils.transform(arg0, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4, _int.valueOf(arg5))

    @staticmethod
    @overload
    def copy(arg0: 'short', arg1: int, arg2: 'Buffer', arg3: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(short[],int,java.nio.Buffer,int)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3))

    @staticmethod
    @overload
    def findFloats(arg0: 'float', arg1: int, arg2: 'Buffer', arg3: int, arg4: float) -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.findFloats(float[],int,java.nio.Buffer,int,float)"""
        return int._wrap(_BufferUtils.findFloats(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3), _float.valueOf(arg4)))

    @staticmethod
    @overload
    def transform(arg0: 'Buffer', arg1: int, arg2: int, arg3: int, arg4: 'Matrix3', arg5: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.transform(java.nio.Buffer,int,int,int,com.badlogic.gdx.math.Matrix3,int)"""
        _BufferUtils.transform(arg0, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4, _int.valueOf(arg5))

    @staticmethod
    @overload
    def copy(arg0: 'float', arg1: int, arg2: int, arg3: 'Buffer'):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(float[],int,int,java.nio.Buffer)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), _int.valueOf(arg2), arg3)

    @staticmethod
    @overload
    def transform(arg0: 'Buffer', arg1: int, arg2: int, arg3: int, arg4: 'Matrix4', arg5: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.transform(java.nio.Buffer,int,int,int,com.badlogic.gdx.math.Matrix4,int)"""
        _BufferUtils.transform(arg0, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4, _int.valueOf(arg5))

    @staticmethod
    @overload
    def findFloats(arg0: 'Buffer', arg1: int, arg2: 'Buffer', arg3: int, arg4: float) -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.findFloats(java.nio.Buffer,int,java.nio.Buffer,int,float)"""
        return int._wrap(_BufferUtils.findFloats(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3), _float.valueOf(arg4)))

    @staticmethod
    @overload
    def findFloats(arg0: 'float', arg1: int, arg2: 'float', arg3: int) -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.findFloats(float[],int,float[],int)"""
        return int._wrap(_BufferUtils.findFloats(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3)))

    @staticmethod
    @overload
    def copy(arg0: 'long', arg1: int, arg2: 'Buffer', arg3: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(long[],int,java.nio.Buffer,int)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3))

    @staticmethod
    @overload
    def clear(arg0: 'ByteBuffer', arg1: int):
        """public static native void com.badlogic.gdx.utils.BufferUtils.clear(java.nio.ByteBuffer,int)"""
        _BufferUtils.clear(arg0, _int.valueOf(arg1))

    @staticmethod
    @overload
    def getUnsafeBufferAddress(arg0: 'Buffer') -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.getUnsafeBufferAddress(java.nio.Buffer)"""
        return int._wrap(_BufferUtils.getUnsafeBufferAddress(arg0))

    @staticmethod
    @overload
    def newCharBuffer(arg0: int) -> 'CharBuffer':
        """public static java.nio.CharBuffer com.badlogic.gdx.utils.BufferUtils.newCharBuffer(int)"""
        return CharBuffer._wrap(_BufferUtils.newCharBuffer(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def transform(arg0: 'float', arg1: int, arg2: int, arg3: int, arg4: 'Matrix4', arg5: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.transform(float[],int,int,int,com.badlogic.gdx.math.Matrix4,int)"""
        _BufferUtils.transform(arg0, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4, _int.valueOf(arg5))

    @staticmethod
    @overload
    def copy(arg0: 'char', arg1: int, arg2: 'Buffer', arg3: int):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(char[],int,java.nio.Buffer,int)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def transform(arg0: 'Buffer', arg1: int, arg2: int, arg3: int, arg4: 'Matrix3'):
        """public static void com.badlogic.gdx.utils.BufferUtils.transform(java.nio.Buffer,int,int,int,com.badlogic.gdx.math.Matrix3)"""
        _BufferUtils.transform(arg0, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4)

    @staticmethod
    @overload
    def copy(arg0: 'char', arg1: int, arg2: int, arg3: 'Buffer'):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(char[],int,int,java.nio.Buffer)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), _int.valueOf(arg2), arg3)

    @staticmethod
    @overload
    def findFloats(arg0: 'float', arg1: int, arg2: 'Buffer', arg3: int) -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.findFloats(float[],int,java.nio.Buffer,int)"""
        return int._wrap(_BufferUtils.findFloats(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3)))

    @staticmethod
    @overload
    def getAllocatedBytesUnsafe() -> int:
        """public static int com.badlogic.gdx.utils.BufferUtils.getAllocatedBytesUnsafe()"""
        return int._wrap(_BufferUtils.getAllocatedBytesUnsafe())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def findFloats(arg0: 'float', arg1: int, arg2: 'float', arg3: int, arg4: float) -> int:
        """public static long com.badlogic.gdx.utils.BufferUtils.findFloats(float[],int,float[],int,float)"""
        return int._wrap(_BufferUtils.findFloats(arg0, _int.valueOf(arg1), arg2, _int.valueOf(arg3), _float.valueOf(arg4)))

    @staticmethod
    @overload
    def copy(arg0: 'double', arg1: int, arg2: int, arg3: 'Buffer'):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(double[],int,int,java.nio.Buffer)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), _int.valueOf(arg2), arg3)

    @staticmethod
    @overload
    def copy(arg0: 'long', arg1: int, arg2: int, arg3: 'Buffer'):
        """public static void com.badlogic.gdx.utils.BufferUtils.copy(long[],int,int,java.nio.Buffer)"""
        _BufferUtils.copy(arg0, _int.valueOf(arg1), _int.valueOf(arg2), arg3) 
 
 
# CLASS: com.badlogic.gdx.utils.DataBuffer
from builtins import str
import java.lang.Double as _double
from pyquantum_helper import override
import java.io.OutputStream as _OutputStream
_OutputStream = _OutputStream
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.DataBuffer as _DataBuffer
_DataBuffer = _DataBuffer
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.Float as _float
import java.lang.String as _string
import java.io.DataOutputStream as _DataOutputStream
_DataOutputStream = _DataOutputStream
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.io.OutputStream as OutputStream
import com.badlogic.gdx.utils.DataOutput as _DataOutput
_DataOutput = _DataOutput
import java.io.FilterOutputStream as _FilterOutputStream
_FilterOutputStream = _FilterOutputStream
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class DataBuffer():
    """com.badlogic.gdx.utils.DataBuffer"""
 
    @staticmethod
    def _wrap(java_value: _DataBuffer) -> 'DataBuffer':
        return DataBuffer(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _DataBuffer):
        """
        Dynamic initializer for DataBuffer.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_DataBuffer__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_DataBuffer__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def writeFloat(self, arg0: float):
        """public final void java.io.DataOutputStream.writeFloat(float) throws java.io.IOException"""
        super(_DataOutputStream, self).writeFloat(_float.valueOf(arg0))

    @overload
    def toArray(self) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.DataBuffer.toArray()"""
        return List[int]._wrap(super(DataBuffer, self).toArray())

    @overload
    def writeInt(self, arg0: int, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.DataOutput.writeInt(int,boolean) throws java.io.IOException"""
        return int._wrap(super(_DataOutput, self).writeInt(_int.valueOf(arg0), _boolean.valueOf(arg1)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def write(self, arg0: int):
        """public synchronized void java.io.DataOutputStream.write(int) throws java.io.IOException"""
        super(_DataOutputStream, self).write(_int.valueOf(arg0))

    @override
    @overload
    def size(self) -> int:
        """public final int java.io.DataOutputStream.size()"""
        return int._wrap(super(DataOutputStream, self).size())

    @override
    @overload
    def writeByte(self, arg0: int):
        """public final void java.io.DataOutputStream.writeByte(int) throws java.io.IOException"""
        super(_DataOutputStream, self).writeByte(_int.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def writeChar(self, arg0: int):
        """public final void java.io.DataOutputStream.writeChar(int) throws java.io.IOException"""
        super(_DataOutputStream, self).writeChar(_int.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def close(self):
        """public void java.io.FilterOutputStream.close() throws java.io.IOException"""
        super(FilterOutputStream, self).close()

    @override
    @overload
    def write(self, arg0: bytes):
        """public void java.io.FilterOutputStream.write(byte[]) throws java.io.IOException"""
        super(_FilterOutputStream, self).write(bytes)

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.DataBuffer()"""
        val = _DataBuffer()
        self.__wrapper = val

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.DataBuffer()"""
        val = _DataBuffer()
        self.__wrapper = val

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.DataBuffer(int)"""
        val = _DataBuffer(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def writeInt(self, arg0: int):
        """public final void java.io.DataOutputStream.writeInt(int) throws java.io.IOException"""
        super(_DataOutputStream, self).writeInt(_int.valueOf(arg0))

    @staticmethod
    @overload
    def nullOutputStream() -> 'OutputStream':
        """public static java.io.OutputStream java.io.OutputStream.nullOutputStream()"""
        return OutputStream._wrap(_OutputStream.nullOutputStream())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def writeString(self, arg0: str):
        """public void com.badlogic.gdx.utils.DataOutput.writeString(java.lang.String) throws java.io.IOException"""
        super(_DataOutput, self).writeString(arg0)

    @override
    @overload
    def writeDouble(self, arg0: float):
        """public final void java.io.DataOutputStream.writeDouble(double) throws java.io.IOException"""
        super(_DataOutputStream, self).writeDouble(_double.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def writeBoolean(self, arg0: bool):
        """public final void java.io.DataOutputStream.writeBoolean(boolean) throws java.io.IOException"""
        super(_DataOutputStream, self).writeBoolean(_boolean.valueOf(arg0))

    @override
    @overload
    def writeChars(self, arg0: str):
        """public final void java.io.DataOutputStream.writeChars(java.lang.String) throws java.io.IOException"""
        super(_DataOutputStream, self).writeChars(arg0)

    @overload
    def getBuffer(self) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.DataBuffer.getBuffer()"""
        return List[int]._wrap(super(DataBuffer, self).getBuffer())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def flush(self):
        """public void java.io.DataOutputStream.flush() throws java.io.IOException"""
        super(DataOutputStream, self).flush()

    @override
    @overload
    def write(self, arg0: bytes, arg1: int, arg2: int):
        """public synchronized void java.io.DataOutputStream.write(byte[],int,int) throws java.io.IOException"""
        super(_DataOutputStream, self).write(bytes, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def writeBytes(self, arg0: str):
        """public final void java.io.DataOutputStream.writeBytes(java.lang.String) throws java.io.IOException"""
        super(_DataOutputStream, self).writeBytes(arg0)

    @override
    @overload
    def writeLong(self, arg0: int):
        """public final void java.io.DataOutputStream.writeLong(long) throws java.io.IOException"""
        super(_DataOutputStream, self).writeLong(_long.valueOf(arg0))

    @override
    @overload
    def writeUTF(self, arg0: str):
        """public final void java.io.DataOutputStream.writeUTF(java.lang.String) throws java.io.IOException"""
        super(_DataOutputStream, self).writeUTF(arg0)

    @override
    @overload
    def writeShort(self, arg0: int):
        """public final void java.io.DataOutputStream.writeShort(int) throws java.io.IOException"""
        super(_DataOutputStream, self).writeShort(_int.valueOf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.LongMap$Entry
from builtins import str
import com.badlogic.gdx.utils.LongMap as _LongMap_Entry
_Entry = _LongMap_Entry.Entry
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entry():
    """com.badlogic.gdx.utils.LongMap.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.LongMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.LongMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.LongMap$Entry.toString()"""
        return str._wrap(super(Entry, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Select
import com.badlogic.gdx.utils.Select as _Select
_Select = _Select
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Select():
    """com.badlogic.gdx.utils.Select"""
 
    @staticmethod
    def _wrap(java_value: _Select) -> 'Select':
        return Select(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Select):
        """
        Dynamic initializer for Select.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Select__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Select__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def select(self, arg0: 'Object', arg1: 'Comparator', arg2: int, arg3: int) -> object:
        """public <T> T com.badlogic.gdx.utils.Select.select(T[],java.util.Comparator<T>,int,int)"""
        return object._wrap(super(_Select, self).select(arg0, arg1, _int.valueOf(arg2), _int.valueOf(arg3)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def instance() -> 'Select':
        """public static com.badlogic.gdx.utils.Select com.badlogic.gdx.utils.Select.instance()"""
        return Select._wrap(_Select.instance())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Select()"""
        val = _Select()
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def selectIndex(self, arg0: 'Object', arg1: 'Comparator', arg2: int, arg3: int) -> int:
        """public <T> int com.badlogic.gdx.utils.Select.selectIndex(T[],java.util.Comparator<T>,int,int)"""
        return int._wrap(super(_Select, self).selectIndex(arg0, arg1, _int.valueOf(arg2), _int.valueOf(arg3)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Select()"""
        val = _Select()
        self.__wrapper = val 
 
 
# CLASS: com.badlogic.gdx.utils.FloatArray
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import float
import com.badlogic.gdx.utils.FloatArray as _FloatArray
_FloatArray = _FloatArray
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.Float as _float
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class FloatArray():
    """com.badlogic.gdx.utils.FloatArray"""
 
    @staticmethod
    def _wrap(java_value: _FloatArray) -> 'FloatArray':
        return FloatArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _FloatArray):
        """
        Dynamic initializer for FloatArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_FloatArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_FloatArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def lastIndexOf(self, arg0: float) -> int:
        """public int com.badlogic.gdx.utils.FloatArray.lastIndexOf(float)"""
        return int._wrap(super(_FloatArray, self).lastIndexOf(_float.valueOf(arg0)))

    @overload
    def set(self, arg0: int, arg1: float):
        """public void com.badlogic.gdx.utils.FloatArray.set(int,float)"""
        super(_FloatArray, self).set(_int.valueOf(arg0), _float.valueOf(arg1))

    @overload
    def mul(self, arg0: float):
        """public void com.badlogic.gdx.utils.FloatArray.mul(float)"""
        super(_FloatArray, self).mul(_float.valueOf(arg0))

    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.FloatArray.swap(int,int)"""
        super(_FloatArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.FloatArray.removeRange(int,int)"""
        super(_FloatArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.FloatArray()"""
        val = _FloatArray()
        self.__wrapper = val

    @overload
    def incr(self, arg0: float):
        """public void com.badlogic.gdx.utils.FloatArray.incr(float)"""
        super(_FloatArray, self).incr(_float.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def add(self, arg0: float, arg1: float, arg2: float):
        """public void com.badlogic.gdx.utils.FloatArray.add(float,float,float)"""
        super(_FloatArray, self).add(_float.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.FloatArray.toString()"""
        return str._wrap(super(FloatArray, self).toString())

    @overload
    def peek(self) -> float:
        """public float com.badlogic.gdx.utils.FloatArray.peek()"""
        return float._wrap(super(FloatArray, self).peek())

    @overload
    def add(self, arg0: float, arg1: float, arg2: float, arg3: float):
        """public void com.badlogic.gdx.utils.FloatArray.add(float,float,float,float)"""
        super(_FloatArray, self).add(_float.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2), _float.valueOf(arg3))

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.FloatArray.shuffle()"""
        super(FloatArray, self).shuffle()

    @overload
    def removeAll(self, arg0: 'FloatArray') -> bool:
        """public boolean com.badlogic.gdx.utils.FloatArray.removeAll(com.badlogic.gdx.utils.FloatArray)"""
        return bool._wrap(super(_FloatArray, self).removeAll(arg0))

    @overload
    def addAll(self, arg0: 'float', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.FloatArray.addAll(float[],int,int)"""
        super(_FloatArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def pop(self) -> float:
        """public float com.badlogic.gdx.utils.FloatArray.pop()"""
        return float._wrap(super(FloatArray, self).pop())

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.FloatArray.clear()"""
        super(FloatArray, self).clear()

    @overload
    def addAll(self, arg0: 'FloatArray', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.FloatArray.addAll(com.badlogic.gdx.utils.FloatArray,int,int)"""
        super(_FloatArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def incr(self, arg0: int, arg1: float):
        """public void com.badlogic.gdx.utils.FloatArray.incr(int,float)"""
        super(_FloatArray, self).incr(_int.valueOf(arg0), _float.valueOf(arg1))

    @overload
    def indexOf(self, arg0: float) -> int:
        """public int com.badlogic.gdx.utils.FloatArray.indexOf(float)"""
        return int._wrap(super(_FloatArray, self).indexOf(_float.valueOf(arg0)))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.FloatArray.isEmpty()"""
        return bool._wrap(super(FloatArray, self).isEmpty())

    @overload
    def toArray(self) -> List[float]:
        """public float[] com.badlogic.gdx.utils.FloatArray.toArray()"""
        return List[float]._wrap(super(FloatArray, self).toArray())

    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.FloatArray.sort()"""
        super(FloatArray, self).sort()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'float'):
        """public com.badlogic.gdx.utils.FloatArray(float[])"""
        val = _FloatArray(arg0)
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.FloatArray.equals(java.lang.Object)"""
        return bool._wrap(super(_FloatArray, self).equals(arg0))

    @overload
    def random(self) -> float:
        """public float com.badlogic.gdx.utils.FloatArray.random()"""
        return float._wrap(super(FloatArray, self).random())

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.FloatArray.toString(java.lang.String)"""
        return str._wrap(super(_FloatArray, self).toString(arg0))

    @overload
    def add(self, arg0: float):
        """public void com.badlogic.gdx.utils.FloatArray.add(float)"""
        super(_FloatArray, self).add(_float.valueOf(arg0))

    @overload
    def insert(self, arg0: int, arg1: float):
        """public void com.badlogic.gdx.utils.FloatArray.insert(int,float)"""
        super(_FloatArray, self).insert(_int.valueOf(arg0), _float.valueOf(arg1))

    @overload
    def mul(self, arg0: int, arg1: float):
        """public void com.badlogic.gdx.utils.FloatArray.mul(int,float)"""
        super(_FloatArray, self).mul(_int.valueOf(arg0), _float.valueOf(arg1))

    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.FloatArray.insertRange(int,int)"""
        super(_FloatArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def get(self, arg0: int) -> float:
        """public float com.badlogic.gdx.utils.FloatArray.get(int)"""
        return float._wrap(super(_FloatArray, self).get(_int.valueOf(arg0)))

    @overload
    def ensureCapacity(self, arg0: int) -> List[float]:
        """public float[] com.badlogic.gdx.utils.FloatArray.ensureCapacity(int)"""
        return List[float]._wrap(super(_FloatArray, self).ensureCapacity(_int.valueOf(arg0)))

    @overload
    def removeValue(self, arg0: float) -> bool:
        """public boolean com.badlogic.gdx.utils.FloatArray.removeValue(float)"""
        return bool._wrap(super(_FloatArray, self).removeValue(_float.valueOf(arg0)))

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.FloatArray(boolean,int)"""
        val = _FloatArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.FloatArray.reverse()"""
        super(FloatArray, self).reverse()

    @overload
    def add(self, arg0: float, arg1: float):
        """public void com.badlogic.gdx.utils.FloatArray.add(float,float)"""
        super(_FloatArray, self).add(_float.valueOf(arg0), _float.valueOf(arg1))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.FloatArray.notEmpty()"""
        return bool._wrap(super(FloatArray, self).notEmpty())

    @overload
    def removeIndex(self, arg0: int) -> float:
        """public float com.badlogic.gdx.utils.FloatArray.removeIndex(int)"""
        return float._wrap(super(_FloatArray, self).removeIndex(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def with(*arg0: float) -> 'FloatArray':
        """public static com.badlogic.gdx.utils.FloatArray com.badlogic.gdx.utils.FloatArray.with(float...)"""
        return FloatArray._wrap(_FloatArray.with(arg0))

    @overload
    def contains(self, arg0: float) -> bool:
        """public boolean com.badlogic.gdx.utils.FloatArray.contains(float)"""
        return bool._wrap(super(_FloatArray, self).contains(_float.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'FloatArray'):
        """public com.badlogic.gdx.utils.FloatArray(com.badlogic.gdx.utils.FloatArray)"""
        val = _FloatArray(arg0)
        self.__wrapper = val

    @overload
    def shrink(self) -> List[float]:
        """public float[] com.badlogic.gdx.utils.FloatArray.shrink()"""
        return List[float]._wrap(super(FloatArray, self).shrink())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: bool, arg1: 'float', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.FloatArray(boolean,float[],int,int)"""
        val = _FloatArray(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @overload
    def setSize(self, arg0: int) -> List[float]:
        """public float[] com.badlogic.gdx.utils.FloatArray.setSize(int)"""
        return List[float]._wrap(super(_FloatArray, self).setSize(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.FloatArray(int)"""
        val = _FloatArray(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.FloatArray.hashCode()"""
        return int._wrap(super(FloatArray, self).hashCode())

    @overload
    def addAll(self, *arg0: float):
        """public void com.badlogic.gdx.utils.FloatArray.addAll(float...)"""
        super(_FloatArray, self).addAll(arg0)

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.FloatArray()"""
        val = _FloatArray()
        self.__wrapper = val

    @overload
    def first(self) -> float:
        """public float com.badlogic.gdx.utils.FloatArray.first()"""
        return float._wrap(super(FloatArray, self).first())

    @overload
    def equals(self, arg0: object, arg1: float) -> bool:
        """public boolean com.badlogic.gdx.utils.FloatArray.equals(java.lang.Object,float)"""
        return bool._wrap(super(_FloatArray, self).equals(arg0, _float.valueOf(arg1)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def addAll(self, arg0: 'FloatArray'):
        """public void com.badlogic.gdx.utils.FloatArray.addAll(com.badlogic.gdx.utils.FloatArray)"""
        super(_FloatArray, self).addAll(arg0)

    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.FloatArray.truncate(int)"""
        super(_FloatArray, self).truncate(_int.valueOf(arg0)) 
 
 
# CLASS: com.badlogic.gdx.utils.LongArray
from builtins import str
import java.lang.Character as _char
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.LongArray as _LongArray
_LongArray = _LongArray
from typing import List
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class LongArray():
    """com.badlogic.gdx.utils.LongArray"""
 
    @staticmethod
    def _wrap(java_value: _LongArray) -> 'LongArray':
        return LongArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _LongArray):
        """
        Dynamic initializer for LongArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_LongArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_LongArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, arg0: 'LongArray'):
        """public void com.badlogic.gdx.utils.LongArray.addAll(com.badlogic.gdx.utils.LongArray)"""
        super(_LongArray, self).addAll(arg0)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def set(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.LongArray.set(int,long)"""
        super(_LongArray, self).set(_int.valueOf(arg0), _long.valueOf(arg1))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LongArray.notEmpty()"""
        return bool._wrap(super(LongArray, self).notEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, arg0: int, arg1: int, arg2: int, arg3: int):
        """public void com.badlogic.gdx.utils.LongArray.add(long,long,long,long)"""
        super(_LongArray, self).add(_long.valueOf(arg0), _long.valueOf(arg1), _long.valueOf(arg2), _long.valueOf(arg3))

    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.LongArray.removeRange(int,int)"""
        super(_LongArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def addAll(self, arg0: 'LongArray', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.LongArray.addAll(com.badlogic.gdx.utils.LongArray,int,int)"""
        super(_LongArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def setSize(self, arg0: int) -> List[int]:
        """public long[] com.badlogic.gdx.utils.LongArray.setSize(int)"""
        return List[int]._wrap(super(_LongArray, self).setSize(_int.valueOf(arg0)))

    @overload
    def contains(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.LongArray.contains(long)"""
        return bool._wrap(super(_LongArray, self).contains(_long.valueOf(arg0)))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.LongArray.toString(java.lang.String)"""
        return str._wrap(super(_LongArray, self).toString(arg0))

    @overload
    def add(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.LongArray.add(long,long)"""
        super(_LongArray, self).add(_long.valueOf(arg0), _long.valueOf(arg1))

    @overload
    def addAll(self, arg0: 'long', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.LongArray.addAll(long[],int,int)"""
        super(_LongArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def incr(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.LongArray.incr(int,long)"""
        super(_LongArray, self).incr(_int.valueOf(arg0), _long.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.LongArray()"""
        val = _LongArray()
        self.__wrapper = val

    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.LongArray.sort()"""
        super(LongArray, self).sort()

    @overload
    def add(self, arg0: int, arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.LongArray.add(long,long,long)"""
        super(_LongArray, self).add(_long.valueOf(arg0), _long.valueOf(arg1), _long.valueOf(arg2))

    @overload
    def shrink(self) -> List[int]:
        """public long[] com.badlogic.gdx.utils.LongArray.shrink()"""
        return List[int]._wrap(super(LongArray, self).shrink())

    @overload
    def pop(self) -> int:
        """public long com.badlogic.gdx.utils.LongArray.pop()"""
        return int._wrap(super(LongArray, self).pop())

    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.LongArray.insertRange(int,int)"""
        super(_LongArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def peek(self) -> int:
        """public long com.badlogic.gdx.utils.LongArray.peek()"""
        return int._wrap(super(LongArray, self).peek())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'long'):
        """public com.badlogic.gdx.utils.LongArray(long[])"""
        val = _LongArray(arg0)
        self.__wrapper = val

    @overload
    def get(self, arg0: int) -> int:
        """public long com.badlogic.gdx.utils.LongArray.get(int)"""
        return int._wrap(super(_LongArray, self).get(_int.valueOf(arg0)))

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.LongArray.shuffle()"""
        super(LongArray, self).shuffle()

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.LongArray(boolean,int)"""
        val = _LongArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def add(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongArray.add(long)"""
        super(_LongArray, self).add(_long.valueOf(arg0))

    @staticmethod
    @overload
    def with(*arg0: int) -> 'LongArray':
        """public static com.badlogic.gdx.utils.LongArray com.badlogic.gdx.utils.LongArray.with(long...)"""
        return LongArray._wrap(_LongArray.with(arg0))

    @overload
    def first(self) -> int:
        """public long com.badlogic.gdx.utils.LongArray.first()"""
        return int._wrap(super(LongArray, self).first())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.LongArray(int)"""
        val = _LongArray(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def __init__(self, arg0: bool, arg1: 'long', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.LongArray(boolean,long[],int,int)"""
        val = _LongArray(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @overload
    def toArray(self) -> List[int]:
        """public long[] com.badlogic.gdx.utils.LongArray.toArray()"""
        return List[int]._wrap(super(LongArray, self).toArray())

    @overload
    def lastIndexOf(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.LongArray.lastIndexOf(char)"""
        return int._wrap(super(_LongArray, self).lastIndexOf(_char.valueOf(arg0)))

    @overload
    def mul(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongArray.mul(long)"""
        super(_LongArray, self).mul(_long.valueOf(arg0))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LongArray.isEmpty()"""
        return bool._wrap(super(LongArray, self).isEmpty())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.LongArray.hashCode()"""
        return int._wrap(super(LongArray, self).hashCode())

    @overload
    def random(self) -> int:
        """public long com.badlogic.gdx.utils.LongArray.random()"""
        return int._wrap(super(LongArray, self).random())

    @overload
    def insert(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.LongArray.insert(int,long)"""
        super(_LongArray, self).insert(_int.valueOf(arg0), _long.valueOf(arg1))

    @overload
    def removeValue(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.LongArray.removeValue(long)"""
        return bool._wrap(super(_LongArray, self).removeValue(_long.valueOf(arg0)))

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.LongArray.reverse()"""
        super(LongArray, self).reverse()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.LongArray.equals(java.lang.Object)"""
        return bool._wrap(super(_LongArray, self).equals(arg0))

    @overload
    def ensureCapacity(self, arg0: int) -> List[int]:
        """public long[] com.badlogic.gdx.utils.LongArray.ensureCapacity(int)"""
        return List[int]._wrap(super(_LongArray, self).ensureCapacity(_int.valueOf(arg0)))

    @overload
    def incr(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongArray.incr(long)"""
        super(_LongArray, self).incr(_long.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.LongArray.truncate(int)"""
        super(_LongArray, self).truncate(_int.valueOf(arg0))

    @overload
    def __init__(self, arg0: 'LongArray'):
        """public com.badlogic.gdx.utils.LongArray(com.badlogic.gdx.utils.LongArray)"""
        val = _LongArray(arg0)
        self.__wrapper = val

    @overload
    def mul(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.LongArray.mul(int,long)"""
        super(_LongArray, self).mul(_int.valueOf(arg0), _long.valueOf(arg1))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.LongArray.clear()"""
        super(LongArray, self).clear()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.LongArray()"""
        val = _LongArray()
        self.__wrapper = val

    @overload
    def indexOf(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.LongArray.indexOf(long)"""
        return int._wrap(super(_LongArray, self).indexOf(_long.valueOf(arg0)))

    @overload
    def removeAll(self, arg0: 'LongArray') -> bool:
        """public boolean com.badlogic.gdx.utils.LongArray.removeAll(com.badlogic.gdx.utils.LongArray)"""
        return bool._wrap(super(_LongArray, self).removeAll(arg0))

    @overload
    def removeIndex(self, arg0: int) -> int:
        """public long com.badlogic.gdx.utils.LongArray.removeIndex(int)"""
        return int._wrap(super(_LongArray, self).removeIndex(_int.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.LongArray.toString()"""
        return str._wrap(super(LongArray, self).toString())

    @overload
    def addAll(self, *arg0: int):
        """public void com.badlogic.gdx.utils.LongArray.addAll(long...)"""
        super(_LongArray, self).addAll(arg0)

    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.LongArray.swap(int,int)"""
        super(_LongArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1)) 
 
 
# CLASS: com.badlogic.gdx.utils.Align
from builtins import str
import com.badlogic.gdx.utils.Align as _Align
_Align = _Align
from pyquantum_helper import override
import java.lang.Integer as _int
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Align():
    """com.badlogic.gdx.utils.Align"""
 
    @staticmethod
    def _wrap(java_value: _Align) -> 'Align':
        return Align(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Align):
        """
        Dynamic initializer for Align.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Align__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Align__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Align()"""
        val = _Align()
        self.__wrapper = val

    @staticmethod
    @overload
    def isTop(arg0: int) -> bool:
        """public static final boolean com.badlogic.gdx.utils.Align.isTop(int)"""
        return bool._wrap(_Align.isTop(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def isLeft(arg0: int) -> bool:
        """public static final boolean com.badlogic.gdx.utils.Align.isLeft(int)"""
        return bool._wrap(_Align.isLeft(_int.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def toString(arg0: int) -> str:
        """public static java.lang.String com.badlogic.gdx.utils.Align.toString(int)"""
        return str._wrap(_Align.toString(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def isCenterHorizontal(arg0: int) -> bool:
        """public static final boolean com.badlogic.gdx.utils.Align.isCenterHorizontal(int)"""
        return bool._wrap(_Align.isCenterHorizontal(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def isRight(arg0: int) -> bool:
        """public static final boolean com.badlogic.gdx.utils.Align.isRight(int)"""
        return bool._wrap(_Align.isRight(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def isCenterVertical(arg0: int) -> bool:
        """public static final boolean com.badlogic.gdx.utils.Align.isCenterVertical(int)"""
        return bool._wrap(_Align.isCenterVertical(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def isBottom(arg0: int) -> bool:
        """public static final boolean com.badlogic.gdx.utils.Align.isBottom(int)"""
        return bool._wrap(_Align.isBottom(_int.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Align()"""
        val = _Align()
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ShortArray
from builtins import str
import java.lang.Character as _char
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.Short as _short
from typing import List
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import com.badlogic.gdx.utils.ShortArray as _ShortArray
_ShortArray = _ShortArray
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ShortArray():
    """com.badlogic.gdx.utils.ShortArray"""
 
    @staticmethod
    def _wrap(java_value: _ShortArray) -> 'ShortArray':
        return ShortArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ShortArray):
        """
        Dynamic initializer for ShortArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ShortArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ShortArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ShortArray.swap(int,int)"""
        super(_ShortArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def mul(self, arg0: int):
        """public void com.badlogic.gdx.utils.ShortArray.mul(short)"""
        super(_ShortArray, self).mul(_short.valueOf(arg0))

    @overload
    def get(self, arg0: int) -> int:
        """public short com.badlogic.gdx.utils.ShortArray.get(int)"""
        return int._wrap(super(_ShortArray, self).get(_int.valueOf(arg0)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ShortArray.toString(java.lang.String)"""
        return str._wrap(super(_ShortArray, self).toString(arg0))

    @overload
    def incr(self, arg0: int):
        """public void com.badlogic.gdx.utils.ShortArray.incr(short)"""
        super(_ShortArray, self).incr(_short.valueOf(arg0))

    @staticmethod
    @overload
    def with(*arg0: int) -> 'ShortArray':
        """public static com.badlogic.gdx.utils.ShortArray com.badlogic.gdx.utils.ShortArray.with(short...)"""
        return ShortArray._wrap(_ShortArray.with(arg0))

    @overload
    def toArray(self) -> List[int]:
        """public short[] com.badlogic.gdx.utils.ShortArray.toArray()"""
        return List[int]._wrap(super(ShortArray, self).toArray())

    @overload
    def addAll(self, arg0: 'short', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ShortArray.addAll(short[],int,int)"""
        super(_ShortArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ShortArray.toString()"""
        return str._wrap(super(ShortArray, self).toString())

    @overload
    def contains(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.ShortArray.contains(short)"""
        return bool._wrap(super(_ShortArray, self).contains(_short.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'short'):
        """public com.badlogic.gdx.utils.ShortArray(short[])"""
        val = _ShortArray(arg0)
        self.__wrapper = val

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.ShortArray.reverse()"""
        super(ShortArray, self).reverse()

    @overload
    def __init__(self, arg0: 'ShortArray'):
        """public com.badlogic.gdx.utils.ShortArray(com.badlogic.gdx.utils.ShortArray)"""
        val = _ShortArray(arg0)
        self.__wrapper = val

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ShortArray.isEmpty()"""
        return bool._wrap(super(ShortArray, self).isEmpty())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.ShortArray(int)"""
        val = _ShortArray(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def addAll(self, arg0: 'ShortArray'):
        """public void com.badlogic.gdx.utils.ShortArray.addAll(com.badlogic.gdx.utils.ShortArray)"""
        super(_ShortArray, self).addAll(arg0)

    @overload
    def random(self) -> int:
        """public short com.badlogic.gdx.utils.ShortArray.random()"""
        return int._wrap(super(ShortArray, self).random())

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.ShortArray(boolean,int)"""
        val = _ShortArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def add(self, arg0: int, arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ShortArray.add(short,short,short)"""
        super(_ShortArray, self).add(_short.valueOf(arg0), _short.valueOf(arg1), _short.valueOf(arg2))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def ensureCapacity(self, arg0: int) -> List[int]:
        """public short[] com.badlogic.gdx.utils.ShortArray.ensureCapacity(int)"""
        return List[int]._wrap(super(_ShortArray, self).ensureCapacity(_int.valueOf(arg0)))

    @overload
    def add(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ShortArray.add(short,short)"""
        super(_ShortArray, self).add(_short.valueOf(arg0), _short.valueOf(arg1))

    @overload
    def addAll(self, *arg0: int):
        """public void com.badlogic.gdx.utils.ShortArray.addAll(short...)"""
        super(_ShortArray, self).addAll(arg0)

    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.ShortArray.truncate(int)"""
        super(_ShortArray, self).truncate(_int.valueOf(arg0))

    @overload
    def shrink(self) -> List[int]:
        """public short[] com.badlogic.gdx.utils.ShortArray.shrink()"""
        return List[int]._wrap(super(ShortArray, self).shrink())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ShortArray()"""
        val = _ShortArray()
        self.__wrapper = val

    @overload
    def mul(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ShortArray.mul(int,short)"""
        super(_ShortArray, self).mul(_int.valueOf(arg0), _short.valueOf(arg1))

    @overload
    def insert(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ShortArray.insert(int,short)"""
        super(_ShortArray, self).insert(_int.valueOf(arg0), _short.valueOf(arg1))

    @overload
    def set(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ShortArray.set(int,short)"""
        super(_ShortArray, self).set(_int.valueOf(arg0), _short.valueOf(arg1))

    @overload
    def __init__(self, arg0: bool, arg1: 'short', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.ShortArray(boolean,short[],int,int)"""
        val = _ShortArray(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @overload
    def setSize(self, arg0: int) -> List[int]:
        """public short[] com.badlogic.gdx.utils.ShortArray.setSize(int)"""
        return List[int]._wrap(super(_ShortArray, self).setSize(_int.valueOf(arg0)))

    @overload
    def add(self, arg0: int):
        """public void com.badlogic.gdx.utils.ShortArray.add(short)"""
        super(_ShortArray, self).add(_short.valueOf(arg0))

    @overload
    def removeIndex(self, arg0: int) -> int:
        """public short com.badlogic.gdx.utils.ShortArray.removeIndex(int)"""
        return int._wrap(super(_ShortArray, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def add(self, arg0: int, arg1: int, arg2: int, arg3: int):
        """public void com.badlogic.gdx.utils.ShortArray.add(short,short,short,short)"""
        super(_ShortArray, self).add(_short.valueOf(arg0), _short.valueOf(arg1), _short.valueOf(arg2), _short.valueOf(arg3))

    @overload
    def lastIndexOf(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.ShortArray.lastIndexOf(char)"""
        return int._wrap(super(_ShortArray, self).lastIndexOf(_char.valueOf(arg0)))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ShortArray()"""
        val = _ShortArray()
        self.__wrapper = val

    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ShortArray.insertRange(int,int)"""
        super(_ShortArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.ShortArray.shuffle()"""
        super(ShortArray, self).shuffle()

    @overload
    def incr(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ShortArray.incr(int,short)"""
        super(_ShortArray, self).incr(_int.valueOf(arg0), _short.valueOf(arg1))

    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.ShortArray.sort()"""
        super(ShortArray, self).sort()

    @overload
    def indexOf(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.ShortArray.indexOf(short)"""
        return int._wrap(super(_ShortArray, self).indexOf(_short.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def peek(self) -> int:
        """public short com.badlogic.gdx.utils.ShortArray.peek()"""
        return int._wrap(super(ShortArray, self).peek())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ShortArray.hashCode()"""
        return int._wrap(super(ShortArray, self).hashCode())

    @overload
    def removeAll(self, arg0: 'ShortArray') -> bool:
        """public boolean com.badlogic.gdx.utils.ShortArray.removeAll(com.badlogic.gdx.utils.ShortArray)"""
        return bool._wrap(super(_ShortArray, self).removeAll(arg0))

    @overload
    def addAll(self, arg0: 'ShortArray', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ShortArray.addAll(com.badlogic.gdx.utils.ShortArray,int,int)"""
        super(_ShortArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def first(self) -> int:
        """public short com.badlogic.gdx.utils.ShortArray.first()"""
        return int._wrap(super(ShortArray, self).first())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ShortArray.equals(java.lang.Object)"""
        return bool._wrap(super(_ShortArray, self).equals(arg0))

    @overload
    def pop(self) -> int:
        """public short com.badlogic.gdx.utils.ShortArray.pop()"""
        return int._wrap(super(ShortArray, self).pop())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ShortArray.notEmpty()"""
        return bool._wrap(super(ShortArray, self).notEmpty())

    @overload
    def add(self, arg0: int):
        """public void com.badlogic.gdx.utils.ShortArray.add(int)"""
        super(_ShortArray, self).add(_int.valueOf(arg0))

    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ShortArray.removeRange(int,int)"""
        super(_ShortArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ShortArray.clear()"""
        super(ShortArray, self).clear()

    @overload
    def removeValue(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.ShortArray.removeValue(short)"""
        return bool._wrap(super(_ShortArray, self).removeValue(_short.valueOf(arg0))) 
 
 
# CLASS: com.badlogic.gdx.utils.ArrayMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.ArrayMap as _ArrayMap_Keys
_Keys = _ArrayMap_Keys.Keys
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.ArrayMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.ArrayMap$Keys.next()"""
        return object._wrap(super(Keys, self).next())

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ArrayMap$Keys.toArray(com.badlogic.gdx.utils.Array)"""
        return 'Array'._wrap(super(_Keys, self).toArray(arg0))

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ArrayMap$Keys.toArray()"""
        return 'Array'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap$Keys.hasNext()"""
        return bool._wrap(super(Keys, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.ArrayMap$Keys.remove()"""
        super(Keys, self).remove()

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.badlogic.gdx.utils.ArrayMap$Keys.iterator()"""
        return 'Iterator'._wrap(super(Keys, self).iterator())

    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.ArrayMap$Keys.reset()"""
        super(Keys, self).reset()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: 'ArrayMap'):
        """public com.badlogic.gdx.utils.ArrayMap$Keys(com.badlogic.gdx.utils.ArrayMap<K, java.lang.Object>)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.XmlReader
from pyquantum_helper import import_once as _import_once
import com.badlogic.gdx.utils.XmlReader as _XmlReader_Element
_Element = _XmlReader_Element.Element
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.XmlReader as _XmlReader
_XmlReader = _XmlReader
import java.lang.String as _string
import java.lang.Integer as _int
import java.io.Reader as Reader
import java.io.InputStream as InputStream
try:
    from pygdx import files
except ImportError:
    files = _import_once("pygdx.files")

from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class XmlReader():
    """com.badlogic.gdx.utils.XmlReader"""
 
    @staticmethod
    def _wrap(java_value: _XmlReader) -> 'XmlReader':
        return XmlReader(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _XmlReader):
        """
        Dynamic initializer for XmlReader.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_XmlReader__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_XmlReader__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def parse(self, arg0: 'char', arg1: int, arg2: int) -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader.parse(char[],int,int)"""
        return 'Element'._wrap(super(_XmlReader, self).parse(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def parse(self, arg0: 'InputStream') -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader.parse(java.io.InputStream)"""
        return 'Element'._wrap(super(_XmlReader, self).parse(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def parse(self, arg0: 'FileHandle') -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader.parse(com.badlogic.gdx.files.FileHandle)"""
        return 'Element'._wrap(super(_XmlReader, self).parse(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.XmlReader()"""
        val = _XmlReader()
        self.__wrapper = val

    @overload
    def parse(self, arg0: str) -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader.parse(java.lang.String)"""
        return 'Element'._wrap(super(_XmlReader, self).parse(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.XmlReader()"""
        val = _XmlReader()
        self.__wrapper = val

    @overload
    def parse(self, arg0: 'Reader') -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader.parse(java.io.Reader)"""
        return 'Element'._wrap(super(_XmlReader, self).parse(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectFloatMap$Values
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import float
import com.badlogic.gdx.utils.FloatArray as _FloatArray
_FloatArray = _FloatArray
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap_Values
_Values = _ObjectFloatMap_Values.Values
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.ObjectFloatMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: 'ObjectFloatMap'):
        """public com.badlogic.gdx.utils.ObjectFloatMap$Values(com.badlogic.gdx.utils.ObjectFloatMap<?>)"""
        val = _Values(arg0)
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def next(self) -> float:
        """public float com.badlogic.gdx.utils.ObjectFloatMap$Values.next()"""
        return float._wrap(super(Values, self).next())

    @overload
    def iterator(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectFloatMap$Values com.badlogic.gdx.utils.ObjectFloatMap$Values.iterator()"""
        return 'Values'._wrap(super(Values, self).iterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def toArray(self, arg0: 'FloatArray') -> 'FloatArray':
        """public com.badlogic.gdx.utils.FloatArray com.badlogic.gdx.utils.ObjectFloatMap$Values.toArray(com.badlogic.gdx.utils.FloatArray)"""
        return 'FloatArray'._wrap(super(_Values, self).toArray(arg0))

    @overload
    def toArray(self) -> 'FloatArray':
        """public com.badlogic.gdx.utils.FloatArray com.badlogic.gdx.utils.ObjectFloatMap$Values.toArray()"""
        return 'FloatArray'._wrap(super(Values, self).toArray())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Json$Serializer
import com.badlogic.gdx.utils.Json as _Json_Serializer
_Serializer = _Json_Serializer.Serializer
from builtins import type
from abc import abstractmethod, ABC
 
class Serializer():
    """com.badlogic.gdx.utils.Json.Serializer"""
 
    @staticmethod
    def _wrap(java_value: _Serializer) -> 'Serializer':
        return Serializer(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Serializer):
        """
        Dynamic initializer for Serializer.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Serializer__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Serializer__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def read(self, arg0: 'Json', arg1: 'JsonValue', arg2: 'Class'):
        """public abstract T com.badlogic.gdx.utils.Json$Serializer.read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class)"""
        pass

    @abstractmethod
    def write(self, arg0: 'Json', arg1: object, arg2: 'Class'):
        """public abstract void com.badlogic.gdx.utils.Json$Serializer.write(com.badlogic.gdx.utils.Json,T,java.lang.Class)"""
        pass 
 
 
# CLASS: com.badlogic.gdx.utils.Queue
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.Queue as _Queue
_Queue = _Queue
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Queue():
    """com.badlogic.gdx.utils.Queue"""
 
    @staticmethod
    def _wrap(java_value: _Queue) -> 'Queue':
        return Queue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Queue):
        """
        Dynamic initializer for Queue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Queue__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Queue__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def indexOf(self, arg0: object, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.Queue.indexOf(T,boolean)"""
        return int._wrap(super(_Queue, self).indexOf(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<T> com.badlogic.gdx.utils.Queue.iterator()"""
        return 'Iterator'._wrap(super(Queue, self).iterator())

    @overload
    def last(self) -> object:
        """public T com.badlogic.gdx.utils.Queue.last()"""
        return object._wrap(super(Queue, self).last())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.Queue.ensureCapacity(int)"""
        super(_Queue, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def removeFirst(self) -> object:
        """public T com.badlogic.gdx.utils.Queue.removeFirst()"""
        return object._wrap(super(Queue, self).removeFirst())

    @overload
    def __init__(self, arg0: int, arg1: 'Class'):
        """public com.badlogic.gdx.utils.Queue(int,java.lang.Class<T>)"""
        val = _Queue(_int.valueOf(arg0), arg1)
        self.__wrapper = val

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Queue()"""
        val = _Queue()
        self.__wrapper = val

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.Queue.hashCode()"""
        return int._wrap(super(Queue, self).hashCode())

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Queue.toString(java.lang.String)"""
        return str._wrap(super(_Queue, self).toString(arg0))

    @overload
    def addLast(self, arg0: object):
        """public void com.badlogic.gdx.utils.Queue.addLast(T)"""
        super(_Queue, self).addLast(arg0)

    @overload
    def removeLast(self) -> object:
        """public T com.badlogic.gdx.utils.Queue.removeLast()"""
        return object._wrap(super(Queue, self).removeLast())

    @overload
    def get(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.Queue.get(int)"""
        return object._wrap(super(_Queue, self).get(_int.valueOf(arg0)))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Queue.notEmpty()"""
        return bool._wrap(super(Queue, self).notEmpty())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Queue()"""
        val = _Queue()
        self.__wrapper = val

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Queue.isEmpty()"""
        return bool._wrap(super(Queue, self).isEmpty())

    @overload
    def addFirst(self, arg0: object):
        """public void com.badlogic.gdx.utils.Queue.addFirst(T)"""
        super(_Queue, self).addFirst(arg0)

    @overload
    def removeIndex(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.Queue.removeIndex(int)"""
        return object._wrap(super(_Queue, self).removeIndex(_int.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.Queue(int)"""
        val = _Queue(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Queue.equals(java.lang.Object)"""
        return bool._wrap(super(_Queue, self).equals(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Queue.toString()"""
        return str._wrap(super(Queue, self).toString())

    @overload
    def removeValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Queue.removeValue(T,boolean)"""
        return bool._wrap(super(_Queue, self).removeValue(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.Queue.clear()"""
        super(Queue, self).clear()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def first(self) -> object:
        """public T com.badlogic.gdx.utils.Queue.first()"""
        return object._wrap(super(Queue, self).first())

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Queue.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_Queue, self).equalsIdentity(arg0)) 
 
 
# CLASS: com.badlogic.gdx.utils.Bits
from builtins import str
from pyquantum_helper import override
import java.lang.Integer as _int
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.Bits as _Bits
_Bits = _Bits
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Bits():
    """com.badlogic.gdx.utils.Bits"""
 
    @staticmethod
    def _wrap(java_value: _Bits) -> 'Bits':
        return Bits(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Bits):
        """
        Dynamic initializer for Bits.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Bits__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Bits__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def nextSetBit(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.Bits.nextSetBit(int)"""
        return int._wrap(super(_Bits, self).nextSetBit(_int.valueOf(arg0)))

    @overload
    def and(self, arg0: 'Bits'):
        """public void com.badlogic.gdx.utils.Bits.and(com.badlogic.gdx.utils.Bits)"""
        super(_Bits, self).and(arg0)

    @overload
    def getAndClear(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.Bits.getAndClear(int)"""
        return bool._wrap(super(_Bits, self).getAndClear(_int.valueOf(arg0)))

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.Bits.clear(int)"""
        super(_Bits, self).clear(_int.valueOf(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def length(self) -> int:
        """public int com.badlogic.gdx.utils.Bits.length()"""
        return int._wrap(super(Bits, self).length())

    @overload
    def get(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.Bits.get(int)"""
        return bool._wrap(super(_Bits, self).get(_int.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Bits()"""
        val = _Bits()
        self.__wrapper = val

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.Bits.clear()"""
        super(Bits, self).clear()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.Bits.hashCode()"""
        return int._wrap(super(Bits, self).hashCode())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Bits.notEmpty()"""
        return bool._wrap(super(Bits, self).notEmpty())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Bits.equals(java.lang.Object)"""
        return bool._wrap(super(_Bits, self).equals(arg0))

    @overload
    def flip(self, arg0: int):
        """public void com.badlogic.gdx.utils.Bits.flip(int)"""
        super(_Bits, self).flip(_int.valueOf(arg0))

    @overload
    def xor(self, arg0: 'Bits'):
        """public void com.badlogic.gdx.utils.Bits.xor(com.badlogic.gdx.utils.Bits)"""
        super(_Bits, self).xor(arg0)

    @overload
    def __init__(self, arg0: 'Bits'):
        """public com.badlogic.gdx.utils.Bits(com.badlogic.gdx.utils.Bits)"""
        val = _Bits(arg0)
        self.__wrapper = val

    @overload
    def numBits(self) -> int:
        """public int com.badlogic.gdx.utils.Bits.numBits()"""
        return int._wrap(super(Bits, self).numBits())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def or(self, arg0: 'Bits'):
        """public void com.badlogic.gdx.utils.Bits.or(com.badlogic.gdx.utils.Bits)"""
        super(_Bits, self).or(arg0)

    @overload
    def getAndSet(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.Bits.getAndSet(int)"""
        return bool._wrap(super(_Bits, self).getAndSet(_int.valueOf(arg0)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def andNot(self, arg0: 'Bits'):
        """public void com.badlogic.gdx.utils.Bits.andNot(com.badlogic.gdx.utils.Bits)"""
        super(_Bits, self).andNot(arg0)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def intersects(self, arg0: 'Bits') -> bool:
        """public boolean com.badlogic.gdx.utils.Bits.intersects(com.badlogic.gdx.utils.Bits)"""
        return bool._wrap(super(_Bits, self).intersects(arg0))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Bits.isEmpty()"""
        return bool._wrap(super(Bits, self).isEmpty())

    @overload
    def containsAll(self, arg0: 'Bits') -> bool:
        """public boolean com.badlogic.gdx.utils.Bits.containsAll(com.badlogic.gdx.utils.Bits)"""
        return bool._wrap(super(_Bits, self).containsAll(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Bits()"""
        val = _Bits()
        self.__wrapper = val

    @overload
    def set(self, arg0: int):
        """public void com.badlogic.gdx.utils.Bits.set(int)"""
        super(_Bits, self).set(_int.valueOf(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.Bits(int)"""
        val = _Bits(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def nextClearBit(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.Bits.nextClearBit(int)"""
        return int._wrap(super(_Bits, self).nextClearBit(_int.valueOf(arg0))) 
 
 
# CLASS: com.badlogic.gdx.utils.IntIntMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.IntArray as _IntArray
_IntArray = _IntArray
import java.lang.Integer as _int
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap_Keys
_Keys = _IntIntMap_Keys.Keys
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.IntIntMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, arg0: 'IntIntMap'):
        """public com.badlogic.gdx.utils.IntIntMap$Keys(com.badlogic.gdx.utils.IntIntMap)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @overload
    def next(self) -> int:
        """public int com.badlogic.gdx.utils.IntIntMap$Keys.next()"""
        return int._wrap(super(Keys, self).next())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def toArray(self) -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntIntMap$Keys.toArray()"""
        return 'IntArray'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'IntArray') -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntIntMap$Keys.toArray(com.badlogic.gdx.utils.IntArray)"""
        return 'IntArray'._wrap(super(_Keys, self).toArray(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntIntMap$Entries
from builtins import str
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap_Entries
_Entries = _IntIntMap_Entries.Entries
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.IntIntMap as _IntIntMap_Entry
_Entry = _IntIntMap_Entry.Entry
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.IntIntMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.IntIntMap$Entry> com.badlogic.gdx.utils.IntIntMap$Entries.iterator()"""
        return 'Iterator'._wrap(super(Entries, self).iterator())

    @overload
    def __init__(self, arg0: 'IntIntMap'):
        """public com.badlogic.gdx.utils.IntIntMap$Entries(com.badlogic.gdx.utils.IntIntMap)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.IntIntMap$Entry com.badlogic.gdx.utils.IntIntMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntIntMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.UBJsonReader
from pyquantum_helper import import_once as _import_once
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.JsonValue as _JsonValue
_JsonValue = _JsonValue
import java.lang.Integer as _int
import com.badlogic.gdx.utils.UBJsonReader as _UBJsonReader
_UBJsonReader = _UBJsonReader
import java.io.InputStream as InputStream
try:
    from pygdx import files
except ImportError:
    files = _import_once("pygdx.files")

from builtins import bool
import java.io.DataInputStream as DataInputStream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class UBJsonReader():
    """com.badlogic.gdx.utils.UBJsonReader"""
 
    @staticmethod
    def _wrap(java_value: _UBJsonReader) -> 'UBJsonReader':
        return UBJsonReader(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _UBJsonReader):
        """
        Dynamic initializer for UBJsonReader.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_UBJsonReader__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_UBJsonReader__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def parse(self, arg0: 'InputStream') -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.UBJsonReader.parse(java.io.InputStream)"""
        return 'JsonValue'._wrap(super(_UBJsonReader, self).parse(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.UBJsonReader()"""
        val = _UBJsonReader()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def parse(self, arg0: 'FileHandle') -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.UBJsonReader.parse(com.badlogic.gdx.files.FileHandle)"""
        return 'JsonValue'._wrap(super(_UBJsonReader, self).parse(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def parse(self, arg0: 'DataInputStream') -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.UBJsonReader.parse(java.io.DataInputStream) throws java.io.IOException"""
        return 'JsonValue'._wrap(super(_UBJsonReader, self).parse(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.UBJsonReader()"""
        val = _UBJsonReader()
        self.__wrapper = val 
 
 
# CLASS: com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from builtins import bool
import com.badlogic.gdx.utils.JsonValue as _JsonValue_PrettyPrintSettings
_PrettyPrintSettings = _JsonValue_PrettyPrintSettings.PrettyPrintSettings
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class PrettyPrintSettings():
    """com.badlogic.gdx.utils.JsonValue.PrettyPrintSettings"""
 
    @staticmethod
    def _wrap(java_value: _PrettyPrintSettings) -> 'PrettyPrintSettings':
        return PrettyPrintSettings(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PrettyPrintSettings):
        """
        Dynamic initializer for PrettyPrintSettings.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PrettyPrintSettings__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PrettyPrintSettings__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings()"""
        val = _PrettyPrintSettings()
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings()"""
        val = _PrettyPrintSettings()
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Base64Coder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import com.badlogic.gdx.utils.Base64Coder as _Base64Coder
_Base64Coder = _Base64Coder
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Base64Coder():
    """com.badlogic.gdx.utils.Base64Coder"""
 
    @staticmethod
    def _wrap(java_value: _Base64Coder) -> 'Base64Coder':
        return Base64Coder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Base64Coder):
        """
        Dynamic initializer for Base64Coder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Base64Coder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Base64Coder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def encode(arg0: bytes) -> List[str]:
        """public static char[] com.badlogic.gdx.utils.Base64Coder.encode(byte[])"""
        return List[str]._wrap(_Base64Coder.encode(bytes))

    @staticmethod
    @overload
    def encodeLines(arg0: bytes, arg1: int, arg2: int, arg3: int, arg4: str, arg5: 'char') -> str:
        """public static java.lang.String com.badlogic.gdx.utils.Base64Coder.encodeLines(byte[],int,int,int,java.lang.String,char[])"""
        return str._wrap(_Base64Coder.encodeLines(bytes, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4, arg5))

    @staticmethod
    @overload
    def decodeString(arg0: str, arg1: bool) -> str:
        """public static java.lang.String com.badlogic.gdx.utils.Base64Coder.decodeString(java.lang.String,boolean)"""
        return str._wrap(_Base64Coder.decodeString(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def decodeLines(arg0: str, arg1: 'CharMap') -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decodeLines(java.lang.String,com.badlogic.gdx.utils.Base64Coder$CharMap)"""
        return List[int]._wrap(_Base64Coder.decodeLines(arg0, arg1))

    @staticmethod
    @overload
    def decodeLines(arg0: str) -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decodeLines(java.lang.String)"""
        return List[int]._wrap(_Base64Coder.decodeLines(arg0))

    @staticmethod
    @overload
    def decode(arg0: str) -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decode(java.lang.String)"""
        return List[int]._wrap(_Base64Coder.decode(arg0))

    @staticmethod
    @overload
    def encode(arg0: bytes, arg1: 'char') -> List[str]:
        """public static char[] com.badlogic.gdx.utils.Base64Coder.encode(byte[],char[])"""
        return List[str]._wrap(_Base64Coder.encode(bytes, arg1))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def encodeLines(arg0: bytes) -> str:
        """public static java.lang.String com.badlogic.gdx.utils.Base64Coder.encodeLines(byte[])"""
        return str._wrap(_Base64Coder.encodeLines(bytes))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def decode(arg0: str, arg1: 'CharMap') -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decode(java.lang.String,com.badlogic.gdx.utils.Base64Coder$CharMap)"""
        return List[int]._wrap(_Base64Coder.decode(arg0, arg1))

    @staticmethod
    @overload
    def encode(arg0: bytes, arg1: int, arg2: int, arg3: 'CharMap') -> List[str]:
        """public static char[] com.badlogic.gdx.utils.Base64Coder.encode(byte[],int,int,com.badlogic.gdx.utils.Base64Coder$CharMap)"""
        return List[str]._wrap(_Base64Coder.encode(bytes, _int.valueOf(arg1), _int.valueOf(arg2), arg3))

    @staticmethod
    @overload
    def encodeString(arg0: str, arg1: bool) -> str:
        """public static java.lang.String com.badlogic.gdx.utils.Base64Coder.encodeString(java.lang.String,boolean)"""
        return str._wrap(_Base64Coder.encodeString(arg0, _boolean.valueOf(arg1)))

    @staticmethod
    @overload
    def decode(arg0: 'char', arg1: int, arg2: int, arg3: bytes) -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decode(char[],int,int,byte[])"""
        return List[int]._wrap(_Base64Coder.decode(arg0, _int.valueOf(arg1), _int.valueOf(arg2), bytes))

    @staticmethod
    @overload
    def encode(arg0: bytes, arg1: 'CharMap') -> List[str]:
        """public static char[] com.badlogic.gdx.utils.Base64Coder.encode(byte[],com.badlogic.gdx.utils.Base64Coder$CharMap)"""
        return List[str]._wrap(_Base64Coder.encode(bytes, arg1))

    @staticmethod
    @overload
    def decode(arg0: 'char') -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decode(char[])"""
        return List[int]._wrap(_Base64Coder.decode(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def decode(arg0: 'char', arg1: 'CharMap') -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decode(char[],com.badlogic.gdx.utils.Base64Coder$CharMap)"""
        return List[int]._wrap(_Base64Coder.decode(arg0, arg1))

    @staticmethod
    @overload
    def decodeLines(arg0: str, arg1: bytes) -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decodeLines(java.lang.String,byte[])"""
        return List[int]._wrap(_Base64Coder.decodeLines(arg0, bytes))

    @staticmethod
    @overload
    def encode(arg0: bytes, arg1: int, arg2: int, arg3: 'char') -> List[str]:
        """public static char[] com.badlogic.gdx.utils.Base64Coder.encode(byte[],int,int,char[])"""
        return List[str]._wrap(_Base64Coder.encode(bytes, _int.valueOf(arg1), _int.valueOf(arg2), arg3))

    @staticmethod
    @overload
    def encode(arg0: bytes, arg1: int) -> List[str]:
        """public static char[] com.badlogic.gdx.utils.Base64Coder.encode(byte[],int)"""
        return List[str]._wrap(_Base64Coder.encode(bytes, _int.valueOf(arg1)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def decodeString(arg0: str) -> str:
        """public static java.lang.String com.badlogic.gdx.utils.Base64Coder.decodeString(java.lang.String)"""
        return str._wrap(_Base64Coder.decodeString(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def decode(arg0: 'char', arg1: bytes) -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decode(char[],byte[])"""
        return List[int]._wrap(_Base64Coder.decode(arg0, bytes))

    @staticmethod
    @overload
    def encodeString(arg0: str) -> str:
        """public static java.lang.String com.badlogic.gdx.utils.Base64Coder.encodeString(java.lang.String)"""
        return str._wrap(_Base64Coder.encodeString(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def encodeLines(arg0: bytes, arg1: int, arg2: int, arg3: int, arg4: str, arg5: 'CharMap') -> str:
        """public static java.lang.String com.badlogic.gdx.utils.Base64Coder.encodeLines(byte[],int,int,int,java.lang.String,com.badlogic.gdx.utils.Base64Coder$CharMap)"""
        return str._wrap(_Base64Coder.encodeLines(bytes, _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), arg4, arg5))

    @staticmethod
    @overload
    def decode(arg0: 'char', arg1: int, arg2: int, arg3: 'CharMap') -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.Base64Coder.decode(char[],int,int,com.badlogic.gdx.utils.Base64Coder$CharMap)"""
        return List[int]._wrap(_Base64Coder.decode(arg0, _int.valueOf(arg1), _int.valueOf(arg2), arg3))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Array$ArrayIterator
from builtins import str
import com.badlogic.gdx.utils.Array as _Array_ArrayIterator
_ArrayIterator = _Array_ArrayIterator.ArrayIterator
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ArrayIterator():
    """com.badlogic.gdx.utils.Array.ArrayIterator"""
 
    @staticmethod
    def _wrap(java_value: _ArrayIterator) -> 'ArrayIterator':
        return ArrayIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ArrayIterator):
        """
        Dynamic initializer for ArrayIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ArrayIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ArrayIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.Array$ArrayIterator.reset()"""
        super(ArrayIterator, self).reset()

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.Array$ArrayIterator.remove()"""
        super(ArrayIterator, self).remove()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: 'Array', arg1: bool):
        """public com.badlogic.gdx.utils.Array$ArrayIterator(com.badlogic.gdx.utils.Array<T>,boolean)"""
        val = _ArrayIterator(arg0, _boolean.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Array$ArrayIterator.hasNext()"""
        return bool._wrap(super(ArrayIterator, self).hasNext())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def iterator(self) -> 'ArrayIterator':
        """public com.badlogic.gdx.utils.Array$ArrayIterator<T> com.badlogic.gdx.utils.Array$ArrayIterator.iterator()"""
        return 'ArrayIterator'._wrap(super(ArrayIterator, self).iterator())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def next(self) -> object:
        """public T com.badlogic.gdx.utils.Array$ArrayIterator.next()"""
        return object._wrap(super(ArrayIterator, self).next())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: 'Array'):
        """public com.badlogic.gdx.utils.Array$ArrayIterator(com.badlogic.gdx.utils.Array<T>)"""
        val = _ArrayIterator(arg0)
        self.__wrapper = val

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.XmlWriter
from builtins import str
import java.lang.Character as _char
import java.lang.CharSequence as CharSequence
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
import java.io.Writer as _Writer
_Writer = _Writer
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.String as _string
import java.lang.Integer as _int
import java.io.Writer as Writer
import com.badlogic.gdx.utils.XmlWriter as _XmlWriter
_XmlWriter = _XmlWriter
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class XmlWriter():
    """com.badlogic.gdx.utils.XmlWriter"""
 
    @staticmethod
    def _wrap(java_value: _XmlWriter) -> 'XmlWriter':
        return XmlWriter(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _XmlWriter):
        """
        Dynamic initializer for XmlWriter.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_XmlWriter__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_XmlWriter__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def append(self, arg0: 'CharSequence') -> 'Writer':
        """public java.io.Writer java.io.Writer.append(java.lang.CharSequence) throws java.io.IOException"""
        return 'Writer'._wrap(super(_Writer, self).append(arg0))

    @override
    @overload
    def flush(self):
        """public void com.badlogic.gdx.utils.XmlWriter.flush() throws java.io.IOException"""
        super(XmlWriter, self).flush()

    @staticmethod
    @overload
    def nullWriter() -> 'Writer':
        """public static java.io.Writer java.io.Writer.nullWriter()"""
        return Writer._wrap(_Writer.nullWriter())

    @overload
    def attribute(self, arg0: str, arg1: object) -> 'XmlWriter':
        """public com.badlogic.gdx.utils.XmlWriter com.badlogic.gdx.utils.XmlWriter.attribute(java.lang.String,java.lang.Object) throws java.io.IOException"""
        return 'XmlWriter'._wrap(super(_XmlWriter, self).attribute(arg0, arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def close(self):
        """public void com.badlogic.gdx.utils.XmlWriter.close() throws java.io.IOException"""
        super(XmlWriter, self).close()

    @overload
    def append(self, arg0: 'CharSequence', arg1: int, arg2: int) -> 'Writer':
        """public java.io.Writer java.io.Writer.append(java.lang.CharSequence,int,int) throws java.io.IOException"""
        return 'Writer'._wrap(super(_Writer, self).append(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def text(self, arg0: object) -> 'XmlWriter':
        """public com.badlogic.gdx.utils.XmlWriter com.badlogic.gdx.utils.XmlWriter.text(java.lang.Object) throws java.io.IOException"""
        return 'XmlWriter'._wrap(super(_XmlWriter, self).text(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def element(self, arg0: str, arg1: object) -> 'XmlWriter':
        """public com.badlogic.gdx.utils.XmlWriter com.badlogic.gdx.utils.XmlWriter.element(java.lang.String,java.lang.Object) throws java.io.IOException"""
        return 'XmlWriter'._wrap(super(_XmlWriter, self).element(arg0, arg1))

    @overload
    def pop(self) -> 'XmlWriter':
        """public com.badlogic.gdx.utils.XmlWriter com.badlogic.gdx.utils.XmlWriter.pop() throws java.io.IOException"""
        return 'XmlWriter'._wrap(super(XmlWriter, self).pop())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @overload
    def element(self, arg0: str) -> 'XmlWriter':
        """public com.badlogic.gdx.utils.XmlWriter com.badlogic.gdx.utils.XmlWriter.element(java.lang.String) throws java.io.IOException"""
        return 'XmlWriter'._wrap(super(_XmlWriter, self).element(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def write(self, arg0: str):
        """public void java.io.Writer.write(java.lang.String) throws java.io.IOException"""
        super(_Writer, self).write(arg0)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def __init__(self, arg0: 'Writer'):
        """public com.badlogic.gdx.utils.XmlWriter(java.io.Writer)"""
        val = _XmlWriter(arg0)
        self.__wrapper = val

    @override
    @overload
    def write(self, arg0: 'char'):
        """public void java.io.Writer.write(char[]) throws java.io.IOException"""
        super(_Writer, self).write(arg0)

    @override
    @overload
    def write(self, arg0: str, arg1: int, arg2: int):
        """public void java.io.Writer.write(java.lang.String,int,int) throws java.io.IOException"""
        super(_Writer, self).write(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def write(self, arg0: 'char', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.XmlWriter.write(char[],int,int) throws java.io.IOException"""
        super(_XmlWriter, self).write(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def write(self, arg0: int):
        """public void java.io.Writer.write(int) throws java.io.IOException"""
        super(_Writer, self).write(_int.valueOf(arg0))

    @overload
    def append(self, arg0: str) -> 'Writer':
        """public java.io.Writer java.io.Writer.append(char) throws java.io.IOException"""
        return 'Writer'._wrap(super(_Writer, self).append(_char.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.SortedIntList
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
import com.badlogic.gdx.utils.SortedIntList as _SortedIntList
_SortedIntList = _SortedIntList
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class SortedIntList():
    """com.badlogic.gdx.utils.SortedIntList"""
 
    @staticmethod
    def _wrap(java_value: _SortedIntList) -> 'SortedIntList':
        return SortedIntList(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SortedIntList):
        """
        Dynamic initializer for SortedIntList.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SortedIntList__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SortedIntList__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.SortedIntList()"""
        val = _SortedIntList()
        self.__wrapper = val

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.SortedIntList.notEmpty()"""
        return bool._wrap(super(SortedIntList, self).notEmpty())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.SortedIntList.isEmpty()"""
        return bool._wrap(super(SortedIntList, self).isEmpty())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.SortedIntList()"""
        val = _SortedIntList()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def size(self) -> int:
        """public int com.badlogic.gdx.utils.SortedIntList.size()"""
        return int._wrap(super(SortedIntList, self).size())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.SortedIntList.clear()"""
        super(SortedIntList, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.SortedIntList$Node<E>> com.badlogic.gdx.utils.SortedIntList.iterator()"""
        return 'Iterator'._wrap(super(SortedIntList, self).iterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def insert(self, arg0: int, arg1: object) -> object:
        """public E com.badlogic.gdx.utils.SortedIntList.insert(int,E)"""
        return object._wrap(super(_SortedIntList, self).insert(_int.valueOf(arg0), arg1))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def get(self, arg0: int) -> object:
        """public E com.badlogic.gdx.utils.SortedIntList.get(int)"""
        return object._wrap(super(_SortedIntList, self).get(_int.valueOf(arg0)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectIntMap
from builtins import str
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap_Values
_Values = _ObjectIntMap_Values.Values
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap
_ObjectIntMap = _ObjectIntMap
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap_Keys
_Keys = _ObjectIntMap_Keys.Keys
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import com.badlogic.gdx.utils.ObjectIntMap as _ObjectIntMap_Entries
_Entries = _ObjectIntMap_Entries.Entries
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ObjectIntMap():
    """com.badlogic.gdx.utils.ObjectIntMap"""
 
    @staticmethod
    def _wrap(java_value: _ObjectIntMap) -> 'ObjectIntMap':
        return ObjectIntMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ObjectIntMap):
        """
        Dynamic initializer for ObjectIntMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ObjectIntMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ObjectIntMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.ObjectIntMap(int)"""
        val = _ObjectIntMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectIntMap.isEmpty()"""
        return bool._wrap(super(ObjectIntMap, self).isEmpty())

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectIntMap$Keys<K> com.badlogic.gdx.utils.ObjectIntMap.keys()"""
        return 'Keys'._wrap(super(ObjectIntMap, self).keys())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, arg0: object, arg1: int, arg2: int) -> int:
        """public int com.badlogic.gdx.utils.ObjectIntMap.put(K,int,int)"""
        return int._wrap(super(_ObjectIntMap, self).put(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def put(self, arg0: object, arg1: int):
        """public void com.badlogic.gdx.utils.ObjectIntMap.put(K,int)"""
        super(_ObjectIntMap, self).put(arg0, _int.valueOf(arg1))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectIntMap.toString(java.lang.String)"""
        return str._wrap(super(_ObjectIntMap, self).toString(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectIntMap()"""
        val = _ObjectIntMap()
        self.__wrapper = val

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectIntMap$Values com.badlogic.gdx.utils.ObjectIntMap.values()"""
        return 'Values'._wrap(super(ObjectIntMap, self).values())

    @overload
    def findKey(self, arg0: int) -> object:
        """public K com.badlogic.gdx.utils.ObjectIntMap.findKey(int)"""
        return object._wrap(super(_ObjectIntMap, self).findKey(_int.valueOf(arg0)))

    @overload
    def containsValue(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectIntMap.containsValue(int)"""
        return bool._wrap(super(_ObjectIntMap, self).containsValue(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.ObjectIntMap(int,float)"""
        val = _ObjectIntMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectIntMap.ensureCapacity(int)"""
        super(_ObjectIntMap, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectIntMap.shrink(int)"""
        super(_ObjectIntMap, self).shrink(_int.valueOf(arg0))

    @overload
    def __init__(self, arg0: 'ObjectIntMap'):
        """public com.badlogic.gdx.utils.ObjectIntMap(com.badlogic.gdx.utils.ObjectIntMap<? extends K>)"""
        val = _ObjectIntMap(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ObjectIntMap.hashCode()"""
        return int._wrap(super(ObjectIntMap, self).hashCode())

    @overload
    def remove(self, arg0: object, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.ObjectIntMap.remove(K,int)"""
        return int._wrap(super(_ObjectIntMap, self).remove(arg0, _int.valueOf(arg1)))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ObjectIntMap.clear()"""
        super(ObjectIntMap, self).clear()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectIntMap()"""
        val = _ObjectIntMap()
        self.__wrapper = val

    @overload
    def get(self, arg0: object, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.ObjectIntMap.get(K,int)"""
        return int._wrap(super(_ObjectIntMap, self).get(arg0, _int.valueOf(arg1)))

    @overload
    def putAll(self, arg0: 'ObjectIntMap'):
        """public void com.badlogic.gdx.utils.ObjectIntMap.putAll(com.badlogic.gdx.utils.ObjectIntMap<? extends K>)"""
        super(_ObjectIntMap, self).putAll(arg0)

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectIntMap$Entries<K> com.badlogic.gdx.utils.ObjectIntMap.entries()"""
        return 'Entries'._wrap(super(ObjectIntMap, self).entries())

    @overload
    def getAndIncrement(self, arg0: object, arg1: int, arg2: int) -> int:
        """public int com.badlogic.gdx.utils.ObjectIntMap.getAndIncrement(K,int,int)"""
        return int._wrap(super(_ObjectIntMap, self).getAndIncrement(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectIntMap.toString()"""
        return str._wrap(super(ObjectIntMap, self).toString())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectIntMap.clear(int)"""
        super(_ObjectIntMap, self).clear(_int.valueOf(arg0))

    @overload
    def containsKey(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectIntMap.containsKey(K)"""
        return bool._wrap(super(_ObjectIntMap, self).containsKey(arg0))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectIntMap.notEmpty()"""
        return bool._wrap(super(ObjectIntMap, self).notEmpty())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectIntMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ObjectIntMap, self).equals(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectIntMap$Entries<K> com.badlogic.gdx.utils.ObjectIntMap.iterator()"""
        return 'Entries'._wrap(super(ObjectIntMap, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.IntMap$Entry
from builtins import str
import com.badlogic.gdx.utils.IntMap as _IntMap_Entry
_Entry = _IntMap_Entry.Entry
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entry():
    """com.badlogic.gdx.utils.IntMap.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IntMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IntMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntMap$Entry.toString()"""
        return str._wrap(super(Entry, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.StringBuilder
from builtins import str
import java.lang.Character as _char
import java.lang.CharSequence as CharSequence
import java.lang.Double as _double
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.CharSequence as _CharSequence
_CharSequence = _CharSequence
import java.lang.String as _String
_String = _String
import java.lang.Float as _float
import com.badlogic.gdx.utils.StringBuilder as _StringBuilder
_StringBuilder = _StringBuilder
import java.lang.String as _string
import java.util.stream.IntStream as _IntStream
_IntStream = _IntStream
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.util.stream.IntStream as IntStream
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StringBuilder():
    """com.badlogic.gdx.utils.StringBuilder"""
 
    @staticmethod
    def _wrap(java_value: _StringBuilder) -> 'StringBuilder':
        return StringBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StringBuilder):
        """
        Dynamic initializer for StringBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StringBuilder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StringBuilder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def append(self, arg0: 'StringBuilder') -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(com.badlogic.gdx.utils.StringBuilder)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0))

    @overload
    def substring(self, arg0: int) -> str:
        """public java.lang.String com.badlogic.gdx.utils.StringBuilder.substring(int)"""
        return str._wrap(super(_StringBuilder, self).substring(_int.valueOf(arg0)))

    @overload
    def insert(self, arg0: int, arg1: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def __init__(self, arg0: 'CharSequence'):
        """public com.badlogic.gdx.utils.StringBuilder(java.lang.CharSequence)"""
        val = _StringBuilder(arg0)
        self.__wrapper = val

    @overload
    def codePointCount(self, arg0: int, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.codePointCount(int,int)"""
        return int._wrap(super(_StringBuilder, self).codePointCount(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def insert(self, arg0: int, arg1: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,long)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), _long.valueOf(arg1)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.StringBuilder()"""
        val = _StringBuilder()
        self.__wrapper = val

    @overload
    def getChars(self, arg0: int, arg1: int, arg2: 'char', arg3: int):
        """public void com.badlogic.gdx.utils.StringBuilder.getChars(int,int,char[],int)"""
        super(_StringBuilder, self).getChars(_int.valueOf(arg0), _int.valueOf(arg1), arg2, _int.valueOf(arg3))

    @overload
    def append(self, arg0: float) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(float)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_float.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def append(self, arg0: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_int.valueOf(arg0)))

    @override
    @overload
    def codePoints(self) -> 'IntStream':
        """public default java.util.stream.IntStream java.lang.CharSequence.codePoints()"""
        return 'IntStream'._wrap(super(CharSequence, self).codePoints())

    @overload
    def indexOf(self, arg0: str, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.indexOf(java.lang.String,int)"""
        return int._wrap(super(_StringBuilder, self).indexOf(arg0, _int.valueOf(arg1)))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.StringBuilder.notEmpty()"""
        return bool._wrap(super(StringBuilder, self).notEmpty())

    @overload
    def append(self, arg0: int, arg1: int, arg2: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(int,int,char)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_int.valueOf(arg0), _int.valueOf(arg1), _char.valueOf(arg2)))

    @overload
    def insert(self, arg0: int, arg1: 'char', arg2: int, arg3: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,char[],int,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3)))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.StringBuilder.clear()"""
        super(StringBuilder, self).clear()

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.StringBuilder.ensureCapacity(int)"""
        super(_StringBuilder, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def lastIndexOf(self, arg0: str, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.lastIndexOf(java.lang.String,int)"""
        return int._wrap(super(_StringBuilder, self).lastIndexOf(arg0, _int.valueOf(arg1)))

    @overload
    def append(self, arg0: str, arg1: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(java.lang.String,java.lang.String)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0, arg1))

    @override
    @overload
    def chars(self) -> 'IntStream':
        """public default java.util.stream.IntStream java.lang.CharSequence.chars()"""
        return 'IntStream'._wrap(super(CharSequence, self).chars())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.StringBuilder(int)"""
        val = _StringBuilder(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.StringBuilder.isEmpty()"""
        return bool._wrap(super(StringBuilder, self).isEmpty())

    @overload
    def charAt(self, arg0: int) -> str:
        """public char com.badlogic.gdx.utils.StringBuilder.charAt(int)"""
        return str._wrap(super(_StringBuilder, self).charAt(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'StringBuilder'):
        """public com.badlogic.gdx.utils.StringBuilder(com.badlogic.gdx.utils.StringBuilder)"""
        val = _StringBuilder(arg0)
        self.__wrapper = val

    @overload
    def insert(self, arg0: int, arg1: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,char)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), _char.valueOf(arg1)))

    @overload
    def delete(self, arg0: int, arg1: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.delete(int,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).delete(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def equalsIgnoreCase(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.StringBuilder.equalsIgnoreCase(java.lang.String)"""
        return bool._wrap(super(_StringBuilder, self).equalsIgnoreCase(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def append(self, arg0: 'StringBuilder', arg1: int, arg2: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(com.badlogic.gdx.utils.StringBuilder,int,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def append(self, arg0: 'char') -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(char[])"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0))

    @overload
    def deleteCharAt(self, arg0: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.deleteCharAt(int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).deleteCharAt(_int.valueOf(arg0)))

    @overload
    def append(self, arg0: float) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(double)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_double.valueOf(arg0)))

    @overload
    def insert(self, arg0: int, arg1: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,java.lang.String)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), arg1))

    @overload
    def insert(self, arg0: int, arg1: 'CharSequence', arg2: int, arg3: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,java.lang.CharSequence,int,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3)))

    @overload
    def capacity(self) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.capacity()"""
        return int._wrap(super(StringBuilder, self).capacity())

    @overload
    def insert(self, arg0: int, arg1: 'char') -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,char[])"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), arg1))

    @overload
    def append(self, arg0: bool) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(boolean)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_boolean.valueOf(arg0)))

    @overload
    def equalsIgnoreCase(self, arg0: 'StringBuilder') -> bool:
        """public boolean com.badlogic.gdx.utils.StringBuilder.equalsIgnoreCase(com.badlogic.gdx.utils.StringBuilder)"""
        return bool._wrap(super(_StringBuilder, self).equalsIgnoreCase(arg0))

    @overload
    def insert(self, arg0: int, arg1: float) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,float)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), _float.valueOf(arg1)))

    @overload
    def subSequence(self, arg0: int, arg1: int) -> 'CharSequence':
        """public java.lang.CharSequence com.badlogic.gdx.utils.StringBuilder.subSequence(int,int)"""
        return 'CharSequence'._wrap(super(_StringBuilder, self).subSequence(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def indexOfIgnoreCase(self, arg0: str, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.indexOfIgnoreCase(java.lang.String,int)"""
        return int._wrap(super(_StringBuilder, self).indexOfIgnoreCase(arg0, _int.valueOf(arg1)))

    @overload
    def insert(self, arg0: int, arg1: float) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,double)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), _double.valueOf(arg1)))

    @overload
    def __init__(self, arg0: str):
        """public com.badlogic.gdx.utils.StringBuilder(java.lang.String)"""
        val = _StringBuilder(arg0)
        self.__wrapper = val

    @overload
    def replace(self, arg0: int, arg1: int, arg2: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.replace(int,int,java.lang.String)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).replace(_int.valueOf(arg0), _int.valueOf(arg1), arg2))

    @overload
    def append(self, arg0: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(char)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_char.valueOf(arg0)))

    @overload
    def offsetByCodePoints(self, arg0: int, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.offsetByCodePoints(int,int)"""
        return int._wrap(super(_StringBuilder, self).offsetByCodePoints(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def contains(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.StringBuilder.contains(java.lang.String)"""
        return bool._wrap(super(_StringBuilder, self).contains(arg0))

    @overload
    def append(self, arg0: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(long)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_long.valueOf(arg0)))

    @overload
    def appendLine(self, arg0: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.appendLine(java.lang.String)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).appendLine(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.StringBuilder.toString()"""
        return str._wrap(super(StringBuilder, self).toString())

    @overload
    def substring(self, arg0: int, arg1: int) -> str:
        """public java.lang.String com.badlogic.gdx.utils.StringBuilder.substring(int,int)"""
        return str._wrap(super(_StringBuilder, self).substring(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def replace(self, arg0: str, arg1: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.replace(java.lang.String,java.lang.String)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).replace(arg0, arg1))

    @overload
    def trimToSize(self):
        """public void com.badlogic.gdx.utils.StringBuilder.trimToSize()"""
        super(StringBuilder, self).trimToSize()

    @overload
    def append(self, arg0: 'CharSequence', arg1: int, arg2: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(java.lang.CharSequence,int,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def setCharAt(self, arg0: int, arg1: str):
        """public void com.badlogic.gdx.utils.StringBuilder.setCharAt(int,char)"""
        super(_StringBuilder, self).setCharAt(_int.valueOf(arg0), _char.valueOf(arg1))

    @overload
    def append(self, arg0: object) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(java.lang.Object)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.StringBuilder.equals(java.lang.Object)"""
        return bool._wrap(super(_StringBuilder, self).equals(arg0))

    @overload
    def toStringAndClear(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.StringBuilder.toStringAndClear()"""
        return str._wrap(super(StringBuilder, self).toStringAndClear())

    @overload
    def codePointBefore(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.codePointBefore(int)"""
        return int._wrap(super(_StringBuilder, self).codePointBefore(_int.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def append(self, arg0: int, arg1: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(int,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_int.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def reverse(self) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.reverse()"""
        return 'StringBuilder'._wrap(super(StringBuilder, self).reverse())

    @overload
    def lastIndexOf(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.lastIndexOf(java.lang.String)"""
        return int._wrap(super(_StringBuilder, self).lastIndexOf(arg0))

    @overload
    def setLength(self, arg0: int):
        """public void com.badlogic.gdx.utils.StringBuilder.setLength(int)"""
        super(_StringBuilder, self).setLength(_int.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.StringBuilder()"""
        val = _StringBuilder()
        self.__wrapper = val

    @overload
    def append(self, arg0: 'char', arg1: int, arg2: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(char[],int,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def append(self, arg0: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(java.lang.String)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0))

    @overload
    def insert(self, arg0: int, arg1: bool) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,boolean)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), _boolean.valueOf(arg1)))

    @overload
    def append(self, arg0: int, arg1: int, arg2: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(long,int,char)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_long.valueOf(arg0), _int.valueOf(arg1), _char.valueOf(arg2)))

    @overload
    def insert(self, arg0: int, arg1: object) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,java.lang.Object)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), arg1))

    @overload
    def replace(self, arg0: str, arg1: str) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.replace(char,java.lang.String)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).replace(_char.valueOf(arg0), arg1))

    @overload
    def indexOf(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.indexOf(java.lang.String)"""
        return int._wrap(super(_StringBuilder, self).indexOf(arg0))

    @overload
    def append(self, arg0: 'CharSequence') -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(java.lang.CharSequence)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(arg0))

    @overload
    def appendCodePoint(self, arg0: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.appendCodePoint(int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).appendCodePoint(_int.valueOf(arg0)))

    @override
    @overload
    def length(self) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.length()"""
        return int._wrap(super(StringBuilder, self).length())

    @overload
    def codePointAt(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.codePointAt(int)"""
        return int._wrap(super(_StringBuilder, self).codePointAt(_int.valueOf(arg0)))

    @staticmethod
    @overload
    def numChars(arg0: int, arg1: int) -> int:
        """public static int com.badlogic.gdx.utils.StringBuilder.numChars(long,int)"""
        return int._wrap(_StringBuilder.numChars(_long.valueOf(arg0), _int.valueOf(arg1)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def numChars(arg0: int, arg1: int) -> int:
        """public static int com.badlogic.gdx.utils.StringBuilder.numChars(int,int)"""
        return int._wrap(_StringBuilder.numChars(_int.valueOf(arg0), _int.valueOf(arg1)))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.StringBuilder.hashCode()"""
        return int._wrap(super(StringBuilder, self).hashCode())

    @overload
    def insert(self, arg0: int, arg1: 'CharSequence') -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.insert(int,java.lang.CharSequence)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).insert(_int.valueOf(arg0), arg1))

    @overload
    def containsIgnoreCase(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.StringBuilder.containsIgnoreCase(java.lang.String)"""
        return bool._wrap(super(_StringBuilder, self).containsIgnoreCase(arg0))

    @overload
    def append(self, arg0: int, arg1: int) -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.StringBuilder.append(long,int)"""
        return 'StringBuilder'._wrap(super(_StringBuilder, self).append(_long.valueOf(arg0), _int.valueOf(arg1))) 
 
 
# CLASS: com.badlogic.gdx.utils.ScreenUtils
from pyquantum_helper import import_once as _import_once
import com.badlogic.gdx.graphics.g2d.TextureRegion as _TextureRegion
_TextureRegion = _TextureRegion
from builtins import str
from pyquantum_helper import override
try:
    from pygdx.graphics import g2d
except ImportError:
    g2d = _import_once("pygdx.graphics.g2d")

import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ScreenUtils as _ScreenUtils
_ScreenUtils = _ScreenUtils
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.Float as _float
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import com.badlogic.gdx.graphics.Pixmap as _Pixmap
_Pixmap = _Pixmap
try:
    from pygdx import graphics
except ImportError:
    graphics = _import_once("pygdx.graphics")

from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ScreenUtils():
    """com.badlogic.gdx.utils.ScreenUtils"""
 
    @staticmethod
    def _wrap(java_value: _ScreenUtils) -> 'ScreenUtils':
        return ScreenUtils(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ScreenUtils):
        """
        Dynamic initializer for ScreenUtils.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ScreenUtils__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ScreenUtils__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def getFrameBufferTexture(arg0: int, arg1: int, arg2: int, arg3: int) -> 'g2d.TextureRegion':
        """public static com.badlogic.gdx.graphics.g2d.TextureRegion com.badlogic.gdx.utils.ScreenUtils.getFrameBufferTexture(int,int,int,int)"""
        return g2d.TextureRegion._wrap(_ScreenUtils.getFrameBufferTexture(_int.valueOf(arg0), _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3)))

    @staticmethod
    @overload
    def clear(arg0: 'Color', arg1: bool):
        """public static void com.badlogic.gdx.utils.ScreenUtils.clear(com.badlogic.gdx.graphics.Color,boolean)"""
        _ScreenUtils.clear(arg0, _boolean.valueOf(arg1))

    @staticmethod
    @overload
    def getFrameBufferPixels(arg0: bool) -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.ScreenUtils.getFrameBufferPixels(boolean)"""
        return List[int]._wrap(_ScreenUtils.getFrameBufferPixels(_boolean.valueOf(arg0)))

    @staticmethod
    @overload
    def getFrameBufferPixmap(arg0: int, arg1: int, arg2: int, arg3: int) -> 'graphics.Pixmap':
        """public static com.badlogic.gdx.graphics.Pixmap com.badlogic.gdx.utils.ScreenUtils.getFrameBufferPixmap(int,int,int,int)"""
        return graphics.Pixmap._wrap(_ScreenUtils.getFrameBufferPixmap(_int.valueOf(arg0), _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def clear(arg0: float, arg1: float, arg2: float, arg3: float, arg4: bool):
        """public static void com.badlogic.gdx.utils.ScreenUtils.clear(float,float,float,float,boolean)"""
        _ScreenUtils.clear(_float.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2), _float.valueOf(arg3), _boolean.valueOf(arg4))

    @staticmethod
    @overload
    def clear(arg0: 'Color'):
        """public static void com.badlogic.gdx.utils.ScreenUtils.clear(com.badlogic.gdx.graphics.Color)"""
        _ScreenUtils.clear(arg0)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def getFrameBufferTexture() -> 'g2d.TextureRegion':
        """public static com.badlogic.gdx.graphics.g2d.TextureRegion com.badlogic.gdx.utils.ScreenUtils.getFrameBufferTexture()"""
        return g2d.TextureRegion._wrap(_ScreenUtils.getFrameBufferTexture())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ScreenUtils()"""
        val = _ScreenUtils()
        self.__wrapper = val

    @staticmethod
    @overload
    def clear(arg0: float, arg1: float, arg2: float, arg3: float):
        """public static void com.badlogic.gdx.utils.ScreenUtils.clear(float,float,float,float)"""
        _ScreenUtils.clear(_float.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2), _float.valueOf(arg3))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ScreenUtils()"""
        val = _ScreenUtils()
        self.__wrapper = val

    @staticmethod
    @overload
    def getFrameBufferPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: bool) -> List[int]:
        """public static byte[] com.badlogic.gdx.utils.ScreenUtils.getFrameBufferPixels(int,int,int,int,boolean)"""
        return List[int]._wrap(_ScreenUtils.getFrameBufferPixels(_int.valueOf(arg0), _int.valueOf(arg1), _int.valueOf(arg2), _int.valueOf(arg3), _boolean.valueOf(arg4)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Timer
import com.badlogic.gdx.utils.Timer as _Timer
_Timer = _Timer
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Timer as _Timer_Task
_Task = _Timer_Task.Task
import java.lang.Float as _float
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Timer():
    """com.badlogic.gdx.utils.Timer"""
 
    @staticmethod
    def _wrap(java_value: _Timer) -> 'Timer':
        return Timer(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Timer):
        """
        Dynamic initializer for Timer.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Timer__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Timer__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def clear(self):
        """public synchronized void com.badlogic.gdx.utils.Timer.clear()"""
        super(Timer, self).clear()

    @overload
    def start(self):
        """public void com.badlogic.gdx.utils.Timer.start()"""
        super(Timer, self).start()

    @overload
    def stop(self):
        """public void com.badlogic.gdx.utils.Timer.stop()"""
        super(Timer, self).stop()

    @overload
    def postTask(self, arg0: 'Task') -> 'Task':
        """public com.badlogic.gdx.utils.Timer$Task com.badlogic.gdx.utils.Timer.postTask(com.badlogic.gdx.utils.Timer$Task)"""
        return 'Task'._wrap(super(_Timer, self).postTask(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def post(arg0: 'Task') -> 'Task':
        """public static com.badlogic.gdx.utils.Timer$Task com.badlogic.gdx.utils.Timer.post(com.badlogic.gdx.utils.Timer$Task)"""
        return Task._wrap(_Timer.post(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Timer()"""
        val = _Timer()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def scheduleTask(self, arg0: 'Task', arg1: float, arg2: float, arg3: int) -> 'Task':
        """public com.badlogic.gdx.utils.Timer$Task com.badlogic.gdx.utils.Timer.scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float,int)"""
        return 'Task'._wrap(super(_Timer, self).scheduleTask(arg0, _float.valueOf(arg1), _float.valueOf(arg2), _int.valueOf(arg3)))

    @staticmethod
    @overload
    def schedule(arg0: 'Task', arg1: float, arg2: float, arg3: int) -> 'Task':
        """public static com.badlogic.gdx.utils.Timer$Task com.badlogic.gdx.utils.Timer.schedule(com.badlogic.gdx.utils.Timer$Task,float,float,int)"""
        return Task._wrap(_Timer.schedule(arg0, _float.valueOf(arg1), _float.valueOf(arg2), _int.valueOf(arg3)))

    @staticmethod
    @overload
    def instance() -> 'Timer':
        """public static com.badlogic.gdx.utils.Timer com.badlogic.gdx.utils.Timer.instance()"""
        return Timer._wrap(_Timer.instance())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Timer()"""
        val = _Timer()
        self.__wrapper = val

    @overload
    def scheduleTask(self, arg0: 'Task', arg1: float, arg2: float) -> 'Task':
        """public com.badlogic.gdx.utils.Timer$Task com.badlogic.gdx.utils.Timer.scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float)"""
        return 'Task'._wrap(super(_Timer, self).scheduleTask(arg0, _float.valueOf(arg1), _float.valueOf(arg2)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def schedule(arg0: 'Task', arg1: float) -> 'Task':
        """public static com.badlogic.gdx.utils.Timer$Task com.badlogic.gdx.utils.Timer.schedule(com.badlogic.gdx.utils.Timer$Task,float)"""
        return Task._wrap(_Timer.schedule(arg0, _float.valueOf(arg1)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def isEmpty(self) -> bool:
        """public synchronized boolean com.badlogic.gdx.utils.Timer.isEmpty()"""
        return bool._wrap(super(Timer, self).isEmpty())

    @overload
    def delay(self, arg0: int):
        """public synchronized void com.badlogic.gdx.utils.Timer.delay(long)"""
        super(_Timer, self).delay(_long.valueOf(arg0))

    @staticmethod
    @overload
    def schedule(arg0: 'Task', arg1: float, arg2: float) -> 'Task':
        """public static com.badlogic.gdx.utils.Timer$Task com.badlogic.gdx.utils.Timer.schedule(com.badlogic.gdx.utils.Timer$Task,float,float)"""
        return Task._wrap(_Timer.schedule(arg0, _float.valueOf(arg1), _float.valueOf(arg2)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def scheduleTask(self, arg0: 'Task', arg1: float) -> 'Task':
        """public com.badlogic.gdx.utils.Timer$Task com.badlogic.gdx.utils.Timer.scheduleTask(com.badlogic.gdx.utils.Timer$Task,float)"""
        return 'Task'._wrap(super(_Timer, self).scheduleTask(arg0, _float.valueOf(arg1)))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.PooledLinkedList
from builtins import str
from pyquantum_helper import override
import com.badlogic.gdx.utils.PooledLinkedList as _PooledLinkedList
_PooledLinkedList = _PooledLinkedList
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import object
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class PooledLinkedList():
    """com.badlogic.gdx.utils.PooledLinkedList"""
 
    @staticmethod
    def _wrap(java_value: _PooledLinkedList) -> 'PooledLinkedList':
        return PooledLinkedList(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PooledLinkedList):
        """
        Dynamic initializer for PooledLinkedList.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PooledLinkedList__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PooledLinkedList__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.PooledLinkedList.clear()"""
        super(PooledLinkedList, self).clear()

    @overload
    def previous(self) -> object:
        """public T com.badlogic.gdx.utils.PooledLinkedList.previous()"""
        return object._wrap(super(PooledLinkedList, self).previous())

    @overload
    def next(self) -> object:
        """public T com.badlogic.gdx.utils.PooledLinkedList.next()"""
        return object._wrap(super(PooledLinkedList, self).next())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def size(self) -> int:
        """public int com.badlogic.gdx.utils.PooledLinkedList.size()"""
        return int._wrap(super(PooledLinkedList, self).size())

    @overload
    def add(self, arg0: object):
        """public void com.badlogic.gdx.utils.PooledLinkedList.add(T)"""
        super(_PooledLinkedList, self).add(arg0)

    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.PooledLinkedList.remove()"""
        super(PooledLinkedList, self).remove()

    @overload
    def iterReverse(self):
        """public void com.badlogic.gdx.utils.PooledLinkedList.iterReverse()"""
        super(PooledLinkedList, self).iterReverse()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.PooledLinkedList(int)"""
        val = _PooledLinkedList(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def addFirst(self, arg0: object):
        """public void com.badlogic.gdx.utils.PooledLinkedList.addFirst(T)"""
        super(_PooledLinkedList, self).addFirst(arg0)

    @overload
    def removeLast(self) -> object:
        """public T com.badlogic.gdx.utils.PooledLinkedList.removeLast()"""
        return object._wrap(super(PooledLinkedList, self).removeLast())

    @overload
    def iter(self):
        """public void com.badlogic.gdx.utils.PooledLinkedList.iter()"""
        super(PooledLinkedList, self).iter()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Predicate$PredicateIterator
import com.badlogic.gdx.utils.Predicate as _Predicate_PredicateIterator
_PredicateIterator = _Predicate_PredicateIterator.PredicateIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.lang.Integer as _int
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class PredicateIterator():
    """com.badlogic.gdx.utils.Predicate.PredicateIterator"""
 
    @staticmethod
    def _wrap(java_value: _PredicateIterator) -> 'PredicateIterator':
        return PredicateIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PredicateIterator):
        """
        Dynamic initializer for PredicateIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PredicateIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PredicateIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def next(self) -> object:
        """public T com.badlogic.gdx.utils.Predicate$PredicateIterator.next()"""
        return object._wrap(super(PredicateIterator, self).next())

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.Predicate$PredicateIterator.remove()"""
        super(PredicateIterator, self).remove()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def set(self, arg0: 'Iterator', arg1: 'Predicate'):
        """public void com.badlogic.gdx.utils.Predicate$PredicateIterator.set(java.util.Iterator<T>,com.badlogic.gdx.utils.Predicate<T>)"""
        super(_PredicateIterator, self).set(arg0, arg1)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'Iterator', arg1: 'Predicate'):
        """public com.badlogic.gdx.utils.Predicate$PredicateIterator(java.util.Iterator<T>,com.badlogic.gdx.utils.Predicate<T>)"""
        val = _PredicateIterator(arg0, arg1)
        self.__wrapper = val

    @overload
    def set(self, arg0: 'Iterable', arg1: 'Predicate'):
        """public void com.badlogic.gdx.utils.Predicate$PredicateIterator.set(java.lang.Iterable<T>,com.badlogic.gdx.utils.Predicate<T>)"""
        super(_PredicateIterator, self).set(arg0, arg1)

    @overload
    def __init__(self, arg0: 'Iterable', arg1: 'Predicate'):
        """public com.badlogic.gdx.utils.Predicate$PredicateIterator(java.lang.Iterable<T>,com.badlogic.gdx.utils.Predicate<T>)"""
        val = _PredicateIterator(arg0, arg1)
        self.__wrapper = val

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Predicate$PredicateIterator.hasNext()"""
        return bool._wrap(super(PredicateIterator, self).hasNext())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntFloatMap$Entry
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap_Entry
_Entry = _IntFloatMap_Entry.Entry
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entry():
    """com.badlogic.gdx.utils.IntFloatMap.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IntFloatMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntFloatMap$Entry.toString()"""
        return str._wrap(super(Entry, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IntFloatMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.FlushablePool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.FlushablePool as _FlushablePool
_FlushablePool = _FlushablePool
import com.badlogic.gdx.utils.Pool as _Pool
_Pool = _Pool
from builtins import object
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class FlushablePool():
    """com.badlogic.gdx.utils.FlushablePool"""
 
    @staticmethod
    def _wrap(java_value: _FlushablePool) -> 'FlushablePool':
        return FlushablePool(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _FlushablePool):
        """
        Dynamic initializer for FlushablePool.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_FlushablePool__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_FlushablePool__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def fill(self, arg0: int):
        """public void com.badlogic.gdx.utils.Pool.fill(int)"""
        super(_Pool, self).fill(_int.valueOf(arg0))

    @override
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.Pool.clear()"""
        super(Pool, self).clear()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: int, arg1: int):
        """public com.badlogic.gdx.utils.FlushablePool(int,int)"""
        val = _FlushablePool(_int.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def free(self, arg0: object):
        """public void com.badlogic.gdx.utils.FlushablePool.free(T)"""
        super(_FlushablePool, self).free(arg0)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.FlushablePool()"""
        val = _FlushablePool()
        self.__wrapper = val

    @overload
    def flush(self):
        """public void com.badlogic.gdx.utils.FlushablePool.flush()"""
        super(FlushablePool, self).flush()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.FlushablePool()"""
        val = _FlushablePool()
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.FlushablePool(int)"""
        val = _FlushablePool(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def freeAll(self, arg0: 'Array'):
        """public void com.badlogic.gdx.utils.FlushablePool.freeAll(com.badlogic.gdx.utils.Array<T>)"""
        super(_FlushablePool, self).freeAll(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def obtain(self) -> object:
        """public T com.badlogic.gdx.utils.FlushablePool.obtain()"""
        return object._wrap(super(FlushablePool, self).obtain())

    @override
    @overload
    def getFree(self) -> int:
        """public int com.badlogic.gdx.utils.Pool.getFree()"""
        return int._wrap(super(Pool, self).getFree())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Predicate
from abc import abstractmethod, ABC
import com.badlogic.gdx.utils.Predicate as _Predicate
_Predicate = _Predicate
 
class Predicate():
    """com.badlogic.gdx.utils.Predicate"""
 
    @staticmethod
    def _wrap(java_value: _Predicate) -> 'Predicate':
        return Predicate(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Predicate):
        """
        Dynamic initializer for Predicate.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Predicate__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Predicate__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def evaluate(self, arg0: object):
        """public abstract boolean com.badlogic.gdx.utils.Predicate.evaluate(T)"""
        pass 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectFloatMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap_Keys
_Keys = _ObjectFloatMap_Keys.Keys
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.ObjectFloatMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap$Keys.hasNext()"""
        return bool._wrap(super(Keys, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectFloatMap$Keys.toArray()"""
        return 'Array'._wrap(super(Keys, self).toArray())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectFloatMap$Keys.toArray(com.badlogic.gdx.utils.Array<K>)"""
        return 'Array'._wrap(super(_Keys, self).toArray(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: 'ObjectFloatMap'):
        """public com.badlogic.gdx.utils.ObjectFloatMap$Keys(com.badlogic.gdx.utils.ObjectFloatMap<K>)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.ObjectFloatMap$Keys.next()"""
        return object._wrap(super(Keys, self).next())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def iterator(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectFloatMap$Keys<K> com.badlogic.gdx.utils.ObjectFloatMap$Keys.iterator()"""
        return 'Keys'._wrap(super(Keys, self).iterator())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.IntMap as _IntMap
_IntMap = _IntMap
import com.badlogic.gdx.utils.IntMap as _IntMap_Values
_Values = _IntMap_Values.Values
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import com.badlogic.gdx.utils.IntMap as _IntMap_Entries
_Entries = _IntMap_Entries.Entries
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.IntMap as _IntMap_Keys
_Keys = _IntMap_Keys.Keys
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class IntMap():
    """com.badlogic.gdx.utils.IntMap"""
 
    @staticmethod
    def _wrap(java_value: _IntMap) -> 'IntMap':
        return IntMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _IntMap):
        """
        Dynamic initializer for IntMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_IntMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_IntMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def containsValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.IntMap.containsValue(java.lang.Object,boolean)"""
        return bool._wrap(super(_IntMap, self).containsValue(arg0, _boolean.valueOf(arg1)))

    @overload
    def get(self, arg0: int) -> object:
        """public V com.badlogic.gdx.utils.IntMap.get(int)"""
        return object._wrap(super(_IntMap, self).get(_int.valueOf(arg0)))

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntMap.clear(int)"""
        super(_IntMap, self).clear(_int.valueOf(arg0))

    @overload
    def put(self, arg0: int, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.IntMap.put(int,V)"""
        return object._wrap(super(_IntMap, self).put(_int.valueOf(arg0), arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def containsKey(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntMap.containsKey(int)"""
        return bool._wrap(super(_IntMap, self).containsKey(_int.valueOf(arg0)))

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.IntMap$Entries<V> com.badlogic.gdx.utils.IntMap.entries()"""
        return 'Entries'._wrap(super(IntMap, self).entries())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def get(self, arg0: int, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.IntMap.get(int,V)"""
        return object._wrap(super(_IntMap, self).get(_int.valueOf(arg0), arg1))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def putAll(self, arg0: 'IntMap'):
        """public void com.badlogic.gdx.utils.IntMap.putAll(com.badlogic.gdx.utils.IntMap<? extends V>)"""
        super(_IntMap, self).putAll(arg0)

    @overload
    def remove(self, arg0: int) -> object:
        """public V com.badlogic.gdx.utils.IntMap.remove(int)"""
        return object._wrap(super(_IntMap, self).remove(_int.valueOf(arg0)))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.IntMap.hashCode()"""
        return int._wrap(super(IntMap, self).hashCode())

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.IntMap(int,float)"""
        val = _IntMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IntMap()"""
        val = _IntMap()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.IntMap.equals(java.lang.Object)"""
        return bool._wrap(super(_IntMap, self).equals(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.IntMap(int)"""
        val = _IntMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def findKey(self, arg0: object, arg1: bool, arg2: int) -> int:
        """public int com.badlogic.gdx.utils.IntMap.findKey(java.lang.Object,boolean,int)"""
        return int._wrap(super(_IntMap, self).findKey(arg0, _boolean.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.IntMap.clear()"""
        super(IntMap, self).clear()

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.IntMap$Keys com.badlogic.gdx.utils.IntMap.keys()"""
        return 'Keys'._wrap(super(IntMap, self).keys())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntMap.isEmpty()"""
        return bool._wrap(super(IntMap, self).isEmpty())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.IntMap$Entry<V>> com.badlogic.gdx.utils.IntMap.iterator()"""
        return 'Iterator'._wrap(super(IntMap, self).iterator())

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntMap.notEmpty()"""
        return bool._wrap(super(IntMap, self).notEmpty())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntMap.toString()"""
        return str._wrap(super(IntMap, self).toString())

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.IntMap.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_IntMap, self).equalsIdentity(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IntMap()"""
        val = _IntMap()
        self.__wrapper = val

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntMap.ensureCapacity(int)"""
        super(_IntMap, self).ensureCapacity(_int.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.IntMap$Values<V> com.badlogic.gdx.utils.IntMap.values()"""
        return 'Values'._wrap(super(IntMap, self).values())

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntMap.shrink(int)"""
        super(_IntMap, self).shrink(_int.valueOf(arg0))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def __init__(self, arg0: 'IntMap'):
        """public com.badlogic.gdx.utils.IntMap(com.badlogic.gdx.utils.IntMap<? extends V>)"""
        val = _IntMap(arg0)
        self.__wrapper = val 
 
 
# CLASS: com.badlogic.gdx.utils.Clipboard
import com.badlogic.gdx.utils.Clipboard as _Clipboard
_Clipboard = _Clipboard
from abc import abstractmethod, ABC
 
class Clipboard():
    """com.badlogic.gdx.utils.Clipboard"""
 
    @staticmethod
    def _wrap(java_value: _Clipboard) -> 'Clipboard':
        return Clipboard(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Clipboard):
        """
        Dynamic initializer for Clipboard.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Clipboard__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Clipboard__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def hasContents(self, ):
        """public abstract boolean com.badlogic.gdx.utils.Clipboard.hasContents()"""
        pass

    @abstractmethod
    def getContents(self, ):
        """public abstract java.lang.String com.badlogic.gdx.utils.Clipboard.getContents()"""
        pass

    @abstractmethod
    def setContents(self, arg0: str):
        """public abstract void com.badlogic.gdx.utils.Clipboard.setContents(java.lang.String)"""
        pass 
 
 
# CLASS: com.badlogic.gdx.utils.ArrayMap$Entries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entry
_Entry = _ObjectMap_Entry.Entry
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.ArrayMap as _ArrayMap_Entries
_Entries = _ArrayMap_Entries.Entries
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.ArrayMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.ArrayMap$Entries.reset()"""
        super(Entries, self).reset()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.ObjectMap$Entry<K, V>> com.badlogic.gdx.utils.ArrayMap$Entries.iterator()"""
        return 'Iterator'._wrap(super(Entries, self).iterator())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.ObjectMap$Entry<K, V> com.badlogic.gdx.utils.ArrayMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.ArrayMap$Entries.remove()"""
        super(Entries, self).remove()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: 'ArrayMap'):
        """public com.badlogic.gdx.utils.ArrayMap$Entries(com.badlogic.gdx.utils.ArrayMap<K, V>)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectLongMap$Entry
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Entry
_Entry = _ObjectLongMap_Entry.Entry
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entry():
    """com.badlogic.gdx.utils.ObjectLongMap.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectLongMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectLongMap$Entry.toString()"""
        return str._wrap(super(Entry, self).toString())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectLongMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.BinaryHeap$Node
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import float
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.BinaryHeap as _BinaryHeap_Node
_Node = _BinaryHeap_Node.Node
import java.lang.Float as _float
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Node():
    """com.badlogic.gdx.utils.BinaryHeap.Node"""
 
    @staticmethod
    def _wrap(java_value: _Node) -> 'Node':
        return Node(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Node):
        """
        Dynamic initializer for Node.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Node__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Node__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.BinaryHeap$Node.toString()"""
        return str._wrap(super(Node, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: float):
        """public com.badlogic.gdx.utils.BinaryHeap$Node(float)"""
        val = _Node(_float.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def getValue(self) -> float:
        """public float com.badlogic.gdx.utils.BinaryHeap$Node.getValue()"""
        return float._wrap(super(Node, self).getValue())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ArrayMap$Values
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.ArrayMap as _ArrayMap_Values
_Values = _ArrayMap_Values.Values
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.ArrayMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.ArrayMap$Values.reset()"""
        super(Values, self).reset()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.ArrayMap$Values.remove()"""
        super(Values, self).remove()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def __init__(self, arg0: 'ArrayMap'):
        """public com.badlogic.gdx.utils.ArrayMap$Values(com.badlogic.gdx.utils.ArrayMap<java.lang.Object, V>)"""
        val = _Values(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def next(self) -> object:
        """public V com.badlogic.gdx.utils.ArrayMap$Values.next()"""
        return object._wrap(super(Values, self).next())

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<V> com.badlogic.gdx.utils.ArrayMap$Values.toArray()"""
        return 'Array'._wrap(super(Values, self).toArray())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ArrayMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<V> com.badlogic.gdx.utils.ArrayMap$Values.toArray(com.badlogic.gdx.utils.Array)"""
        return 'Array'._wrap(super(_Values, self).toArray(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<V> com.badlogic.gdx.utils.ArrayMap$Values.iterator()"""
        return 'Iterator'._wrap(super(Values, self).iterator())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.QuickSelect
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.lang.Integer as _int
import com.badlogic.gdx.utils.QuickSelect as _QuickSelect
_QuickSelect = _QuickSelect
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class QuickSelect():
    """com.badlogic.gdx.utils.QuickSelect"""
 
    @staticmethod
    def _wrap(java_value: _QuickSelect) -> 'QuickSelect':
        return QuickSelect(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _QuickSelect):
        """
        Dynamic initializer for QuickSelect.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_QuickSelect__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_QuickSelect__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def select(self, arg0: 'Object', arg1: 'Comparator', arg2: int, arg3: int) -> int:
        """public int com.badlogic.gdx.utils.QuickSelect.select(T[],java.util.Comparator<T>,int,int)"""
        return int._wrap(super(_QuickSelect, self).select(arg0, arg1, _int.valueOf(arg2), _int.valueOf(arg3)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.QuickSelect()"""
        val = _QuickSelect()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.QuickSelect()"""
        val = _QuickSelect()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.ObjectSet as _ObjectSet
_ObjectSet = _ObjectSet
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.lang.String as _string
import com.badlogic.gdx.utils.ObjectSet as _ObjectSet_ObjectSetIterator
_ObjectSetIterator = _ObjectSet_ObjectSetIterator.ObjectSetIterator
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ObjectSet():
    """com.badlogic.gdx.utils.ObjectSet"""
 
    @staticmethod
    def _wrap(java_value: _ObjectSet) -> 'ObjectSet':
        return ObjectSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ObjectSet):
        """
        Dynamic initializer for ObjectSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ObjectSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ObjectSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectSet.toString(java.lang.String)"""
        return str._wrap(super(_ObjectSet, self).toString(arg0))

    @overload
    def addAll(self, arg0: 'Array'):
        """public void com.badlogic.gdx.utils.ObjectSet.addAll(com.badlogic.gdx.utils.Array<? extends T>)"""
        super(_ObjectSet, self).addAll(arg0)

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectSet()"""
        val = _ObjectSet()
        self.__wrapper = val

    @override
    @overload
    def iterator(self) -> 'ObjectSetIterator':
        """public com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator<T> com.badlogic.gdx.utils.ObjectSet.iterator()"""
        return 'ObjectSetIterator'._wrap(super(ObjectSet, self).iterator())

    @overload
    def get(self, arg0: object) -> object:
        """public T com.badlogic.gdx.utils.ObjectSet.get(T)"""
        return object._wrap(super(_ObjectSet, self).get(arg0))

    @overload
    def __init__(self, arg0: 'ObjectSet'):
        """public com.badlogic.gdx.utils.ObjectSet(com.badlogic.gdx.utils.ObjectSet<? extends T>)"""
        val = _ObjectSet(arg0)
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def remove(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.remove(T)"""
        return bool._wrap(super(_ObjectSet, self).remove(arg0))

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectSet.ensureCapacity(int)"""
        super(_ObjectSet, self).ensureCapacity(_int.valueOf(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.ObjectSet(int,float)"""
        val = _ObjectSet(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def first(self) -> object:
        """public T com.badlogic.gdx.utils.ObjectSet.first()"""
        return object._wrap(super(ObjectSet, self).first())

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectSet.shrink(int)"""
        super(_ObjectSet, self).shrink(_int.valueOf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ObjectSet.hashCode()"""
        return int._wrap(super(ObjectSet, self).hashCode())

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.isEmpty()"""
        return bool._wrap(super(ObjectSet, self).isEmpty())

    @overload
    def contains(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.contains(T)"""
        return bool._wrap(super(_ObjectSet, self).contains(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectSet()"""
        val = _ObjectSet()
        self.__wrapper = val

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.notEmpty()"""
        return bool._wrap(super(ObjectSet, self).notEmpty())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.ObjectSet(int)"""
        val = _ObjectSet(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectSet.toString()"""
        return str._wrap(super(ObjectSet, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def with(*arg0: object) -> 'ObjectSet':
        """public static <T> com.badlogic.gdx.utils.ObjectSet<T> com.badlogic.gdx.utils.ObjectSet.with(T...)"""
        return ObjectSet._wrap(_ObjectSet.with(arg0))

    @overload
    def addAll(self, *arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.addAll(T...)"""
        return bool._wrap(super(_ObjectSet, self).addAll(arg0))

    @overload
    def addAll(self, arg0: 'Array', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ObjectSet.addAll(com.badlogic.gdx.utils.Array<? extends T>,int,int)"""
        super(_ObjectSet, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectSet.clear(int)"""
        super(_ObjectSet, self).clear(_int.valueOf(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ObjectSet, self).equals(arg0))

    @overload
    def addAll(self, arg0: 'Object', arg1: int, arg2: int) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.addAll(T[],int,int)"""
        return bool._wrap(super(_ObjectSet, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ObjectSet.clear()"""
        super(ObjectSet, self).clear()

    @overload
    def addAll(self, arg0: 'ObjectSet'):
        """public void com.badlogic.gdx.utils.ObjectSet.addAll(com.badlogic.gdx.utils.ObjectSet<T>)"""
        super(_ObjectSet, self).addAll(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.add(T)"""
        return bool._wrap(super(_ObjectSet, self).add(arg0))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.Timer$Task
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Timer as _Timer_Task
_Task = _Timer_Task.Task
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Task():
    """com.badlogic.gdx.utils.Timer.Task"""
 
    @staticmethod
    def _wrap(java_value: _Task) -> 'Task':
        return Task(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Task):
        """
        Dynamic initializer for Task.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Task__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Task__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def run(self, ):
        """public abstract void com.badlogic.gdx.utils.Timer$Task.run()"""
        pass

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Timer$Task()"""
        val = _Task()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getExecuteTimeMillis(self) -> int:
        """public synchronized long com.badlogic.gdx.utils.Timer$Task.getExecuteTimeMillis()"""
        return int._wrap(super(Task, self).getExecuteTimeMillis())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def cancel(self):
        """public void com.badlogic.gdx.utils.Timer$Task.cancel()"""
        super(Task, self).cancel()

    @overload
    def isScheduled(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Timer$Task.isScheduled()"""
        return bool._wrap(super(Task, self).isScheduled())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Timer$Task()"""
        val = _Task()
        self.__wrapper = val 
 
 
# CLASS: com.badlogic.gdx.utils.IntFloatMap
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap_Values
_Values = _IntFloatMap_Values.Values
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import float
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap
_IntFloatMap = _IntFloatMap
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.util.Spliterator as Spliterator
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap_Keys
_Keys = _IntFloatMap_Keys.Keys
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap_Entries
_Entries = _IntFloatMap_Entries.Entries
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class IntFloatMap():
    """com.badlogic.gdx.utils.IntFloatMap"""
 
    @staticmethod
    def _wrap(java_value: _IntFloatMap) -> 'IntFloatMap':
        return IntFloatMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _IntFloatMap):
        """
        Dynamic initializer for IntFloatMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_IntFloatMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_IntFloatMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def findKey(self, arg0: float, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.IntFloatMap.findKey(float,int)"""
        return int._wrap(super(_IntFloatMap, self).findKey(_float.valueOf(arg0), _int.valueOf(arg1)))

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntFloatMap.shrink(int)"""
        super(_IntFloatMap, self).shrink(_int.valueOf(arg0))

    @overload
    def __init__(self, arg0: 'IntFloatMap'):
        """public com.badlogic.gdx.utils.IntFloatMap(com.badlogic.gdx.utils.IntFloatMap)"""
        val = _IntFloatMap(arg0)
        self.__wrapper = val

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntFloatMap.clear(int)"""
        super(_IntFloatMap, self).clear(_int.valueOf(arg0))

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.IntFloatMap$Entries com.badlogic.gdx.utils.IntFloatMap.entries()"""
        return 'Entries'._wrap(super(IntFloatMap, self).entries())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def containsKey(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.IntFloatMap.containsKey(int)"""
        return bool._wrap(super(_IntFloatMap, self).containsKey(_int.valueOf(arg0)))

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.IntFloatMap.ensureCapacity(int)"""
        super(_IntFloatMap, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def getAndIncrement(self, arg0: int, arg1: float, arg2: float) -> float:
        """public float com.badlogic.gdx.utils.IntFloatMap.getAndIncrement(int,float,float)"""
        return float._wrap(super(_IntFloatMap, self).getAndIncrement(_int.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.IntFloatMap.clear()"""
        super(IntFloatMap, self).clear()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.IntFloatMap$Entry> com.badlogic.gdx.utils.IntFloatMap.iterator()"""
        return 'Iterator'._wrap(super(IntFloatMap, self).iterator())

    @overload
    def remove(self, arg0: int, arg1: float) -> float:
        """public float com.badlogic.gdx.utils.IntFloatMap.remove(int,float)"""
        return float._wrap(super(_IntFloatMap, self).remove(_int.valueOf(arg0), _float.valueOf(arg1)))

    @overload
    def containsValue(self, arg0: float) -> bool:
        """public boolean com.badlogic.gdx.utils.IntFloatMap.containsValue(float)"""
        return bool._wrap(super(_IntFloatMap, self).containsValue(_float.valueOf(arg0)))

    @overload
    def get(self, arg0: int, arg1: float) -> float:
        """public float com.badlogic.gdx.utils.IntFloatMap.get(int,float)"""
        return float._wrap(super(_IntFloatMap, self).get(_int.valueOf(arg0), _float.valueOf(arg1)))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.IntFloatMap.hashCode()"""
        return int._wrap(super(IntFloatMap, self).hashCode())

    @overload
    def containsValue(self, arg0: float, arg1: float) -> bool:
        """public boolean com.badlogic.gdx.utils.IntFloatMap.containsValue(float,float)"""
        return bool._wrap(super(_IntFloatMap, self).containsValue(_float.valueOf(arg0), _float.valueOf(arg1)))

    @overload
    def put(self, arg0: int, arg1: float):
        """public void com.badlogic.gdx.utils.IntFloatMap.put(int,float)"""
        super(_IntFloatMap, self).put(_int.valueOf(arg0), _float.valueOf(arg1))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.IntFloatMap.equals(java.lang.Object)"""
        return bool._wrap(super(_IntFloatMap, self).equals(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.IntFloatMap()"""
        val = _IntFloatMap()
        self.__wrapper = val

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.IntFloatMap(int)"""
        val = _IntFloatMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def findKey(self, arg0: float, arg1: float, arg2: int) -> int:
        """public int com.badlogic.gdx.utils.IntFloatMap.findKey(float,float,int)"""
        return int._wrap(super(_IntFloatMap, self).findKey(_float.valueOf(arg0), _float.valueOf(arg1), _int.valueOf(arg2)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.IntFloatMap()"""
        val = _IntFloatMap()
        self.__wrapper = val

    @overload
    def put(self, arg0: int, arg1: float, arg2: float) -> float:
        """public float com.badlogic.gdx.utils.IntFloatMap.put(int,float,float)"""
        return float._wrap(super(_IntFloatMap, self).put(_int.valueOf(arg0), _float.valueOf(arg1), _float.valueOf(arg2)))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntFloatMap.notEmpty()"""
        return bool._wrap(super(IntFloatMap, self).notEmpty())

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.IntFloatMap(int,float)"""
        val = _IntFloatMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.IntFloatMap.toString()"""
        return str._wrap(super(IntFloatMap, self).toString())

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.IntFloatMap$Keys com.badlogic.gdx.utils.IntFloatMap.keys()"""
        return 'Keys'._wrap(super(IntFloatMap, self).keys())

    @overload
    def putAll(self, arg0: 'IntFloatMap'):
        """public void com.badlogic.gdx.utils.IntFloatMap.putAll(com.badlogic.gdx.utils.IntFloatMap)"""
        super(_IntFloatMap, self).putAll(arg0)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.IntFloatMap$Values com.badlogic.gdx.utils.IntFloatMap.values()"""
        return 'Values'._wrap(super(IntFloatMap, self).values())

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntFloatMap.isEmpty()"""
        return bool._wrap(super(IntFloatMap, self).isEmpty())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.Logger
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.String as _string
import java.lang.Exception as Exception
import com.badlogic.gdx.utils.Logger as _Logger
_Logger = _Logger
import java.lang.Integer as _int
import java.lang.Throwable as Throwable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Logger():
    """com.badlogic.gdx.utils.Logger"""
 
    @staticmethod
    def _wrap(java_value: _Logger) -> 'Logger':
        return Logger(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Logger):
        """
        Dynamic initializer for Logger.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Logger__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Logger__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def debug(self, arg0: str):
        """public void com.badlogic.gdx.utils.Logger.debug(java.lang.String)"""
        super(_Logger, self).debug(arg0)

    @overload
    def __init__(self, arg0: str):
        """public com.badlogic.gdx.utils.Logger(java.lang.String)"""
        val = _Logger(arg0)
        self.__wrapper = val

    @overload
    def error(self, arg0: str, arg1: 'Throwable'):
        """public void com.badlogic.gdx.utils.Logger.error(java.lang.String,java.lang.Throwable)"""
        super(_Logger, self).error(arg0, arg1)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getLevel(self) -> int:
        """public int com.badlogic.gdx.utils.Logger.getLevel()"""
        return int._wrap(super(Logger, self).getLevel())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, arg0: str, arg1: int):
        """public com.badlogic.gdx.utils.Logger(java.lang.String,int)"""
        val = _Logger(arg0, _int.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def info(self, arg0: str, arg1: 'Exception'):
        """public void com.badlogic.gdx.utils.Logger.info(java.lang.String,java.lang.Exception)"""
        super(_Logger, self).info(arg0, arg1)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def error(self, arg0: str):
        """public void com.badlogic.gdx.utils.Logger.error(java.lang.String)"""
        super(_Logger, self).error(arg0)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def setLevel(self, arg0: int):
        """public void com.badlogic.gdx.utils.Logger.setLevel(int)"""
        super(_Logger, self).setLevel(_int.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def debug(self, arg0: str, arg1: 'Exception'):
        """public void com.badlogic.gdx.utils.Logger.debug(java.lang.String,java.lang.Exception)"""
        super(_Logger, self).debug(arg0, arg1)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def info(self, arg0: str):
        """public void com.badlogic.gdx.utils.Logger.info(java.lang.String)"""
        super(_Logger, self).info(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.DelayedRemovalArray
from builtins import str
import com.badlogic.gdx.utils.Array as _Array_ArrayIterator
_ArrayIterator = _Array_ArrayIterator.ArrayIterator
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
from typing import List
import java.util.function.Consumer as Consumer
import java.util.Comparator as Comparator
import java.lang.String as _string
import com.badlogic.gdx.utils.DelayedRemovalArray as _DelayedRemovalArray
_DelayedRemovalArray = _DelayedRemovalArray
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class DelayedRemovalArray():
    """com.badlogic.gdx.utils.DelayedRemovalArray"""
 
    @staticmethod
    def _wrap(java_value: _DelayedRemovalArray) -> 'DelayedRemovalArray':
        return DelayedRemovalArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _DelayedRemovalArray):
        """
        Dynamic initializer for DelayedRemovalArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_DelayedRemovalArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_DelayedRemovalArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def removeAll(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.removeAll(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_Array, self).removeAll(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.toArray()"""
        return List[object]._wrap(super(Array, self).toArray())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.DelayedRemovalArray(int)"""
        val = _DelayedRemovalArray(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def iterator(self) -> 'ArrayIterator':
        """public com.badlogic.gdx.utils.Array$ArrayIterator<T> com.badlogic.gdx.utils.Array.iterator()"""
        return 'ArrayIterator'._wrap(super(Array, self).iterator())

    @overload
    def begin(self):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.begin()"""
        super(DelayedRemovalArray, self).begin()

    @override
    @overload
    def shrink(self) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.shrink()"""
        return List[object]._wrap(super(Array, self).shrink())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def removeValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.DelayedRemovalArray.removeValue(T,boolean)"""
        return bool._wrap(super(_DelayedRemovalArray, self).removeValue(arg0, _boolean.valueOf(arg1)))

    @overload
    def selectRankedIndex(self, arg0: 'Comparator', arg1: int) -> int:
        """public int com.badlogic.gdx.utils.Array.selectRankedIndex(java.util.Comparator<T>,int)"""
        return int._wrap(super(_Array, self).selectRankedIndex(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def removeIndex(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.DelayedRemovalArray.removeIndex(int)"""
        return object._wrap(super(_DelayedRemovalArray, self).removeIndex(_int.valueOf(arg0)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def addAll(self, arg0: 'Array', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.Array.addAll(com.badlogic.gdx.utils.Array<? extends T>,int,int)"""
        super(_Array, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def containsAny(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.containsAny(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_Array, self).containsAny(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def insert(self, arg0: int, arg1: object):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.insert(int,T)"""
        super(_DelayedRemovalArray, self).insert(_int.valueOf(arg0), arg1)

    @override
    @overload
    def add(self, arg0: object):
        """public void com.badlogic.gdx.utils.Array.add(T)"""
        super(_Array, self).add(arg0)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Array.toString()"""
        return str._wrap(super(Array, self).toString())

    @overload
    def get(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.Array.get(int)"""
        return object._wrap(super(_Array, self).get(_int.valueOf(arg0)))

    @override
    @overload
    def addAll(self, arg0: 'Array'):
        """public void com.badlogic.gdx.utils.Array.addAll(com.badlogic.gdx.utils.Array<? extends T>)"""
        super(_Array, self).addAll(arg0)

    @override
    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.reverse()"""
        super(DelayedRemovalArray, self).reverse()

    @override
    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.notEmpty()"""
        return bool._wrap(super(Array, self).notEmpty())

    @override
    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.sort()"""
        super(DelayedRemovalArray, self).sort()

    @overload
    def __init__(self, arg0: 'Array'):
        """public com.badlogic.gdx.utils.DelayedRemovalArray(com.badlogic.gdx.utils.Array)"""
        val = _DelayedRemovalArray(arg0)
        self.__wrapper = val

    @override
    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.truncate(int)"""
        super(_DelayedRemovalArray, self).truncate(_int.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.DelayedRemovalArray()"""
        val = _DelayedRemovalArray()
        self.__wrapper = val

    @override
    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.insertRange(int,int)"""
        super(_DelayedRemovalArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.shuffle()"""
        super(DelayedRemovalArray, self).shuffle()

    @overload
    def __init__(self, arg0: 'Class'):
        """public com.badlogic.gdx.utils.DelayedRemovalArray(java.lang.Class)"""
        val = _DelayedRemovalArray(arg0)
        self.__wrapper = val

    @override
    @overload
    def addAll(self, *arg0: object):
        """public void com.badlogic.gdx.utils.Array.addAll(T...)"""
        super(_Array, self).addAll(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.Array.hashCode()"""
        return int._wrap(super(Array, self).hashCode())

    @override
    @overload
    def add(self, arg0: object, arg1: object, arg2: object, arg3: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T,T,T)"""
        super(_Array, self).add(arg0, arg1, arg2, arg3)

    @overload
    def setSize(self, arg0: int) -> List[object]:
        """public T[] com.badlogic.gdx.utils.DelayedRemovalArray.setSize(int)"""
        return List[object]._wrap(super(_DelayedRemovalArray, self).setSize(_int.valueOf(arg0)))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.isEmpty()"""
        return bool._wrap(super(Array, self).isEmpty())

    @overload
    def end(self):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.end()"""
        super(DelayedRemovalArray, self).end()

    @overload
    def toArray(self, arg0: 'Class') -> List[object]:
        """public <V> V[] com.badlogic.gdx.utils.Array.toArray(java.lang.Class<V>)"""
        return List[object]._wrap(super(_Array, self).toArray(arg0))

    @overload
    def lastIndexOf(self, arg0: object, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.Array.lastIndexOf(T,boolean)"""
        return int._wrap(super(_Array, self).lastIndexOf(arg0, _boolean.valueOf(arg1)))

    @staticmethod
    @overload
    def with(*arg0: object) -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.with(T...)"""
        return Array._wrap(_Array.with(arg0))

    @override
    @overload
    def first(self) -> object:
        """public T com.badlogic.gdx.utils.Array.first()"""
        return object._wrap(super(Array, self).first())

    @override
    @overload
    def random(self) -> object:
        """public T com.badlogic.gdx.utils.Array.random()"""
        return object._wrap(super(Array, self).random())

    @overload
    def select(self, arg0: 'Predicate') -> 'Iterable':
        """public java.lang.Iterable<T> com.badlogic.gdx.utils.Array.select(com.badlogic.gdx.utils.Predicate<T>)"""
        return 'Iterable'._wrap(super(_Array, self).select(arg0))

    @overload
    def selectRanked(self, arg0: 'Comparator', arg1: int) -> object:
        """public T com.badlogic.gdx.utils.Array.selectRanked(java.util.Comparator<T>,int)"""
        return object._wrap(super(_Array, self).selectRanked(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.swap(int,int)"""
        super(_DelayedRemovalArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def add(self, arg0: object, arg1: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T)"""
        super(_Array, self).add(arg0, arg1)

    @override
    @overload
    def set(self, arg0: int, arg1: object):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.set(int,T)"""
        super(_DelayedRemovalArray, self).set(_int.valueOf(arg0), arg1)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.equals(java.lang.Object)"""
        return bool._wrap(super(_Array, self).equals(arg0))

    @override
    @overload
    def sort(self, arg0: 'Comparator'):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.sort(java.util.Comparator<? super T>)"""
        super(_DelayedRemovalArray, self).sort(arg0)

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.DelayedRemovalArray()"""
        val = _DelayedRemovalArray()
        self.__wrapper = val

    @overload
    def __init__(self, arg0: bool, arg1: int, arg2: 'Class'):
        """public com.badlogic.gdx.utils.DelayedRemovalArray(boolean,int,java.lang.Class)"""
        val = _DelayedRemovalArray(_boolean.valueOf(arg0), _int.valueOf(arg1), arg2)
        self.__wrapper = val

    @overload
    def contains(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.contains(T,boolean)"""
        return bool._wrap(super(_Array, self).contains(arg0, _boolean.valueOf(arg1)))

    @staticmethod
    @overload
    def of(arg0: 'Class') -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.of(java.lang.Class<T>)"""
        return Array._wrap(_Array.of(arg0))

    @overload
    def indexOf(self, arg0: object, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.Array.indexOf(T,boolean)"""
        return int._wrap(super(_Array, self).indexOf(arg0, _boolean.valueOf(arg1)))

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_Array, self).equalsIdentity(arg0))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Array.toString(java.lang.String)"""
        return str._wrap(super(_Array, self).toString(arg0))

    @overload
    def __init__(self, arg0: 'Object'):
        """public com.badlogic.gdx.utils.DelayedRemovalArray(T[])"""
        val = _DelayedRemovalArray(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def pop(self) -> object:
        """public T com.badlogic.gdx.utils.DelayedRemovalArray.pop()"""
        return object._wrap(super(DelayedRemovalArray, self).pop())

    @overload
    def __init__(self, arg0: bool, arg1: 'Object', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.DelayedRemovalArray(boolean,T[],int,int)"""
        val = _DelayedRemovalArray(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @staticmethod
    @overload
    def with(*arg0: object) -> 'DelayedRemovalArray':
        """public static <T> com.badlogic.gdx.utils.DelayedRemovalArray<T> com.badlogic.gdx.utils.DelayedRemovalArray.with(T...)"""
        return DelayedRemovalArray._wrap(_DelayedRemovalArray.with(arg0))

    @overload
    def ensureCapacity(self, arg0: int) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.ensureCapacity(int)"""
        return List[object]._wrap(super(_Array, self).ensureCapacity(_int.valueOf(arg0)))

    @override
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.clear()"""
        super(DelayedRemovalArray, self).clear()

    @override
    @overload
    def addAll(self, arg0: 'Object', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.Array.addAll(T[],int,int)"""
        super(_Array, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.DelayedRemovalArray(boolean,int)"""
        val = _DelayedRemovalArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def add(self, arg0: object, arg1: object, arg2: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T,T)"""
        super(_Array, self).add(arg0, arg1, arg2)

    @staticmethod
    @overload
    def of(arg0: bool, arg1: int, arg2: 'Class') -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.of(boolean,int,java.lang.Class<T>)"""
        return Array._wrap(_Array.of(_boolean.valueOf(arg0), _int.valueOf(arg1), arg2))

    @overload
    def containsAll(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.containsAll(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_Array, self).containsAll(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def peek(self) -> object:
        """public T com.badlogic.gdx.utils.Array.peek()"""
        return object._wrap(super(Array, self).peek())

    @override
    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.DelayedRemovalArray.removeRange(int,int)"""
        super(_DelayedRemovalArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1)) 
 
 
# CLASS: com.badlogic.gdx.utils.ByteArray
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.String as _string
import com.badlogic.gdx.utils.ByteArray as _ByteArray
_ByteArray = _ByteArray
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Byte as _byte
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ByteArray():
    """com.badlogic.gdx.utils.ByteArray"""
 
    @staticmethod
    def _wrap(java_value: _ByteArray) -> 'ByteArray':
        return ByteArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ByteArray):
        """
        Dynamic initializer for ByteArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ByteArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ByteArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def contains(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.ByteArray.contains(byte)"""
        return bool._wrap(super(_ByteArray, self).contains(_byte.valueOf(arg0)))

    @overload
    def incr(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ByteArray.incr(int,byte)"""
        super(_ByteArray, self).incr(_int.valueOf(arg0), _byte.valueOf(arg1))

    @staticmethod
    @overload
    def with(*arg0: int) -> 'ByteArray':
        """public static com.badlogic.gdx.utils.ByteArray com.badlogic.gdx.utils.ByteArray.with(byte...)"""
        return ByteArray._wrap(_ByteArray.with(bytes))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ByteArray.insertRange(int,int)"""
        super(_ByteArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def random(self) -> int:
        """public byte com.badlogic.gdx.utils.ByteArray.random()"""
        return int._wrap(super(ByteArray, self).random())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def add(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ByteArray.add(byte,byte)"""
        super(_ByteArray, self).add(_byte.valueOf(arg0), _byte.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ByteArray()"""
        val = _ByteArray()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def insert(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ByteArray.insert(int,byte)"""
        super(_ByteArray, self).insert(_int.valueOf(arg0), _byte.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ByteArray()"""
        val = _ByteArray()
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ByteArray.hashCode()"""
        return int._wrap(super(ByteArray, self).hashCode())

    @overload
    def shrink(self) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.ByteArray.shrink()"""
        return List[int]._wrap(super(ByteArray, self).shrink())

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.ByteArray.shuffle()"""
        super(ByteArray, self).shuffle()

    @overload
    def toArray(self) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.ByteArray.toArray()"""
        return List[int]._wrap(super(ByteArray, self).toArray())

    @overload
    def removeIndex(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.ByteArray.removeIndex(int)"""
        return int._wrap(super(_ByteArray, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def indexOf(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.ByteArray.indexOf(byte)"""
        return int._wrap(super(_ByteArray, self).indexOf(_byte.valueOf(arg0)))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ByteArray.notEmpty()"""
        return bool._wrap(super(ByteArray, self).notEmpty())

    @overload
    def get(self, arg0: int) -> int:
        """public byte com.badlogic.gdx.utils.ByteArray.get(int)"""
        return int._wrap(super(_ByteArray, self).get(_int.valueOf(arg0)))

    @overload
    def add(self, arg0: int, arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ByteArray.add(byte,byte,byte)"""
        super(_ByteArray, self).add(_byte.valueOf(arg0), _byte.valueOf(arg1), _byte.valueOf(arg2))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ByteArray.toString(java.lang.String)"""
        return str._wrap(super(_ByteArray, self).toString(arg0))

    @overload
    def removeAll(self, arg0: 'ByteArray') -> bool:
        """public boolean com.badlogic.gdx.utils.ByteArray.removeAll(com.badlogic.gdx.utils.ByteArray)"""
        return bool._wrap(super(_ByteArray, self).removeAll(arg0))

    @overload
    def removeValue(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.ByteArray.removeValue(byte)"""
        return bool._wrap(super(_ByteArray, self).removeValue(_byte.valueOf(arg0)))

    @overload
    def addAll(self, *arg0: int):
        """public void com.badlogic.gdx.utils.ByteArray.addAll(byte...)"""
        super(_ByteArray, self).addAll(bytes)

    @overload
    def lastIndexOf(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.ByteArray.lastIndexOf(byte)"""
        return int._wrap(super(_ByteArray, self).lastIndexOf(_byte.valueOf(arg0)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ByteArray.toString()"""
        return str._wrap(super(ByteArray, self).toString())

    @overload
    def set(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ByteArray.set(int,byte)"""
        super(_ByteArray, self).set(_int.valueOf(arg0), _byte.valueOf(arg1))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.ByteArray(int)"""
        val = _ByteArray(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def mul(self, arg0: int):
        """public void com.badlogic.gdx.utils.ByteArray.mul(byte)"""
        super(_ByteArray, self).mul(_byte.valueOf(arg0))

    @overload
    def add(self, arg0: int):
        """public void com.badlogic.gdx.utils.ByteArray.add(byte)"""
        super(_ByteArray, self).add(_byte.valueOf(arg0))

    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.ByteArray.truncate(int)"""
        super(_ByteArray, self).truncate(_int.valueOf(arg0))

    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.ByteArray.sort()"""
        super(ByteArray, self).sort()

    @overload
    def addAll(self, arg0: bytes, arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ByteArray.addAll(byte[],int,int)"""
        super(_ByteArray, self).addAll(bytes, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def first(self) -> int:
        """public byte com.badlogic.gdx.utils.ByteArray.first()"""
        return int._wrap(super(ByteArray, self).first())

    @overload
    def __init__(self, arg0: bytes):
        """public com.badlogic.gdx.utils.ByteArray(byte[])"""
        val = _ByteArray(bytes)
        self.__wrapper = val

    @overload
    def incr(self, arg0: int):
        """public void com.badlogic.gdx.utils.ByteArray.incr(byte)"""
        super(_ByteArray, self).incr(_byte.valueOf(arg0))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ByteArray.clear()"""
        super(ByteArray, self).clear()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ByteArray.equals(java.lang.Object)"""
        return bool._wrap(super(_ByteArray, self).equals(arg0))

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.ByteArray.reverse()"""
        super(ByteArray, self).reverse()

    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ByteArray.swap(int,int)"""
        super(_ByteArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ByteArray.isEmpty()"""
        return bool._wrap(super(ByteArray, self).isEmpty())

    @overload
    def pop(self) -> int:
        """public byte com.badlogic.gdx.utils.ByteArray.pop()"""
        return int._wrap(super(ByteArray, self).pop())

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.ByteArray(boolean,int)"""
        val = _ByteArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @overload
    def setSize(self, arg0: int) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.ByteArray.setSize(int)"""
        return List[int]._wrap(super(_ByteArray, self).setSize(_int.valueOf(arg0)))

    @overload
    def addAll(self, arg0: 'ByteArray', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ByteArray.addAll(com.badlogic.gdx.utils.ByteArray,int,int)"""
        super(_ByteArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def mul(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ByteArray.mul(int,byte)"""
        super(_ByteArray, self).mul(_int.valueOf(arg0), _byte.valueOf(arg1))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: bool, arg1: bytes, arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.ByteArray(boolean,byte[],int,int)"""
        val = _ByteArray(_boolean.valueOf(arg0), bytes, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @overload
    def add(self, arg0: int, arg1: int, arg2: int, arg3: int):
        """public void com.badlogic.gdx.utils.ByteArray.add(byte,byte,byte,byte)"""
        super(_ByteArray, self).add(_byte.valueOf(arg0), _byte.valueOf(arg1), _byte.valueOf(arg2), _byte.valueOf(arg3))

    @overload
    def ensureCapacity(self, arg0: int) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.ByteArray.ensureCapacity(int)"""
        return List[int]._wrap(super(_ByteArray, self).ensureCapacity(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'ByteArray'):
        """public com.badlogic.gdx.utils.ByteArray(com.badlogic.gdx.utils.ByteArray)"""
        val = _ByteArray(arg0)
        self.__wrapper = val

    @overload
    def peek(self) -> int:
        """public byte com.badlogic.gdx.utils.ByteArray.peek()"""
        return int._wrap(super(ByteArray, self).peek())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.ByteArray.removeRange(int,int)"""
        super(_ByteArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def addAll(self, arg0: 'ByteArray'):
        """public void com.badlogic.gdx.utils.ByteArray.addAll(com.badlogic.gdx.utils.ByteArray)"""
        super(_ByteArray, self).addAll(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.Sort
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.Sort as _Sort
_Sort = _Sort
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Sort():
    """com.badlogic.gdx.utils.Sort"""
 
    @staticmethod
    def _wrap(java_value: _Sort) -> 'Sort':
        return Sort(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Sort):
        """
        Dynamic initializer for Sort.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Sort__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Sort__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def instance() -> 'Sort':
        """public static com.badlogic.gdx.utils.Sort com.badlogic.gdx.utils.Sort.instance()"""
        return Sort._wrap(_Sort.instance())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Sort()"""
        val = _Sort()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Sort()"""
        val = _Sort()
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def sort(self, arg0: 'Object', arg1: 'Comparator', arg2: int, arg3: int):
        """public <T> void com.badlogic.gdx.utils.Sort.sort(T[],java.util.Comparator<? super T>,int,int)"""
        super(_Sort, self).sort(arg0, arg1, _int.valueOf(arg2), _int.valueOf(arg3))

    @overload
    def sort(self, arg0: 'Array', arg1: 'Comparator'):
        """public <T> void com.badlogic.gdx.utils.Sort.sort(com.badlogic.gdx.utils.Array<T>,java.util.Comparator<? super T>)"""
        super(_Sort, self).sort(arg0, arg1)

    @overload
    def sort(self, arg0: 'Object'):
        """public void com.badlogic.gdx.utils.Sort.sort(java.lang.Object[])"""
        super(_Sort, self).sort(arg0)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def sort(self, arg0: 'Object', arg1: 'Comparator'):
        """public <T> void com.badlogic.gdx.utils.Sort.sort(T[],java.util.Comparator<? super T>)"""
        super(_Sort, self).sort(arg0, arg1)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def sort(self, arg0: 'Object', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.Sort.sort(java.lang.Object[],int,int)"""
        super(_Sort, self).sort(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def sort(self, arg0: 'Array'):
        """public <T extends java.lang.Comparable> void com.badlogic.gdx.utils.Sort.sort(com.badlogic.gdx.utils.Array<T>)"""
        super(_Sort, self).sort(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.AtomicQueue
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import object
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
import com.badlogic.gdx.utils.AtomicQueue as _AtomicQueue
_AtomicQueue = _AtomicQueue
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class AtomicQueue():
    """com.badlogic.gdx.utils.AtomicQueue"""
 
    @staticmethod
    def _wrap(java_value: _AtomicQueue) -> 'AtomicQueue':
        return AtomicQueue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _AtomicQueue):
        """
        Dynamic initializer for AtomicQueue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_AtomicQueue__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_AtomicQueue__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def poll(self) -> object:
        """public T com.badlogic.gdx.utils.AtomicQueue.poll()"""
        return object._wrap(super(AtomicQueue, self).poll())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def put(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.AtomicQueue.put(T)"""
        return bool._wrap(super(_AtomicQueue, self).put(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.AtomicQueue(int)"""
        val = _AtomicQueue(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectMap$Entries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entry
_Entry = _ObjectMap_Entry.Entry
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entries
_Entries = _ObjectMap_Entries.Entries
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.ObjectMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectMap$Entries<K, V> com.badlogic.gdx.utils.ObjectMap$Entries.iterator()"""
        return 'Entries'._wrap(super(Entries, self).iterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: 'ObjectMap'):
        """public com.badlogic.gdx.utils.ObjectMap$Entries(com.badlogic.gdx.utils.ObjectMap<K, V>)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.ObjectMap$Entry<K, V> com.badlogic.gdx.utils.ObjectMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Array$ArrayIterable
from builtins import str
import com.badlogic.gdx.utils.Array as _Array_ArrayIterator
_ArrayIterator = _Array_ArrayIterator.ArrayIterator
import com.badlogic.gdx.utils.Array as _Array_ArrayIterable
_ArrayIterable = _Array_ArrayIterable.ArrayIterable
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ArrayIterable():
    """com.badlogic.gdx.utils.Array.ArrayIterable"""
 
    @staticmethod
    def _wrap(java_value: _ArrayIterable) -> 'ArrayIterable':
        return ArrayIterable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ArrayIterable):
        """
        Dynamic initializer for ArrayIterable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ArrayIterable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ArrayIterable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def iterator(self) -> 'ArrayIterator':
        """public com.badlogic.gdx.utils.Array$ArrayIterator<T> com.badlogic.gdx.utils.Array$ArrayIterable.iterator()"""
        return 'ArrayIterator'._wrap(super(ArrayIterable, self).iterator())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: 'Array', arg1: bool):
        """public com.badlogic.gdx.utils.Array$ArrayIterable(com.badlogic.gdx.utils.Array<T>,boolean)"""
        val = _ArrayIterable(arg0, _boolean.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: 'Array'):
        """public com.badlogic.gdx.utils.Array$ArrayIterable(com.badlogic.gdx.utils.Array<T>)"""
        val = _ArrayIterable(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.OrderedMap$OrderedMapValues
from builtins import str
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Values
_Values = _ObjectMap_Values.Values
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import com.badlogic.gdx.utils.OrderedMap as _OrderedMap_OrderedMapValues
_OrderedMapValues = _OrderedMap_OrderedMapValues.OrderedMapValues
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class OrderedMapValues():
    """com.badlogic.gdx.utils.OrderedMap.OrderedMapValues"""
 
    @staticmethod
    def _wrap(java_value: _OrderedMapValues) -> 'OrderedMapValues':
        return OrderedMapValues(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _OrderedMapValues):
        """
        Dynamic initializer for OrderedMapValues.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_OrderedMapValues__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_OrderedMapValues__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<V> com.badlogic.gdx.utils.OrderedMap$OrderedMapValues.toArray()"""
        return 'Array'._wrap(super(OrderedMapValues, self).toArray())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.OrderedMap$OrderedMapValues.reset()"""
        super(OrderedMapValues, self).reset()

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def next(self) -> object:
        """public V com.badlogic.gdx.utils.OrderedMap$OrderedMapValues.next()"""
        return object._wrap(super(OrderedMapValues, self).next())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<V> com.badlogic.gdx.utils.OrderedMap$OrderedMapValues.toArray(com.badlogic.gdx.utils.Array<V>)"""
        return 'Array'._wrap(super(_OrderedMapValues, self).toArray(arg0))

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def iterator(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectMap$Values<V> com.badlogic.gdx.utils.ObjectMap$Values.iterator()"""
        return 'Values'._wrap(super(Values, self).iterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.OrderedMap$OrderedMapValues.remove()"""
        super(OrderedMapValues, self).remove()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def __init__(self, arg0: 'OrderedMap'):
        """public com.badlogic.gdx.utils.OrderedMap$OrderedMapValues(com.badlogic.gdx.utils.OrderedMap<?, V>)"""
        val = _OrderedMapValues(arg0)
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntMap$Entries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import com.badlogic.gdx.utils.IntMap as _IntMap_Entries
_Entries = _IntMap_Entries.Entries
import com.badlogic.gdx.utils.IntMap as _IntMap_Entry
_Entry = _IntMap_Entry.Entry
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.IntMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.IntMap$Entry<V>> com.badlogic.gdx.utils.IntMap$Entries.iterator()"""
        return 'Iterator'._wrap(super(Entries, self).iterator())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def __init__(self, arg0: 'IntMap'):
        """public com.badlogic.gdx.utils.IntMap$Entries(com.badlogic.gdx.utils.IntMap)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.IntMap$Entry<V> com.badlogic.gdx.utils.IntMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.XmlReader$Element
import com.badlogic.gdx.utils.XmlReader as _XmlReader_Element
_Element = _XmlReader_Element.Element
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap
_ObjectMap = _ObjectMap
from builtins import float
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.lang.Float as _float
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Element():
    """com.badlogic.gdx.utils.XmlReader.Element"""
 
    @staticmethod
    def _wrap(java_value: _Element) -> 'Element':
        return Element(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Element):
        """
        Dynamic initializer for Element.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Element__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Element__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def getFloat(self, arg0: str) -> float:
        """public float com.badlogic.gdx.utils.XmlReader$Element.getFloat(java.lang.String)"""
        return float._wrap(super(_Element, self).getFloat(arg0))

    @overload
    def getChildByName(self, arg0: str) -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader$Element.getChildByName(java.lang.String)"""
        return 'Element'._wrap(super(_Element, self).getChildByName(arg0))

    @overload
    def getText(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.XmlReader$Element.getText()"""
        return str._wrap(super(Element, self).getText())

    @overload
    def setText(self, arg0: str):
        """public void com.badlogic.gdx.utils.XmlReader$Element.setText(java.lang.String)"""
        super(_Element, self).setText(arg0)

    @overload
    def getInt(self, arg0: str, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.XmlReader$Element.getInt(java.lang.String,int)"""
        return int._wrap(super(_Element, self).getInt(arg0, _int.valueOf(arg1)))

    @overload
    def getAttributes(self) -> 'ObjectMap':
        """public com.badlogic.gdx.utils.ObjectMap<java.lang.String, java.lang.String> com.badlogic.gdx.utils.XmlReader$Element.getAttributes()"""
        return 'ObjectMap'._wrap(super(Element, self).getAttributes())

    @overload
    def getIntAttribute(self, arg0: str, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.XmlReader$Element.getIntAttribute(java.lang.String,int)"""
        return int._wrap(super(_Element, self).getIntAttribute(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.XmlReader$Element.toString()"""
        return str._wrap(super(Element, self).toString())

    @overload
    def getFloatAttribute(self, arg0: str) -> float:
        """public float com.badlogic.gdx.utils.XmlReader$Element.getFloatAttribute(java.lang.String)"""
        return float._wrap(super(_Element, self).getFloatAttribute(arg0))

    @overload
    def getIntAttribute(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.XmlReader$Element.getIntAttribute(java.lang.String)"""
        return int._wrap(super(_Element, self).getIntAttribute(arg0))

    @overload
    def getName(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.XmlReader$Element.getName()"""
        return str._wrap(super(Element, self).getName())

    @overload
    def getChildrenByNameRecursively(self, arg0: str) -> 'Array':
        """public com.badlogic.gdx.utils.Array<com.badlogic.gdx.utils.XmlReader$Element> com.badlogic.gdx.utils.XmlReader$Element.getChildrenByNameRecursively(java.lang.String)"""
        return 'Array'._wrap(super(_Element, self).getChildrenByNameRecursively(arg0))

    @overload
    def getBoolean(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.XmlReader$Element.getBoolean(java.lang.String)"""
        return bool._wrap(super(_Element, self).getBoolean(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def getChildByNameRecursive(self, arg0: str) -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader$Element.getChildByNameRecursive(java.lang.String)"""
        return 'Element'._wrap(super(_Element, self).getChildByNameRecursive(arg0))

    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.XmlReader$Element.remove()"""
        super(Element, self).remove()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def removeChild(self, arg0: int):
        """public void com.badlogic.gdx.utils.XmlReader$Element.removeChild(int)"""
        super(_Element, self).removeChild(_int.valueOf(arg0))

    @overload
    def setAttribute(self, arg0: str, arg1: str):
        """public void com.badlogic.gdx.utils.XmlReader$Element.setAttribute(java.lang.String,java.lang.String)"""
        super(_Element, self).setAttribute(arg0, arg1)

    @overload
    def getChildrenByName(self, arg0: str) -> 'Array':
        """public com.badlogic.gdx.utils.Array<com.badlogic.gdx.utils.XmlReader$Element> com.badlogic.gdx.utils.XmlReader$Element.getChildrenByName(java.lang.String)"""
        return 'Array'._wrap(super(_Element, self).getChildrenByName(arg0))

    @overload
    def getAttribute(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.XmlReader$Element.getAttribute(java.lang.String)"""
        return str._wrap(super(_Element, self).getAttribute(arg0))

    @overload
    def addChild(self, arg0: 'Element'):
        """public void com.badlogic.gdx.utils.XmlReader$Element.addChild(com.badlogic.gdx.utils.XmlReader$Element)"""
        super(_Element, self).addChild(arg0)

    @overload
    def get(self, arg0: str, arg1: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.XmlReader$Element.get(java.lang.String,java.lang.String)"""
        return str._wrap(super(_Element, self).get(arg0, arg1))

    @overload
    def hasChild(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.XmlReader$Element.hasChild(java.lang.String)"""
        return bool._wrap(super(_Element, self).hasChild(arg0))

    @overload
    def getBooleanAttribute(self, arg0: str, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.XmlReader$Element.getBooleanAttribute(java.lang.String,boolean)"""
        return bool._wrap(super(_Element, self).getBooleanAttribute(arg0, _boolean.valueOf(arg1)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @overload
    def removeChild(self, arg0: 'Element'):
        """public void com.badlogic.gdx.utils.XmlReader$Element.removeChild(com.badlogic.gdx.utils.XmlReader$Element)"""
        super(_Element, self).removeChild(arg0)

    @overload
    def hasAttribute(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.XmlReader$Element.hasAttribute(java.lang.String)"""
        return bool._wrap(super(_Element, self).hasAttribute(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getInt(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.XmlReader$Element.getInt(java.lang.String)"""
        return int._wrap(super(_Element, self).getInt(arg0))

    @overload
    def getFloat(self, arg0: str, arg1: float) -> float:
        """public float com.badlogic.gdx.utils.XmlReader$Element.getFloat(java.lang.String,float)"""
        return float._wrap(super(_Element, self).getFloat(arg0, _float.valueOf(arg1)))

    @overload
    def getBooleanAttribute(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.XmlReader$Element.getBooleanAttribute(java.lang.String)"""
        return bool._wrap(super(_Element, self).getBooleanAttribute(arg0))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.XmlReader$Element.toString(java.lang.String)"""
        return str._wrap(super(_Element, self).toString(arg0))

    @overload
    def getChild(self, arg0: int) -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader$Element.getChild(int)"""
        return 'Element'._wrap(super(_Element, self).getChild(_int.valueOf(arg0)))

    @overload
    def getBoolean(self, arg0: str, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.XmlReader$Element.getBoolean(java.lang.String,boolean)"""
        return bool._wrap(super(_Element, self).getBoolean(arg0, _boolean.valueOf(arg1)))

    @overload
    def getAttribute(self, arg0: str, arg1: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.XmlReader$Element.getAttribute(java.lang.String,java.lang.String)"""
        return str._wrap(super(_Element, self).getAttribute(arg0, arg1))

    @overload
    def hasChildRecursive(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.XmlReader$Element.hasChildRecursive(java.lang.String)"""
        return bool._wrap(super(_Element, self).hasChildRecursive(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def get(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.XmlReader$Element.get(java.lang.String)"""
        return str._wrap(super(_Element, self).get(arg0))

    @overload
    def getParent(self) -> 'Element':
        """public com.badlogic.gdx.utils.XmlReader$Element com.badlogic.gdx.utils.XmlReader$Element.getParent()"""
        return 'Element'._wrap(super(Element, self).getParent())

    @overload
    def getChildCount(self) -> int:
        """public int com.badlogic.gdx.utils.XmlReader$Element.getChildCount()"""
        return int._wrap(super(Element, self).getChildCount())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def getFloatAttribute(self, arg0: str, arg1: float) -> float:
        """public float com.badlogic.gdx.utils.XmlReader$Element.getFloatAttribute(java.lang.String,float)"""
        return float._wrap(super(_Element, self).getFloatAttribute(arg0, _float.valueOf(arg1)))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self, arg0: str, arg1: 'Element'):
        """public com.badlogic.gdx.utils.XmlReader$Element(java.lang.String,com.badlogic.gdx.utils.XmlReader$Element)"""
        val = _Element(arg0, arg1)
        self.__wrapper = val 
 
 
# CLASS: com.badlogic.gdx.utils.LongMap$Values
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import com.badlogic.gdx.utils.LongMap as _LongMap_Values
_Values = _LongMap_Values.Values
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.LongMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, arg0: 'LongMap'):
        """public com.badlogic.gdx.utils.LongMap$Values(com.badlogic.gdx.utils.LongMap<V>)"""
        val = _Values(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<V> com.badlogic.gdx.utils.LongMap$Values.toArray()"""
        return 'Array'._wrap(super(Values, self).toArray())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def next(self) -> object:
        """public V com.badlogic.gdx.utils.LongMap$Values.next()"""
        return object._wrap(super(Values, self).next())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.LongMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<V> com.badlogic.gdx.utils.LongMap$Values.iterator()"""
        return 'Iterator'._wrap(super(Values, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Predicate$PredicateIterable
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.Predicate as _Predicate_PredicateIterable
_PredicateIterable = _Predicate_PredicateIterable.PredicateIterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class PredicateIterable():
    """com.badlogic.gdx.utils.Predicate.PredicateIterable"""
 
    @staticmethod
    def _wrap(java_value: _PredicateIterable) -> 'PredicateIterable':
        return PredicateIterable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PredicateIterable):
        """
        Dynamic initializer for PredicateIterable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PredicateIterable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PredicateIterable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<T> com.badlogic.gdx.utils.Predicate$PredicateIterable.iterator()"""
        return 'Iterator'._wrap(super(PredicateIterable, self).iterator())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: 'Iterable', arg1: 'Predicate'):
        """public com.badlogic.gdx.utils.Predicate$PredicateIterable(java.lang.Iterable<T>,com.badlogic.gdx.utils.Predicate<T>)"""
        val = _PredicateIterable(arg0, arg1)
        self.__wrapper = val

    @overload
    def set(self, arg0: 'Iterable', arg1: 'Predicate'):
        """public void com.badlogic.gdx.utils.Predicate$PredicateIterable.set(java.lang.Iterable<T>,com.badlogic.gdx.utils.Predicate<T>)"""
        super(_PredicateIterable, self).set(arg0, arg1)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectFloatMap$Entry
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap_Entry
_Entry = _ObjectFloatMap_Entry.Entry
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entry():
    """com.badlogic.gdx.utils.ObjectFloatMap.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectFloatMap$Entry.toString()"""
        return str._wrap(super(Entry, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectFloatMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectFloatMap$Entry()"""
        val = _Entry()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import com.badlogic.gdx.utils.ObjectSet as _ObjectSet_ObjectSetIterator
_ObjectSetIterator = _ObjectSet_ObjectSetIterator.ObjectSetIterator
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ObjectSetIterator():
    """com.badlogic.gdx.utils.ObjectSet.ObjectSetIterator"""
 
    @staticmethod
    def _wrap(java_value: _ObjectSetIterator) -> 'ObjectSetIterator':
        return ObjectSetIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ObjectSetIterator):
        """
        Dynamic initializer for ObjectSetIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ObjectSetIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ObjectSetIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.toArray()"""
        return 'Array'._wrap(super(ObjectSetIterator, self).toArray())

    @override
    @overload
    def iterator(self) -> 'ObjectSetIterator':
        """public com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator<K> com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.iterator()"""
        return 'ObjectSetIterator'._wrap(super(ObjectSetIterator, self).iterator())

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.toArray(com.badlogic.gdx.utils.Array<K>)"""
        return 'Array'._wrap(super(_ObjectSetIterator, self).toArray(arg0))

    @overload
    def __init__(self, arg0: 'ObjectSet'):
        """public com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator(com.badlogic.gdx.utils.ObjectSet<K>)"""
        val = _ObjectSetIterator(arg0)
        self.__wrapper = val

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.remove()"""
        super(ObjectSetIterator, self).remove()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.hasNext()"""
        return bool._wrap(super(ObjectSetIterator, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.next()"""
        return object._wrap(super(ObjectSetIterator, self).next())

    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator.reset()"""
        super(ObjectSetIterator, self).reset()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Json$Serializable
from abc import abstractmethod, ABC
import com.badlogic.gdx.utils.Json as _Json_Serializable
_Serializable = _Json_Serializable.Serializable
 
class Serializable():
    """com.badlogic.gdx.utils.Json.Serializable"""
 
    @staticmethod
    def _wrap(java_value: _Serializable) -> 'Serializable':
        return Serializable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Serializable):
        """
        Dynamic initializer for Serializable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Serializable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Serializable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def read(self, arg0: 'Json', arg1: 'JsonValue'):
        """public abstract void com.badlogic.gdx.utils.Json$Serializable.read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue)"""
        pass

    @abstractmethod
    def write(self, arg0: 'Json'):
        """public abstract void com.badlogic.gdx.utils.Json$Serializable.write(com.badlogic.gdx.utils.Json)"""
        pass 
 
 
# CLASS: com.badlogic.gdx.utils.IntFloatMap$Keys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.IntArray as _IntArray
_IntArray = _IntArray
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap_Keys
_Keys = _IntFloatMap_Keys.Keys
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Keys():
    """com.badlogic.gdx.utils.IntFloatMap.Keys"""
 
    @staticmethod
    def _wrap(java_value: _Keys) -> 'Keys':
        return Keys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Keys):
        """
        Dynamic initializer for Keys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Keys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Keys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def next(self) -> int:
        """public int com.badlogic.gdx.utils.IntFloatMap$Keys.next()"""
        return int._wrap(super(Keys, self).next())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def toArray(self, arg0: 'IntArray') -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntFloatMap$Keys.toArray(com.badlogic.gdx.utils.IntArray)"""
        return 'IntArray'._wrap(super(_Keys, self).toArray(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'IntFloatMap'):
        """public com.badlogic.gdx.utils.IntFloatMap$Keys(com.badlogic.gdx.utils.IntFloatMap)"""
        val = _Keys(arg0)
        self.__wrapper = val

    @overload
    def toArray(self) -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntFloatMap$Keys.toArray()"""
        return 'IntArray'._wrap(super(Keys, self).toArray())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entry
_Entry = _ObjectMap_Entry.Entry
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entries
_Entries = _ObjectMap_Entries.Entries
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import com.badlogic.gdx.utils.OrderedMap as _OrderedMap_OrderedMapEntries
_OrderedMapEntries = _OrderedMap_OrderedMapEntries.OrderedMapEntries
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class OrderedMapEntries():
    """com.badlogic.gdx.utils.OrderedMap.OrderedMapEntries"""
 
    @staticmethod
    def _wrap(java_value: _OrderedMapEntries) -> 'OrderedMapEntries':
        return OrderedMapEntries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _OrderedMapEntries):
        """
        Dynamic initializer for OrderedMapEntries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_OrderedMapEntries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_OrderedMapEntries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.ObjectMap$Entry com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries.next()"""
        return 'Entry'._wrap(super(OrderedMapEntries, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries.remove()"""
        super(OrderedMapEntries, self).remove()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries.reset()"""
        super(OrderedMapEntries, self).reset()

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectMap$Entries<K, V> com.badlogic.gdx.utils.ObjectMap$Entries.iterator()"""
        return 'Entries'._wrap(super(Entries, self).iterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def __init__(self, arg0: 'OrderedMap'):
        """public com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries(com.badlogic.gdx.utils.OrderedMap<K, V>)"""
        val = _OrderedMapEntries(arg0)
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.NumberUtils
from builtins import str
import java.lang.Double as _double
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.badlogic.gdx.utils.NumberUtils as _NumberUtils
_NumberUtils = _NumberUtils
from builtins import float
import java.lang.String as _String
_String = _String
import java.lang.Float as _float
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class NumberUtils():
    """com.badlogic.gdx.utils.NumberUtils"""
 
    @staticmethod
    def _wrap(java_value: _NumberUtils) -> 'NumberUtils':
        return NumberUtils(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _NumberUtils):
        """
        Dynamic initializer for NumberUtils.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_NumberUtils__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_NumberUtils__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def doubleToLongBits(arg0: float) -> int:
        """public static long com.badlogic.gdx.utils.NumberUtils.doubleToLongBits(double)"""
        return int._wrap(_NumberUtils.doubleToLongBits(_double.valueOf(arg0)))

    @staticmethod
    @overload
    def floatToRawIntBits(arg0: float) -> int:
        """public static int com.badlogic.gdx.utils.NumberUtils.floatToRawIntBits(float)"""
        return int._wrap(_NumberUtils.floatToRawIntBits(_float.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.NumberUtils()"""
        val = _NumberUtils()
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def intToFloatColor(arg0: int) -> float:
        """public static float com.badlogic.gdx.utils.NumberUtils.intToFloatColor(int)"""
        return float._wrap(_NumberUtils.intToFloatColor(_int.valueOf(arg0)))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.NumberUtils()"""
        val = _NumberUtils()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def intBitsToFloat(arg0: int) -> float:
        """public static float com.badlogic.gdx.utils.NumberUtils.intBitsToFloat(int)"""
        return float._wrap(_NumberUtils.intBitsToFloat(_int.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def floatToIntBits(arg0: float) -> int:
        """public static int com.badlogic.gdx.utils.NumberUtils.floatToIntBits(float)"""
        return int._wrap(_NumberUtils.floatToIntBits(_float.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def longBitsToDouble(arg0: int) -> float:
        """public static double com.badlogic.gdx.utils.NumberUtils.longBitsToDouble(long)"""
        return float._wrap(_NumberUtils.longBitsToDouble(_long.valueOf(arg0)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def floatToIntColor(arg0: float) -> int:
        """public static int com.badlogic.gdx.utils.NumberUtils.floatToIntColor(float)"""
        return int._wrap(_NumberUtils.floatToIntColor(_float.valueOf(arg0)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.BooleanArray
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import com.badlogic.gdx.utils.BooleanArray as _BooleanArray
_BooleanArray = _BooleanArray
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class BooleanArray():
    """com.badlogic.gdx.utils.BooleanArray"""
 
    @staticmethod
    def _wrap(java_value: _BooleanArray) -> 'BooleanArray':
        return BooleanArray(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _BooleanArray):
        """
        Dynamic initializer for BooleanArray.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_BooleanArray__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_BooleanArray__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def first(self) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.first()"""
        return bool._wrap(super(BooleanArray, self).first())

    @overload
    def insert(self, arg0: int, arg1: bool):
        """public void com.badlogic.gdx.utils.BooleanArray.insert(int,boolean)"""
        super(_BooleanArray, self).insert(_int.valueOf(arg0), _boolean.valueOf(arg1))

    @overload
    def removeAll(self, arg0: 'BooleanArray') -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.removeAll(com.badlogic.gdx.utils.BooleanArray)"""
        return bool._wrap(super(_BooleanArray, self).removeAll(arg0))

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.BooleanArray.shuffle()"""
        super(BooleanArray, self).shuffle()

    @overload
    def add(self, arg0: bool):
        """public void com.badlogic.gdx.utils.BooleanArray.add(boolean)"""
        super(_BooleanArray, self).add(_boolean.valueOf(arg0))

    @overload
    def get(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.get(int)"""
        return bool._wrap(super(_BooleanArray, self).get(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: bool, arg1: 'boolean', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.BooleanArray(boolean,boolean[],int,int)"""
        val = _BooleanArray(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.equals(java.lang.Object)"""
        return bool._wrap(super(_BooleanArray, self).equals(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.BooleanArray.toString(java.lang.String)"""
        return str._wrap(super(_BooleanArray, self).toString(arg0))

    @overload
    def addAll(self, arg0: 'BooleanArray', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.BooleanArray.addAll(com.badlogic.gdx.utils.BooleanArray,int,int)"""
        super(_BooleanArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def set(self, arg0: int, arg1: bool):
        """public void com.badlogic.gdx.utils.BooleanArray.set(int,boolean)"""
        super(_BooleanArray, self).set(_int.valueOf(arg0), _boolean.valueOf(arg1))

    @overload
    def random(self) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.random()"""
        return bool._wrap(super(BooleanArray, self).random())

    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.BooleanArray.insertRange(int,int)"""
        super(_BooleanArray, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def add(self, arg0: bool, arg1: bool, arg2: bool, arg3: bool):
        """public void com.badlogic.gdx.utils.BooleanArray.add(boolean,boolean,boolean,boolean)"""
        super(_BooleanArray, self).add(_boolean.valueOf(arg0), _boolean.valueOf(arg1), _boolean.valueOf(arg2), _boolean.valueOf(arg3))

    @overload
    def pop(self) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.pop()"""
        return bool._wrap(super(BooleanArray, self).pop())

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.notEmpty()"""
        return bool._wrap(super(BooleanArray, self).notEmpty())

    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.BooleanArray.removeRange(int,int)"""
        super(_BooleanArray, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.BooleanArray(boolean,int)"""
        val = _BooleanArray(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.BooleanArray.hashCode()"""
        return int._wrap(super(BooleanArray, self).hashCode())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.BooleanArray.truncate(int)"""
        super(_BooleanArray, self).truncate(_int.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.BooleanArray.toString()"""
        return str._wrap(super(BooleanArray, self).toString())

    @overload
    def addAll(self, *arg0: bool):
        """public void com.badlogic.gdx.utils.BooleanArray.addAll(boolean...)"""
        super(_BooleanArray, self).addAll(arg0)

    @overload
    def ensureCapacity(self, arg0: int) -> List[bool]:
        """public boolean[] com.badlogic.gdx.utils.BooleanArray.ensureCapacity(int)"""
        return List[bool]._wrap(super(_BooleanArray, self).ensureCapacity(_int.valueOf(arg0)))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.BooleanArray()"""
        val = _BooleanArray()
        self.__wrapper = val

    @overload
    def addAll(self, arg0: 'boolean', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.BooleanArray.addAll(boolean[],int,int)"""
        super(_BooleanArray, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def setSize(self, arg0: int) -> List[bool]:
        """public boolean[] com.badlogic.gdx.utils.BooleanArray.setSize(int)"""
        return List[bool]._wrap(super(_BooleanArray, self).setSize(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'BooleanArray'):
        """public com.badlogic.gdx.utils.BooleanArray(com.badlogic.gdx.utils.BooleanArray)"""
        val = _BooleanArray(arg0)
        self.__wrapper = val

    @overload
    def toArray(self) -> List[bool]:
        """public boolean[] com.badlogic.gdx.utils.BooleanArray.toArray()"""
        return List[bool]._wrap(super(BooleanArray, self).toArray())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.BooleanArray()"""
        val = _BooleanArray()
        self.__wrapper = val

    @staticmethod
    @overload
    def with(*arg0: bool) -> 'BooleanArray':
        """public static com.badlogic.gdx.utils.BooleanArray com.badlogic.gdx.utils.BooleanArray.with(boolean...)"""
        return BooleanArray._wrap(_BooleanArray.with(arg0))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.BooleanArray.clear()"""
        super(BooleanArray, self).clear()

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.isEmpty()"""
        return bool._wrap(super(BooleanArray, self).isEmpty())

    @overload
    def add(self, arg0: bool, arg1: bool):
        """public void com.badlogic.gdx.utils.BooleanArray.add(boolean,boolean)"""
        super(_BooleanArray, self).add(_boolean.valueOf(arg0), _boolean.valueOf(arg1))

    @overload
    def shrink(self) -> List[bool]:
        """public boolean[] com.badlogic.gdx.utils.BooleanArray.shrink()"""
        return List[bool]._wrap(super(BooleanArray, self).shrink())

    @overload
    def __init__(self, arg0: 'boolean'):
        """public com.badlogic.gdx.utils.BooleanArray(boolean[])"""
        val = _BooleanArray(arg0)
        self.__wrapper = val

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.BooleanArray.reverse()"""
        super(BooleanArray, self).reverse()

    @overload
    def addAll(self, arg0: 'BooleanArray'):
        """public void com.badlogic.gdx.utils.BooleanArray.addAll(com.badlogic.gdx.utils.BooleanArray)"""
        super(_BooleanArray, self).addAll(arg0)

    @overload
    def add(self, arg0: bool, arg1: bool, arg2: bool):
        """public void com.badlogic.gdx.utils.BooleanArray.add(boolean,boolean,boolean)"""
        super(_BooleanArray, self).add(_boolean.valueOf(arg0), _boolean.valueOf(arg1), _boolean.valueOf(arg2))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.BooleanArray(int)"""
        val = _BooleanArray(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def peek(self) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.peek()"""
        return bool._wrap(super(BooleanArray, self).peek())

    @overload
    def removeIndex(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.BooleanArray.removeIndex(int)"""
        return bool._wrap(super(_BooleanArray, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.BooleanArray.swap(int,int)"""
        super(_BooleanArray, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.badlogic.gdx.utils.SerializationException
from builtins import str
import java.lang.StackTraceElement as _StackTraceElement
_StackTraceElement = _StackTraceElement
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import com.badlogic.gdx.utils.SerializationException as _SerializationException
_SerializationException = _SerializationException
import java.io.PrintWriter as PrintWriter
import java.lang.String as _String
_String = _String
import java.lang.StackTraceElement as StackTraceElement
from typing import List
import java.lang.String as _string
import java.io.PrintStream as PrintStream
import java.lang.Integer as _int
import java.lang.Throwable as _Throwable
_Throwable = _Throwable
import java.lang.Throwable as Throwable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class SerializationException():
    """com.badlogic.gdx.utils.SerializationException"""
 
    @staticmethod
    def _wrap(java_value: _SerializationException) -> 'SerializationException':
        return SerializationException(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SerializationException):
        """
        Dynamic initializer for SerializationException.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SerializationException__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SerializationException__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getLocalizedMessage(self) -> str:
        """public java.lang.String java.lang.Throwable.getLocalizedMessage()"""
        return str._wrap(super(Throwable, self).getLocalizedMessage())

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.SerializationException()"""
        val = _SerializationException()
        self.__wrapper = val

    @override
    @overload
    def getCause(self) -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.getCause()"""
        return 'Throwable'._wrap(super(Throwable, self).getCause())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def printStackTrace(self, arg0: 'PrintWriter'):
        """public void java.lang.Throwable.printStackTrace(java.io.PrintWriter)"""
        super(_Throwable, self).printStackTrace(arg0)

    @override
    @overload
    def fillInStackTrace(self) -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.fillInStackTrace()"""
        return 'Throwable'._wrap(super(Throwable, self).fillInStackTrace())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.SerializationException()"""
        val = _SerializationException()
        self.__wrapper = val

    @override
    @overload
    def printStackTrace(self):
        """public void java.lang.Throwable.printStackTrace()"""
        super(Throwable, self).printStackTrace()

    @override
    @overload
    def getSuppressed(self) -> List['Throwable']:
        """public final synchronized java.lang.Throwable[] java.lang.Throwable.getSuppressed()"""
        return List['Throwable']._wrap(super(Throwable, self).getSuppressed())

    @override
    @overload
    def printStackTrace(self, arg0: 'PrintStream'):
        """public void java.lang.Throwable.printStackTrace(java.io.PrintStream)"""
        super(_Throwable, self).printStackTrace(arg0)

    @overload
    def initCause(self, arg0: 'Throwable') -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.initCause(java.lang.Throwable)"""
        return 'Throwable'._wrap(super(_Throwable, self).initCause(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getMessage(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.SerializationException.getMessage()"""
        return str._wrap(super(SerializationException, self).getMessage())

    @overload
    def causedBy(self, arg0: 'Class') -> bool:
        """public boolean com.badlogic.gdx.utils.SerializationException.causedBy(java.lang.Class)"""
        return bool._wrap(super(_SerializationException, self).causedBy(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Throwable.toString()"""
        return str._wrap(super(Throwable, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def addTrace(self, arg0: str):
        """public void com.badlogic.gdx.utils.SerializationException.addTrace(java.lang.String)"""
        super(_SerializationException, self).addTrace(arg0)

    @overload
    def __init__(self, arg0: 'Throwable'):
        """public com.badlogic.gdx.utils.SerializationException(java.lang.Throwable)"""
        val = _SerializationException(arg0)
        self.__wrapper = val

    @override
    @overload
    def getStackTrace(self) -> List['StackTraceElement']:
        """public java.lang.StackTraceElement[] java.lang.Throwable.getStackTrace()"""
        return List['StackTraceElement']._wrap(super(Throwable, self).getStackTrace())

    @override
    @overload
    def addSuppressed(self, arg0: 'Throwable'):
        """public final synchronized void java.lang.Throwable.addSuppressed(java.lang.Throwable)"""
        super(_Throwable, self).addSuppressed(arg0)

    @overload
    def __init__(self, arg0: str, arg1: 'Throwable'):
        """public com.badlogic.gdx.utils.SerializationException(java.lang.String,java.lang.Throwable)"""
        val = _SerializationException(arg0, arg1)
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def setStackTrace(self, arg0: 'StackTraceElement'):
        """public void java.lang.Throwable.setStackTrace(java.lang.StackTraceElement[])"""
        super(_Throwable, self).setStackTrace(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: str):
        """public com.badlogic.gdx.utils.SerializationException(java.lang.String)"""
        val = _SerializationException(arg0)
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream
from builtins import str
from pyquantum_helper import override
import java.nio.charset.Charset as Charset
import java.io.OutputStream as _OutputStream
_OutputStream = _OutputStream
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.String as _string
import java.lang.Integer as _int
import java.io.OutputStream as OutputStream
import java.io.ByteArrayOutputStream as _ByteArrayOutputStream
_ByteArrayOutputStream = _ByteArrayOutputStream
import com.badlogic.gdx.utils.StreamUtils as _StreamUtils_OptimizedByteArrayOutputStream
_OptimizedByteArrayOutputStream = _StreamUtils_OptimizedByteArrayOutputStream.OptimizedByteArrayOutputStream
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class OptimizedByteArrayOutputStream():
    """com.badlogic.gdx.utils.StreamUtils.OptimizedByteArrayOutputStream"""
 
    @staticmethod
    def _wrap(java_value: _OptimizedByteArrayOutputStream) -> 'OptimizedByteArrayOutputStream':
        return OptimizedByteArrayOutputStream(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _OptimizedByteArrayOutputStream):
        """
        Dynamic initializer for OptimizedByteArrayOutputStream.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_OptimizedByteArrayOutputStream__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_OptimizedByteArrayOutputStream__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def toString(self, arg0: str) -> str:
        """public synchronized java.lang.String java.io.ByteArrayOutputStream.toString(java.lang.String) throws java.io.UnsupportedEncodingException"""
        return str._wrap(super(_ByteArrayOutputStream, self).toString(arg0))

    @override
    @overload
    def reset(self):
        """public synchronized void java.io.ByteArrayOutputStream.reset()"""
        super(ByteArrayOutputStream, self).reset()

    @override
    @overload
    def toByteArray(self) -> List[int]:
        """public synchronized byte[] com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream.toByteArray()"""
        return List[int]._wrap(super(OptimizedByteArrayOutputStream, self).toByteArray())

    @override
    @overload
    def writeBytes(self, arg0: bytes):
        """public void java.io.ByteArrayOutputStream.writeBytes(byte[])"""
        super(_ByteArrayOutputStream, self).writeBytes(bytes)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public synchronized java.lang.String java.io.ByteArrayOutputStream.toString()"""
        return str._wrap(super(ByteArrayOutputStream, self).toString())

    @overload
    def getBuffer(self) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream.getBuffer()"""
        return List[int]._wrap(super(OptimizedByteArrayOutputStream, self).getBuffer())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def close(self):
        """public void java.io.ByteArrayOutputStream.close() throws java.io.IOException"""
        super(ByteArrayOutputStream, self).close()

    @override
    @overload
    def size(self) -> int:
        """public synchronized int java.io.ByteArrayOutputStream.size()"""
        return int._wrap(super(ByteArrayOutputStream, self).size())

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream(int)"""
        val = _OptimizedByteArrayOutputStream(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def writeTo(self, arg0: 'OutputStream'):
        """public synchronized void java.io.ByteArrayOutputStream.writeTo(java.io.OutputStream) throws java.io.IOException"""
        super(_ByteArrayOutputStream, self).writeTo(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def flush(self):
        """public void java.io.OutputStream.flush() throws java.io.IOException"""
        super(OutputStream, self).flush()

    @staticmethod
    @overload
    def nullOutputStream() -> 'OutputStream':
        """public static java.io.OutputStream java.io.OutputStream.nullOutputStream()"""
        return OutputStream._wrap(_OutputStream.nullOutputStream())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def write(self, arg0: int):
        """public synchronized void java.io.ByteArrayOutputStream.write(int)"""
        super(_ByteArrayOutputStream, self).write(_int.valueOf(arg0))

    @override
    @overload
    def write(self, arg0: bytes, arg1: int, arg2: int):
        """public synchronized void java.io.ByteArrayOutputStream.write(byte[],int,int)"""
        super(_ByteArrayOutputStream, self).write(bytes, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def toString(self, arg0: int) -> str:
        """public synchronized java.lang.String java.io.ByteArrayOutputStream.toString(int)"""
        return str._wrap(super(_ByteArrayOutputStream, self).toString(_int.valueOf(arg0)))

    @override
    @overload
    def write(self, arg0: bytes):
        """public void java.io.OutputStream.write(byte[]) throws java.io.IOException"""
        super(_OutputStream, self).write(bytes)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def toString(self, arg0: 'Charset') -> str:
        """public synchronized java.lang.String java.io.ByteArrayOutputStream.toString(java.nio.charset.Charset)"""
        return str._wrap(super(_ByteArrayOutputStream, self).toString(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectLongMap$Entries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Entries
_Entries = _ObjectLongMap_Entries.Entries
from builtins import bool
import java.lang.Long as _long
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Entry
_Entry = _ObjectLongMap_Entry.Entry
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.ObjectLongMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectLongMap$Entries<K> com.badlogic.gdx.utils.ObjectLongMap$Entries.iterator()"""
        return 'Entries'._wrap(super(Entries, self).iterator())

    @overload
    def __init__(self, arg0: 'ObjectLongMap'):
        """public com.badlogic.gdx.utils.ObjectLongMap$Entries(com.badlogic.gdx.utils.ObjectLongMap<K>)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.ObjectLongMap$Entry<K> com.badlogic.gdx.utils.ObjectLongMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.GdxRuntimeException
from builtins import str
import java.lang.StackTraceElement as _StackTraceElement
_StackTraceElement = _StackTraceElement
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.io.PrintWriter as PrintWriter
import java.lang.String as _String
_String = _String
import java.lang.StackTraceElement as StackTraceElement
from typing import List
import java.lang.String as _string
import java.io.PrintStream as PrintStream
import java.lang.Integer as _int
import com.badlogic.gdx.utils.GdxRuntimeException as _GdxRuntimeException
_GdxRuntimeException = _GdxRuntimeException
import java.lang.Throwable as _Throwable
_Throwable = _Throwable
import java.lang.Throwable as Throwable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class GdxRuntimeException():
    """com.badlogic.gdx.utils.GdxRuntimeException"""
 
    @staticmethod
    def _wrap(java_value: _GdxRuntimeException) -> 'GdxRuntimeException':
        return GdxRuntimeException(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _GdxRuntimeException):
        """
        Dynamic initializer for GdxRuntimeException.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_GdxRuntimeException__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_GdxRuntimeException__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getLocalizedMessage(self) -> str:
        """public java.lang.String java.lang.Throwable.getLocalizedMessage()"""
        return str._wrap(super(Throwable, self).getLocalizedMessage())

    @overload
    def __init__(self, arg0: str, arg1: 'Throwable'):
        """public com.badlogic.gdx.utils.GdxRuntimeException(java.lang.String,java.lang.Throwable)"""
        val = _GdxRuntimeException(arg0, arg1)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def getCause(self) -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.getCause()"""
        return 'Throwable'._wrap(super(Throwable, self).getCause())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def printStackTrace(self, arg0: 'PrintWriter'):
        """public void java.lang.Throwable.printStackTrace(java.io.PrintWriter)"""
        super(_Throwable, self).printStackTrace(arg0)

    @override
    @overload
    def fillInStackTrace(self) -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.fillInStackTrace()"""
        return 'Throwable'._wrap(super(Throwable, self).fillInStackTrace())

    @override
    @overload
    def printStackTrace(self):
        """public void java.lang.Throwable.printStackTrace()"""
        super(Throwable, self).printStackTrace()

    @override
    @overload
    def getSuppressed(self) -> List['Throwable']:
        """public final synchronized java.lang.Throwable[] java.lang.Throwable.getSuppressed()"""
        return List['Throwable']._wrap(super(Throwable, self).getSuppressed())

    @override
    @overload
    def getMessage(self) -> str:
        """public java.lang.String java.lang.Throwable.getMessage()"""
        return str._wrap(super(Throwable, self).getMessage())

    @override
    @overload
    def printStackTrace(self, arg0: 'PrintStream'):
        """public void java.lang.Throwable.printStackTrace(java.io.PrintStream)"""
        super(_Throwable, self).printStackTrace(arg0)

    @overload
    def initCause(self, arg0: 'Throwable') -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.initCause(java.lang.Throwable)"""
        return 'Throwable'._wrap(super(_Throwable, self).initCause(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def getStackTrace(self) -> List['StackTraceElement']:
        """public java.lang.StackTraceElement[] java.lang.Throwable.getStackTrace()"""
        return List['StackTraceElement']._wrap(super(Throwable, self).getStackTrace())

    @override
    @overload
    def addSuppressed(self, arg0: 'Throwable'):
        """public final synchronized void java.lang.Throwable.addSuppressed(java.lang.Throwable)"""
        super(_Throwable, self).addSuppressed(arg0)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: str):
        """public com.badlogic.gdx.utils.GdxRuntimeException(java.lang.String)"""
        val = _GdxRuntimeException(arg0)
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, arg0: 'Throwable'):
        """public com.badlogic.gdx.utils.GdxRuntimeException(java.lang.Throwable)"""
        val = _GdxRuntimeException(arg0)
        self.__wrapper = val

    @override
    @overload
    def setStackTrace(self, arg0: 'StackTraceElement'):
        """public void java.lang.Throwable.setStackTrace(java.lang.StackTraceElement[])"""
        super(_Throwable, self).setStackTrace(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Throwable.toString()"""
        return str._wrap(super(Throwable, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.PerformanceCounters
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.Float as _float
import com.badlogic.gdx.utils.StringBuilder as _StringBuilder
_StringBuilder = _StringBuilder
import java.lang.String as _string
import com.badlogic.gdx.utils.PerformanceCounters as _PerformanceCounters
_PerformanceCounters = _PerformanceCounters
import com.badlogic.gdx.utils.PerformanceCounter as _PerformanceCounter
_PerformanceCounter = _PerformanceCounter
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class PerformanceCounters():
    """com.badlogic.gdx.utils.PerformanceCounters"""
 
    @staticmethod
    def _wrap(java_value: _PerformanceCounters) -> 'PerformanceCounters':
        return PerformanceCounters(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PerformanceCounters):
        """
        Dynamic initializer for PerformanceCounters.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PerformanceCounters__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PerformanceCounters__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.PerformanceCounters()"""
        val = _PerformanceCounters()
        self.__wrapper = val

    @overload
    def tick(self, arg0: float):
        """public void com.badlogic.gdx.utils.PerformanceCounters.tick(float)"""
        super(_PerformanceCounters, self).tick(_float.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.PerformanceCounters()"""
        val = _PerformanceCounters()
        self.__wrapper = val

    @overload
    def toString(self, arg0: 'StringBuilder') -> 'StringBuilder':
        """public com.badlogic.gdx.utils.StringBuilder com.badlogic.gdx.utils.PerformanceCounters.toString(com.badlogic.gdx.utils.StringBuilder)"""
        return 'StringBuilder'._wrap(super(_PerformanceCounters, self).toString(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def tick(self):
        """public void com.badlogic.gdx.utils.PerformanceCounters.tick()"""
        super(PerformanceCounters, self).tick()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def add(self, arg0: str, arg1: int) -> 'PerformanceCounter':
        """public com.badlogic.gdx.utils.PerformanceCounter com.badlogic.gdx.utils.PerformanceCounters.add(java.lang.String,int)"""
        return 'PerformanceCounter'._wrap(super(_PerformanceCounters, self).add(arg0, _int.valueOf(arg1)))

    @overload
    def add(self, arg0: str) -> 'PerformanceCounter':
        """public com.badlogic.gdx.utils.PerformanceCounter com.badlogic.gdx.utils.PerformanceCounters.add(java.lang.String)"""
        return 'PerformanceCounter'._wrap(super(_PerformanceCounters, self).add(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.TimeUtils
from builtins import str
import com.badlogic.gdx.utils.TimeUtils as _TimeUtils
_TimeUtils = _TimeUtils
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class TimeUtils():
    """com.badlogic.gdx.utils.TimeUtils"""
 
    @staticmethod
    def _wrap(java_value: _TimeUtils) -> 'TimeUtils':
        return TimeUtils(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _TimeUtils):
        """
        Dynamic initializer for TimeUtils.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_TimeUtils__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_TimeUtils__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def nanosToMillis(arg0: int) -> int:
        """public static long com.badlogic.gdx.utils.TimeUtils.nanosToMillis(long)"""
        return int._wrap(_TimeUtils.nanosToMillis(_long.valueOf(arg0)))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.TimeUtils()"""
        val = _TimeUtils()
        self.__wrapper = val

    @staticmethod
    @overload
    def millisToNanos(arg0: int) -> int:
        """public static long com.badlogic.gdx.utils.TimeUtils.millisToNanos(long)"""
        return int._wrap(_TimeUtils.millisToNanos(_long.valueOf(arg0)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.TimeUtils()"""
        val = _TimeUtils()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def timeSinceNanos(arg0: int) -> int:
        """public static long com.badlogic.gdx.utils.TimeUtils.timeSinceNanos(long)"""
        return int._wrap(_TimeUtils.timeSinceNanos(_long.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def timeSinceMillis(arg0: int) -> int:
        """public static long com.badlogic.gdx.utils.TimeUtils.timeSinceMillis(long)"""
        return int._wrap(_TimeUtils.timeSinceMillis(_long.valueOf(arg0)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def millis() -> int:
        """public static long com.badlogic.gdx.utils.TimeUtils.millis()"""
        return int._wrap(_TimeUtils.millis())

    @staticmethod
    @overload
    def nanoTime() -> int:
        """public static long com.badlogic.gdx.utils.TimeUtils.nanoTime()"""
        return int._wrap(_TimeUtils.nanoTime())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Null
from abc import abstractmethod, ABC
import com.badlogic.gdx.utils.Null as _Null
_Null = _Null
import java.lang.annotation.Annotation as _Annotation
_Annotation = _Annotation
 
class Null():
    """com.badlogic.gdx.utils.Null"""
 
    @staticmethod
    def _wrap(java_value: _Null) -> 'Null':
        return Null(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Null):
        """
        Dynamic initializer for Null.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Null__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Null__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def equals(self, arg0: object):
        """public abstract boolean java.lang.annotation.Annotation.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String java.lang.annotation.Annotation.toString()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int java.lang.annotation.Annotation.hashCode()"""
        pass

    @abstractmethod
    def annotationType(self, ):
        """public abstract java.lang.Class<? extends java.lang.annotation.Annotation> java.lang.annotation.Annotation.annotationType()"""
        pass 
 
 
# CLASS: com.badlogic.gdx.utils.JsonValue
import com.badlogic.gdx.utils.JsonValue as _JsonValue_JsonIterator
_JsonIterator = _JsonValue_JsonIterator.JsonIterator
import java.lang.Character as _char
import java.lang.Double as _double
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Short as _short
import java.util.function.Consumer as Consumer
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Byte as _byte
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
from builtins import float
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.Float as _float
import com.badlogic.gdx.utils.JsonValue as _JsonValue_ValueType
_ValueType = _JsonValue_ValueType.ValueType
import com.badlogic.gdx.utils.JsonValue as _JsonValue
_JsonValue = _JsonValue
import java.lang.Integer as _int
import java.io.Writer as Writer
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class JsonValue():
    """com.badlogic.gdx.utils.JsonValue"""
 
    @staticmethod
    def _wrap(java_value: _JsonValue) -> 'JsonValue':
        return JsonValue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _JsonValue):
        """
        Dynamic initializer for JsonValue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_JsonValue__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_JsonValue__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def getBoolean(self, arg0: str, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.getBoolean(java.lang.String,boolean)"""
        return bool._wrap(super(_JsonValue, self).getBoolean(arg0, _boolean.valueOf(arg1)))

    @overload
    def isLong(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isLong()"""
        return bool._wrap(super(JsonValue, self).isLong())

    @overload
    def getBoolean(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.getBoolean(java.lang.String)"""
        return bool._wrap(super(_JsonValue, self).getBoolean(arg0))

    @overload
    def next(self) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.next()"""
        return 'JsonValue'._wrap(super(JsonValue, self).next())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def addChild(self, arg0: str, arg1: 'JsonValue'):
        """public void com.badlogic.gdx.utils.JsonValue.addChild(java.lang.String,com.badlogic.gdx.utils.JsonValue)"""
        super(_JsonValue, self).addChild(arg0, arg1)

    @overload
    def isObject(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isObject()"""
        return bool._wrap(super(JsonValue, self).isObject())

    @overload
    def getByte(self, arg0: str, arg1: int) -> int:
        """public byte com.badlogic.gdx.utils.JsonValue.getByte(java.lang.String,byte)"""
        return int._wrap(super(_JsonValue, self).getByte(arg0, _byte.valueOf(arg1)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.toString()"""
        return str._wrap(super(JsonValue, self).toString())

    @overload
    def getShort(self, arg0: int) -> int:
        """public short com.badlogic.gdx.utils.JsonValue.getShort(int)"""
        return int._wrap(super(_JsonValue, self).getShort(_int.valueOf(arg0)))

    @overload
    def getString(self, arg0: int) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.getString(int)"""
        return str._wrap(super(_JsonValue, self).getString(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'ValueType'):
        """public com.badlogic.gdx.utils.JsonValue(com.badlogic.gdx.utils.JsonValue$ValueType)"""
        val = _JsonValue(arg0)
        self.__wrapper = val

    @overload
    def getLong(self, arg0: str, arg1: int) -> int:
        """public long com.badlogic.gdx.utils.JsonValue.getLong(java.lang.String,long)"""
        return int._wrap(super(_JsonValue, self).getLong(arg0, _long.valueOf(arg1)))

    @overload
    def isValue(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isValue()"""
        return bool._wrap(super(JsonValue, self).isValue())

    @overload
    def __init__(self, arg0: int, arg1: str):
        """public com.badlogic.gdx.utils.JsonValue(long,java.lang.String)"""
        val = _JsonValue(_long.valueOf(arg0), arg1)
        self.__wrapper = val

    @overload
    def asBooleanArray(self) -> List[bool]:
        """public boolean[] com.badlogic.gdx.utils.JsonValue.asBooleanArray()"""
        return List[bool]._wrap(super(JsonValue, self).asBooleanArray())

    @override
    @overload
    def iterator(self) -> 'JsonIterator':
        """public com.badlogic.gdx.utils.JsonValue$JsonIterator com.badlogic.gdx.utils.JsonValue.iterator()"""
        return 'JsonIterator'._wrap(super(JsonValue, self).iterator())

    @overload
    def getLong(self, arg0: int) -> int:
        """public long com.badlogic.gdx.utils.JsonValue.getLong(int)"""
        return int._wrap(super(_JsonValue, self).getLong(_int.valueOf(arg0)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def require(self, arg0: int) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.require(int)"""
        return 'JsonValue'._wrap(super(_JsonValue, self).require(_int.valueOf(arg0)))

    @overload
    def isArray(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isArray()"""
        return bool._wrap(super(JsonValue, self).isArray())

    @overload
    def iterator(self, arg0: str) -> 'JsonIterator':
        """public com.badlogic.gdx.utils.JsonValue$JsonIterator com.badlogic.gdx.utils.JsonValue.iterator(java.lang.String)"""
        return 'JsonIterator'._wrap(super(_JsonValue, self).iterator(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self, arg0: float):
        """public com.badlogic.gdx.utils.JsonValue(double)"""
        val = _JsonValue(_double.valueOf(arg0))
        self.__wrapper = val

    @overload
    def has(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.has(java.lang.String)"""
        return bool._wrap(super(_JsonValue, self).has(arg0))

    @overload
    def getFloat(self, arg0: str, arg1: float) -> float:
        """public float com.badlogic.gdx.utils.JsonValue.getFloat(java.lang.String,float)"""
        return float._wrap(super(_JsonValue, self).getFloat(arg0, _float.valueOf(arg1)))

    @overload
    def __init__(self, arg0: str):
        """public com.badlogic.gdx.utils.JsonValue(java.lang.String)"""
        val = _JsonValue(arg0)
        self.__wrapper = val

    @overload
    def asIntArray(self) -> List[int]:
        """public int[] com.badlogic.gdx.utils.JsonValue.asIntArray()"""
        return List[int]._wrap(super(JsonValue, self).asIntArray())

    @overload
    def getString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.getString(java.lang.String)"""
        return str._wrap(super(_JsonValue, self).getString(arg0))

    @overload
    def hasChild(self, arg0: str) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.hasChild(java.lang.String)"""
        return bool._wrap(super(_JsonValue, self).hasChild(arg0))

    @overload
    def parent(self) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.parent()"""
        return 'JsonValue'._wrap(super(JsonValue, self).parent())

    @overload
    def getInt(self, arg0: int) -> int:
        """public int com.badlogic.gdx.utils.JsonValue.getInt(int)"""
        return int._wrap(super(_JsonValue, self).getInt(_int.valueOf(arg0)))

    @overload
    def isBoolean(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isBoolean()"""
        return bool._wrap(super(JsonValue, self).isBoolean())

    @overload
    def getByte(self, arg0: int) -> int:
        """public byte com.badlogic.gdx.utils.JsonValue.getByte(int)"""
        return int._wrap(super(_JsonValue, self).getByte(_int.valueOf(arg0)))

    @overload
    def asStringArray(self) -> List[str]:
        """public java.lang.String[] com.badlogic.gdx.utils.JsonValue.asStringArray()"""
        return List[str]._wrap(super(JsonValue, self).asStringArray())

    @overload
    def asFloat(self) -> float:
        """public float com.badlogic.gdx.utils.JsonValue.asFloat()"""
        return float._wrap(super(JsonValue, self).asFloat())

    @overload
    def setType(self, arg0: 'ValueType'):
        """public void com.badlogic.gdx.utils.JsonValue.setType(com.badlogic.gdx.utils.JsonValue$ValueType)"""
        super(_JsonValue, self).setType(arg0)

    @overload
    def getDouble(self, arg0: str, arg1: float) -> float:
        """public double com.badlogic.gdx.utils.JsonValue.getDouble(java.lang.String,double)"""
        return float._wrap(super(_JsonValue, self).getDouble(arg0, _double.valueOf(arg1)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def asString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.asString()"""
        return str._wrap(super(JsonValue, self).asString())

    @overload
    def set(self, arg0: float, arg1: str):
        """public void com.badlogic.gdx.utils.JsonValue.set(double,java.lang.String)"""
        super(_JsonValue, self).set(_double.valueOf(arg0), arg1)

    @overload
    def setPrev(self, arg0: 'JsonValue'):
        """public void com.badlogic.gdx.utils.JsonValue.setPrev(com.badlogic.gdx.utils.JsonValue)"""
        super(_JsonValue, self).setPrev(arg0)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def getChar(self, arg0: int) -> str:
        """public char com.badlogic.gdx.utils.JsonValue.getChar(int)"""
        return str._wrap(super(_JsonValue, self).getChar(_int.valueOf(arg0)))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def getByte(self, arg0: str) -> int:
        """public byte com.badlogic.gdx.utils.JsonValue.getByte(java.lang.String)"""
        return int._wrap(super(_JsonValue, self).getByte(arg0))

    @overload
    def getChar(self, arg0: str, arg1: str) -> str:
        """public char com.badlogic.gdx.utils.JsonValue.getChar(java.lang.String,char)"""
        return str._wrap(super(_JsonValue, self).getChar(arg0, _char.valueOf(arg1)))

    @overload
    def getBoolean(self, arg0: int) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.getBoolean(int)"""
        return bool._wrap(super(_JsonValue, self).getBoolean(_int.valueOf(arg0)))

    @overload
    def toJson(self, arg0: 'OutputType') -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.toJson(com.badlogic.gdx.utils.JsonWriter$OutputType)"""
        return str._wrap(super(_JsonValue, self).toJson(arg0))

    @overload
    def getChild(self, arg0: str) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.getChild(java.lang.String)"""
        return 'JsonValue'._wrap(super(_JsonValue, self).getChild(arg0))

    @overload
    def remove(self, arg0: str) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.remove(java.lang.String)"""
        return 'JsonValue'._wrap(super(_JsonValue, self).remove(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.JsonValue(long)"""
        val = _JsonValue(_long.valueOf(arg0))
        self.__wrapper = val

    @overload
    def isString(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isString()"""
        return bool._wrap(super(JsonValue, self).isString())

    @overload
    def setName(self, arg0: str):
        """public void com.badlogic.gdx.utils.JsonValue.setName(java.lang.String)"""
        super(_JsonValue, self).setName(arg0)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def set(self, arg0: int, arg1: str):
        """public void com.badlogic.gdx.utils.JsonValue.set(long,java.lang.String)"""
        super(_JsonValue, self).set(_long.valueOf(arg0), arg1)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def get(self, arg0: str) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.get(java.lang.String)"""
        return 'JsonValue'._wrap(super(_JsonValue, self).get(arg0))

    @overload
    def asByteArray(self) -> List[int]:
        """public byte[] com.badlogic.gdx.utils.JsonValue.asByteArray()"""
        return List[int]._wrap(super(JsonValue, self).asByteArray())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @overload
    def asDoubleArray(self) -> List[float]:
        """public double[] com.badlogic.gdx.utils.JsonValue.asDoubleArray()"""
        return List[float]._wrap(super(JsonValue, self).asDoubleArray())

    @overload
    def getDouble(self, arg0: int) -> float:
        """public double com.badlogic.gdx.utils.JsonValue.getDouble(int)"""
        return float._wrap(super(_JsonValue, self).getDouble(_int.valueOf(arg0)))

    @overload
    def getString(self, arg0: str, arg1: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.getString(java.lang.String,java.lang.String)"""
        return str._wrap(super(_JsonValue, self).getString(arg0, arg1))

    @overload
    def prettyPrint(self, arg0: 'OutputType', arg1: int) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,int)"""
        return str._wrap(super(_JsonValue, self).prettyPrint(arg0, _int.valueOf(arg1)))

    @overload
    def asCharArray(self) -> List[str]:
        """public char[] com.badlogic.gdx.utils.JsonValue.asCharArray()"""
        return List[str]._wrap(super(JsonValue, self).asCharArray())

    @overload
    def getFloat(self, arg0: int) -> float:
        """public float com.badlogic.gdx.utils.JsonValue.getFloat(int)"""
        return float._wrap(super(_JsonValue, self).getFloat(_int.valueOf(arg0)))

    @overload
    def trace(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.trace()"""
        return str._wrap(super(JsonValue, self).trace())

    @overload
    def asByte(self) -> int:
        """public byte com.badlogic.gdx.utils.JsonValue.asByte()"""
        return int._wrap(super(JsonValue, self).asByte())

    @overload
    def set(self, arg0: bool):
        """public void com.badlogic.gdx.utils.JsonValue.set(boolean)"""
        super(_JsonValue, self).set(_boolean.valueOf(arg0))

    @overload
    def asChar(self) -> str:
        """public char com.badlogic.gdx.utils.JsonValue.asChar()"""
        return str._wrap(super(JsonValue, self).asChar())

    @overload
    def getFloat(self, arg0: str) -> float:
        """public float com.badlogic.gdx.utils.JsonValue.getFloat(java.lang.String)"""
        return float._wrap(super(_JsonValue, self).getFloat(arg0))

    @overload
    def getDouble(self, arg0: str) -> float:
        """public double com.badlogic.gdx.utils.JsonValue.getDouble(java.lang.String)"""
        return float._wrap(super(_JsonValue, self).getDouble(arg0))

    @overload
    def getInt(self, arg0: str) -> int:
        """public int com.badlogic.gdx.utils.JsonValue.getInt(java.lang.String)"""
        return int._wrap(super(_JsonValue, self).getInt(arg0))

    @overload
    def child(self) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.child()"""
        return 'JsonValue'._wrap(super(JsonValue, self).child())

    @overload
    def type(self) -> 'ValueType':
        """public com.badlogic.gdx.utils.JsonValue$ValueType com.badlogic.gdx.utils.JsonValue.type()"""
        return 'ValueType'._wrap(super(JsonValue, self).type())

    @overload
    def getShort(self, arg0: str, arg1: int) -> int:
        """public short com.badlogic.gdx.utils.JsonValue.getShort(java.lang.String,short)"""
        return int._wrap(super(_JsonValue, self).getShort(arg0, _short.valueOf(arg1)))

    @overload
    def prev(self) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.prev()"""
        return 'JsonValue'._wrap(super(JsonValue, self).prev())

    @overload
    def __init__(self, arg0: bool):
        """public com.badlogic.gdx.utils.JsonValue(boolean)"""
        val = _JsonValue(_boolean.valueOf(arg0))
        self.__wrapper = val

    @overload
    def isNumber(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isNumber()"""
        return bool._wrap(super(JsonValue, self).isNumber())

    @overload
    def getInt(self, arg0: str, arg1: int) -> int:
        """public int com.badlogic.gdx.utils.JsonValue.getInt(java.lang.String,int)"""
        return int._wrap(super(_JsonValue, self).getInt(arg0, _int.valueOf(arg1)))

    @overload
    def getShort(self, arg0: str) -> int:
        """public short com.badlogic.gdx.utils.JsonValue.getShort(java.lang.String)"""
        return int._wrap(super(_JsonValue, self).getShort(arg0))

    @overload
    def getLong(self, arg0: str) -> int:
        """public long com.badlogic.gdx.utils.JsonValue.getLong(java.lang.String)"""
        return int._wrap(super(_JsonValue, self).getLong(arg0))

    @overload
    def require(self, arg0: str) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.require(java.lang.String)"""
        return 'JsonValue'._wrap(super(_JsonValue, self).require(arg0))

    @overload
    def getChar(self, arg0: str) -> str:
        """public char com.badlogic.gdx.utils.JsonValue.getChar(java.lang.String)"""
        return str._wrap(super(_JsonValue, self).getChar(arg0))

    @overload
    def asBoolean(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.asBoolean()"""
        return bool._wrap(super(JsonValue, self).asBoolean())

    @overload
    def addChild(self, arg0: 'JsonValue'):
        """public void com.badlogic.gdx.utils.JsonValue.addChild(com.badlogic.gdx.utils.JsonValue)"""
        super(_JsonValue, self).addChild(arg0)

    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.JsonValue.remove()"""
        super(JsonValue, self).remove()

    @overload
    def __init__(self, arg0: float, arg1: str):
        """public com.badlogic.gdx.utils.JsonValue(double,java.lang.String)"""
        val = _JsonValue(_double.valueOf(arg0), arg1)
        self.__wrapper = val

    @overload
    def prettyPrint(self, arg0: 'OutputType', arg1: 'Writer'):
        """public void com.badlogic.gdx.utils.JsonValue.prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,java.io.Writer) throws java.io.IOException"""
        super(_JsonValue, self).prettyPrint(arg0, arg1)

    @overload
    def isNull(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isNull()"""
        return bool._wrap(super(JsonValue, self).isNull())

    @overload
    def asShortArray(self) -> List[int]:
        """public short[] com.badlogic.gdx.utils.JsonValue.asShortArray()"""
        return List[int]._wrap(super(JsonValue, self).asShortArray())

    @overload
    def asShort(self) -> int:
        """public short com.badlogic.gdx.utils.JsonValue.asShort()"""
        return int._wrap(super(JsonValue, self).asShort())

    @overload
    def set(self, arg0: str):
        """public void com.badlogic.gdx.utils.JsonValue.set(java.lang.String)"""
        super(_JsonValue, self).set(arg0)

    @overload
    def asDouble(self) -> float:
        """public double com.badlogic.gdx.utils.JsonValue.asDouble()"""
        return float._wrap(super(JsonValue, self).asDouble())

    @overload
    def name(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.name()"""
        return str._wrap(super(JsonValue, self).name())

    @overload
    def prettyPrint(self, arg0: 'PrettyPrintSettings') -> str:
        """public java.lang.String com.badlogic.gdx.utils.JsonValue.prettyPrint(com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings)"""
        return str._wrap(super(_JsonValue, self).prettyPrint(arg0))

    @overload
    def isDouble(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isDouble()"""
        return bool._wrap(super(JsonValue, self).isDouble())

    @overload
    def asFloatArray(self) -> List[float]:
        """public float[] com.badlogic.gdx.utils.JsonValue.asFloatArray()"""
        return List[float]._wrap(super(JsonValue, self).asFloatArray())

    @overload
    def size(self) -> int:
        """public int com.badlogic.gdx.utils.JsonValue.size()"""
        return int._wrap(super(JsonValue, self).size())

    @overload
    def get(self, arg0: int) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.get(int)"""
        return 'JsonValue'._wrap(super(_JsonValue, self).get(_int.valueOf(arg0)))

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.notEmpty()"""
        return bool._wrap(super(JsonValue, self).notEmpty())

    @overload
    def setNext(self, arg0: 'JsonValue'):
        """public void com.badlogic.gdx.utils.JsonValue.setNext(com.badlogic.gdx.utils.JsonValue)"""
        super(_JsonValue, self).setNext(arg0)

    @overload
    def asLong(self) -> int:
        """public long com.badlogic.gdx.utils.JsonValue.asLong()"""
        return int._wrap(super(JsonValue, self).asLong())

    @overload
    def asInt(self) -> int:
        """public int com.badlogic.gdx.utils.JsonValue.asInt()"""
        return int._wrap(super(JsonValue, self).asInt())

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonValue.isEmpty()"""
        return bool._wrap(super(JsonValue, self).isEmpty())

    @overload
    def asLongArray(self) -> List[int]:
        """public long[] com.badlogic.gdx.utils.JsonValue.asLongArray()"""
        return List[int]._wrap(super(JsonValue, self).asLongArray())

    @overload
    def remove(self, arg0: int) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonValue.remove(int)"""
        return 'JsonValue'._wrap(super(_JsonValue, self).remove(_int.valueOf(arg0))) 
 
 
# CLASS: com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Keys
_Keys = _ObjectMap_Keys.Keys
import java.lang.Integer as _int
import com.badlogic.gdx.utils.OrderedMap as _OrderedMap_OrderedMapKeys
_OrderedMapKeys = _OrderedMap_OrderedMapKeys.OrderedMapKeys
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class OrderedMapKeys():
    """com.badlogic.gdx.utils.OrderedMap.OrderedMapKeys"""
 
    @staticmethod
    def _wrap(java_value: _OrderedMapKeys) -> 'OrderedMapKeys':
        return OrderedMapKeys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _OrderedMapKeys):
        """
        Dynamic initializer for OrderedMapKeys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_OrderedMapKeys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_OrderedMapKeys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: 'OrderedMap'):
        """public com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys(com.badlogic.gdx.utils.OrderedMap<K, ?>)"""
        val = _OrderedMapKeys(arg0)
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toArray(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys.toArray()"""
        return 'Array'._wrap(super(OrderedMapKeys, self).toArray())

    @overload
    def toArray(self, arg0: 'Array') -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys.toArray(com.badlogic.gdx.utils.Array<K>)"""
        return 'Array'._wrap(super(_OrderedMapKeys, self).toArray(arg0))

    @override
    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys.reset()"""
        super(OrderedMapKeys, self).reset()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys.remove()"""
        super(OrderedMapKeys, self).remove()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def next(self) -> object:
        """public K com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys.next()"""
        return object._wrap(super(OrderedMapKeys, self).next())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap$Keys.hasNext()"""
        return bool._wrap(super(Keys, self).hasNext())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def iterator(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectMap$Keys<K> com.badlogic.gdx.utils.ObjectMap$Keys.iterator()"""
        return 'Keys'._wrap(super(Keys, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.OrderedMap
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Values
_Values = _ObjectMap_Values.Values
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import com.badlogic.gdx.utils.OrderedMap as _OrderedMap
_OrderedMap = _OrderedMap
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap
_ObjectMap = _ObjectMap
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.lang.Float as _float
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Entries
_Entries = _ObjectMap_Entries.Entries
import com.badlogic.gdx.utils.ObjectMap as _ObjectMap_Keys
_Keys = _ObjectMap_Keys.Keys
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class OrderedMap():
    """com.badlogic.gdx.utils.OrderedMap"""
 
    @staticmethod
    def _wrap(java_value: _OrderedMap) -> 'OrderedMap':
        return OrderedMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _OrderedMap):
        """
        Dynamic initializer for OrderedMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_OrderedMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_OrderedMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.OrderedMap.clear(int)"""
        super(_OrderedMap, self).clear(_int.valueOf(arg0))

    @override
    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectMap$Entries<K, V> com.badlogic.gdx.utils.OrderedMap.entries()"""
        return 'Entries'._wrap(super(OrderedMap, self).entries())

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.OrderedMap()"""
        val = _OrderedMap()
        self.__wrapper = val

    @overload
    def removeIndex(self, arg0: int) -> object:
        """public V com.badlogic.gdx.utils.OrderedMap.removeIndex(int)"""
        return object._wrap(super(_OrderedMap, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def __init__(self, arg0: 'OrderedMap'):
        """public com.badlogic.gdx.utils.OrderedMap(com.badlogic.gdx.utils.OrderedMap<? extends K, ? extends V>)"""
        val = _OrderedMap(arg0)
        self.__wrapper = val

    @override
    @overload
    def putAll(self, arg0: 'ObjectMap'):
        """public void com.badlogic.gdx.utils.ObjectMap.putAll(com.badlogic.gdx.utils.ObjectMap<? extends K, ? extends V>)"""
        super(_ObjectMap, self).putAll(arg0)

    @overload
    def remove(self, arg0: object) -> object:
        """public V com.badlogic.gdx.utils.OrderedMap.remove(K)"""
        return object._wrap(super(_OrderedMap, self).remove(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectMap$Keys<K> com.badlogic.gdx.utils.OrderedMap.keys()"""
        return 'Keys'._wrap(super(OrderedMap, self).keys())

    @overload
    def containsValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.containsValue(java.lang.Object,boolean)"""
        return bool._wrap(super(_ObjectMap, self).containsValue(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def alterIndex(self, arg0: int, arg1: object) -> bool:
        """public boolean com.badlogic.gdx.utils.OrderedMap.alterIndex(int,K)"""
        return bool._wrap(super(_OrderedMap, self).alterIndex(_int.valueOf(arg0), arg1))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectMap.toString(java.lang.String)"""
        return str._wrap(super(_ObjectMap, self).toString(arg0))

    @override
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.OrderedMap.clear()"""
        super(OrderedMap, self).clear()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.OrderedMap()"""
        val = _OrderedMap()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectMap.toString()"""
        return str._wrap(super(ObjectMap, self).toString())

    @override
    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectMap.shrink(int)"""
        super(_ObjectMap, self).shrink(_int.valueOf(arg0))

    @overload
    def get(self, arg0: object) -> object:
        """public <T extends K> V com.badlogic.gdx.utils.ObjectMap.get(T)"""
        return object._wrap(super(_ObjectMap, self).get(arg0))

    @overload
    def containsKey(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.containsKey(K)"""
        return bool._wrap(super(_ObjectMap, self).containsKey(arg0))

    @override
    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectMap$Values<V> com.badlogic.gdx.utils.OrderedMap.values()"""
        return 'Values'._wrap(super(OrderedMap, self).values())

    @overload
    def orderedKeys(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<K> com.badlogic.gdx.utils.OrderedMap.orderedKeys()"""
        return 'Array'._wrap(super(OrderedMap, self).orderedKeys())

    @overload
    def alter(self, arg0: object, arg1: object) -> bool:
        """public boolean com.badlogic.gdx.utils.OrderedMap.alter(K,K)"""
        return bool._wrap(super(_OrderedMap, self).alter(arg0, arg1))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def get(self, arg0: object, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.ObjectMap.get(K,V)"""
        return object._wrap(super(_ObjectMap, self).get(arg0, arg1))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.OrderedMap(int)"""
        val = _OrderedMap(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.notEmpty()"""
        return bool._wrap(super(ObjectMap, self).notEmpty())

    @overload
    def putAll(self, arg0: 'OrderedMap'):
        """public <T extends K> void com.badlogic.gdx.utils.OrderedMap.putAll(com.badlogic.gdx.utils.OrderedMap<T, ? extends V>)"""
        super(_OrderedMap, self).putAll(arg0)

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ObjectMap.hashCode()"""
        return int._wrap(super(ObjectMap, self).hashCode())

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_ObjectMap, self).equalsIdentity(arg0))

    @override
    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectMap.ensureCapacity(int)"""
        super(_ObjectMap, self).ensureCapacity(_int.valueOf(arg0))

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectMap$Entries<K, V> com.badlogic.gdx.utils.OrderedMap.iterator()"""
        return 'Entries'._wrap(super(OrderedMap, self).iterator())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ObjectMap, self).equals(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def put(self, arg0: object, arg1: object) -> object:
        """public V com.badlogic.gdx.utils.OrderedMap.put(K,V)"""
        return object._wrap(super(_OrderedMap, self).put(arg0, arg1))

    @overload
    def findKey(self, arg0: object, arg1: bool) -> object:
        """public K com.badlogic.gdx.utils.ObjectMap.findKey(java.lang.Object,boolean)"""
        return object._wrap(super(_ObjectMap, self).findKey(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.OrderedMap(int,float)"""
        val = _OrderedMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectMap.isEmpty()"""
        return bool._wrap(super(ObjectMap, self).isEmpty())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.JsonReader
from pyquantum_helper import import_once as _import_once
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.String as _string
import com.badlogic.gdx.utils.JsonValue as _JsonValue
_JsonValue = _JsonValue
import java.lang.Integer as _int
import java.io.Reader as Reader
import java.io.InputStream as InputStream
try:
    from pygdx import files
except ImportError:
    files = _import_once("pygdx.files")

from builtins import bool
import com.badlogic.gdx.utils.JsonReader as _JsonReader
_JsonReader = _JsonReader
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class JsonReader():
    """com.badlogic.gdx.utils.JsonReader"""
 
    @staticmethod
    def _wrap(java_value: _JsonReader) -> 'JsonReader':
        return JsonReader(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _JsonReader):
        """
        Dynamic initializer for JsonReader.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_JsonReader__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_JsonReader__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def parse(self, arg0: 'char', arg1: int, arg2: int) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonReader.parse(char[],int,int)"""
        return 'JsonValue'._wrap(super(_JsonReader, self).parse(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def parse(self, arg0: 'Reader') -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonReader.parse(java.io.Reader)"""
        return 'JsonValue'._wrap(super(_JsonReader, self).parse(arg0))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.JsonReader()"""
        val = _JsonReader()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def stop(self):
        """public void com.badlogic.gdx.utils.JsonReader.stop()"""
        super(JsonReader, self).stop()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def parse(self, arg0: 'FileHandle') -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonReader.parse(com.badlogic.gdx.files.FileHandle)"""
        return 'JsonValue'._wrap(super(_JsonReader, self).parse(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def isStopped(self) -> bool:
        """public boolean com.badlogic.gdx.utils.JsonReader.isStopped()"""
        return bool._wrap(super(JsonReader, self).isStopped())

    @overload
    def parse(self, arg0: 'InputStream') -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonReader.parse(java.io.InputStream)"""
        return 'JsonValue'._wrap(super(_JsonReader, self).parse(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.JsonReader()"""
        val = _JsonReader()
        self.__wrapper = val

    @overload
    def parse(self, arg0: str) -> 'JsonValue':
        """public com.badlogic.gdx.utils.JsonValue com.badlogic.gdx.utils.JsonReader.parse(java.lang.String)"""
        return 'JsonValue'._wrap(super(_JsonReader, self).parse(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntFloatMap$Entries
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap_Entry
_Entry = _IntFloatMap_Entry.Entry
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.IntFloatMap as _IntFloatMap_Entries
_Entries = _IntFloatMap_Entries.Entries
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Entries():
    """com.badlogic.gdx.utils.IntFloatMap.Entries"""
 
    @staticmethod
    def _wrap(java_value: _Entries) -> 'Entries':
        return Entries(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entries):
        """
        Dynamic initializer for Entries.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entries__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entries__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.IntFloatMap$Entries.remove()"""
        super(Entries, self).remove()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def __init__(self, arg0: 'IntFloatMap'):
        """public com.badlogic.gdx.utils.IntFloatMap$Entries(com.badlogic.gdx.utils.IntFloatMap)"""
        val = _Entries(arg0)
        self.__wrapper = val

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<com.badlogic.gdx.utils.IntFloatMap$Entry> com.badlogic.gdx.utils.IntFloatMap$Entries.iterator()"""
        return 'Iterator'._wrap(super(Entries, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.IntFloatMap$Entries.hasNext()"""
        return bool._wrap(super(Entries, self).hasNext())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def next(self) -> 'Entry':
        """public com.badlogic.gdx.utils.IntFloatMap$Entry com.badlogic.gdx.utils.IntFloatMap$Entries.next()"""
        return 'Entry'._wrap(super(Entries, self).next())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.IntSet$IntSetIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.IntArray as _IntArray
_IntArray = _IntArray
import java.lang.Integer as _int
from builtins import bool
import com.badlogic.gdx.utils.IntSet as _IntSet_IntSetIterator
_IntSetIterator = _IntSet_IntSetIterator.IntSetIterator
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class IntSetIterator():
    """com.badlogic.gdx.utils.IntSet.IntSetIterator"""
 
    @staticmethod
    def _wrap(java_value: _IntSetIterator) -> 'IntSetIterator':
        return IntSetIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _IntSetIterator):
        """
        Dynamic initializer for IntSetIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_IntSetIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_IntSetIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def toArray(self) -> 'IntArray':
        """public com.badlogic.gdx.utils.IntArray com.badlogic.gdx.utils.IntSet$IntSetIterator.toArray()"""
        return 'IntArray'._wrap(super(IntSetIterator, self).toArray())

    @overload
    def next(self) -> int:
        """public int com.badlogic.gdx.utils.IntSet$IntSetIterator.next()"""
        return int._wrap(super(IntSetIterator, self).next())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, arg0: 'IntSet'):
        """public com.badlogic.gdx.utils.IntSet$IntSetIterator(com.badlogic.gdx.utils.IntSet)"""
        val = _IntSetIterator(arg0)
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def reset(self):
        """public void com.badlogic.gdx.utils.IntSet$IntSetIterator.reset()"""
        super(IntSetIterator, self).reset()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def remove(self):
        """public void com.badlogic.gdx.utils.IntSet$IntSetIterator.remove()"""
        super(IntSetIterator, self).remove()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.Array
from builtins import str
import com.badlogic.gdx.utils.Array as _Array_ArrayIterator
_ArrayIterator = _Array_ArrayIterator.ArrayIterator
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
from typing import List
import java.util.function.Consumer as Consumer
import java.lang.String as _string
import java.util.Comparator as Comparator
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Array():
    """com.badlogic.gdx.utils.Array"""
 
    @staticmethod
    def _wrap(java_value: _Array) -> 'Array':
        return Array(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Array):
        """
        Dynamic initializer for Array.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Array__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Array__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def removeAll(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.removeAll(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_Array, self).removeAll(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def iterator(self) -> 'ArrayIterator':
        """public com.badlogic.gdx.utils.Array$ArrayIterator<T> com.badlogic.gdx.utils.Array.iterator()"""
        return 'ArrayIterator'._wrap(super(Array, self).iterator())

    @overload
    def add(self, arg0: object):
        """public void com.badlogic.gdx.utils.Array.add(T)"""
        super(_Array, self).add(arg0)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Array()"""
        val = _Array()
        self.__wrapper = val

    @overload
    def selectRankedIndex(self, arg0: 'Comparator', arg1: int) -> int:
        """public int com.badlogic.gdx.utils.Array.selectRankedIndex(java.util.Comparator<T>,int)"""
        return int._wrap(super(_Array, self).selectRankedIndex(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def containsAny(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.containsAny(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_Array, self).containsAny(arg0, _boolean.valueOf(arg1)))

    @overload
    def set(self, arg0: int, arg1: object):
        """public void com.badlogic.gdx.utils.Array.set(int,T)"""
        super(_Array, self).set(_int.valueOf(arg0), arg1)

    @overload
    def __init__(self, arg0: 'Array'):
        """public com.badlogic.gdx.utils.Array(com.badlogic.gdx.utils.Array<? extends T>)"""
        val = _Array(arg0)
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Array.toString()"""
        return str._wrap(super(Array, self).toString())

    @overload
    def get(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.Array.get(int)"""
        return object._wrap(super(_Array, self).get(_int.valueOf(arg0)))

    @overload
    def toArray(self) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.toArray()"""
        return List[object]._wrap(super(Array, self).toArray())

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.notEmpty()"""
        return bool._wrap(super(Array, self).notEmpty())

    @overload
    def removeRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.Array.removeRange(int,int)"""
        super(_Array, self).removeRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def reverse(self):
        """public void com.badlogic.gdx.utils.Array.reverse()"""
        super(Array, self).reverse()

    @overload
    def addAll(self, arg0: 'Array', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.Array.addAll(com.badlogic.gdx.utils.Array<? extends T>,int,int)"""
        super(_Array, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.Array.clear()"""
        super(Array, self).clear()

    @overload
    def add(self, arg0: object, arg1: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T)"""
        super(_Array, self).add(arg0, arg1)

    @overload
    def random(self) -> object:
        """public T com.badlogic.gdx.utils.Array.random()"""
        return object._wrap(super(Array, self).random())

    @overload
    def pop(self) -> object:
        """public T com.badlogic.gdx.utils.Array.pop()"""
        return object._wrap(super(Array, self).pop())

    @overload
    def add(self, arg0: object, arg1: object, arg2: object, arg3: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T,T,T)"""
        super(_Array, self).add(arg0, arg1, arg2, arg3)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def shrink(self) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.shrink()"""
        return List[object]._wrap(super(Array, self).shrink())

    @overload
    def removeValue(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.removeValue(T,boolean)"""
        return bool._wrap(super(_Array, self).removeValue(arg0, _boolean.valueOf(arg1)))

    @overload
    def shuffle(self):
        """public void com.badlogic.gdx.utils.Array.shuffle()"""
        super(Array, self).shuffle()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.Array.hashCode()"""
        return int._wrap(super(Array, self).hashCode())

    @overload
    def toArray(self, arg0: 'Class') -> List[object]:
        """public <V> V[] com.badlogic.gdx.utils.Array.toArray(java.lang.Class<V>)"""
        return List[object]._wrap(super(_Array, self).toArray(arg0))

    @overload
    def swap(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.Array.swap(int,int)"""
        super(_Array, self).swap(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def lastIndexOf(self, arg0: object, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.Array.lastIndexOf(T,boolean)"""
        return int._wrap(super(_Array, self).lastIndexOf(arg0, _boolean.valueOf(arg1)))

    @staticmethod
    @overload
    def with(*arg0: object) -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.with(T...)"""
        return Array._wrap(_Array.with(arg0))

    @overload
    def insert(self, arg0: int, arg1: object):
        """public void com.badlogic.gdx.utils.Array.insert(int,T)"""
        super(_Array, self).insert(_int.valueOf(arg0), arg1)

    @overload
    def __init__(self, arg0: bool, arg1: int, arg2: 'Class'):
        """public com.badlogic.gdx.utils.Array(boolean,int,java.lang.Class)"""
        val = _Array(_boolean.valueOf(arg0), _int.valueOf(arg1), arg2)
        self.__wrapper = val

    @overload
    def select(self, arg0: 'Predicate') -> 'Iterable':
        """public java.lang.Iterable<T> com.badlogic.gdx.utils.Array.select(com.badlogic.gdx.utils.Predicate<T>)"""
        return 'Iterable'._wrap(super(_Array, self).select(arg0))

    @overload
    def selectRanked(self, arg0: 'Comparator', arg1: int) -> object:
        """public T com.badlogic.gdx.utils.Array.selectRanked(java.util.Comparator<T>,int)"""
        return object._wrap(super(_Array, self).selectRanked(arg0, _int.valueOf(arg1)))

    @overload
    def peek(self) -> object:
        """public T com.badlogic.gdx.utils.Array.peek()"""
        return object._wrap(super(Array, self).peek())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.equals(java.lang.Object)"""
        return bool._wrap(super(_Array, self).equals(arg0))

    @overload
    def first(self) -> object:
        """public T com.badlogic.gdx.utils.Array.first()"""
        return object._wrap(super(Array, self).first())

    @overload
    def contains(self, arg0: object, arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.contains(T,boolean)"""
        return bool._wrap(super(_Array, self).contains(arg0, _boolean.valueOf(arg1)))

    @overload
    def __init__(self, arg0: 'Class'):
        """public com.badlogic.gdx.utils.Array(java.lang.Class)"""
        val = _Array(arg0)
        self.__wrapper = val

    @overload
    def __init__(self, arg0: bool, arg1: int):
        """public com.badlogic.gdx.utils.Array(boolean,int)"""
        val = _Array(_boolean.valueOf(arg0), _int.valueOf(arg1))
        self.__wrapper = val

    @staticmethod
    @overload
    def of(arg0: 'Class') -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.of(java.lang.Class<T>)"""
        return Array._wrap(_Array.of(arg0))

    @overload
    def addAll(self, arg0: 'Object', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.Array.addAll(T[],int,int)"""
        super(_Array, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def sort(self):
        """public void com.badlogic.gdx.utils.Array.sort()"""
        super(Array, self).sort()

    @overload
    def indexOf(self, arg0: object, arg1: bool) -> int:
        """public int com.badlogic.gdx.utils.Array.indexOf(T,boolean)"""
        return int._wrap(super(_Array, self).indexOf(arg0, _boolean.valueOf(arg1)))

    @overload
    def insertRange(self, arg0: int, arg1: int):
        """public void com.badlogic.gdx.utils.Array.insertRange(int,int)"""
        super(_Array, self).insertRange(_int.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def add(self, arg0: object, arg1: object, arg2: object):
        """public void com.badlogic.gdx.utils.Array.add(T,T,T)"""
        super(_Array, self).add(arg0, arg1, arg2)

    @overload
    def equalsIdentity(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.equalsIdentity(java.lang.Object)"""
        return bool._wrap(super(_Array, self).equalsIdentity(arg0))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Array.toString(java.lang.String)"""
        return str._wrap(super(_Array, self).toString(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, arg0: bool, arg1: 'Object', arg2: int, arg3: int):
        """public com.badlogic.gdx.utils.Array(boolean,T[],int,int)"""
        val = _Array(_boolean.valueOf(arg0), arg1, _int.valueOf(arg2), _int.valueOf(arg3))
        self.__wrapper = val

    @overload
    def setSize(self, arg0: int) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.setSize(int)"""
        return List[object]._wrap(super(_Array, self).setSize(_int.valueOf(arg0)))

    @overload
    def removeIndex(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.Array.removeIndex(int)"""
        return object._wrap(super(_Array, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def ensureCapacity(self, arg0: int) -> List[object]:
        """public T[] com.badlogic.gdx.utils.Array.ensureCapacity(int)"""
        return List[object]._wrap(super(_Array, self).ensureCapacity(_int.valueOf(arg0)))

    @overload
    def sort(self, arg0: 'Comparator'):
        """public void com.badlogic.gdx.utils.Array.sort(java.util.Comparator<? super T>)"""
        super(_Array, self).sort(arg0)

    @overload
    def addAll(self, *arg0: object):
        """public void com.badlogic.gdx.utils.Array.addAll(T...)"""
        super(_Array, self).addAll(arg0)

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.Array(int)"""
        val = _Array(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def __init__(self, arg0: 'Object'):
        """public com.badlogic.gdx.utils.Array(T[])"""
        val = _Array(arg0)
        self.__wrapper = val

    @overload
    def addAll(self, arg0: 'Array'):
        """public void com.badlogic.gdx.utils.Array.addAll(com.badlogic.gdx.utils.Array<? extends T>)"""
        super(_Array, self).addAll(arg0)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.isEmpty()"""
        return bool._wrap(super(Array, self).isEmpty())

    @staticmethod
    @overload
    def of(arg0: bool, arg1: int, arg2: 'Class') -> 'Array':
        """public static <T> com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.Array.of(boolean,int,java.lang.Class<T>)"""
        return Array._wrap(_Array.of(_boolean.valueOf(arg0), _int.valueOf(arg1), arg2))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Array()"""
        val = _Array()
        self.__wrapper = val

    @overload
    def truncate(self, arg0: int):
        """public void com.badlogic.gdx.utils.Array.truncate(int)"""
        super(_Array, self).truncate(_int.valueOf(arg0))

    @overload
    def containsAll(self, arg0: 'Array', arg1: bool) -> bool:
        """public boolean com.badlogic.gdx.utils.Array.containsAll(com.badlogic.gdx.utils.Array<? extends T>,boolean)"""
        return bool._wrap(super(_Array, self).containsAll(arg0, _boolean.valueOf(arg1)))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.OrderedSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import com.badlogic.gdx.utils.ObjectSet as _ObjectSet
_ObjectSet = _ObjectSet
import java.lang.String as _String
_String = _String
from builtins import object
import com.badlogic.gdx.utils.Array as _Array
_Array = _Array
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import com.badlogic.gdx.utils.OrderedSet as _OrderedSet_OrderedSetIterator
_OrderedSetIterator = _OrderedSet_OrderedSetIterator.OrderedSetIterator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.OrderedSet as _OrderedSet
_OrderedSet = _OrderedSet
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class OrderedSet():
    """com.badlogic.gdx.utils.OrderedSet"""
 
    @staticmethod
    def _wrap(java_value: _OrderedSet) -> 'OrderedSet':
        return OrderedSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _OrderedSet):
        """
        Dynamic initializer for OrderedSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_OrderedSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_OrderedSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def addAll(self, arg0: 'ObjectSet'):
        """public void com.badlogic.gdx.utils.ObjectSet.addAll(com.badlogic.gdx.utils.ObjectSet<T>)"""
        super(_ObjectSet, self).addAll(arg0)

    @overload
    def removeIndex(self, arg0: int) -> object:
        """public T com.badlogic.gdx.utils.OrderedSet.removeIndex(int)"""
        return object._wrap(super(_OrderedSet, self).removeIndex(_int.valueOf(arg0)))

    @overload
    def get(self, arg0: object) -> object:
        """public T com.badlogic.gdx.utils.ObjectSet.get(T)"""
        return object._wrap(super(_ObjectSet, self).get(arg0))

    @overload
    def remove(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.OrderedSet.remove(T)"""
        return bool._wrap(super(_OrderedSet, self).remove(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def addAll(self, arg0: 'OrderedSet'):
        """public void com.badlogic.gdx.utils.OrderedSet.addAll(com.badlogic.gdx.utils.OrderedSet<T>)"""
        super(_OrderedSet, self).addAll(arg0)

    @override
    @overload
    def addAll(self, arg0: 'Array'):
        """public void com.badlogic.gdx.utils.ObjectSet.addAll(com.badlogic.gdx.utils.Array<? extends T>)"""
        super(_ObjectSet, self).addAll(arg0)

    @overload
    def __init__(self, arg0: 'OrderedSet'):
        """public com.badlogic.gdx.utils.OrderedSet(com.badlogic.gdx.utils.OrderedSet<? extends T>)"""
        val = _OrderedSet(arg0)
        self.__wrapper = val

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.OrderedSet.add(T)"""
        return bool._wrap(super(_OrderedSet, self).add(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.OrderedSet(int)"""
        val = _OrderedSet(_int.valueOf(arg0))
        self.__wrapper = val

    @override
    @overload
    def addAll(self, arg0: 'Array', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.ObjectSet.addAll(com.badlogic.gdx.utils.Array<? extends T>,int,int)"""
        super(_ObjectSet, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectSet.ensureCapacity(int)"""
        super(_ObjectSet, self).ensureCapacity(_int.valueOf(arg0))

    @overload
    def orderedItems(self) -> 'Array':
        """public com.badlogic.gdx.utils.Array<T> com.badlogic.gdx.utils.OrderedSet.orderedItems()"""
        return 'Array'._wrap(super(OrderedSet, self).orderedItems())

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.OrderedSet(int,float)"""
        val = _OrderedSet(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.OrderedSet.toString()"""
        return str._wrap(super(OrderedSet, self).toString())

    @staticmethod
    @overload
    def with(*arg0: object) -> 'OrderedSet':
        """public static <T> com.badlogic.gdx.utils.OrderedSet<T> com.badlogic.gdx.utils.OrderedSet.with(T...)"""
        return OrderedSet._wrap(_OrderedSet.with(arg0))

    @override
    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.notEmpty()"""
        return bool._wrap(super(ObjectSet, self).notEmpty())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ObjectSet.hashCode()"""
        return int._wrap(super(ObjectSet, self).hashCode())

    @override
    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectSet.shrink(int)"""
        super(_ObjectSet, self).shrink(_int.valueOf(arg0))

    @overload
    def contains(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.contains(T)"""
        return bool._wrap(super(_ObjectSet, self).contains(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.OrderedSet()"""
        val = _OrderedSet()
        self.__wrapper = val

    @override
    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.OrderedSet.clear(int)"""
        super(_OrderedSet, self).clear(_int.valueOf(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def with(*arg0: object) -> 'ObjectSet':
        """public static <T> com.badlogic.gdx.utils.ObjectSet<T> com.badlogic.gdx.utils.ObjectSet.with(T...)"""
        return ObjectSet._wrap(_ObjectSet.with(arg0))

    @override
    @overload
    def first(self) -> object:
        """public T com.badlogic.gdx.utils.ObjectSet.first()"""
        return object._wrap(super(ObjectSet, self).first())

    @overload
    def alter(self, arg0: object, arg1: object) -> bool:
        """public boolean com.badlogic.gdx.utils.OrderedSet.alter(T,T)"""
        return bool._wrap(super(_OrderedSet, self).alter(arg0, arg1))

    @overload
    def addAll(self, *arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.addAll(T...)"""
        return bool._wrap(super(_ObjectSet, self).addAll(arg0))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.OrderedSet.toString(java.lang.String)"""
        return str._wrap(super(_OrderedSet, self).toString(arg0))

    @override
    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.OrderedSet.clear()"""
        super(OrderedSet, self).clear()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.isEmpty()"""
        return bool._wrap(super(ObjectSet, self).isEmpty())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ObjectSet, self).equals(arg0))

    @overload
    def addAll(self, arg0: 'Object', arg1: int, arg2: int) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectSet.addAll(T[],int,int)"""
        return bool._wrap(super(_ObjectSet, self).addAll(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @overload
    def add(self, arg0: object, arg1: int) -> bool:
        """public boolean com.badlogic.gdx.utils.OrderedSet.add(T,int)"""
        return bool._wrap(super(_OrderedSet, self).add(arg0, _int.valueOf(arg1)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def iterator(self) -> 'OrderedSetIterator':
        """public com.badlogic.gdx.utils.OrderedSet$OrderedSetIterator<T> com.badlogic.gdx.utils.OrderedSet.iterator()"""
        return 'OrderedSetIterator'._wrap(super(OrderedSet, self).iterator())

    @overload
    def alterIndex(self, arg0: int, arg1: object) -> bool:
        """public boolean com.badlogic.gdx.utils.OrderedSet.alterIndex(int,T)"""
        return bool._wrap(super(_OrderedSet, self).alterIndex(_int.valueOf(arg0), arg1))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.OrderedSet()"""
        val = _OrderedSet()
        self.__wrapper = val

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.JsonWriter
from builtins import str
import java.lang.Character as _char
import java.lang.CharSequence as CharSequence
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
import java.io.Writer as _Writer
_Writer = _Writer
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.String as _string
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import com.badlogic.gdx.utils.JsonWriter as _JsonWriter
_JsonWriter = _JsonWriter
import java.io.Writer as Writer
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class JsonWriter():
    """com.badlogic.gdx.utils.JsonWriter"""
 
    @staticmethod
    def _wrap(java_value: _JsonWriter) -> 'JsonWriter':
        return JsonWriter(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _JsonWriter):
        """
        Dynamic initializer for JsonWriter.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_JsonWriter__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_JsonWriter__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def append(self, arg0: 'CharSequence') -> 'Writer':
        """public java.io.Writer java.io.Writer.append(java.lang.CharSequence) throws java.io.IOException"""
        return 'Writer'._wrap(super(_Writer, self).append(arg0))

    @overload
    def pop(self) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.pop() throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(JsonWriter, self).pop())

    @staticmethod
    @overload
    def nullWriter() -> 'Writer':
        """public static java.io.Writer java.io.Writer.nullWriter()"""
        return Writer._wrap(_Writer.nullWriter())

    @override
    @overload
    def flush(self):
        """public void com.badlogic.gdx.utils.JsonWriter.flush() throws java.io.IOException"""
        super(JsonWriter, self).flush()

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def append(self, arg0: 'CharSequence', arg1: int, arg2: int) -> 'Writer':
        """public java.io.Writer java.io.Writer.append(java.lang.CharSequence,int,int) throws java.io.IOException"""
        return 'Writer'._wrap(super(_Writer, self).append(arg0, _int.valueOf(arg1), _int.valueOf(arg2)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def set(self, arg0: str, arg1: object) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.set(java.lang.String,java.lang.Object) throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(_JsonWriter, self).set(arg0, arg1))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def value(self, arg0: object) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.value(java.lang.Object) throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(_JsonWriter, self).value(arg0))

    @overload
    def getWriter(self) -> 'Writer':
        """public java.io.Writer com.badlogic.gdx.utils.JsonWriter.getWriter()"""
        return 'Writer'._wrap(super(JsonWriter, self).getWriter())

    @overload
    def array(self) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.array() throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(JsonWriter, self).array())

    @overload
    def json(self, arg0: str) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.json(java.lang.String) throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(_JsonWriter, self).json(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def write(self, arg0: 'char', arg1: int, arg2: int):
        """public void com.badlogic.gdx.utils.JsonWriter.write(char[],int,int) throws java.io.IOException"""
        super(_JsonWriter, self).write(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def setOutputType(self, arg0: 'OutputType'):
        """public void com.badlogic.gdx.utils.JsonWriter.setOutputType(com.badlogic.gdx.utils.JsonWriter$OutputType)"""
        super(_JsonWriter, self).setOutputType(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def close(self):
        """public void com.badlogic.gdx.utils.JsonWriter.close() throws java.io.IOException"""
        super(JsonWriter, self).close()

    @override
    @overload
    def write(self, arg0: str):
        """public void java.io.Writer.write(java.lang.String) throws java.io.IOException"""
        super(_Writer, self).write(arg0)

    @overload
    def json(self, arg0: str, arg1: str) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.json(java.lang.String,java.lang.String) throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(_JsonWriter, self).json(arg0, arg1))

    @overload
    def object(self) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.object() throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(JsonWriter, self).object())

    @overload
    def setQuoteLongValues(self, arg0: bool):
        """public void com.badlogic.gdx.utils.JsonWriter.setQuoteLongValues(boolean)"""
        super(_JsonWriter, self).setQuoteLongValues(_boolean.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def name(self, arg0: str) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.name(java.lang.String) throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(_JsonWriter, self).name(arg0))

    @override
    @overload
    def write(self, arg0: 'char'):
        """public void java.io.Writer.write(char[]) throws java.io.IOException"""
        super(_Writer, self).write(arg0)

    @override
    @overload
    def write(self, arg0: str, arg1: int, arg2: int):
        """public void java.io.Writer.write(java.lang.String,int,int) throws java.io.IOException"""
        super(_Writer, self).write(arg0, _int.valueOf(arg1), _int.valueOf(arg2))

    @overload
    def __init__(self, arg0: 'Writer'):
        """public com.badlogic.gdx.utils.JsonWriter(java.io.Writer)"""
        val = _JsonWriter(arg0)
        self.__wrapper = val

    @override
    @overload
    def write(self, arg0: int):
        """public void java.io.Writer.write(int) throws java.io.IOException"""
        super(_Writer, self).write(_int.valueOf(arg0))

    @overload
    def array(self, arg0: str) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.array(java.lang.String) throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(_JsonWriter, self).array(arg0))

    @overload
    def append(self, arg0: str) -> 'Writer':
        """public java.io.Writer java.io.Writer.append(char) throws java.io.IOException"""
        return 'Writer'._wrap(super(_Writer, self).append(_char.valueOf(arg0)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def object(self, arg0: str) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.JsonWriter.object(java.lang.String) throws java.io.IOException"""
        return 'JsonWriter'._wrap(super(_JsonWriter, self).object(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectFloatMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from builtins import float
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap_Entries
_Entries = _ObjectFloatMap_Entries.Entries
import java.util.function.Consumer as Consumer
import java.lang.Float as _float
import java.lang.String as _string
import java.util.Spliterator as Spliterator
import java.lang.Integer as _int
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap
_ObjectFloatMap = _ObjectFloatMap
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap_Values
_Values = _ObjectFloatMap_Values.Values
from builtins import bool
import com.badlogic.gdx.utils.ObjectFloatMap as _ObjectFloatMap_Keys
_Keys = _ObjectFloatMap_Keys.Keys
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ObjectFloatMap():
    """com.badlogic.gdx.utils.ObjectFloatMap"""
 
    @staticmethod
    def _wrap(java_value: _ObjectFloatMap) -> 'ObjectFloatMap':
        return ObjectFloatMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ObjectFloatMap):
        """
        Dynamic initializer for ObjectFloatMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ObjectFloatMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ObjectFloatMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectFloatMap.toString()"""
        return str._wrap(super(ObjectFloatMap, self).toString())

    @overload
    def __init__(self, arg0: int, arg1: float):
        """public com.badlogic.gdx.utils.ObjectFloatMap(int,float)"""
        val = _ObjectFloatMap(_int.valueOf(arg0), _float.valueOf(arg1))
        self.__wrapper = val

    @overload
    def containsValue(self, arg0: float) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap.containsValue(float)"""
        return bool._wrap(super(_ObjectFloatMap, self).containsValue(_float.valueOf(arg0)))

    @overload
    def remove(self, arg0: object, arg1: float) -> float:
        """public float com.badlogic.gdx.utils.ObjectFloatMap.remove(K,float)"""
        return float._wrap(super(_ObjectFloatMap, self).remove(arg0, _float.valueOf(arg1)))

    @overload
    def clear(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectFloatMap.clear(int)"""
        super(_ObjectFloatMap, self).clear(_int.valueOf(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def findKey(self, arg0: float, arg1: float) -> object:
        """public K com.badlogic.gdx.utils.ObjectFloatMap.findKey(float,float)"""
        return object._wrap(super(_ObjectFloatMap, self).findKey(_float.valueOf(arg0), _float.valueOf(arg1)))

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.ObjectFloatMap()"""
        val = _ObjectFloatMap()
        self.__wrapper = val

    @overload
    def getAndIncrement(self, arg0: object, arg1: float, arg2: float) -> float:
        """public float com.badlogic.gdx.utils.ObjectFloatMap.getAndIncrement(K,float,float)"""
        return float._wrap(super(_ObjectFloatMap, self).getAndIncrement(arg0, _float.valueOf(arg1), _float.valueOf(arg2)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @overload
    def __init__(self, arg0: 'ObjectFloatMap'):
        """public com.badlogic.gdx.utils.ObjectFloatMap(com.badlogic.gdx.utils.ObjectFloatMap<? extends K>)"""
        val = _ObjectFloatMap(arg0)
        self.__wrapper = val

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap.isEmpty()"""
        return bool._wrap(super(ObjectFloatMap, self).isEmpty())

    @overload
    def keys(self) -> 'Keys':
        """public com.badlogic.gdx.utils.ObjectFloatMap$Keys<K> com.badlogic.gdx.utils.ObjectFloatMap.keys()"""
        return 'Keys'._wrap(super(ObjectFloatMap, self).keys())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, arg0: object, arg1: float, arg2: float) -> float:
        """public float com.badlogic.gdx.utils.ObjectFloatMap.put(K,float,float)"""
        return float._wrap(super(_ObjectFloatMap, self).put(arg0, _float.valueOf(arg1), _float.valueOf(arg2)))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.badlogic.gdx.utils.ObjectFloatMap.hashCode()"""
        return int._wrap(super(ObjectFloatMap, self).hashCode())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def get(self, arg0: object, arg1: float) -> float:
        """public float com.badlogic.gdx.utils.ObjectFloatMap.get(K,float)"""
        return float._wrap(super(_ObjectFloatMap, self).get(arg0, _float.valueOf(arg1)))

    @overload
    def toString(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.ObjectFloatMap.toString(java.lang.String)"""
        return str._wrap(super(_ObjectFloatMap, self).toString(arg0))

    @overload
    def __init__(self, arg0: int):
        """public com.badlogic.gdx.utils.ObjectFloatMap(int)"""
        val = _ObjectFloatMap(_int.valueOf(arg0))
        self.__wrapper = val

    @overload
    def putAll(self, arg0: 'ObjectFloatMap'):
        """public void com.badlogic.gdx.utils.ObjectFloatMap.putAll(com.badlogic.gdx.utils.ObjectFloatMap<? extends K>)"""
        super(_ObjectFloatMap, self).putAll(arg0)

    @overload
    def containsValue(self, arg0: float, arg1: float) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap.containsValue(float,float)"""
        return bool._wrap(super(_ObjectFloatMap, self).containsValue(_float.valueOf(arg0), _float.valueOf(arg1)))

    @overload
    def put(self, arg0: object, arg1: float):
        """public void com.badlogic.gdx.utils.ObjectFloatMap.put(K,float)"""
        super(_ObjectFloatMap, self).put(arg0, _float.valueOf(arg1))

    @overload
    def findKey(self, arg0: float) -> object:
        """public K com.badlogic.gdx.utils.ObjectFloatMap.findKey(float)"""
        return object._wrap(super(_ObjectFloatMap, self).findKey(_float.valueOf(arg0)))

    @overload
    def clear(self):
        """public void com.badlogic.gdx.utils.ObjectFloatMap.clear()"""
        super(ObjectFloatMap, self).clear()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ObjectFloatMap, self).equals(arg0))

    @overload
    def entries(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectFloatMap$Entries<K> com.badlogic.gdx.utils.ObjectFloatMap.entries()"""
        return 'Entries'._wrap(super(ObjectFloatMap, self).entries())

    @overload
    def shrink(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectFloatMap.shrink(int)"""
        super(_ObjectFloatMap, self).shrink(_int.valueOf(arg0))

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.ObjectFloatMap()"""
        val = _ObjectFloatMap()
        self.__wrapper = val

    @overload
    def values(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectFloatMap$Values com.badlogic.gdx.utils.ObjectFloatMap.values()"""
        return 'Values'._wrap(super(ObjectFloatMap, self).values())

    @overload
    def containsKey(self, arg0: object) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap.containsKey(K)"""
        return bool._wrap(super(_ObjectFloatMap, self).containsKey(arg0))

    @overload
    def ensureCapacity(self, arg0: int):
        """public void com.badlogic.gdx.utils.ObjectFloatMap.ensureCapacity(int)"""
        super(_ObjectFloatMap, self).ensureCapacity(_int.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def notEmpty(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectFloatMap.notEmpty()"""
        return bool._wrap(super(ObjectFloatMap, self).notEmpty())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def iterator(self) -> 'Entries':
        """public com.badlogic.gdx.utils.ObjectFloatMap$Entries<K> com.badlogic.gdx.utils.ObjectFloatMap.iterator()"""
        return 'Entries'._wrap(super(ObjectFloatMap, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.badlogic.gdx.utils.Json
from pyquantum_helper import import_once as _import_once
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import com.badlogic.gdx.utils.Json as _Json
_Json = _Json
import java.lang.String as _String
_String = _String
from builtins import object
try:
    from pygdx.utils import reflect
except ImportError:
    reflect = _import_once("pygdx.utils.reflect")

import java.lang.String as _string
import com.badlogic.gdx.utils.Json as _Json_Serializer
_Serializer = _Json_Serializer.Serializer
import java.lang.Boolean as _boolean
import java.lang.Integer as _int
import com.badlogic.gdx.utils.JsonWriter as _JsonWriter
_JsonWriter = _JsonWriter
import java.io.Reader as Reader
import java.io.Writer as Writer
import java.io.InputStream as InputStream
try:
    from pygdx import files
except ImportError:
    files = _import_once("pygdx.files")

from builtins import bool
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
from builtins import int
 
class Json():
    """com.badlogic.gdx.utils.Json"""
 
    @staticmethod
    def _wrap(java_value: _Json) -> 'Json':
        return Json(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Json):
        """
        Dynamic initializer for Json.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Json__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Json__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def writeObjectStart(self, arg0: str, arg1: 'Class', arg2: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeObjectStart(java.lang.String,java.lang.Class,java.lang.Class)"""
        super(_Json, self).writeObjectStart(arg0, arg1, arg2)

    @overload
    def writeObjectStart(self, arg0: str):
        """public void com.badlogic.gdx.utils.Json.writeObjectStart(java.lang.String)"""
        super(_Json, self).writeObjectStart(arg0)

    @overload
    def getClass(self, arg0: str) -> 'type.Class':
        """public java.lang.Class com.badlogic.gdx.utils.Json.getClass(java.lang.String)"""
        return 'type.Class'._wrap(super(_Json, self).getClass(arg0))

    @overload
    def prettyPrint(self, arg0: object) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.prettyPrint(java.lang.Object)"""
        return str._wrap(super(_Json, self).prettyPrint(arg0))

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'char', arg2: int, arg3: int) -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,char[],int,int)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1, _int.valueOf(arg2), _int.valueOf(arg3)))

    @overload
    def getSerializer(self, arg0: 'Class') -> 'Serializer':
        """public <T> com.badlogic.gdx.utils.Json$Serializer<T> com.badlogic.gdx.utils.Json.getSerializer(java.lang.Class<T>)"""
        return 'Serializer'._wrap(super(_Json, self).getSerializer(arg0))

    @overload
    def writeArrayStart(self):
        """public void com.badlogic.gdx.utils.Json.writeArrayStart()"""
        super(Json, self).writeArrayStart()

    @overload
    def readFields(self, arg0: object, arg1: 'JsonValue'):
        """public void com.badlogic.gdx.utils.Json.readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue)"""
        super(_Json, self).readFields(arg0, arg1)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def prettyPrint(self, arg0: object, arg1: int) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.prettyPrint(java.lang.Object,int)"""
        return str._wrap(super(_Json, self).prettyPrint(arg0, _int.valueOf(arg1)))

    @overload
    def setEnumNames(self, arg0: bool):
        """public void com.badlogic.gdx.utils.Json.setEnumNames(boolean)"""
        super(_Json, self).setEnumNames(_boolean.valueOf(arg0))

    @overload
    def setUsePrototypes(self, arg0: bool):
        """public void com.badlogic.gdx.utils.Json.setUsePrototypes(boolean)"""
        super(_Json, self).setUsePrototypes(_boolean.valueOf(arg0))

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'Reader') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,java.io.Reader)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def getIgnoreUnknownFields(self) -> bool:
        """public boolean com.badlogic.gdx.utils.Json.getIgnoreUnknownFields()"""
        return bool._wrap(super(Json, self).getIgnoreUnknownFields())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'InputStream') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,java.io.InputStream)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1))

    @overload
    def toJson(self, arg0: object, arg1: 'FileHandle'):
        """public void com.badlogic.gdx.utils.Json.toJson(java.lang.Object,com.badlogic.gdx.files.FileHandle)"""
        super(_Json, self).toJson(arg0, arg1)

    @overload
    def writeValue(self, arg0: object):
        """public void com.badlogic.gdx.utils.Json.writeValue(java.lang.Object)"""
        super(_Json, self).writeValue(arg0)

    @overload
    def writeObjectStart(self):
        """public void com.badlogic.gdx.utils.Json.writeObjectStart()"""
        super(Json, self).writeObjectStart()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @overload
    def setReadDeprecated(self, arg0: bool):
        """public void com.badlogic.gdx.utils.Json.setReadDeprecated(boolean)"""
        super(_Json, self).setReadDeprecated(_boolean.valueOf(arg0))

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'Class', arg2: 'InputStream') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,java.lang.Class,java.io.InputStream)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1, arg2))

    @overload
    def readField(self, arg0: object, arg1: str, arg2: str, arg3: 'JsonValue'):
        """public void com.badlogic.gdx.utils.Json.readField(java.lang.Object,java.lang.String,java.lang.String,com.badlogic.gdx.utils.JsonValue)"""
        super(_Json, self).readField(arg0, arg1, arg2, arg3)

    @overload
    def setIgnoreDeprecated(self, arg0: bool):
        """public void com.badlogic.gdx.utils.Json.setIgnoreDeprecated(boolean)"""
        super(_Json, self).setIgnoreDeprecated(_boolean.valueOf(arg0))

    @overload
    def writeValue(self, arg0: str, arg1: object):
        """public void com.badlogic.gdx.utils.Json.writeValue(java.lang.String,java.lang.Object)"""
        super(_Json, self).writeValue(arg0, arg1)

    @overload
    def readField(self, arg0: object, arg1: str, arg2: str, arg3: 'Class', arg4: 'JsonValue'):
        """public void com.badlogic.gdx.utils.Json.readField(java.lang.Object,java.lang.String,java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue)"""
        super(_Json, self).readField(arg0, arg1, arg2, arg3, arg4)

    @overload
    def setQuoteLongValues(self, arg0: bool):
        """public void com.badlogic.gdx.utils.Json.setQuoteLongValues(boolean)"""
        super(_Json, self).setQuoteLongValues(_boolean.valueOf(arg0))

    @overload
    def writeValue(self, arg0: str, arg1: object, arg2: 'Class', arg3: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeValue(java.lang.String,java.lang.Object,java.lang.Class,java.lang.Class)"""
        super(_Json, self).writeValue(arg0, arg1, arg2, arg3)

    @overload
    def toJson(self, arg0: object, arg1: 'Writer'):
        """public void com.badlogic.gdx.utils.Json.toJson(java.lang.Object,java.io.Writer)"""
        super(_Json, self).toJson(arg0, arg1)

    @overload
    def toJson(self, arg0: object, arg1: 'Class', arg2: 'Class') -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.toJson(java.lang.Object,java.lang.Class,java.lang.Class)"""
        return str._wrap(super(_Json, self).toJson(arg0, arg1, arg2))

    @overload
    def writeValue(self, arg0: str, arg1: object, arg2: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeValue(java.lang.String,java.lang.Object,java.lang.Class)"""
        super(_Json, self).writeValue(arg0, arg1, arg2)

    @overload
    def setOutputType(self, arg0: 'OutputType'):
        """public void com.badlogic.gdx.utils.Json.setOutputType(com.badlogic.gdx.utils.JsonWriter$OutputType)"""
        super(_Json, self).setOutputType(arg0)

    @overload
    def readValue(self, arg0: str, arg1: 'Class', arg2: 'Class', arg3: object, arg4: 'JsonValue') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.readValue(java.lang.String,java.lang.Class<T>,java.lang.Class,T,com.badlogic.gdx.utils.JsonValue)"""
        return object._wrap(super(_Json, self).readValue(arg0, arg1, arg2, arg3, arg4))

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'FileHandle') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,com.badlogic.gdx.files.FileHandle)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'Class', arg2: 'Reader') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,java.lang.Class,java.io.Reader)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1, arg2))

    @overload
    def writeArrayEnd(self):
        """public void com.badlogic.gdx.utils.Json.writeArrayEnd()"""
        super(Json, self).writeArrayEnd()

    @overload
    def writeType(self, arg0: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeType(java.lang.Class)"""
        super(_Json, self).writeType(arg0)

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'Class', arg2: 'FileHandle') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,java.lang.Class,com.badlogic.gdx.files.FileHandle)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1, arg2))

    @overload
    def writeArrayStart(self, arg0: str):
        """public void com.badlogic.gdx.utils.Json.writeArrayStart(java.lang.String)"""
        super(_Json, self).writeArrayStart(arg0)

    @overload
    def copyFields(self, arg0: object, arg1: object):
        """public void com.badlogic.gdx.utils.Json.copyFields(java.lang.Object,java.lang.Object)"""
        super(_Json, self).copyFields(arg0, arg1)

    @overload
    def getTag(self, arg0: 'Class') -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.getTag(java.lang.Class)"""
        return str._wrap(super(_Json, self).getTag(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def setSerializer(self, arg0: 'Class', arg1: 'Serializer'):
        """public <T> void com.badlogic.gdx.utils.Json.setSerializer(java.lang.Class<T>,com.badlogic.gdx.utils.Json$Serializer<T>)"""
        super(_Json, self).setSerializer(arg0, arg1)

    @overload
    def readField(self, arg0: object, arg1: str, arg2: 'Class', arg3: 'JsonValue'):
        """public void com.badlogic.gdx.utils.Json.readField(java.lang.Object,java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue)"""
        super(_Json, self).readField(arg0, arg1, arg2, arg3)

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def writeField(self, arg0: object, arg1: str, arg2: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeField(java.lang.Object,java.lang.String,java.lang.Class)"""
        super(_Json, self).writeField(arg0, arg1, arg2)

    @overload
    def writeObjectEnd(self):
        """public void com.badlogic.gdx.utils.Json.writeObjectEnd()"""
        super(Json, self).writeObjectEnd()

    @overload
    def writeObjectStart(self, arg0: 'Class', arg1: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeObjectStart(java.lang.Class,java.lang.Class)"""
        super(_Json, self).writeObjectStart(arg0, arg1)

    @overload
    def __init__(self, ):
        """public com.badlogic.gdx.utils.Json()"""
        val = _Json()
        self.__wrapper = val

    @overload
    def toJson(self, arg0: object, arg1: 'Class', arg2: 'Class', arg3: 'Writer'):
        """public void com.badlogic.gdx.utils.Json.toJson(java.lang.Object,java.lang.Class,java.lang.Class,java.io.Writer)"""
        super(_Json, self).toJson(arg0, arg1, arg2, arg3)

    @overload
    def setDeprecated(self, arg0: 'Class', arg1: str, arg2: bool):
        """public void com.badlogic.gdx.utils.Json.setDeprecated(java.lang.Class,java.lang.String,boolean)"""
        super(_Json, self).setDeprecated(arg0, arg1, _boolean.valueOf(arg2))

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'Class', arg2: 'char', arg3: int, arg4: int) -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,java.lang.Class,char[],int,int)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1, arg2, _int.valueOf(arg3), _int.valueOf(arg4)))

    @overload
    def toJson(self, arg0: object, arg1: 'Class') -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.toJson(java.lang.Object,java.lang.Class)"""
        return str._wrap(super(_Json, self).toJson(arg0, arg1))

    @overload
    def __init__(self, arg0: 'OutputType'):
        """public com.badlogic.gdx.utils.Json(com.badlogic.gdx.utils.JsonWriter$OutputType)"""
        val = _Json(arg0)
        self.__wrapper = val

    @overload
    def writeFields(self, arg0: object):
        """public void com.badlogic.gdx.utils.Json.writeFields(java.lang.Object)"""
        super(_Json, self).writeFields(arg0)

    @overload
    def setSortFields(self, arg0: bool):
        """public void com.badlogic.gdx.utils.Json.setSortFields(boolean)"""
        super(_Json, self).setSortFields(_boolean.valueOf(arg0))

    @overload
    def setTypeName(self, arg0: str):
        """public void com.badlogic.gdx.utils.Json.setTypeName(java.lang.String)"""
        super(_Json, self).setTypeName(arg0)

    @overload
    def writeField(self, arg0: object, arg1: str, arg2: str):
        """public void com.badlogic.gdx.utils.Json.writeField(java.lang.Object,java.lang.String,java.lang.String)"""
        super(_Json, self).writeField(arg0, arg1, arg2)

    @overload
    def readValue(self, arg0: 'Class', arg1: 'Class', arg2: 'JsonValue') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.readValue(java.lang.Class<T>,java.lang.Class,com.badlogic.gdx.utils.JsonValue)"""
        return object._wrap(super(_Json, self).readValue(arg0, arg1, arg2))

    @overload
    def readValue(self, arg0: str, arg1: 'Class', arg2: 'JsonValue') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.readValue(java.lang.String,java.lang.Class<T>,com.badlogic.gdx.utils.JsonValue)"""
        return object._wrap(super(_Json, self).readValue(arg0, arg1, arg2))

    @overload
    def prettyPrint(self, arg0: object, arg1: 'PrettyPrintSettings') -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.prettyPrint(java.lang.Object,com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings)"""
        return str._wrap(super(_Json, self).prettyPrint(arg0, arg1))

    @overload
    def getWriter(self) -> 'JsonWriter':
        """public com.badlogic.gdx.utils.JsonWriter com.badlogic.gdx.utils.Json.getWriter()"""
        return 'JsonWriter'._wrap(super(Json, self).getWriter())

    @overload
    def addClassTag(self, arg0: str, arg1: 'Class'):
        """public void com.badlogic.gdx.utils.Json.addClassTag(java.lang.String,java.lang.Class)"""
        super(_Json, self).addClassTag(arg0, arg1)

    @overload
    def toJson(self, arg0: object, arg1: 'Class', arg2: 'Class', arg3: 'FileHandle'):
        """public void com.badlogic.gdx.utils.Json.toJson(java.lang.Object,java.lang.Class,java.lang.Class,com.badlogic.gdx.files.FileHandle)"""
        super(_Json, self).toJson(arg0, arg1, arg2, arg3)

    @overload
    def readField(self, arg0: object, arg1: 'Field', arg2: str, arg3: 'Class', arg4: 'JsonValue'):
        """public void com.badlogic.gdx.utils.Json.readField(java.lang.Object,com.badlogic.gdx.utils.reflect.Field,java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue)"""
        super(_Json, self).readField(arg0, arg1, arg2, arg3, arg4)

    @overload
    def writeField(self, arg0: object, arg1: str, arg2: str, arg3: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeField(java.lang.Object,java.lang.String,java.lang.String,java.lang.Class)"""
        super(_Json, self).writeField(arg0, arg1, arg2, arg3)

    @overload
    def writeField(self, arg0: object, arg1: str):
        """public void com.badlogic.gdx.utils.Json.writeField(java.lang.Object,java.lang.String)"""
        super(_Json, self).writeField(arg0, arg1)

    @overload
    def readValue(self, arg0: str, arg1: 'Class', arg2: 'Class', arg3: 'JsonValue') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.readValue(java.lang.String,java.lang.Class<T>,java.lang.Class,com.badlogic.gdx.utils.JsonValue)"""
        return object._wrap(super(_Json, self).readValue(arg0, arg1, arg2, arg3))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def toJson(self, arg0: object, arg1: 'Class', arg2: 'Writer'):
        """public void com.badlogic.gdx.utils.Json.toJson(java.lang.Object,java.lang.Class,java.io.Writer)"""
        super(_Json, self).toJson(arg0, arg1, arg2)

    @overload
    def readValue(self, arg0: 'Class', arg1: 'JsonValue') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.readValue(java.lang.Class<T>,com.badlogic.gdx.utils.JsonValue)"""
        return object._wrap(super(_Json, self).readValue(arg0, arg1))

    @overload
    def toJson(self, arg0: object, arg1: 'Class', arg2: 'FileHandle'):
        """public void com.badlogic.gdx.utils.Json.toJson(java.lang.Object,java.lang.Class,com.badlogic.gdx.files.FileHandle)"""
        super(_Json, self).toJson(arg0, arg1, arg2)

    @overload
    def setIgnoreUnknownFields(self, arg0: bool):
        """public void com.badlogic.gdx.utils.Json.setIgnoreUnknownFields(boolean)"""
        super(_Json, self).setIgnoreUnknownFields(_boolean.valueOf(arg0))

    @overload
    def fromJson(self, arg0: 'Class', arg1: str) -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,java.lang.String)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1))

    @overload
    def setDefaultSerializer(self, arg0: 'Serializer'):
        """public void com.badlogic.gdx.utils.Json.setDefaultSerializer(com.badlogic.gdx.utils.Json$Serializer)"""
        super(_Json, self).setDefaultSerializer(arg0)

    @overload
    def writeValue(self, arg0: object, arg1: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeValue(java.lang.Object,java.lang.Class)"""
        super(_Json, self).writeValue(arg0, arg1)

    @overload
    def writeValue(self, arg0: object, arg1: 'Class', arg2: 'Class'):
        """public void com.badlogic.gdx.utils.Json.writeValue(java.lang.Object,java.lang.Class,java.lang.Class)"""
        super(_Json, self).writeValue(arg0, arg1, arg2)

    @overload
    def __init__(self):
        """public com.badlogic.gdx.utils.Json()"""
        val = _Json()
        self.__wrapper = val

    @overload
    def prettyPrint(self, arg0: str, arg1: 'PrettyPrintSettings') -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.prettyPrint(java.lang.String,com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings)"""
        return str._wrap(super(_Json, self).prettyPrint(arg0, arg1))

    @overload
    def readField(self, arg0: object, arg1: str, arg2: 'JsonValue'):
        """public void com.badlogic.gdx.utils.Json.readField(java.lang.Object,java.lang.String,com.badlogic.gdx.utils.JsonValue)"""
        super(_Json, self).readField(arg0, arg1, arg2)

    @overload
    def readValue(self, arg0: 'Class', arg1: 'Class', arg2: object, arg3: 'JsonValue') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.readValue(java.lang.Class<T>,java.lang.Class,T,com.badlogic.gdx.utils.JsonValue)"""
        return object._wrap(super(_Json, self).readValue(arg0, arg1, arg2, arg3))

    @overload
    def prettyPrint(self, arg0: str, arg1: int) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.prettyPrint(java.lang.String,int)"""
        return str._wrap(super(_Json, self).prettyPrint(arg0, _int.valueOf(arg1)))

    @overload
    def setWriter(self, arg0: 'Writer'):
        """public void com.badlogic.gdx.utils.Json.setWriter(java.io.Writer)"""
        super(_Json, self).setWriter(arg0)

    @overload
    def fromJson(self, arg0: 'Class', arg1: 'Class', arg2: str) -> object:
        """public <T> T com.badlogic.gdx.utils.Json.fromJson(java.lang.Class<T>,java.lang.Class,java.lang.String)"""
        return object._wrap(super(_Json, self).fromJson(arg0, arg1, arg2))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def readValue(self, arg0: str, arg1: 'Class', arg2: object, arg3: 'JsonValue') -> object:
        """public <T> T com.badlogic.gdx.utils.Json.readValue(java.lang.String,java.lang.Class<T>,T,com.badlogic.gdx.utils.JsonValue)"""
        return object._wrap(super(_Json, self).readValue(arg0, arg1, arg2, arg3))

    @overload
    def toJson(self, arg0: object) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.toJson(java.lang.Object)"""
        return str._wrap(super(_Json, self).toJson(arg0))

    @overload
    def prettyPrint(self, arg0: str) -> str:
        """public java.lang.String com.badlogic.gdx.utils.Json.prettyPrint(java.lang.String)"""
        return str._wrap(super(_Json, self).prettyPrint(arg0))

    @overload
    def setElementType(self, arg0: 'Class', arg1: str, arg2: 'Class'):
        """public void com.badlogic.gdx.utils.Json.setElementType(java.lang.Class,java.lang.String,java.lang.Class)"""
        super(_Json, self).setElementType(arg0, arg1, arg2) 
 
 
# CLASS: com.badlogic.gdx.utils.ObjectLongMap$Values
from builtins import str
import com.badlogic.gdx.utils.ObjectLongMap as _ObjectLongMap_Values
_Values = _ObjectLongMap_Values.Values
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.badlogic.gdx.utils.LongArray as _LongArray
_LongArray = _LongArray
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Values():
    """com.badlogic.gdx.utils.ObjectLongMap.Values"""
 
    @staticmethod
    def _wrap(java_value: _Values) -> 'Values':
        return Values(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Values):
        """
        Dynamic initializer for Values.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Values__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Values__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def next(self) -> int:
        """public long com.badlogic.gdx.utils.ObjectLongMap$Values.next()"""
        return int._wrap(super(Values, self).next())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def toArray(self, arg0: 'LongArray') -> 'LongArray':
        """public com.badlogic.gdx.utils.LongArray com.badlogic.gdx.utils.ObjectLongMap$Values.toArray(com.badlogic.gdx.utils.LongArray)"""
        return 'LongArray'._wrap(super(_Values, self).toArray(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def iterator(self) -> 'Values':
        """public com.badlogic.gdx.utils.ObjectLongMap$Values com.badlogic.gdx.utils.ObjectLongMap$Values.iterator()"""
        return 'Values'._wrap(super(Values, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def hasNext(self) -> bool:
        """public boolean com.badlogic.gdx.utils.ObjectLongMap$Values.hasNext()"""
        return bool._wrap(super(Values, self).hasNext())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, arg0: 'ObjectLongMap'):
        """public com.badlogic.gdx.utils.ObjectLongMap$Values(com.badlogic.gdx.utils.ObjectLongMap<?>)"""
        val = _Values(arg0)
        self.__wrapper = val

    @overload
    def toArray(self) -> 'LongArray':
        """public com.badlogic.gdx.utils.LongArray com.badlogic.gdx.utils.ObjectLongMap$Values.toArray()"""
        return 'LongArray'._wrap(super(Values, self).toArray())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())