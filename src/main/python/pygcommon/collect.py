from __future__ import annotations
from overload import overload


 
import com.google.common.collect.ForwardingSortedSet as _ForwardingSortedSet
_ForwardingSortedSet = _ForwardingSortedSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import com.google.common.collect.ForwardingSet as _ForwardingSet
_ForwardingSet = _ForwardingSet
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingSortedSet():
    """com.google.common.collect.ForwardingSortedSet"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingSortedSet) -> 'ForwardingSortedSet':
        return ForwardingSortedSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingSortedSet):
        """
        Dynamic initializer for ForwardingSortedSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingSortedSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingSortedSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.SortedSet.removeFirst()"""
        return object._wrap(super(SortedSet, self).removeFirst())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingSet, self).equals(object))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ForwardingSortedSet.comparator()"""
        return 'Comparator'._wrap(super(ForwardingSortedSet, self).comparator())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int._wrap(super(ForwardingSet, self).hashCode())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.last()"""
        return object._wrap(super(ForwardingSortedSet, self).last())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.headSet(E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).headSet(toElement))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.subSet(E,E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).subSet(fromElement, toElement))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(SortedSet, self).spliterator())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.SortedSet.removeLast()"""
        return object._wrap(super(SortedSet, self).removeLast())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.tailSet(E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).tailSet(fromElement))

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def reversed(self) -> 'SortedSet':
        """public default java.util.SortedSet<E> java.util.SortedSet.reversed()"""
        return 'SortedSet'._wrap(super(SortedSet, self).reversed())

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.first()"""
        return object._wrap(super(ForwardingSortedSet, self).first())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

 
 
 
# CLASS: com.google.common.collect.ForwardingSortedSet
import com.google.common.collect.ForwardingSortedSet as _ForwardingSortedSet
_ForwardingSortedSet = _ForwardingSortedSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import com.google.common.collect.ForwardingSet as _ForwardingSet
_ForwardingSet = _ForwardingSet
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingSortedSet():
    """com.google.common.collect.ForwardingSortedSet"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingSortedSet) -> 'ForwardingSortedSet':
        return ForwardingSortedSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingSortedSet):
        """
        Dynamic initializer for ForwardingSortedSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingSortedSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingSortedSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.SortedSet.removeFirst()"""
        return object._wrap(super(SortedSet, self).removeFirst())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingSet, self).equals(object))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ForwardingSortedSet.comparator()"""
        return 'Comparator'._wrap(super(ForwardingSortedSet, self).comparator())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int._wrap(super(ForwardingSet, self).hashCode())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.last()"""
        return object._wrap(super(ForwardingSortedSet, self).last())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.headSet(E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).headSet(toElement))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.subSet(E,E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).subSet(fromElement, toElement))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(SortedSet, self).spliterator())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.SortedSet.removeLast()"""
        return object._wrap(super(SortedSet, self).removeLast())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.tailSet(E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).tailSet(fromElement))

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def reversed(self) -> 'SortedSet':
        """public default java.util.SortedSet<E> java.util.SortedSet.reversed()"""
        return 'SortedSet'._wrap(super(SortedSet, self).reversed())

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.first()"""
        return object._wrap(super(ForwardingSortedSet, self).first())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

 
 
 
# CLASS: com.google.common.collect.ForwardingSortedSet 
 
 
# CLASS: com.google.common.collect.ForwardingSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import com.google.common.collect.ForwardingSet as _ForwardingSet
_ForwardingSet = _ForwardingSet
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingSet():
    """com.google.common.collect.ForwardingSet"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingSet) -> 'ForwardingSet':
        return ForwardingSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingSet):
        """
        Dynamic initializer for ForwardingSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingSet, self).equals(object))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int._wrap(super(ForwardingSet, self).hashCode())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'._wrap(super(Set, self).spliterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedMap
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.ImmutableMap as _ImmutableMap_Builder
_Builder = _ImmutableMap_Builder.Builder
from builtins import type
import java.util.SequencedSet as _SequencedSet
_SequencedSet = _SequencedSet
import java.util.NavigableMap as NavigableMap
import java.util.SequencedCollection as SequencedCollection
import java.util.Map.Entry as Entry
import java.lang.Boolean as _boolean
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import java.util.function.BinaryOperator as BinaryOperator
import java.util.SortedMap as _SortedMap
_SortedMap = _SortedMap
import java.util.NavigableMap as _NavigableMap
_NavigableMap = _NavigableMap
import java.util.SortedMap as SortedMap
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
import java.util.SequencedSet as SequencedSet
from builtins import bool
import java.util.SequencedMap as _SequencedMap
_SequencedMap = _SequencedMap
from builtins import str
from pyquantum_helper import override
import java.util.SequencedCollection as _SequencedCollection
_SequencedCollection = _SequencedCollection
import java.lang.Object as _object
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.Comparable as Comparable
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import com.google.common.collect.ImmutableSetMultimap as _ImmutableSetMultimap
_ImmutableSetMultimap = _ImmutableSetMultimap
import java.util.function.BiFunction as BiFunction
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
import java.util.Comparator as Comparator
import java.util.function.BiConsumer as BiConsumer
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.Map as _Map_Entry
_Entry = _Map_Entry.Entry
import com.google.common.collect.ImmutableSortedMap as _ImmutableSortedMap
_ImmutableSortedMap = _ImmutableSortedMap
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet
_ImmutableSortedSet = _ImmutableSortedSet
import java.util.function.Function as Function
import java.util.Map as Map
import com.google.common.collect.ImmutableSortedMap as _ImmutableSortedMap_Builder
_Builder = _ImmutableSortedMap_Builder.Builder
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableSortedMap():
    """com.google.common.collect.ImmutableSortedMap"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableSortedMap) -> 'ImmutableSortedMap':
        return ImmutableSortedMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableSortedMap):
        """
        Dynamic initializer for ImmutableSortedMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableSortedMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableSortedMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ImmutableSortedMap.size()"""
        return int._wrap(super(ImmutableSortedMap, self).size())

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableSortedMap.entrySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableSortedMap, self).entrySet())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.copyOf(map))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2))

    @overload
    def lowerKey(self, key: object) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.lowerKey(K)"""
        return object._wrap(super(_ImmutableSortedMap, self).lowerKey(key))

    @overload
    def floorKey(self, key: object) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.floorKey(K)"""
        return object._wrap(super(_ImmutableSortedMap, self).floorKey(key))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @overload
    def lowerEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.lowerEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ImmutableSortedMap, self).lowerEntry(key))

    @overload
    def headMap(self, toKey: object, inclusive: bool) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.headMap(K,boolean)"""
        return 'ImmutableSortedMap'._wrap(super(_ImmutableSortedMap, self).headMap(toKey, _boolean.valueOf(inclusive)))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @override
    @overload
    def lastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.lastEntry()"""
        return 'Entry.Map$Entry'._wrap(super(ImmutableSortedMap, self).lastEntry())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object, k7: 'Comparable', v7: object, k8: 'Comparable', v8: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @overload
    def computeIfAbsent(self, key: object, mappingFunction: 'Function') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).computeIfAbsent(key, mappingFunction))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMap.clear()"""
        super(ImmutableMap, self).clear()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3))

    @override
    @overload
    def firstKey(self) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.firstKey()"""
        return object._wrap(super(ImmutableSortedMap, self).firstKey())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable', comparator: 'Comparator') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>,java.util.Comparator<? super K>)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.copyOf(entries, comparator))

    @overload
    def putLast(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putLast(K,V)"""
        return object._wrap(super(_SortedMap, self).putLast(arg0, arg1))

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableMap._wrap(_ImmutableMap.ofEntries(entries))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMap.hashCode()"""
        return int._wrap(super(ImmutableMap, self).hashCode())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMap.toString()"""
        return str._wrap(super(ImmutableMap, self).toString())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).remove(key, value))

    @overload
    def putFirst(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putFirst(K,V)"""
        return object._wrap(super(_SortedMap, self).putFirst(arg0, arg1))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1))

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public final void com.google.common.collect.ImmutableMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ImmutableMap, self).putAll(map)

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableMap.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).containsKey(key))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object, k7: 'Comparable', v7: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @staticmethod
    @overload
    def reverseOrder() -> 'Builder':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.reverseOrder()"""
        return Builder._wrap(_ImmutableSortedMap.reverseOrder())

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableSortedMap.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.ofEntries(entries))

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableSortedMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableSortedMap.toImmutableMap(keyFunction, valueFunction))

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public final void com.google.common.collect.ImmutableMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_ImmutableMap, self).replaceAll(function)

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.isEmpty()"""
        return bool._wrap(super(ImmutableMap, self).isEmpty())

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object, k7: 'Comparable', v7: object, k8: 'Comparable', v8: object, k9: 'Comparable', v9: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @override
    @overload
    def descendingMap(self) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.descendingMap()"""
        return 'ImmutableSortedMap'._wrap(super(ImmutableSortedMap, self).descendingMap())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3))

    @overload
    def merge(self, key: object, value: object, function: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).merge(key, value, function))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableMap._wrap(_ImmutableMap.copyOf(map))

    @overload
    def remove(self, o: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.remove(java.lang.Object)"""
        return object._wrap(super(_ImmutableMap, self).remove(o))

    @override
    @overload
    def asMultimap(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableMap.asMultimap()"""
        return 'ImmutableSetMultimap'._wrap(super(ImmutableMap, self).asMultimap())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def headMap(self, toKey: object) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.headMap(K)"""
        return 'ImmutableSortedMap'._wrap(super(_ImmutableSortedMap, self).headMap(toKey))

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.orderedBy(java.util.Comparator<K>)"""
        return Builder._wrap(_ImmutableSortedMap.orderedBy(comparator))

    @override
    @overload
    def sequencedValues(self) -> 'SequencedCollection':
        """public default java.util.SequencedCollection<V> java.util.SequencedMap.sequencedValues()"""
        return 'SequencedCollection'._wrap(super(SequencedMap, self).sequencedValues())

    @override
    @overload
    def reversed(self) -> 'NavigableMap':
        """public default java.util.NavigableMap<K, V> java.util.NavigableMap.reversed()"""
        return 'NavigableMap'._wrap(super(NavigableMap, self).reversed())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2))

    @override
    @overload
    def navigableKeySet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<K> com.google.common.collect.ImmutableSortedMap.navigableKeySet()"""
        return 'ImmutableSortedSet'._wrap(super(ImmutableSortedMap, self).navigableKeySet())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).equals(object))

    @overload
    def ceilingKey(self, key: object) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.ceilingKey(K)"""
        return object._wrap(super(_ImmutableSortedMap, self).ceilingKey(key))

    @overload
    def higherEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.higherEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ImmutableSortedMap, self).higherEntry(key))

    @overload
    def replace(self, key: object, oldValue: object, newValue: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.replace(K,V,V)"""
        return bool._wrap(super(_ImmutableMap, self).replace(key, oldValue, newValue))

    @staticmethod
    @overload
    def of() -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of()"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builder()"""
        return Builder._wrap(_ImmutableMap.builder())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def higherKey(self, key: object) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.higherKey(K)"""
        return object._wrap(super(_ImmutableSortedMap, self).higherKey(key))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @overload
    def subMap(self, fromKey: object, toKey: object) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.subMap(K,K)"""
        return 'ImmutableSortedMap'._wrap(super(_ImmutableSortedMap, self).subMap(fromKey, toKey))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.copyOf(entries))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ImmutableSortedMap.get(java.lang.Object)"""
        return object._wrap(super(_ImmutableSortedMap, self).get(key))

    @staticmethod
    @overload
    def toImmutableSortedMap(comparator: 'Comparator', keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSortedMap<K, V>> com.google.common.collect.ImmutableSortedMap.toImmutableSortedMap(java.util.Comparator<? super K>,java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector._wrap(_ImmutableSortedMap.toImmutableSortedMap(comparator, keyFunction, valueFunction, mergeFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1))

    @override
    @overload
    def descendingKeySet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<K> com.google.common.collect.ImmutableSortedMap.descendingKeySet()"""
        return 'ImmutableSortedSet'._wrap(super(ImmutableSortedMap, self).descendingKeySet())

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMap._wrap(_ImmutableMap.copyOf(entries))

    @staticmethod
    @overload
    def of() -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of()"""
        return ImmutableMap._wrap(_ImmutableMap.of())

    @override
    @overload
    def pollLastEntry(self) -> 'Entry.Map$Entry':
        """public final java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.pollLastEntry()"""
        return 'Entry.Map$Entry'._wrap(super(ImmutableSortedMap, self).pollLastEntry())

    @staticmethod
    @overload
    def copyOf(map: 'Map', comparator: 'Comparator') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOf(java.util.Map<? extends K, ? extends V>,java.util.Comparator<? super K>)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.copyOf(map, comparator))

    @override
    @overload
    def sequencedEntrySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<java.util.Map$Entry<K, V>> java.util.SequencedMap.sequencedEntrySet()"""
        return 'SequencedSet'._wrap(super(SequencedMap, self).sequencedEntrySet())

    @overload
    def replace(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.replace(K,V)"""
        return object._wrap(super(_ImmutableMap, self).replace(key, value))

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableSortedMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector._wrap(_ImmutableSortedMap.toImmutableMap(keyFunction, valueFunction, mergeFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2))

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.ImmutableSortedMap.comparator()"""
        return 'Comparator'._wrap(super(ImmutableSortedMap, self).comparator())

    @overload
    def compute(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).compute(key, remappingFunction))

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry.Map$Entry':
        """public final java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.pollFirstEntry()"""
        return 'Entry.Map$Entry'._wrap(super(ImmutableSortedMap, self).pollFirstEntry())

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.ImmutableSortedMap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_ImmutableSortedMap, self).forEach(action)

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object, k7: 'Comparable', v7: object, k8: 'Comparable', v8: object, k9: 'Comparable', v9: object, k10: 'Comparable', v10: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @override
    @overload
    def lastKey(self) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.lastKey()"""
        return object._wrap(super(ImmutableSortedMap, self).lastKey())

    @staticmethod
    @overload
    def copyOfSorted(map: 'SortedMap') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOfSorted(java.util.SortedMap<K, ? extends V>)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.copyOfSorted(map))

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableSortedMap.values()"""
        return 'ImmutableCollection'._wrap(super(ImmutableSortedMap, self).values())

    @staticmethod
    @overload
    def toImmutableSortedMap(comparator: 'Comparator', keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSortedMap<K, V>> com.google.common.collect.ImmutableSortedMap.toImmutableSortedMap(java.util.Comparator<? super K>,java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableSortedMap.toImmutableSortedMap(comparator, keyFunction, valueFunction))

    @override
    @overload
    def sequencedKeySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<K> java.util.SequencedMap.sequencedKeySet()"""
        return 'SequencedSet'._wrap(super(SequencedMap, self).sequencedKeySet())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.builder()"""
        return Builder._wrap(_ImmutableSortedMap.builder())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @overload
    def subMap(self, fromKey: object, fromInclusive: bool, toKey: object, toInclusive: bool) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.subMap(K,boolean,K,boolean)"""
        return 'ImmutableSortedMap'._wrap(super(_ImmutableSortedMap, self).subMap(fromKey, _boolean.valueOf(fromInclusive), toKey, _boolean.valueOf(toInclusive)))

    @overload
    def tailMap(self, fromKey: object) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.tailMap(K)"""
        return 'ImmutableSortedMap'._wrap(super(_ImmutableSortedMap, self).tailMap(fromKey))

    @overload
    def computeIfPresent(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).computeIfPresent(key, remappingFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @overload
    def ceilingEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.ceilingEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ImmutableSortedMap, self).ceilingEntry(key))

    @override
    @overload
    def keySet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<K> com.google.common.collect.ImmutableSortedMap.keySet()"""
        return 'ImmutableSortedSet'._wrap(super(ImmutableSortedMap, self).keySet())

    @overload
    def tailMap(self, fromKey: object, inclusive: bool) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.tailMap(K,boolean)"""
        return 'ImmutableSortedMap'._wrap(super(_ImmutableSortedMap, self).tailMap(fromKey, _boolean.valueOf(inclusive)))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).containsValue(value))

    @override
    @overload
    def firstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.firstEntry()"""
        return 'Entry.Map$Entry'._wrap(super(ImmutableSortedMap, self).firstEntry())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @overload
    def floorEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.floorEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ImmutableSortedMap, self).floorEntry(key))

    @overload
    def putIfAbsent(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.putIfAbsent(K,V)"""
        return object._wrap(super(_ImmutableMap, self).putIfAbsent(key, value))

    @overload
    def put(self, k: object, v: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.put(K,V)"""
        return object._wrap(super(_ImmutableMap, self).put(k, v))

    @overload
    def getOrDefault(self, key: object, defaultValue: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_ImmutableMap, self).getOrDefault(key, defaultValue))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V)"""
        return ImmutableSortedMap._wrap(_ImmutableSortedMap.of(k1, v1))

    @staticmethod
    @overload
    def naturalOrder() -> 'Builder':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.naturalOrder()"""
        return Builder._wrap(_ImmutableSortedMap.naturalOrder()) 
 
 
# CLASS: com.google.common.collect.ImmutableSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ImmutableSet as _ImmutableSet_Builder
_Builder = _ImmutableSet_Builder.Builder
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
from typing import List
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableSet():
    """com.google.common.collect.ImmutableSet"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableSet) -> 'ImmutableSet':
        return ImmutableSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableSet):
        """
        Dynamic initializer for ImmutableSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool._wrap(super(_ImmutableCollection, self).add(e))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ImmutableCollection, self).remove(object))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object]._wrap(super(_ImmutableCollection, self).toArray(other))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @abstractmethod
    def contains(self, object: object):
        """public abstract boolean com.google.common.collect.ImmutableCollection.contains(java.lang.Object)"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableSet, self).equals(object))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object]._wrap(super(ImmutableCollection, self).toArray())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableSet.hashCode()"""
        return int._wrap(super(ImmutableSet, self).hashCode())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ImmutableCollection, self).addAll(newElements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableCollection.spliterator()"""
        return 'Spliterator'._wrap(super(ImmutableCollection, self).spliterator())

    @staticmethod
    @overload
    def toImmutableSet() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSet<E>> com.google.common.collect.ImmutableSet.toImmutableSet()"""
        return Collector._wrap(_ImmutableSet.toImmutableSet())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builder()"""
        return Builder._wrap(_ImmutableSet.builder())

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(element))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def of() -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of()"""
        return ImmutableSet._wrap(_ImmutableSet.of())

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableSet.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(E[])"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @override
    @overload
    def asList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableCollection.asList()"""
        return 'ImmutableList'._wrap(super(ImmutableCollection, self).asList())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSet.iterator()"""
        pass

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4, e5, e6, others))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.ImmutableSetMultimap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSetMultimap as _ImmutableSetMultimap
_ImmutableSetMultimap = _ImmutableSetMultimap
import java.util.stream.Collector as Collector
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset
_ImmutableMultiset = _ImmutableMultiset
import com.google.common.collect.ImmutableSetMultimap as _ImmutableSetMultimap_Builder
_Builder = _ImmutableSetMultimap_Builder.Builder
import com.google.common.collect.ImmutableMultimap as _ImmutableMultimap_Builder
_Builder = _ImmutableMultimap_Builder.Builder
import java.util.function.BiConsumer as BiConsumer
import java.lang.Integer as _int
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
import java.util.function.Function as Function
from builtins import bool
import java.lang.Long as _long
import com.google.common.collect.ImmutableMultimap as _ImmutableMultimap
_ImmutableMultimap = _ImmutableMultimap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableSetMultimap():
    """com.google.common.collect.ImmutableSetMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableSetMultimap) -> 'ImmutableSetMultimap':
        return ImmutableSetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableSetMultimap):
        """
        Dynamic initializer for ImmutableSetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableSetMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableSetMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def asMap(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, java.util.Collection<V>> com.google.common.collect.ImmutableMultimap.asMap()"""
        return 'ImmutableMap'._wrap(super(ImmutableMultimap, self).asMap())

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.copyOf(multimap))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ImmutableMultimap.size()"""
        return int._wrap(super(ImmutableMultimap, self).size())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def entries(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableSetMultimap.entries()"""
        return 'ImmutableSet'._wrap(super(ImmutableSetMultimap, self).entries())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.copyOf(entries))

    @staticmethod
    @overload
    def toImmutableSetMultimap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSetMultimap<K, V>> com.google.common.collect.ImmutableSetMultimap.toImmutableSetMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableSetMultimap.toImmutableSetMultimap(keyFunction, valueFunction))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableSetMultimap._wrap(_ImmutableSetMultimap.copyOf(entries))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.put(K,V)"""
        return bool._wrap(super(_ImmutableMultimap, self).put(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V,K,V)"""
        return ImmutableSetMultimap._wrap(_ImmutableSetMultimap.of(k1, v1, k2, v2))

    @staticmethod
    @overload
    def flatteningToImmutableSetMultimap(keyFunction: 'Function', valuesFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSetMultimap<K, V>> com.google.common.collect.ImmutableSetMultimap.flatteningToImmutableSetMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends V>>)"""
        return Collector._wrap(_ImmutableSetMultimap.flatteningToImmutableSetMultimap(keyFunction, valuesFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap.builder()"""
        return Builder._wrap(_ImmutableSetMultimap.builder())

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.values()"""
        return 'ImmutableCollection'._wrap(super(ImmutableMultimap, self).values())

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableSetMultimap._wrap(_ImmutableSetMultimap.copyOf(multimap))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1))

    @overload
    def removeAll(self, key: object) -> 'ImmutableSet':
        """public final com.google.common.collect.ImmutableSet<V> com.google.common.collect.ImmutableSetMultimap.removeAll(java.lang.Object)"""
        return 'ImmutableSet'._wrap(super(_ImmutableSetMultimap, self).removeAll(key))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).containsValue(value))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableSetMultimap._wrap(_ImmutableSetMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'ImmutableSet':
        """public final com.google.common.collect.ImmutableSet<V> com.google.common.collect.ImmutableSetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'ImmutableSet'._wrap(super(_ImmutableSetMultimap, self).replaceValues(key, values))

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool._wrap(super(_ImmutableMultimap, self).putAll(multimap))

    @override
    @overload
    def keys(self) -> 'ImmutableMultiset':
        """public com.google.common.collect.ImmutableMultiset<K> com.google.common.collect.ImmutableMultimap.keys()"""
        return 'ImmutableMultiset'._wrap(super(ImmutableMultimap, self).keys())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool._wrap(super(_ImmutableMultimap, self).putAll(key, values))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.ImmutableMultimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_ImmutableMultimap, self).forEach(action)

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V)"""
        return ImmutableSetMultimap._wrap(_ImmutableSetMultimap.of(k1, v1))

    @override
    @overload
    def inverse(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<V, K> com.google.common.collect.ImmutableSetMultimap.inverse()"""
        return 'ImmutableSetMultimap'._wrap(super(ImmutableSetMultimap, self).inverse())

    @overload
    def get(self, key: object) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<V> com.google.common.collect.ImmutableSetMultimap.get(K)"""
        return 'ImmutableSet'._wrap(super(_ImmutableSetMultimap, self).get(key))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).remove(key, value))

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMultimap.keySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMultimap, self).keySet())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).containsKey(key))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of() -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of()"""
        return ImmutableSetMultimap._wrap(_ImmutableSetMultimap.of())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMultimap.clear()"""
        super(ImmutableMultimap, self).clear()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V,K,V,K,V)"""
        return ImmutableSetMultimap._wrap(_ImmutableSetMultimap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSetMultimap._wrap(_ImmutableSetMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def of() -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of()"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap.builder()"""
        return Builder._wrap(_ImmutableMultimap.builder()) 
 
 
# CLASS: com.google.common.collect.ImmutableListMultimap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import java.util.stream.Collector as Collector
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset
_ImmutableMultiset = _ImmutableMultiset
import com.google.common.collect.ImmutableMultimap as _ImmutableMultimap_Builder
_Builder = _ImmutableMultimap_Builder.Builder
import java.util.function.BiConsumer as BiConsumer
import java.lang.Integer as _int
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import com.google.common.collect.ImmutableListMultimap as _ImmutableListMultimap_Builder
_Builder = _ImmutableListMultimap_Builder.Builder
import java.util.function.Function as Function
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
import java.lang.Long as _long
import com.google.common.collect.ImmutableListMultimap as _ImmutableListMultimap
_ImmutableListMultimap = _ImmutableListMultimap
import com.google.common.collect.ImmutableMultimap as _ImmutableMultimap
_ImmutableMultimap = _ImmutableMultimap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableListMultimap():
    """com.google.common.collect.ImmutableListMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableListMultimap) -> 'ImmutableListMultimap':
        return ImmutableListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableListMultimap):
        """
        Dynamic initializer for ImmutableListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableListMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableListMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def inverse(self) -> 'ImmutableListMultimap':
        """public com.google.common.collect.ImmutableListMultimap<V, K> com.google.common.collect.ImmutableListMultimap.inverse()"""
        return 'ImmutableListMultimap'._wrap(super(ImmutableListMultimap, self).inverse())

    @override
    @overload
    def asMap(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, java.util.Collection<V>> com.google.common.collect.ImmutableMultimap.asMap()"""
        return 'ImmutableMap'._wrap(super(ImmutableMultimap, self).asMap())

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.copyOf(multimap))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def toImmutableListMultimap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableListMultimap<K, V>> com.google.common.collect.ImmutableListMultimap.toImmutableListMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableListMultimap.toImmutableListMultimap(keyFunction, valueFunction))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ImmutableMultimap.size()"""
        return int._wrap(super(ImmutableMultimap, self).size())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableListMultimap._wrap(_ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V)"""
        return ImmutableListMultimap._wrap(_ImmutableListMultimap.of(k1, v1))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableListMultimap._wrap(_ImmutableListMultimap.copyOf(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V,K,V,K,V)"""
        return ImmutableListMultimap._wrap(_ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of() -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of()"""
        return ImmutableListMultimap._wrap(_ImmutableListMultimap.of())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableListMultimap._wrap(_ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.copyOf(entries))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def put(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.put(K,V)"""
        return bool._wrap(super(_ImmutableMultimap, self).put(key, value))

    @overload
    def get(self, key: object) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<V> com.google.common.collect.ImmutableListMultimap.get(K)"""
        return 'ImmutableList'._wrap(super(_ImmutableListMultimap, self).get(key))

    @staticmethod
    @overload
    def flatteningToImmutableListMultimap(keyFunction: 'Function', valuesFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableListMultimap<K, V>> com.google.common.collect.ImmutableListMultimap.flatteningToImmutableListMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends V>>)"""
        return Collector._wrap(_ImmutableListMultimap.flatteningToImmutableListMultimap(keyFunction, valuesFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.values()"""
        return 'ImmutableCollection'._wrap(super(ImmutableMultimap, self).values())

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).containsValue(value))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap.builder()"""
        return Builder._wrap(_ImmutableListMultimap.builder())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3))

    @overload
    def removeAll(self, key: object) -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<V> com.google.common.collect.ImmutableListMultimap.removeAll(java.lang.Object)"""
        return 'ImmutableList'._wrap(super(_ImmutableListMultimap, self).removeAll(key))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V,K,V)"""
        return ImmutableListMultimap._wrap(_ImmutableListMultimap.of(k1, v1, k2, v2))

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool._wrap(super(_ImmutableMultimap, self).putAll(multimap))

    @override
    @overload
    def keys(self) -> 'ImmutableMultiset':
        """public com.google.common.collect.ImmutableMultiset<K> com.google.common.collect.ImmutableMultimap.keys()"""
        return 'ImmutableMultiset'._wrap(super(ImmutableMultimap, self).keys())

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableListMultimap._wrap(_ImmutableListMultimap.copyOf(multimap))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool._wrap(super(_ImmutableMultimap, self).putAll(key, values))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.ImmutableMultimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_ImmutableMultimap, self).forEach(action)

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).remove(key, value))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<V> com.google.common.collect.ImmutableListMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'ImmutableList'._wrap(super(_ImmutableListMultimap, self).replaceValues(key, values))

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMultimap.keySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMultimap, self).keySet())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).containsKey(key))

    @override
    @overload
    def entries(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableMultimap.entries()"""
        return 'ImmutableCollection'._wrap(super(ImmutableMultimap, self).entries())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMultimap.clear()"""
        super(ImmutableMultimap, self).clear()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def of() -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of()"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap.builder()"""
        return Builder._wrap(_ImmutableMultimap.builder()) 
 
 
# CLASS: com.google.common.collect.SortedMultiset
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
import java.util.function.Predicate as Predicate
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _Object
_Object = _Object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.Collection as Collection
from abc import abstractmethod, ABC
from builtins import object
import java.util.function.Consumer as Consumer
from typing import List
import java.util.Spliterator as Spliterator
import java.util.Collection as _Collection
_Collection = _Collection
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.SortedMultiset as _SortedMultiset
_SortedMultiset = _SortedMultiset
from builtins import bool
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class SortedMultiset():
    """com.google.common.collect.SortedMultiset"""
 
    @staticmethod
    def _wrap(java_value: _SortedMultiset) -> 'SortedMultiset':
        return SortedMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SortedMultiset):
        """
        Dynamic initializer for SortedMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SortedMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SortedMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def lastEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.lastEntry()"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean java.util.Collection.isEmpty()"""
        pass

    @abstractmethod
    def setCount(self, element: object, oldCount: int, newCount: int):
        """public abstract boolean com.google.common.collect.Multiset.setCount(E,int,int)"""
        pass

    @abstractmethod
    def subMultiset(self, lowerBound: object, lowerBoundType: 'BoundType', upperBound: object, upperBoundType: 'BoundType'):
        """public abstract com.google.common.collect.SortedMultiset<E> com.google.common.collect.SortedMultiset.subMultiset(E,com.google.common.collect.BoundType,E,com.google.common.collect.BoundType)"""
        pass

    @abstractmethod
    def removeAll(self, c: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.removeAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.Multiset.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def contains(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.contains(java.lang.Object)"""
        pass

    @abstractmethod
    def add(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.add(E)"""
        pass

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def firstEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.firstEntry()"""
        pass

    @abstractmethod
    def containsAll(self, elements: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.containsAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def count(self, element: object):
        """public abstract int com.google.common.collect.Multiset.count(java.lang.Object)"""
        pass

    @abstractmethod
    def toArray(self, arg0: 'Object'):
        """public abstract <T> T[] java.util.Collection.toArray(T[])"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multiset.hashCode()"""
        pass

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @abstractmethod
    def clear(self, ):
        """public abstract void java.util.Collection.clear()"""
        pass

    @abstractmethod
    def iterator(self, ):
        """public abstract java.util.Iterator<E> com.google.common.collect.SortedMultiset.iterator()"""
        pass

    @abstractmethod
    def descendingMultiset(self, ):
        """public abstract com.google.common.collect.SortedMultiset<E> com.google.common.collect.SortedMultiset.descendingMultiset()"""
        pass

    @abstractmethod
    def setCount(self, element: object, count: int):
        """public abstract int com.google.common.collect.Multiset.setCount(E,int)"""
        pass

    @abstractmethod
    def comparator(self, ):
        """public abstract java.util.Comparator<? super E> com.google.common.collect.SortedMultiset.comparator()"""
        pass

    @abstractmethod
    def elementSet(self, ):
        """public abstract java.util.NavigableSet<E> com.google.common.collect.SortedMultiset.elementSet()"""
        pass

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_Multiset, self).forEachEntry(action)

    @abstractmethod
    def pollFirstEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.pollFirstEntry()"""
        pass

    @abstractmethod
    def addAll(self, arg0: 'Collection'):
        """public abstract boolean java.util.Collection.addAll(java.util.Collection<? extends E>)"""
        pass

    @abstractmethod
    def retainAll(self, c: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.retainAll(java.util.Collection<?>)"""
        pass

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @abstractmethod
    def remove(self, element: object, occurrences: int):
        """public abstract int com.google.common.collect.Multiset.remove(java.lang.Object,int)"""
        pass

    @abstractmethod
    def toArray(self, ):
        """public abstract java.lang.Object[] java.util.Collection.toArray()"""
        pass

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @abstractmethod
    def tailMultiset(self, lowerBound: object, boundType: 'BoundType'):
        """public abstract com.google.common.collect.SortedMultiset<E> com.google.common.collect.SortedMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        pass

    @abstractmethod
    def entrySet(self, ):
        """public abstract java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.SortedMultiset.entrySet()"""
        pass

    @abstractmethod
    def remove(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.remove(java.lang.Object)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multiset.size()"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.Multiset.toString()"""
        pass

    @abstractmethod
    def pollLastEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.pollLastEntry()"""
        pass

    @abstractmethod
    def add(self, element: object, occurrences: int):
        """public abstract int com.google.common.collect.Multiset.add(E,int)"""
        pass

    @abstractmethod
    def headMultiset(self, upperBound: object, boundType: 'BoundType'):
        """public abstract com.google.common.collect.SortedMultiset<E> com.google.common.collect.SortedMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        pass 
 
 
# CLASS: com.google.common.collect.ImmutableCollection$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.lang.Integer as _int
import com.google.common.collect.ImmutableCollection as _ImmutableCollection_Builder
_Builder = _ImmutableCollection_Builder.Builder
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableCollection.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableCollection$Builder<E> com.google.common.collect.ImmutableCollection$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableCollection$Builder<E> com.google.common.collect.ImmutableCollection$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableCollection$Builder<E> com.google.common.collect.ImmutableCollection$Builder.add(E...)"""
        return 'Builder'._wrap(super(_Builder, self).add(elements))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def build(self, ):
        """public abstract com.google.common.collect.ImmutableCollection<E> com.google.common.collect.ImmutableCollection$Builder.build()"""
        pass

    @abstractmethod
    def add(self, element: object):
        """public abstract com.google.common.collect.ImmutableCollection$Builder<E> com.google.common.collect.ImmutableCollection$Builder.add(E)"""
        pass

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import java.util.Collection as Collection
import java.util.SequencedSet as _SequencedSet
_SequencedSet = _SequencedSet
import java.util.NavigableMap as NavigableMap
import java.util.Set as _Set
_Set = _Set
import java.util.SequencedCollection as SequencedCollection
import java.util.Map.Entry as Entry
import java.lang.Boolean as _boolean
import java.util.SortedMap as _SortedMap
_SortedMap = _SortedMap
import java.util.NavigableMap as _NavigableMap
_NavigableMap = _NavigableMap
import java.util.SortedMap as SortedMap
import com.google.common.collect.ForwardingNavigableMap as _ForwardingNavigableMap_StandardDescendingMap
_StandardDescendingMap = _ForwardingNavigableMap_StandardDescendingMap.StandardDescendingMap
import java.util.SequencedSet as SequencedSet
from builtins import bool
import java.util.SequencedMap as _SequencedMap
_SequencedMap = _SequencedMap
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.SequencedCollection as _SequencedCollection
_SequencedCollection = _SequencedCollection
import java.lang.Object as _object
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
import java.util.Comparator as Comparator
import java.util.Set as Set
import com.google.common.collect.Maps as _Maps_DescendingMap
_DescendingMap = _Maps_DescendingMap.DescendingMap
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.Map as _Map_Entry
_Entry = _Map_Entry.Entry
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import java.util.function.Function as Function
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardDescendingMap():
    """com.google.common.collect.ForwardingNavigableMap.StandardDescendingMap"""
 
    @staticmethod
    def _wrap(java_value: _StandardDescendingMap) -> 'StandardDescendingMap':
        return StandardDescendingMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardDescendingMap):
        """
        Dynamic initializer for StandardDescendingMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardDescendingMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardDescendingMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def lastKey(self) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.lastKey()"""
        return object._wrap(super(DescendingMap, self).lastKey())

    @overload
    def floorEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.floorEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_DescendingMap, self).floorEntry(key))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def ceilingEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.ceilingEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_DescendingMap, self).ceilingEntry(key))

    @overload
    def tailMap(self, fromKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.Maps$DescendingMap.tailMap(K)"""
        return 'SortedMap'._wrap(super(_DescendingMap, self).tailMap(fromKey))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.Maps$DescendingMap.toString()"""
        return str._wrap(super(DescendingMap, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object._wrap(super(_ForwardingMap, self).put(key, value))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def navigableKeySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$DescendingMap.navigableKeySet()"""
        return 'NavigableSet'._wrap(super(DescendingMap, self).navigableKeySet())

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public void com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_StandardDescendingMap, self).replaceAll(function)

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @overload
    def floorKey(self, key: object) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.floorKey(K)"""
        return object._wrap(super(_DescendingMap, self).floorKey(key))

    @override
    @overload
    def descendingKeySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$DescendingMap.descendingKeySet()"""
        return 'NavigableSet'._wrap(super(DescendingMap, self).descendingKeySet())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsValue(value))

    @overload
    def headMap(self, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.Maps$DescendingMap.headMap(K)"""
        return 'SortedMap'._wrap(super(_DescendingMap, self).headMap(toKey))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @overload
    def headMap(self, toKey: object, inclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.Maps$DescendingMap.headMap(K,boolean)"""
        return 'NavigableMap'._wrap(super(_DescendingMap, self).headMap(toKey, _boolean.valueOf(inclusive)))

    @override
    @overload
    def sequencedEntrySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<java.util.Map$Entry<K, V>> java.util.SequencedMap.sequencedEntrySet()"""
        return 'SequencedSet'._wrap(super(SequencedMap, self).sequencedEntrySet())

    @overload
    def ceilingKey(self, key: object) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.ceilingKey(K)"""
        return object._wrap(super(_DescendingMap, self).ceilingKey(key))

    @override
    @overload
    def pollLastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.pollLastEntry()"""
        return 'Entry.Map$Entry'._wrap(super(DescendingMap, self).pollLastEntry())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @overload
    def putLast(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putLast(K,V)"""
        return object._wrap(super(_SortedMap, self).putLast(arg0, arg1))

    @overload
    def subMap(self, fromKey: object, fromInclusive: bool, toKey: object, toInclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.Maps$DescendingMap.subMap(K,boolean,K,boolean)"""
        return 'NavigableMap'._wrap(super(_DescendingMap, self).subMap(fromKey, _boolean.valueOf(fromInclusive), toKey, _boolean.valueOf(toInclusive)))

    @overload
    def tailMap(self, fromKey: object, inclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.Maps$DescendingMap.tailMap(K,boolean)"""
        return 'NavigableMap'._wrap(super(_DescendingMap, self).tailMap(fromKey, _boolean.valueOf(inclusive)))

    @override
    @overload
    def firstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.firstEntry()"""
        return 'Entry.Map$Entry'._wrap(super(DescendingMap, self).firstEntry())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def higherKey(self, key: object) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.higherKey(K)"""
        return object._wrap(super(_DescendingMap, self).higherKey(key))

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0)

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @overload
    def putFirst(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putFirst(K,V)"""
        return object._wrap(super(_SortedMap, self).putFirst(arg0, arg1))

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.Maps$DescendingMap.entrySet()"""
        return 'Set'._wrap(super(DescendingMap, self).entrySet())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.Maps$DescendingMap.comparator()"""
        return 'Comparator'._wrap(super(DescendingMap, self).comparator())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def sequencedKeySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<K> java.util.SequencedMap.sequencedKeySet()"""
        return 'SequencedSet'._wrap(super(SequencedMap, self).sequencedKeySet())

    @override
    @overload
    def lastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.lastEntry()"""
        return 'Entry.Map$Entry'._wrap(super(DescendingMap, self).lastEntry())

    @overload
    def __init__(self, this$0: 'ForwardingNavigableMap'):
        """public com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap(com.google.common.collect.ForwardingNavigableMap)"""
        val = _StandardDescendingMap(this$0)
        self.__wrapper = val

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ForwardingMap, self).putAll(map)

    @override
    @overload
    def firstKey(self) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.firstKey()"""
        return object._wrap(super(DescendingMap, self).firstKey())

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.Maps$DescendingMap.values()"""
        return 'Collection'._wrap(super(DescendingMap, self).values())

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.pollFirstEntry()"""
        return 'Entry.Map$Entry'._wrap(super(DescendingMap, self).pollFirstEntry())

    @override
    @overload
    def descendingMap(self) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.Maps$DescendingMap.descendingMap()"""
        return 'NavigableMap'._wrap(super(DescendingMap, self).descendingMap())

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @overload
    def lowerEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.lowerEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_DescendingMap, self).lowerEntry(key))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).remove(key))

    @overload
    def higherEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.higherEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_DescendingMap, self).higherEntry(key))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.Maps$DescendingMap.keySet()"""
        return 'Set'._wrap(super(DescendingMap, self).keySet())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def lowerKey(self, key: object) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.lowerKey(K)"""
        return object._wrap(super(_DescendingMap, self).lowerKey(key))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def subMap(self, fromKey: object, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.Maps$DescendingMap.subMap(K,K)"""
        return 'SortedMap'._wrap(super(_DescendingMap, self).subMap(fromKey, toKey))

    @override
    @overload
    def sequencedValues(self) -> 'SequencedCollection':
        """public default java.util.SequencedCollection<V> java.util.SequencedMap.sequencedValues()"""
        return 'SequencedCollection'._wrap(super(SequencedMap, self).sequencedValues())

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def reversed(self) -> 'NavigableMap':
        """public default java.util.NavigableMap<K, V> java.util.NavigableMap.reversed()"""
        return 'NavigableMap'._wrap(super(NavigableMap, self).reversed()) 
 
 
# CLASS: com.google.common.collect.ForwardingBlockingDeque
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.google.common.collect.ForwardingQueue as _ForwardingQueue
_ForwardingQueue = _ForwardingQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import com.google.common.collect.ForwardingDeque as _ForwardingDeque
_ForwardingDeque = _ForwardingDeque
import java.util.Deque as Deque
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Collection as _Collection
_Collection = _Collection
import java.util.Deque as _Deque
_Deque = _Deque
import java.lang.Integer as _int
import com.google.common.collect.ForwardingBlockingDeque as _ForwardingBlockingDeque
_ForwardingBlockingDeque = _ForwardingBlockingDeque
import java.util.concurrent.TimeUnit as TimeUnit
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingBlockingDeque():
    """com.google.common.collect.ForwardingBlockingDeque"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingBlockingDeque) -> 'ForwardingBlockingDeque':
        return ForwardingBlockingDeque(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingBlockingDeque):
        """
        Dynamic initializer for ForwardingBlockingDeque.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingBlockingDeque__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingBlockingDeque__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.getLast()"""
        return object._wrap(super(ForwardingDeque, self).getLast())

    @overload
    def poll(self, timeout: int, unit: 'TimeUnit') -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.poll(long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return object._wrap(super(_ForwardingBlockingDeque, self).poll(_long.valueOf(timeout), unit))

    @override
    @overload
    def removeLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.removeLast()"""
        return object._wrap(super(ForwardingDeque, self).removeLast())

    @overload
    def offerFirst(self, e: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.offerFirst(E)"""
        return bool._wrap(super(_ForwardingDeque, self).offerFirst(e))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def offerFirst(self, e: object, timeout: int, unit: 'TimeUnit') -> bool:
        """public boolean com.google.common.collect.ForwardingBlockingDeque.offerFirst(E,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return bool._wrap(super(_ForwardingBlockingDeque, self).offerFirst(e, _long.valueOf(timeout), unit))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def peekLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.peekLast()"""
        return object._wrap(super(ForwardingDeque, self).peekLast())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def remove(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.remove()"""
        return object._wrap(super(ForwardingQueue, self).remove())

    @overload
    def offer(self, e: object, timeout: int, unit: 'TimeUnit') -> bool:
        """public boolean com.google.common.collect.ForwardingBlockingDeque.offer(E,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return bool._wrap(super(_ForwardingBlockingDeque, self).offer(e, _long.valueOf(timeout), unit))

    @override
    @overload
    def addFirst(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.addFirst(E)"""
        super(_ForwardingDeque, self).addFirst(e)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def removeFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.removeFirst()"""
        return object._wrap(super(ForwardingDeque, self).removeFirst())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @overload
    def pollLast(self, timeout: int, unit: 'TimeUnit') -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.pollLast(long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return object._wrap(super(_ForwardingBlockingDeque, self).pollLast(_long.valueOf(timeout), unit))

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.peek()"""
        return object._wrap(super(ForwardingQueue, self).peek())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @override
    @overload
    def push(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.push(E)"""
        super(_ForwardingDeque, self).push(e)

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.poll()"""
        return object._wrap(super(ForwardingQueue, self).poll())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pollFirst()"""
        return object._wrap(super(ForwardingDeque, self).pollFirst())

    @override
    @overload
    def remainingCapacity(self) -> int:
        """public int com.google.common.collect.ForwardingBlockingDeque.remainingCapacity()"""
        return int._wrap(super(ForwardingBlockingDeque, self).remainingCapacity())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingDeque.descendingIterator()"""
        return 'Iterator'._wrap(super(ForwardingDeque, self).descendingIterator())

    @override
    @overload
    def putLast(self, e: object):
        """public void com.google.common.collect.ForwardingBlockingDeque.putLast(E) throws java.lang.InterruptedException"""
        super(_ForwardingBlockingDeque, self).putLast(e)

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @overload
    def pollFirst(self, timeout: int, unit: 'TimeUnit') -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.pollFirst(long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return object._wrap(super(_ForwardingBlockingDeque, self).pollFirst(_long.valueOf(timeout), unit))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def addLast(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.addLast(E)"""
        super(_ForwardingDeque, self).addLast(e)

    @overload
    def removeLastOccurrence(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.removeLastOccurrence(java.lang.Object)"""
        return bool._wrap(super(_ForwardingDeque, self).removeLastOccurrence(o))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def drainTo(self, c: 'Collection', maxElements: int) -> int:
        """public int com.google.common.collect.ForwardingBlockingDeque.drainTo(java.util.Collection<? super E>,int)"""
        return int._wrap(super(_ForwardingBlockingDeque, self).drainTo(c, _int.valueOf(maxElements)))

    @override
    @overload
    def reversed(self) -> 'Deque':
        """public default java.util.Deque<E> java.util.Deque.reversed()"""
        return 'Deque'._wrap(super(Deque, self).reversed())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def put(self, e: object):
        """public void com.google.common.collect.ForwardingBlockingDeque.put(E) throws java.lang.InterruptedException"""
        super(_ForwardingBlockingDeque, self).put(e)

    @override
    @overload
    def take(self) -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.take() throws java.lang.InterruptedException"""
        return object._wrap(super(ForwardingBlockingDeque, self).take())

    @override
    @overload
    def pop(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pop()"""
        return object._wrap(super(ForwardingDeque, self).pop())

    @overload
    def offerLast(self, e: object, timeout: int, unit: 'TimeUnit') -> bool:
        """public boolean com.google.common.collect.ForwardingBlockingDeque.offerLast(E,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return bool._wrap(super(_ForwardingBlockingDeque, self).offerLast(e, _long.valueOf(timeout), unit))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'._wrap(super(Collection, self).spliterator())

    @override
    @overload
    def putFirst(self, e: object):
        """public void com.google.common.collect.ForwardingBlockingDeque.putFirst(E) throws java.lang.InterruptedException"""
        super(_ForwardingBlockingDeque, self).putFirst(e)

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def removeFirstOccurrence(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.removeFirstOccurrence(java.lang.Object)"""
        return bool._wrap(super(_ForwardingDeque, self).removeFirstOccurrence(o))

    @override
    @overload
    def peekFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.peekFirst()"""
        return object._wrap(super(ForwardingDeque, self).peekFirst())

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @overload
    def offerLast(self, e: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.offerLast(E)"""
        return bool._wrap(super(_ForwardingDeque, self).offerLast(e))

    @override
    @overload
    def takeLast(self) -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.takeLast() throws java.lang.InterruptedException"""
        return object._wrap(super(ForwardingBlockingDeque, self).takeLast())

    @override
    @overload
    def element(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.element()"""
        return object._wrap(super(ForwardingQueue, self).element())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pollLast()"""
        return object._wrap(super(ForwardingDeque, self).pollLast())

    @override
    @overload
    def getFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.getFirst()"""
        return object._wrap(super(ForwardingDeque, self).getFirst())

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def offer(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingQueue.offer(E)"""
        return bool._wrap(super(_ForwardingQueue, self).offer(o))

    @override
    @overload
    def takeFirst(self) -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.takeFirst() throws java.lang.InterruptedException"""
        return object._wrap(super(ForwardingBlockingDeque, self).takeFirst())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def drainTo(self, c: 'Collection') -> int:
        """public int com.google.common.collect.ForwardingBlockingDeque.drainTo(java.util.Collection<? super E>)"""
        return int._wrap(super(_ForwardingBlockingDeque, self).drainTo(c))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.ForwardingConcurrentMap
from builtins import str
import java.util.concurrent.ConcurrentMap as _ConcurrentMap
_ConcurrentMap = _ConcurrentMap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import com.google.common.collect.ForwardingConcurrentMap as _ForwardingConcurrentMap
_ForwardingConcurrentMap = _ForwardingConcurrentMap
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import java.util.function.Function as Function
from builtins import bool
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingConcurrentMap():
    """com.google.common.collect.ForwardingConcurrentMap"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingConcurrentMap) -> 'ForwardingConcurrentMap':
        return ForwardingConcurrentMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingConcurrentMap):
        """
        Dynamic initializer for ForwardingConcurrentMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingConcurrentMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingConcurrentMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingConcurrentMap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingConcurrentMap, self).remove(key, value))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.concurrent.ConcurrentMap.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_ConcurrentMap, self).merge(arg0, arg1, arg2))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.concurrent.ConcurrentMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_ConcurrentMap, self).replaceAll(arg0)

    @overload
    def replace(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingConcurrentMap.replace(K,V)"""
        return object._wrap(super(_ForwardingConcurrentMap, self).replace(key, value))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.concurrent.ConcurrentMap.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_ConcurrentMap, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ForwardingMap, self).putAll(map)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object._wrap(super(_ForwardingMap, self).put(key, value))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.concurrent.ConcurrentMap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_ConcurrentMap, self).forEach(arg0)

    @overload
    def replace(self, key: object, oldValue: object, newValue: object) -> bool:
        """public boolean com.google.common.collect.ForwardingConcurrentMap.replace(K,V,V)"""
        return bool._wrap(super(_ForwardingConcurrentMap, self).replace(key, oldValue, newValue))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @overload
    def putIfAbsent(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingConcurrentMap.putIfAbsent(K,V)"""
        return object._wrap(super(_ForwardingConcurrentMap, self).putIfAbsent(key, value))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsValue(value))

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).entrySet())

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.concurrent.ConcurrentMap.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_ConcurrentMap, self).compute(arg0, arg1))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).keySet())

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'._wrap(super(ForwardingMap, self).values())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.concurrent.ConcurrentMap.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_ConcurrentMap, self).getOrDefault(arg0, arg1))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.concurrent.ConcurrentMap.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_ConcurrentMap, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.Multimap
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
 
class Multimap():
    """com.google.common.collect.Multimap"""
 
    @staticmethod
    def _wrap(java_value: _Multimap) -> 'Multimap':
        return Multimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Multimap):
        """
        Dynamic initializer for Multimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Multimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Multimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def keys(self, ):
        """public abstract com.google.common.collect.Multiset<K> com.google.common.collect.Multimap.keys()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.Multimap.equals(java.lang.Object)"""
        pass

    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @abstractmethod
    def replaceValues(self, key: object, values: 'Iterable'):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Multimap.isEmpty()"""
        pass

    @abstractmethod
    def asMap(self, ):
        """public abstract java.util.Map<K, java.util.Collection<V>> com.google.common.collect.Multimap.asMap()"""
        pass

    @abstractmethod
    def removeAll(self, key: object):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.removeAll(java.lang.Object)"""
        pass

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> com.google.common.collect.Multimap.keySet()"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.put(K,V)"""
        pass

    @abstractmethod
    def entries(self, ):
        """public abstract java.util.Collection<java.util.Map$Entry<K, V>> com.google.common.collect.Multimap.entries()"""
        pass

    @abstractmethod
    def containsEntry(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def remove(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def containsKey(self, key: object):
        """public abstract boolean com.google.common.collect.Multimap.containsKey(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.values()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multimap.hashCode()"""
        pass

    @abstractmethod
    def putAll(self, key: object, values: 'Iterable'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def get(self, key: object):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.get(K)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Multimap.clear()"""
        pass

    @abstractmethod
    def putAll(self, multimap: 'Multimap'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multimap.size()"""
        pass 
 
 
# CLASS: com.google.common.collect.Comparators
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.lang.Comparable as Comparable
from builtins import object
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.util.Comparator as Comparator
import com.google.common.collect.Comparators as _Comparators
_Comparators = _Comparators
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Comparable as _Comparable
_Comparable = _Comparable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Comparators():
    """com.google.common.collect.Comparators"""
 
    @staticmethod
    def _wrap(java_value: _Comparators) -> 'Comparators':
        return Comparators(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Comparators):
        """
        Dynamic initializer for Comparators.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Comparators__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Comparators__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def lexicographical(comparator: 'Comparator') -> 'Comparator':
        """public static <T,S extends T> java.util.Comparator<java.lang.Iterable<S>> com.google.common.collect.Comparators.lexicographical(java.util.Comparator<T>)"""
        return Comparator._wrap(_Comparators.lexicographical(comparator))

    @staticmethod
    @overload
    def min(a: 'Comparable', b: 'Comparable') -> 'Comparable':
        """public static <T extends java.lang.Comparable<? super T>> T com.google.common.collect.Comparators.min(T,T)"""
        return Comparable._wrap(_Comparators.min(a, b))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def min(a: object, b: object, comparator: 'Comparator') -> object:
        """public static <T> T com.google.common.collect.Comparators.min(T,T,java.util.Comparator<? super T>)"""
        return object._wrap(_Comparators.min(a, b, comparator))

    @staticmethod
    @overload
    def emptiesFirst(valueComparator: 'Comparator') -> 'Comparator':
        """public static <T> java.util.Comparator<java.util.Optional<T>> com.google.common.collect.Comparators.emptiesFirst(java.util.Comparator<? super T>)"""
        return Comparator._wrap(_Comparators.emptiesFirst(valueComparator))

    @staticmethod
    @overload
    def isInStrictOrder(iterable: 'Iterable', comparator: 'Comparator') -> bool:
        """public static <T> boolean com.google.common.collect.Comparators.isInStrictOrder(java.lang.Iterable<? extends T>,java.util.Comparator<T>)"""
        return bool._wrap(_Comparators.isInStrictOrder(iterable, comparator))

    @staticmethod
    @overload
    def greatest(k: int, comparator: 'Comparator') -> 'Collector':
        """public static <T> java.util.stream.Collector<T, ?, java.util.List<T>> com.google.common.collect.Comparators.greatest(int,java.util.Comparator<? super T>)"""
        return Collector._wrap(_Comparators.greatest(_int.valueOf(k), comparator))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def max(a: object, b: object, comparator: 'Comparator') -> object:
        """public static <T> T com.google.common.collect.Comparators.max(T,T,java.util.Comparator<? super T>)"""
        return object._wrap(_Comparators.max(a, b, comparator))

    @staticmethod
    @overload
    def isInOrder(iterable: 'Iterable', comparator: 'Comparator') -> bool:
        """public static <T> boolean com.google.common.collect.Comparators.isInOrder(java.lang.Iterable<? extends T>,java.util.Comparator<T>)"""
        return bool._wrap(_Comparators.isInOrder(iterable, comparator))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def emptiesLast(valueComparator: 'Comparator') -> 'Comparator':
        """public static <T> java.util.Comparator<java.util.Optional<T>> com.google.common.collect.Comparators.emptiesLast(java.util.Comparator<? super T>)"""
        return Comparator._wrap(_Comparators.emptiesLast(valueComparator))

    @staticmethod
    @overload
    def max(a: 'Comparable', b: 'Comparable') -> 'Comparable':
        """public static <T extends java.lang.Comparable<? super T>> T com.google.common.collect.Comparators.max(T,T)"""
        return Comparable._wrap(_Comparators.max(a, b))

    @staticmethod
    @overload
    def least(k: int, comparator: 'Comparator') -> 'Collector':
        """public static <T> java.util.stream.Collector<T, ?, java.util.List<T>> com.google.common.collect.Comparators.least(int,java.util.Comparator<? super T>)"""
        return Collector._wrap(_Comparators.least(_int.valueOf(k), comparator))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.SortedSetMultimap as _SortedSetMultimap
_SortedSetMultimap = _SortedSetMultimap
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_MultimapBuilderWithKeys
_MultimapBuilderWithKeys = _MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.lang.Integer as _int
import com.google.common.collect.MultimapBuilder as _MultimapBuilder
_MultimapBuilder = _MultimapBuilder
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_SortedSetMultimapBuilder
_SortedSetMultimapBuilder = _MultimapBuilder_SortedSetMultimapBuilder.SortedSetMultimapBuilder
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class SortedSetMultimapBuilder():
    """com.google.common.collect.MultimapBuilder.SortedSetMultimapBuilder"""
 
    @staticmethod
    def _wrap(java_value: _SortedSetMultimapBuilder) -> 'SortedSetMultimapBuilder':
        return SortedSetMultimapBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SortedSetMultimapBuilder):
        """
        Dynamic initializer for SortedSetMultimapBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SortedSetMultimapBuilder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SortedSetMultimapBuilder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def linkedHashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys(int)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.linkedHashKeys(_int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def hashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys(int)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.hashKeys(_int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def treeKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Comparable> com.google.common.collect.MultimapBuilder.treeKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.treeKeys())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def enumKeys(keyClass: 'Class') -> 'MultimapBuilderWithKeys':
        """public static <K0 extends java.lang.Enum<K0>> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.enumKeys(java.lang.Class<K0>)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.enumKeys(keyClass))

    @staticmethod
    @overload
    def hashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.hashKeys())

    @abstractmethod
    def build(self, ):
        """public abstract <K extends K0,V extends V0> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder.build()"""
        pass

    @staticmethod
    @overload
    def linkedHashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.linkedHashKeys())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def build(self, multimap: 'Multimap') -> 'SortedSetMultimap':
        """public <K extends K0,V extends V0> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder.build(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'SortedSetMultimap'._wrap(super(_SortedSetMultimapBuilder, self).build(multimap))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def treeKeys(comparator: 'Comparator') -> 'MultimapBuilderWithKeys':
        """public static <K0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.treeKeys(java.util.Comparator<K0>)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.treeKeys(comparator))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingListMultimap
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.ForwardingMultimap as _ForwardingMultimap
_ForwardingMultimap = _ForwardingMultimap
from builtins import type
import java.util.Map as _Map
_Map = _Map
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.lang.String as _String
_String = _String
import java.util.List as _List
_List = _List
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ForwardingListMultimap as _ForwardingListMultimap
_ForwardingListMultimap = _ForwardingListMultimap
import java.util.Map as Map
import java.lang.Long as _long
import java.util.List as List
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingListMultimap():
    """com.google.common.collect.ForwardingListMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingListMultimap) -> 'ForwardingListMultimap':
        return ForwardingListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingListMultimap):
        """
        Dynamic initializer for ForwardingListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingListMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingListMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def asMap(self) -> 'Map':
        """public java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ForwardingMultimap.asMap()"""
        return 'Map'._wrap(super(ForwardingMultimap, self).asMap())

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool._wrap(super(_ForwardingMultimap, self).putAll(multimap))

    @override
    @overload
    def keys(self) -> 'Multiset':
        """public com.google.common.collect.Multiset<K> com.google.common.collect.ForwardingMultimap.keys()"""
        return 'Multiset'._wrap(super(ForwardingMultimap, self).keys())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.size()"""
        return int._wrap(super(ForwardingMultimap, self).size())

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool._wrap(super(_ForwardingMultimap, self).putAll(key, values))

    @overload
    def containsEntry(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsEntry(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsEntry(key, value))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.put(K,V)"""
        return bool._wrap(super(_ForwardingMultimap, self).put(key, value))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.values()"""
        return 'Collection'._wrap(super(ForwardingMultimap, self).values())

    @overload
    def removeAll(self, key: object) -> 'List':
        """public java.util.List<V> com.google.common.collect.ForwardingListMultimap.removeAll(java.lang.Object)"""
        return 'List'._wrap(super(_ForwardingListMultimap, self).removeAll(key))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMultimap.clear()"""
        super(ForwardingMultimap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).equals(object))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMultimap.keySet()"""
        return 'Set'._wrap(super(ForwardingMultimap, self).keySet())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsKey(key))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).remove(key, value))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'List':
        """public java.util.List<V> com.google.common.collect.ForwardingListMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'List'._wrap(super(_ForwardingListMultimap, self).replaceValues(key, values))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsValue(value))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def get(self, key: object) -> 'List':
        """public java.util.List<V> com.google.common.collect.ForwardingListMultimap.get(K)"""
        return 'List'._wrap(super(_ForwardingListMultimap, self).get(key))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.hashCode()"""
        return int._wrap(super(ForwardingMultimap, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def entries(self) -> 'Collection':
        """public java.util.Collection<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMultimap.entries()"""
        return 'Collection'._wrap(super(ForwardingMultimap, self).entries())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.isEmpty()"""
        return bool._wrap(super(ForwardingMultimap, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_MultimapBuilderWithKeys
_MultimapBuilderWithKeys = _MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.lang.Integer as _int
import com.google.common.collect.MultimapBuilder as _MultimapBuilder
_MultimapBuilder = _MultimapBuilder
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class MultimapBuilder():
    """com.google.common.collect.MultimapBuilder"""
 
    @staticmethod
    def _wrap(java_value: _MultimapBuilder) -> 'MultimapBuilder':
        return MultimapBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _MultimapBuilder):
        """
        Dynamic initializer for MultimapBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_MultimapBuilder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_MultimapBuilder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def linkedHashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys(int)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.linkedHashKeys(_int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def hashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys(int)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.hashKeys(_int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def treeKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Comparable> com.google.common.collect.MultimapBuilder.treeKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.treeKeys())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @abstractmethod
    def build(self, ):
        """public abstract <K extends K0,V extends V0> com.google.common.collect.Multimap<K, V> com.google.common.collect.MultimapBuilder.build()"""
        pass

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def enumKeys(keyClass: 'Class') -> 'MultimapBuilderWithKeys':
        """public static <K0 extends java.lang.Enum<K0>> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.enumKeys(java.lang.Class<K0>)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.enumKeys(keyClass))

    @staticmethod
    @overload
    def hashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.hashKeys())

    @overload
    def build(self, multimap: 'Multimap') -> 'Multimap':
        """public <K extends K0,V extends V0> com.google.common.collect.Multimap<K, V> com.google.common.collect.MultimapBuilder.build(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'Multimap'._wrap(super(_MultimapBuilder, self).build(multimap))

    @staticmethod
    @overload
    def linkedHashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.linkedHashKeys())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def treeKeys(comparator: 'Comparator') -> 'MultimapBuilderWithKeys':
        """public static <K0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.treeKeys(java.util.Comparator<K0>)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.treeKeys(comparator))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.AbstractIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.UnmodifiableIterator as _UnmodifiableIterator
_UnmodifiableIterator = _UnmodifiableIterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.lang.Integer as _int
import com.google.common.collect.AbstractIterator as _AbstractIterator
_AbstractIterator = _AbstractIterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class AbstractIterator():
    """com.google.common.collect.AbstractIterator"""
 
    @staticmethod
    def _wrap(java_value: _AbstractIterator) -> 'AbstractIterator':
        return AbstractIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _AbstractIterator):
        """
        Dynamic initializer for AbstractIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_AbstractIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_AbstractIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def next(self) -> object:
        """public final T com.google.common.collect.AbstractIterator.next()"""
        return object._wrap(super(AbstractIterator, self).next())

    @override
    @overload
    def remove(self):
        """public final void com.google.common.collect.UnmodifiableIterator.remove()"""
        super(UnmodifiableIterator, self).remove()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def hasNext(self) -> bool:
        """public final boolean com.google.common.collect.AbstractIterator.hasNext()"""
        return bool._wrap(super(AbstractIterator, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def peek(self) -> object:
        """public final T com.google.common.collect.AbstractIterator.peek()"""
        return object._wrap(super(AbstractIterator, self).peek())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableClassToInstanceMap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import java.lang.String as _String
_String = _String
import com.google.common.collect.ImmutableClassToInstanceMap as _ImmutableClassToInstanceMap_Builder
_Builder = _ImmutableClassToInstanceMap_Builder.Builder
import java.lang.Integer as _int
import com.google.common.collect.ImmutableClassToInstanceMap as _ImmutableClassToInstanceMap
_ImmutableClassToInstanceMap = _ImmutableClassToInstanceMap
import java.util.Map as Map
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableClassToInstanceMap.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableClassToInstanceMap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableClassToInstanceMap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def build(self) -> 'ImmutableClassToInstanceMap':
        """public com.google.common.collect.ImmutableClassToInstanceMap<B> com.google.common.collect.ImmutableClassToInstanceMap$Builder.build()"""
        return 'ImmutableClassToInstanceMap'._wrap(super(Builder, self).build())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def putAll(self, map: 'Map') -> 'Builder':
        """public <T extends B> com.google.common.collect.ImmutableClassToInstanceMap$Builder<B> com.google.common.collect.ImmutableClassToInstanceMap$Builder.putAll(java.util.Map<? extends java.lang.Class<? extends T>, ? extends T>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(map))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def put(self, key: 'Class', value: object) -> 'Builder':
        """public <T extends B> com.google.common.collect.ImmutableClassToInstanceMap$Builder<B> com.google.common.collect.ImmutableClassToInstanceMap$Builder.put(java.lang.Class<T>,T)"""
        return 'Builder'._wrap(super(_Builder, self).put(key, value))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.HashBiMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import java.util.AbstractMap as _AbstractMap
_AbstractMap = _AbstractMap
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.util.Set as _Set
_Set = _Set
import com.google.common.collect.HashBiMap as _HashBiMap
_HashBiMap = _HashBiMap
import java.util.Set as Set
import com.google.common.collect.BiMap as _BiMap
_BiMap = _BiMap
import java.util.function.BiConsumer as BiConsumer
import java.lang.Integer as _int
import java.util.function.Function as Function
from builtins import bool
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class HashBiMap():
    """com.google.common.collect.HashBiMap"""
 
    @staticmethod
    def _wrap(java_value: _HashBiMap) -> 'HashBiMap':
        return HashBiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _HashBiMap):
        """
        Dynamic initializer for HashBiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_HashBiMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_HashBiMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractMap.isEmpty()"""
        return bool._wrap(super(AbstractMap, self).isEmpty())

    @override
    @overload
    def inverse(self) -> 'BiMap':
        """public com.google.common.collect.BiMap<V, K> com.google.common.collect.HashBiMap.inverse()"""
        return 'BiMap'._wrap(super(HashBiMap, self).inverse())

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public void com.google.common.collect.HashBiMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_HashBiMap, self).replaceAll(function)

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.HashBiMap.keySet()"""
        return 'Set'._wrap(super(HashBiMap, self).keySet())

    @staticmethod
    @overload
    def create() -> 'HashBiMap':
        """public static <K,V> com.google.common.collect.HashBiMap<K, V> com.google.common.collect.HashBiMap.create()"""
        return HashBiMap._wrap(_HashBiMap.create())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractMap.toString()"""
        return str._wrap(super(AbstractMap, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractMap.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractMap, self).equals(arg0))

    @staticmethod
    @overload
    def create(expectedSize: int) -> 'HashBiMap':
        """public static <K,V> com.google.common.collect.HashBiMap<K, V> com.google.common.collect.HashBiMap.create(int)"""
        return HashBiMap._wrap(_HashBiMap.create(_int.valueOf(expectedSize)))

    @overload
    def forcePut(self, key: object, value: object) -> object:
        """public V com.google.common.collect.HashBiMap.forcePut(K,V)"""
        return object._wrap(super(_HashBiMap, self).forcePut(key, value))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.HashBiMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_HashBiMap, self).containsValue(value))

    @staticmethod
    @overload
    def create(map: 'Map') -> 'HashBiMap':
        """public static <K,V> com.google.common.collect.HashBiMap<K, V> com.google.common.collect.HashBiMap.create(java.util.Map<? extends K, ? extends V>)"""
        return HashBiMap._wrap(_HashBiMap.create(map))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.HashBiMap.remove(java.lang.Object)"""
        return object._wrap(super(_HashBiMap, self).remove(key))

    @override
    @overload
    def values(self) -> 'Set':
        """public java.util.Set<V> com.google.common.collect.HashBiMap.values()"""
        return 'Set'._wrap(super(HashBiMap, self).values())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @override
    @overload
    def putAll(self, arg0: 'Map'):
        """public void java.util.AbstractMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_AbstractMap, self).putAll(arg0)

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.HashBiMap.clear()"""
        super(HashBiMap, self).clear()

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.HashBiMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_HashBiMap, self).containsKey(key))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.HashBiMap.size()"""
        return int._wrap(super(HashBiMap, self).size())

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.HashBiMap.get(java.lang.Object)"""
        return object._wrap(super(_HashBiMap, self).get(key))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.HashBiMap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_HashBiMap, self).forEach(action)

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.HashBiMap.put(K,V)"""
        return object._wrap(super(_HashBiMap, self).put(key, value))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractMap.hashCode()"""
        return int._wrap(super(AbstractMap, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.BiMap
import com.google.common.collect.BiMap as _BiMap
_BiMap = _BiMap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.util.function.BiConsumer as BiConsumer
import java.lang.Object as _object
import java.util.Map as _Map
_Map = _Map
from abc import abstractmethod, ABC
from builtins import object
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import bool
import java.util.function.BiFunction as BiFunction
 
class BiMap():
    """com.google.common.collect.BiMap"""
 
    @staticmethod
    def _wrap(java_value: _BiMap) -> 'BiMap':
        return BiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _BiMap):
        """
        Dynamic initializer for BiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_BiMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_BiMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean java.util.Map.isEmpty()"""
        pass

    @abstractmethod
    def putAll(self, map: 'Map'):
        """public abstract void com.google.common.collect.BiMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void java.util.Map.clear()"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract V com.google.common.collect.BiMap.put(K,V)"""
        pass

    @abstractmethod
    def get(self, arg0: object):
        """public abstract V java.util.Map.get(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Set<V> com.google.common.collect.BiMap.values()"""
        pass

    @abstractmethod
    def containsValue(self, arg0: object):
        """public abstract boolean java.util.Map.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def remove(self, arg0: object):
        """public abstract V java.util.Map.remove(java.lang.Object)"""
        pass

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_Map, self).replaceAll(arg0)

    @abstractmethod
    def inverse(self, ):
        """public abstract com.google.common.collect.BiMap<V, K> com.google.common.collect.BiMap.inverse()"""
        pass

    @abstractmethod
    def containsKey(self, arg0: object):
        """public abstract boolean java.util.Map.containsKey(java.lang.Object)"""
        pass

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> java.util.Map.keySet()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int java.util.Map.hashCode()"""
        pass

    @abstractmethod
    def entrySet(self, ):
        """public abstract java.util.Set<java.util.Map$Entry<K, V>> java.util.Map.entrySet()"""
        pass

    @abstractmethod
    def forcePut(self, key: object, value: object):
        """public abstract V com.google.common.collect.BiMap.forcePut(K,V)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.Map.size()"""
        pass

    @abstractmethod
    def equals(self, arg0: object):
        """public abstract boolean java.util.Map.equals(java.lang.Object)"""
        pass

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.Ordering
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
from abc import abstractmethod, ABC
import com.google.common.collect.Ordering as _Ordering
_Ordering = _Ordering
import java.util.function.ToIntFunction as ToIntFunction
import java.util.function.ToLongFunction as ToLongFunction
import java.util.function.ToDoubleFunction as ToDoubleFunction
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.List as _List
_List = _List
import java.util.Iterator as Iterator
import java.util.Comparator as Comparator
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.function.Function as Function
import java.lang.Long as _long
import java.util.List as List
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Ordering():
    """com.google.common.collect.Ordering"""
 
    @staticmethod
    def _wrap(java_value: _Ordering) -> 'Ordering':
        return Ordering(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Ordering):
        """
        Dynamic initializer for Ordering.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Ordering__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Ordering__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def compound(comparators: 'Iterable') -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.compound(java.lang.Iterable<? extends java.util.Comparator<? super T>>)"""
        return Ordering._wrap(_Ordering.compound(comparators))

    @overload
    def nullsFirst(self) -> 'Ordering':
        """public <S extends T> com.google.common.collect.Ordering<S> com.google.common.collect.Ordering.nullsFirst()"""
        return 'Ordering'._wrap(super(Ordering, self).nullsFirst())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def from(ordering: 'Ordering') -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.from(com.google.common.collect.Ordering<T>)"""
        return Ordering._wrap(_Ordering.from(ordering))

    @overload
    def isStrictlyOrdered(self, iterable: 'Iterable') -> bool:
        """public boolean com.google.common.collect.Ordering.isStrictlyOrdered(java.lang.Iterable<? extends T>)"""
        return bool._wrap(super(_Ordering, self).isStrictlyOrdered(iterable))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def thenComparing(self, arg0: 'Function', arg1: 'Comparator') -> 'Comparator':
        """public default <U> java.util.Comparator<T> java.util.Comparator.thenComparing(java.util.function.Function<? super T, ? extends U>,java.util.Comparator<? super U>)"""
        return 'Comparator'._wrap(super(_Comparator, self).thenComparing(arg0, arg1))

    @overload
    def lexicographical(self) -> 'Ordering':
        """public <S extends T> com.google.common.collect.Ordering<java.lang.Iterable<S>> com.google.common.collect.Ordering.lexicographical()"""
        return 'Ordering'._wrap(super(Ordering, self).lexicographical())

    @staticmethod
    @overload
    def usingToString() -> 'Ordering':
        """public static com.google.common.collect.Ordering<java.lang.Object> com.google.common.collect.Ordering.usingToString()"""
        return Ordering._wrap(_Ordering.usingToString())

    @overload
    def greatestOf(self, iterable: 'Iterable', k: int) -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.greatestOf(java.lang.Iterable<E>,int)"""
        return 'List'._wrap(super(_Ordering, self).greatestOf(iterable, _int.valueOf(k)))

    @overload
    def min(self, a: object, b: object) -> object:
        """public <E extends T> E com.google.common.collect.Ordering.min(E,E)"""
        return object._wrap(super(_Ordering, self).min(a, b))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @overload
    def thenComparingDouble(self, arg0: 'ToDoubleFunction') -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.thenComparingDouble(java.util.function.ToDoubleFunction<? super T>)"""
        return 'Comparator'._wrap(super(_Comparator, self).thenComparingDouble(arg0))

    @overload
    def min(self, iterable: 'Iterable') -> object:
        """public <E extends T> E com.google.common.collect.Ordering.min(java.lang.Iterable<E>)"""
        return object._wrap(super(_Ordering, self).min(iterable))

    @staticmethod
    @overload
    def natural() -> 'Ordering':
        """public static <C extends java.lang.Comparable> com.google.common.collect.Ordering<C> com.google.common.collect.Ordering.natural()"""
        return Ordering._wrap(_Ordering.natural())

    @overload
    def thenComparing(self, arg0: 'Function') -> 'Comparator':
        """public default <U extends java.lang.Comparable<? super U>> java.util.Comparator<T> java.util.Comparator.thenComparing(java.util.function.Function<? super T, ? extends U>)"""
        return 'Comparator'._wrap(super(_Comparator, self).thenComparing(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def from(comparator: 'Comparator') -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.from(java.util.Comparator<T>)"""
        return Ordering._wrap(_Ordering.from(comparator))

    @staticmethod
    @overload
    def explicit(leastValue: object, *remainingValuesInOrder: object) -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.explicit(T,T...)"""
        return Ordering._wrap(_Ordering.explicit(leastValue, remainingValuesInOrder))

    @overload
    def binarySearch(self, sortedList: 'List', key: object) -> int:
        """public int com.google.common.collect.Ordering.binarySearch(java.util.List<? extends T>,T)"""
        return int._wrap(super(_Ordering, self).binarySearch(sortedList, key))

    @overload
    def max(self, iterable: 'Iterable') -> object:
        """public <E extends T> E com.google.common.collect.Ordering.max(java.lang.Iterable<E>)"""
        return object._wrap(super(_Ordering, self).max(iterable))

    @overload
    def max(self, iterator: 'Iterator') -> object:
        """public <E extends T> E com.google.common.collect.Ordering.max(java.util.Iterator<E>)"""
        return object._wrap(super(_Ordering, self).max(iterator))

    @staticmethod
    @overload
    def arbitrary() -> 'Ordering':
        """public static com.google.common.collect.Ordering<java.lang.Object> com.google.common.collect.Ordering.arbitrary()"""
        return Ordering._wrap(_Ordering.arbitrary())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def compound(self, secondaryComparator: 'Comparator') -> 'Ordering':
        """public <U extends T> com.google.common.collect.Ordering<U> com.google.common.collect.Ordering.compound(java.util.Comparator<? super U>)"""
        return 'Ordering'._wrap(super(_Ordering, self).compound(secondaryComparator))

    @override
    @overload
    def reversed(self) -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.reversed()"""
        return 'Comparator'._wrap(super(Comparator, self).reversed())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def reverse(self) -> 'Ordering':
        """public <S extends T> com.google.common.collect.Ordering<S> com.google.common.collect.Ordering.reverse()"""
        return 'Ordering'._wrap(super(Ordering, self).reverse())

    @abstractmethod
    def compare(self, left: object, right: object):
        """public abstract int com.google.common.collect.Ordering.compare(T,T)"""
        pass

    @overload
    def thenComparing(self, arg0: 'Comparator') -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.thenComparing(java.util.Comparator<? super T>)"""
        return 'Comparator'._wrap(super(_Comparator, self).thenComparing(arg0))

    @overload
    def min(self, a: object, b: object, c: object, *rest: object) -> object:
        """public <E extends T> E com.google.common.collect.Ordering.min(E,E,E,E...)"""
        return object._wrap(super(_Ordering, self).min(a, b, c, rest))

    @overload
    def min(self, iterator: 'Iterator') -> object:
        """public <E extends T> E com.google.common.collect.Ordering.min(java.util.Iterator<E>)"""
        return object._wrap(super(_Ordering, self).min(iterator))

    @overload
    def isOrdered(self, iterable: 'Iterable') -> bool:
        """public boolean com.google.common.collect.Ordering.isOrdered(java.lang.Iterable<? extends T>)"""
        return bool._wrap(super(_Ordering, self).isOrdered(iterable))

    @staticmethod
    @overload
    def explicit(valuesInOrder: 'List') -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.explicit(java.util.List<T>)"""
        return Ordering._wrap(_Ordering.explicit(valuesInOrder))

    @overload
    def leastOf(self, iterable: 'Iterable', k: int) -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.leastOf(java.lang.Iterable<E>,int)"""
        return 'List'._wrap(super(_Ordering, self).leastOf(iterable, _int.valueOf(k)))

    @overload
    def greatestOf(self, iterator: 'Iterator', k: int) -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.greatestOf(java.util.Iterator<E>,int)"""
        return 'List'._wrap(super(_Ordering, self).greatestOf(iterator, _int.valueOf(k)))

    @overload
    def thenComparingLong(self, arg0: 'ToLongFunction') -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.thenComparingLong(java.util.function.ToLongFunction<? super T>)"""
        return 'Comparator'._wrap(super(_Comparator, self).thenComparingLong(arg0))

    @overload
    def onResultOf(self, function: 'Function') -> 'Ordering':
        """public <F> com.google.common.collect.Ordering<F> com.google.common.collect.Ordering.onResultOf(com.google.common.base.Function<F, ? extends T>)"""
        return 'Ordering'._wrap(super(_Ordering, self).onResultOf(function))

    @overload
    def sortedCopy(self, elements: 'Iterable') -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.sortedCopy(java.lang.Iterable<E>)"""
        return 'List'._wrap(super(_Ordering, self).sortedCopy(elements))

    @overload
    def max(self, a: object, b: object) -> object:
        """public <E extends T> E com.google.common.collect.Ordering.max(E,E)"""
        return object._wrap(super(_Ordering, self).max(a, b))

    @overload
    def nullsLast(self) -> 'Ordering':
        """public <S extends T> com.google.common.collect.Ordering<S> com.google.common.collect.Ordering.nullsLast()"""
        return 'Ordering'._wrap(super(Ordering, self).nullsLast())

    @overload
    def thenComparingInt(self, arg0: 'ToIntFunction') -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.thenComparingInt(java.util.function.ToIntFunction<? super T>)"""
        return 'Comparator'._wrap(super(_Comparator, self).thenComparingInt(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def immutableSortedCopy(self, elements: 'Iterable') -> 'ImmutableList':
        """public <E extends T> com.google.common.collect.ImmutableList<E> com.google.common.collect.Ordering.immutableSortedCopy(java.lang.Iterable<E>)"""
        return 'ImmutableList'._wrap(super(_Ordering, self).immutableSortedCopy(elements))

    @overload
    def leastOf(self, iterator: 'Iterator', k: int) -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.leastOf(java.util.Iterator<E>,int)"""
        return 'List'._wrap(super(_Ordering, self).leastOf(iterator, _int.valueOf(k)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def allEqual() -> 'Ordering':
        """public static com.google.common.collect.Ordering<java.lang.Object> com.google.common.collect.Ordering.allEqual()"""
        return Ordering._wrap(_Ordering.allEqual())

    @overload
    def max(self, a: object, b: object, c: object, *rest: object) -> object:
        """public <E extends T> E com.google.common.collect.Ordering.max(E,E,E,E...)"""
        return object._wrap(super(_Ordering, self).max(a, b, c, rest)) 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableMap
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Map as _Map
_Map = _Map
import java.util.Collection as Collection
import java.util.SequencedSet as _SequencedSet
_SequencedSet = _SequencedSet
import java.util.NavigableMap as NavigableMap
import java.util.Set as _Set
_Set = _Set
import java.util.SequencedCollection as SequencedCollection
import java.util.Map.Entry as Entry
import java.lang.Boolean as _boolean
import java.util.SortedMap as _SortedMap
_SortedMap = _SortedMap
import java.util.NavigableMap as _NavigableMap
_NavigableMap = _NavigableMap
import com.google.common.collect.ForwardingNavigableMap as _ForwardingNavigableMap
_ForwardingNavigableMap = _ForwardingNavigableMap
import java.util.SortedMap as SortedMap
import java.util.SequencedSet as SequencedSet
from builtins import bool
import java.util.SequencedMap as _SequencedMap
_SequencedMap = _SequencedMap
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.SequencedCollection as _SequencedCollection
_SequencedCollection = _SequencedCollection
import java.lang.Object as _object
import com.google.common.collect.ForwardingSortedMap as _ForwardingSortedMap
_ForwardingSortedMap = _ForwardingSortedMap
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import java.util.Map as _Map_Entry
_Entry = _Map_Entry.Entry
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import java.util.function.Function as Function
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingNavigableMap():
    """com.google.common.collect.ForwardingNavigableMap"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingNavigableMap) -> 'ForwardingNavigableMap':
        return ForwardingNavigableMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingNavigableMap):
        """
        Dynamic initializer for ForwardingNavigableMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingNavigableMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingNavigableMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @overload
    def ceilingEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.ceilingEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ForwardingNavigableMap, self).ceilingEntry(key))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def subMap(self, fromKey: object, fromInclusive: bool, toKey: object, toInclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.ForwardingNavigableMap.subMap(K,boolean,K,boolean)"""
        return 'NavigableMap'._wrap(super(_ForwardingNavigableMap, self).subMap(fromKey, _boolean.valueOf(fromInclusive), toKey, _boolean.valueOf(toInclusive)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object._wrap(super(_ForwardingMap, self).put(key, value))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def firstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.firstEntry()"""
        return 'Entry.Map$Entry'._wrap(super(ForwardingNavigableMap, self).firstEntry())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def firstKey(self) -> object:
        """public K com.google.common.collect.ForwardingSortedMap.firstKey()"""
        return object._wrap(super(ForwardingSortedMap, self).firstKey())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @override
    @overload
    def navigableKeySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.ForwardingNavigableMap.navigableKeySet()"""
        return 'NavigableSet'._wrap(super(ForwardingNavigableMap, self).navigableKeySet())

    @override
    @overload
    def lastKey(self) -> object:
        """public K com.google.common.collect.ForwardingSortedMap.lastKey()"""
        return object._wrap(super(ForwardingSortedMap, self).lastKey())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsValue(value))

    @overload
    def floorKey(self, key: object) -> object:
        """public K com.google.common.collect.ForwardingNavigableMap.floorKey(K)"""
        return object._wrap(super(_ForwardingNavigableMap, self).floorKey(key))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.pollFirstEntry()"""
        return 'Entry.Map$Entry'._wrap(super(ForwardingNavigableMap, self).pollFirstEntry())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.ForwardingSortedMap.comparator()"""
        return 'Comparator'._wrap(super(ForwardingSortedMap, self).comparator())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_Map, self).replaceAll(arg0)

    @override
    @overload
    def sequencedEntrySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<java.util.Map$Entry<K, V>> java.util.SequencedMap.sequencedEntrySet()"""
        return 'SequencedSet'._wrap(super(SequencedMap, self).sequencedEntrySet())

    @override
    @overload
    def lastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.lastEntry()"""
        return 'Entry.Map$Entry'._wrap(super(ForwardingNavigableMap, self).lastEntry())

    @override
    @overload
    def descendingMap(self) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.ForwardingNavigableMap.descendingMap()"""
        return 'NavigableMap'._wrap(super(ForwardingNavigableMap, self).descendingMap())

    @overload
    def higherKey(self, key: object) -> object:
        """public K com.google.common.collect.ForwardingNavigableMap.higherKey(K)"""
        return object._wrap(super(_ForwardingNavigableMap, self).higherKey(key))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'._wrap(super(ForwardingMap, self).values())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @overload
    def putLast(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putLast(K,V)"""
        return object._wrap(super(_SortedMap, self).putLast(arg0, arg1))

    @overload
    def higherEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.higherEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ForwardingNavigableMap, self).higherEntry(key))

    @overload
    def ceilingKey(self, key: object) -> object:
        """public K com.google.common.collect.ForwardingNavigableMap.ceilingKey(K)"""
        return object._wrap(super(_ForwardingNavigableMap, self).ceilingKey(key))

    @overload
    def tailMap(self, fromKey: object, inclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.ForwardingNavigableMap.tailMap(K,boolean)"""
        return 'NavigableMap'._wrap(super(_ForwardingNavigableMap, self).tailMap(fromKey, _boolean.valueOf(inclusive)))

    @override
    @overload
    def descendingKeySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.ForwardingNavigableMap.descendingKeySet()"""
        return 'NavigableSet'._wrap(super(ForwardingNavigableMap, self).descendingKeySet())

    @overload
    def tailMap(self, fromKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.tailMap(K)"""
        return 'SortedMap'._wrap(super(_ForwardingSortedMap, self).tailMap(fromKey))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def lowerEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.lowerEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ForwardingNavigableMap, self).lowerEntry(key))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0)

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @overload
    def putFirst(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putFirst(K,V)"""
        return object._wrap(super(_SortedMap, self).putFirst(arg0, arg1))

    @overload
    def subMap(self, fromKey: object, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.subMap(K,K)"""
        return 'SortedMap'._wrap(super(_ForwardingSortedMap, self).subMap(fromKey, toKey))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def sequencedKeySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<K> java.util.SequencedMap.sequencedKeySet()"""
        return 'SequencedSet'._wrap(super(SequencedMap, self).sequencedKeySet())

    @override
    @overload
    def pollLastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.pollLastEntry()"""
        return 'Entry.Map$Entry'._wrap(super(ForwardingNavigableMap, self).pollLastEntry())

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ForwardingMap, self).putAll(map)

    @overload
    def headMap(self, toKey: object, inclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.ForwardingNavigableMap.headMap(K,boolean)"""
        return 'NavigableMap'._wrap(super(_ForwardingNavigableMap, self).headMap(toKey, _boolean.valueOf(inclusive)))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).entrySet())

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).remove(key))

    @overload
    def lowerKey(self, key: object) -> object:
        """public K com.google.common.collect.ForwardingNavigableMap.lowerKey(K)"""
        return object._wrap(super(_ForwardingNavigableMap, self).lowerKey(key))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).keySet())

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def headMap(self, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.headMap(K)"""
        return 'SortedMap'._wrap(super(_ForwardingSortedMap, self).headMap(toKey))

    @overload
    def floorEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.floorEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ForwardingNavigableMap, self).floorEntry(key))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def sequencedValues(self) -> 'SequencedCollection':
        """public default java.util.SequencedCollection<V> java.util.SequencedMap.sequencedValues()"""
        return 'SequencedCollection'._wrap(super(SequencedMap, self).sequencedValues())

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def reversed(self) -> 'NavigableMap':
        """public default java.util.NavigableMap<K, V> java.util.NavigableMap.reversed()"""
        return 'NavigableMap'._wrap(super(NavigableMap, self).reversed()) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedSet$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet_Builder
_Builder = _ImmutableSortedSet_Builder.Builder
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.Comparator as Comparator
import java.lang.Integer as _int
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet
_ImmutableSortedSet = _ImmutableSortedSet
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableSortedSet.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, comparator: 'Comparator'):
        """public com.google.common.collect.ImmutableSortedSet$Builder(java.util.Comparator<? super E>)"""
        val = _Builder(comparator)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet$Builder.add(E...)"""
        return 'Builder'._wrap(super(_Builder, self).add(elements))

    @override
    @overload
    def build(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet$Builder.build()"""
        return 'ImmutableSortedSet'._wrap(super(Builder, self).build())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet$Builder.add(E)"""
        return 'Builder'._wrap(super(_Builder, self).add(element))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableMap
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.ImmutableMap as _ImmutableMap_Builder
_Builder = _ImmutableMap_Builder.Builder
from builtins import type
import java.util.Map as _Map
_Map = _Map
from abc import abstractmethod, ABC
import java.util.Map.Entry as Entry
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import java.util.function.BinaryOperator as BinaryOperator
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.stream.Collector as Collector
import com.google.common.collect.ImmutableSetMultimap as _ImmutableSetMultimap
_ImmutableSetMultimap = _ImmutableSetMultimap
import java.util.function.BiFunction as BiFunction
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import java.util.function.Function as Function
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableMap():
    """com.google.common.collect.ImmutableMap"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableMap) -> 'ImmutableMap':
        return ImmutableMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableMap):
        """
        Dynamic initializer for ImmutableMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector._wrap(_ImmutableMap.toImmutableMap(keyFunction, valueFunction, mergeFunction))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).equals(object))

    @overload
    def replace(self, key: object, oldValue: object, newValue: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.replace(K,V,V)"""
        return bool._wrap(super(_ImmutableMap, self).replace(key, oldValue, newValue))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builder()"""
        return Builder._wrap(_ImmutableMap.builder())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableMap.entrySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMap, self).entrySet())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMap._wrap(_ImmutableMap.copyOf(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @staticmethod
    @overload
    def of() -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of()"""
        return ImmutableMap._wrap(_ImmutableMap.of())

    @overload
    def replace(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.replace(K,V)"""
        return object._wrap(super(_ImmutableMap, self).replace(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @overload
    def computeIfAbsent(self, key: object, mappingFunction: 'Function') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).computeIfAbsent(key, mappingFunction))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMap.clear()"""
        super(ImmutableMap, self).clear()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMap.hashCode()"""
        return int._wrap(super(ImmutableMap, self).hashCode())

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableMap._wrap(_ImmutableMap.ofEntries(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMap.toString()"""
        return str._wrap(super(ImmutableMap, self).toString())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.Map.size()"""
        pass

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).remove(key, value))

    @overload
    def compute(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).compute(key, remappingFunction))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0)

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1))

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public final void com.google.common.collect.ImmutableMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ImmutableMap, self).putAll(map)

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableMap.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @abstractmethod
    def get(self, key: object):
        """public abstract V com.google.common.collect.ImmutableMap.get(java.lang.Object)"""
        pass

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).containsKey(key))

    @overload
    def asMultimap(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableMap.asMultimap()"""
        return 'ImmutableSetMultimap'._wrap(super(ImmutableMap, self).asMultimap())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @overload
    def computeIfPresent(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).computeIfPresent(key, remappingFunction))

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableMap.toImmutableMap(keyFunction, valueFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public final void com.google.common.collect.ImmutableMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_ImmutableMap, self).replaceAll(function)

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.isEmpty()"""
        return bool._wrap(super(ImmutableMap, self).isEmpty())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).containsValue(value))

    @overload
    def merge(self, key: object, value: object, function: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).merge(key, value, function))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def putIfAbsent(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.putIfAbsent(K,V)"""
        return object._wrap(super(_ImmutableMap, self).putIfAbsent(key, value))

    @overload
    def put(self, k: object, v: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.put(K,V)"""
        return object._wrap(super(_ImmutableMap, self).put(k, v))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableMap._wrap(_ImmutableMap.copyOf(map))

    @overload
    def remove(self, o: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.remove(java.lang.Object)"""
        return object._wrap(super(_ImmutableMap, self).remove(o))

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMap.keySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMap, self).keySet())

    @overload
    def getOrDefault(self, key: object, defaultValue: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_ImmutableMap, self).getOrDefault(key, defaultValue))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMap.values()"""
        return 'ImmutableCollection'._wrap(super(ImmutableMap, self).values()) 
 
 
# CLASS: com.google.common.collect.SortedMapDifference
import com.google.common.collect.MapDifference as _MapDifference
_MapDifference = _MapDifference
from abc import abstractmethod, ABC
import com.google.common.collect.SortedMapDifference as _SortedMapDifference
_SortedMapDifference = _SortedMapDifference
 
class SortedMapDifference():
    """com.google.common.collect.SortedMapDifference"""
 
    @staticmethod
    def _wrap(java_value: _SortedMapDifference) -> 'SortedMapDifference':
        return SortedMapDifference(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SortedMapDifference):
        """
        Dynamic initializer for SortedMapDifference.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SortedMapDifference__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SortedMapDifference__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def entriesOnlyOnLeft(self, ):
        """public abstract java.util.SortedMap<K, V> com.google.common.collect.SortedMapDifference.entriesOnlyOnLeft()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.MapDifference.hashCode()"""
        pass

    @abstractmethod
    def entriesInCommon(self, ):
        """public abstract java.util.SortedMap<K, V> com.google.common.collect.SortedMapDifference.entriesInCommon()"""
        pass

    @abstractmethod
    def entriesOnlyOnRight(self, ):
        """public abstract java.util.SortedMap<K, V> com.google.common.collect.SortedMapDifference.entriesOnlyOnRight()"""
        pass

    @abstractmethod
    def areEqual(self, ):
        """public abstract boolean com.google.common.collect.MapDifference.areEqual()"""
        pass

    @abstractmethod
    def entriesDiffering(self, ):
        """public abstract java.util.SortedMap<K, com.google.common.collect.MapDifference$ValueDifference<V>> com.google.common.collect.SortedMapDifference.entriesDiffering()"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.MapDifference.equals(java.lang.Object)"""
        pass 
 
 
# CLASS: com.google.common.collect.EvictingQueue
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import com.google.common.collect.EvictingQueue as _EvictingQueue
_EvictingQueue = _EvictingQueue
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.google.common.collect.ForwardingQueue as _ForwardingQueue
_ForwardingQueue = _ForwardingQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class EvictingQueue():
    """com.google.common.collect.EvictingQueue"""
 
    @staticmethod
    def _wrap(java_value: _EvictingQueue) -> 'EvictingQueue':
        return EvictingQueue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _EvictingQueue):
        """
        Dynamic initializer for EvictingQueue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_EvictingQueue__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_EvictingQueue__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @overload
    def add(self, e: object) -> bool:
        """public boolean com.google.common.collect.EvictingQueue.add(E)"""
        return bool._wrap(super(_EvictingQueue, self).add(e))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'._wrap(super(Collection, self).spliterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def remove(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.remove()"""
        return object._wrap(super(ForwardingQueue, self).remove())

    @overload
    def remainingCapacity(self) -> int:
        """public int com.google.common.collect.EvictingQueue.remainingCapacity()"""
        return int._wrap(super(EvictingQueue, self).remainingCapacity())

    @staticmethod
    @overload
    def create(maxSize: int) -> 'EvictingQueue':
        """public static <E> com.google.common.collect.EvictingQueue<E> com.google.common.collect.EvictingQueue.create(int)"""
        return EvictingQueue._wrap(_EvictingQueue.create(_int.valueOf(maxSize)))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def element(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.element()"""
        return object._wrap(super(ForwardingQueue, self).element())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.peek()"""
        return object._wrap(super(ForwardingQueue, self).peek())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.poll()"""
        return object._wrap(super(ForwardingQueue, self).poll())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.EvictingQueue.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_EvictingQueue, self).addAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.EvictingQueue.toArray()"""
        return List[object]._wrap(super(EvictingQueue, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @overload
    def offer(self, e: object) -> bool:
        """public boolean com.google.common.collect.EvictingQueue.offer(E)"""
        return bool._wrap(super(_EvictingQueue, self).offer(e))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import com.google.common.collect.ForwardingMultiset as _ForwardingMultiset
_ForwardingMultiset = _ForwardingMultiset
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ForwardingMultiset():
    """com.google.common.collect.ForwardingMultiset"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingMultiset) -> 'ForwardingMultiset':
        return ForwardingMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingMultiset):
        """
        Dynamic initializer for ForwardingMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ForwardingMultiset.entrySet()"""
        return 'Set'._wrap(super(ForwardingMultiset, self).entrySet())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultiset, self).equals(object))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.setCount(E,int,int)"""
        return bool._wrap(super(_ForwardingMultiset, self).setCount(element, _int.valueOf(oldCount), _int.valueOf(newCount)))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.add(E,int)"""
        return int._wrap(super(_ForwardingMultiset, self).add(element, _int.valueOf(occurrences)))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.setCount(E,int)"""
        return int._wrap(super(_ForwardingMultiset, self).setCount(element, _int.valueOf(count)))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_Multiset, self).forEachEntry(action)

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultiset.hashCode()"""
        return int._wrap(super(ForwardingMultiset, self).hashCode())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingMultiset.count(java.lang.Object)"""
        return int._wrap(super(_ForwardingMultiset, self).count(element))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.remove(java.lang.Object,int)"""
        return int._wrap(super(_ForwardingMultiset, self).remove(element, _int.valueOf(occurrences)))

    @override
    @overload
    def elementSet(self) -> 'Set':
        """public java.util.Set<E> com.google.common.collect.ForwardingMultiset.elementSet()"""
        return 'Set'._wrap(super(ForwardingMultiset, self).elementSet())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.Interner
import com.google.common.collect.Interner as _Interner
_Interner = _Interner
from abc import abstractmethod, ABC
 
class Interner():
    """com.google.common.collect.Interner"""
 
    @staticmethod
    def _wrap(java_value: _Interner) -> 'Interner':
        return Interner(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Interner):
        """
        Dynamic initializer for Interner.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Interner__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Interner__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def intern(self, sample: object):
        """public abstract E com.google.common.collect.Interner.intern(E)"""
        pass 
 
 
# CLASS: com.google.common.collect.Multiset$Entry
import com.google.common.collect.Multiset as _Multiset_Entry
_Entry = _Multiset_Entry.Entry
from abc import abstractmethod, ABC
 
class Entry():
    """com.google.common.collect.Multiset.Entry"""
 
    @staticmethod
    def _wrap(java_value: _Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Entry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Entry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def getElement(self, ):
        """public abstract E com.google.common.collect.Multiset$Entry.getElement()"""
        pass

    @abstractmethod
    def equals(self, o: object):
        """public abstract boolean com.google.common.collect.Multiset$Entry.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multiset$Entry.hashCode()"""
        pass

    @abstractmethod
    def getCount(self, ):
        """public abstract int com.google.common.collect.Multiset$Entry.getCount()"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.Multiset$Entry.toString()"""
        pass 
 
 
# CLASS: com.google.common.collect.DiscreteDomain
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Comparable as Comparable
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
import java.lang.Comparable as _Comparable
_Comparable = _Comparable
import com.google.common.collect.DiscreteDomain as _DiscreteDomain
_DiscreteDomain = _DiscreteDomain
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class DiscreteDomain():
    """com.google.common.collect.DiscreteDomain"""
 
    @staticmethod
    def _wrap(java_value: _DiscreteDomain) -> 'DiscreteDomain':
        return DiscreteDomain(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _DiscreteDomain):
        """
        Dynamic initializer for DiscreteDomain.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_DiscreteDomain__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_DiscreteDomain__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def longs() -> 'DiscreteDomain':
        """public static com.google.common.collect.DiscreteDomain<java.lang.Long> com.google.common.collect.DiscreteDomain.longs()"""
        return DiscreteDomain._wrap(_DiscreteDomain.longs())

    @abstractmethod
    def distance(self, start: 'Comparable', end: 'Comparable'):
        """public abstract long com.google.common.collect.DiscreteDomain.distance(C,C)"""
        pass

    @abstractmethod
    def previous(self, value: 'Comparable'):
        """public abstract C com.google.common.collect.DiscreteDomain.previous(C)"""
        pass

    @overload
    def maxValue(self) -> 'Comparable':
        """public C com.google.common.collect.DiscreteDomain.maxValue()"""
        return 'Comparable'._wrap(super(DiscreteDomain, self).maxValue())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def minValue(self) -> 'Comparable':
        """public C com.google.common.collect.DiscreteDomain.minValue()"""
        return 'Comparable'._wrap(super(DiscreteDomain, self).minValue())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def bigIntegers() -> 'DiscreteDomain':
        """public static com.google.common.collect.DiscreteDomain<java.math.BigInteger> com.google.common.collect.DiscreteDomain.bigIntegers()"""
        return DiscreteDomain._wrap(_DiscreteDomain.bigIntegers())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def integers() -> 'DiscreteDomain':
        """public static com.google.common.collect.DiscreteDomain<java.lang.Integer> com.google.common.collect.DiscreteDomain.integers()"""
        return DiscreteDomain._wrap(_DiscreteDomain.integers())

    @abstractmethod
    def next(self, value: 'Comparable'):
        """public abstract C com.google.common.collect.DiscreteDomain.next(C)"""
        pass

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingTable
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import com.google.common.collect.ForwardingTable as _ForwardingTable
_ForwardingTable = _ForwardingTable
import java.util.Collection as Collection
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
from builtins import bool
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingTable():
    """com.google.common.collect.ForwardingTable"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingTable) -> 'ForwardingTable':
        return ForwardingTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingTable):
        """
        Dynamic initializer for ForwardingTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingTable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingTable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def columnKeySet(self) -> 'Set':
        """public java.util.Set<C> com.google.common.collect.ForwardingTable.columnKeySet()"""
        return 'Set'._wrap(super(ForwardingTable, self).columnKeySet())

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingTable.values()"""
        return 'Collection'._wrap(super(ForwardingTable, self).values())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def get(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ForwardingTable.get(java.lang.Object,java.lang.Object)"""
        return object._wrap(super(_ForwardingTable, self).get(rowKey, columnKey))

    @overload
    def equals(self, obj: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingTable, self).equals(obj))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.isEmpty()"""
        return bool._wrap(super(ForwardingTable, self).isEmpty())

    @overload
    def remove(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ForwardingTable.remove(java.lang.Object,java.lang.Object)"""
        return object._wrap(super(_ForwardingTable, self).remove(rowKey, columnKey))

    @override
    @overload
    def columnMap(self) -> 'Map':
        """public java.util.Map<C, java.util.Map<R, V>> com.google.common.collect.ForwardingTable.columnMap()"""
        return 'Map'._wrap(super(ForwardingTable, self).columnMap())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def rowMap(self) -> 'Map':
        """public java.util.Map<R, java.util.Map<C, V>> com.google.common.collect.ForwardingTable.rowMap()"""
        return 'Map'._wrap(super(ForwardingTable, self).rowMap())

    @overload
    def put(self, rowKey: object, columnKey: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingTable.put(R,C,V)"""
        return object._wrap(super(_ForwardingTable, self).put(rowKey, columnKey, value))

    @overload
    def row(self, rowKey: object) -> 'Map':
        """public java.util.Map<C, V> com.google.common.collect.ForwardingTable.row(R)"""
        return 'Map'._wrap(super(_ForwardingTable, self).row(rowKey))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingTable.size()"""
        return int._wrap(super(ForwardingTable, self).size())

    @overload
    def containsRow(self, rowKey: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.containsRow(java.lang.Object)"""
        return bool._wrap(super(_ForwardingTable, self).containsRow(rowKey))

    @overload
    def contains(self, rowKey: object, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.contains(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingTable, self).contains(rowKey, columnKey))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingTable.hashCode()"""
        return int._wrap(super(ForwardingTable, self).hashCode())

    @override
    @overload
    def putAll(self, table: 'Table'):
        """public void com.google.common.collect.ForwardingTable.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        super(_ForwardingTable, self).putAll(table)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingTable, self).containsValue(value))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingTable.clear()"""
        super(ForwardingTable, self).clear()

    @overload
    def containsColumn(self, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.containsColumn(java.lang.Object)"""
        return bool._wrap(super(_ForwardingTable, self).containsColumn(columnKey))

    @override
    @overload
    def rowKeySet(self) -> 'Set':
        """public java.util.Set<R> com.google.common.collect.ForwardingTable.rowKeySet()"""
        return 'Set'._wrap(super(ForwardingTable, self).rowKeySet())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def column(self, columnKey: object) -> 'Map':
        """public java.util.Map<R, V> com.google.common.collect.ForwardingTable.column(C)"""
        return 'Map'._wrap(super(_ForwardingTable, self).column(columnKey))

    @override
    @overload
    def cellSet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.ForwardingTable.cellSet()"""
        return 'Set'._wrap(super(ForwardingTable, self).cellSet()) 
 
 
# CLASS: com.google.common.collect.Multiset
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
import java.util.function.Predicate as Predicate
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _Object
_Object = _Object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.Collection as Collection
from abc import abstractmethod, ABC
from builtins import object
import java.util.function.Consumer as Consumer
from typing import List
import java.util.Spliterator as Spliterator
import java.util.Collection as _Collection
_Collection = _Collection
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
from builtins import bool
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class Multiset():
    """com.google.common.collect.Multiset"""
 
    @staticmethod
    def _wrap(java_value: _Multiset) -> 'Multiset':
        return Multiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Multiset):
        """
        Dynamic initializer for Multiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Multiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Multiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean java.util.Collection.isEmpty()"""
        pass

    @abstractmethod
    def setCount(self, element: object, oldCount: int, newCount: int):
        """public abstract boolean com.google.common.collect.Multiset.setCount(E,int,int)"""
        pass

    @abstractmethod
    def removeAll(self, c: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.removeAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.Multiset.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def contains(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.contains(java.lang.Object)"""
        pass

    @abstractmethod
    def add(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.add(E)"""
        pass

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def containsAll(self, elements: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.containsAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def count(self, element: object):
        """public abstract int com.google.common.collect.Multiset.count(java.lang.Object)"""
        pass

    @abstractmethod
    def elementSet(self, ):
        """public abstract java.util.Set<E> com.google.common.collect.Multiset.elementSet()"""
        pass

    @abstractmethod
    def toArray(self, arg0: 'Object'):
        """public abstract <T> T[] java.util.Collection.toArray(T[])"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multiset.hashCode()"""
        pass

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @abstractmethod
    def clear(self, ):
        """public abstract void java.util.Collection.clear()"""
        pass

    @abstractmethod
    def setCount(self, element: object, count: int):
        """public abstract int com.google.common.collect.Multiset.setCount(E,int)"""
        pass

    @abstractmethod
    def entrySet(self, ):
        """public abstract java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.Multiset.entrySet()"""
        pass

    @abstractmethod
    def iterator(self, ):
        """public abstract java.util.Iterator<E> com.google.common.collect.Multiset.iterator()"""
        pass

    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_Multiset, self).forEachEntry(action)

    @abstractmethod
    def addAll(self, arg0: 'Collection'):
        """public abstract boolean java.util.Collection.addAll(java.util.Collection<? extends E>)"""
        pass

    @abstractmethod
    def retainAll(self, c: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.retainAll(java.util.Collection<?>)"""
        pass

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @abstractmethod
    def remove(self, element: object, occurrences: int):
        """public abstract int com.google.common.collect.Multiset.remove(java.lang.Object,int)"""
        pass

    @abstractmethod
    def toArray(self, ):
        """public abstract java.lang.Object[] java.util.Collection.toArray()"""
        pass

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @abstractmethod
    def remove(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.remove(java.lang.Object)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multiset.size()"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.Multiset.toString()"""
        pass

    @abstractmethod
    def add(self, element: object, occurrences: int):
        """public abstract int com.google.common.collect.Multiset.add(E,int)"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingMultimap
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.ForwardingMultimap as _ForwardingMultimap
_ForwardingMultimap = _ForwardingMultimap
import java.lang.Object as _object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
import java.lang.String as _String
_String = _String
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
from builtins import bool
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingMultimap():
    """com.google.common.collect.ForwardingMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingMultimap) -> 'ForwardingMultimap':
        return ForwardingMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingMultimap):
        """
        Dynamic initializer for ForwardingMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def asMap(self) -> 'Map':
        """public java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ForwardingMultimap.asMap()"""
        return 'Map'._wrap(super(ForwardingMultimap, self).asMap())

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool._wrap(super(_ForwardingMultimap, self).putAll(multimap))

    @override
    @overload
    def keys(self) -> 'Multiset':
        """public com.google.common.collect.Multiset<K> com.google.common.collect.ForwardingMultimap.keys()"""
        return 'Multiset'._wrap(super(ForwardingMultimap, self).keys())

    @overload
    def removeAll(self, key: object) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.removeAll(java.lang.Object)"""
        return 'Collection'._wrap(super(_ForwardingMultimap, self).removeAll(key))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.size()"""
        return int._wrap(super(ForwardingMultimap, self).size())

    @overload
    def get(self, key: object) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.get(K)"""
        return 'Collection'._wrap(super(_ForwardingMultimap, self).get(key))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool._wrap(super(_ForwardingMultimap, self).putAll(key, values))

    @overload
    def containsEntry(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsEntry(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsEntry(key, value))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.put(K,V)"""
        return bool._wrap(super(_ForwardingMultimap, self).put(key, value))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.values()"""
        return 'Collection'._wrap(super(ForwardingMultimap, self).values())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMultimap.clear()"""
        super(ForwardingMultimap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).equals(object))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMultimap.keySet()"""
        return 'Set'._wrap(super(ForwardingMultimap, self).keySet())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsKey(key))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).remove(key, value))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsValue(value))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'Collection'._wrap(super(_ForwardingMultimap, self).replaceValues(key, values))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.hashCode()"""
        return int._wrap(super(ForwardingMultimap, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def entries(self) -> 'Collection':
        """public java.util.Collection<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMultimap.entries()"""
        return 'Collection'._wrap(super(ForwardingMultimap, self).entries())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.isEmpty()"""
        return bool._wrap(super(ForwardingMultimap, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.ImmutableBiMap
import com.google.common.collect.ImmutableBiMap as _ImmutableBiMap
_ImmutableBiMap = _ImmutableBiMap
import com.google.common.collect.ImmutableMap as _ImmutableMap_Builder
_Builder = _ImmutableMap_Builder.Builder
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.ImmutableBiMap as _ImmutableBiMap_Builder
_Builder = _ImmutableBiMap_Builder.Builder
from builtins import type
import java.util.Map as _Map
_Map = _Map
from abc import abstractmethod, ABC
import java.util.Map.Entry as Entry
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import java.util.function.BinaryOperator as BinaryOperator
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.stream.Collector as Collector
from builtins import object
import java.lang.String as _String
_String = _String
import com.google.common.collect.ImmutableSetMultimap as _ImmutableSetMultimap
_ImmutableSetMultimap = _ImmutableSetMultimap
import java.util.function.BiFunction as BiFunction
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import java.util.function.Function as Function
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableBiMap():
    """com.google.common.collect.ImmutableBiMap"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableBiMap) -> 'ImmutableBiMap':
        return ImmutableBiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableBiMap):
        """
        Dynamic initializer for ImmutableBiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableBiMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableBiMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).equals(object))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def of() -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of()"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of())

    @overload
    def replace(self, key: object, oldValue: object, newValue: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.replace(K,V,V)"""
        return bool._wrap(super(_ImmutableMap, self).replace(key, oldValue, newValue))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builder()"""
        return Builder._wrap(_ImmutableMap.builder())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap.builder()"""
        return Builder._wrap(_ImmutableBiMap.builder())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableMap.entrySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMap, self).entrySet())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.ofEntries(entries))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMap._wrap(_ImmutableMap.copyOf(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @staticmethod
    @overload
    def of() -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of()"""
        return ImmutableMap._wrap(_ImmutableMap.of())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @overload
    def replace(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.replace(K,V)"""
        return object._wrap(super(_ImmutableMap, self).replace(key, value))

    @overload
    def computeIfAbsent(self, key: object, mappingFunction: 'Function') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).computeIfAbsent(key, mappingFunction))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMap.clear()"""
        super(ImmutableMap, self).clear()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableMap._wrap(_ImmutableMap.ofEntries(entries))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMap.hashCode()"""
        return int._wrap(super(ImmutableMap, self).hashCode())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMap.toString()"""
        return str._wrap(super(ImmutableMap, self).toString())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.Map.size()"""
        pass

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).remove(key, value))

    @overload
    def compute(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).compute(key, remappingFunction))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableBiMap.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @abstractmethod
    def inverse(self, ):
        """public abstract com.google.common.collect.ImmutableBiMap<V, K> com.google.common.collect.ImmutableBiMap.inverse()"""
        pass

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @overload
    def forcePut(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableBiMap.forcePut(K,V)"""
        return object._wrap(super(_ImmutableBiMap, self).forcePut(key, value))

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public final void com.google.common.collect.ImmutableMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ImmutableMap, self).putAll(map)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableMap.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def toImmutableBiMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableBiMap<K, V>> com.google.common.collect.ImmutableBiMap.toImmutableBiMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableBiMap.toImmutableBiMap(keyFunction, valueFunction))

    @abstractmethod
    def get(self, key: object):
        """public abstract V com.google.common.collect.ImmutableMap.get(java.lang.Object)"""
        pass

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).containsKey(key))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @overload
    def computeIfPresent(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).computeIfPresent(key, remappingFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap._wrap(_ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public final void com.google.common.collect.ImmutableMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_ImmutableMap, self).replaceAll(function)

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.isEmpty()"""
        return bool._wrap(super(ImmutableMap, self).isEmpty())

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.copyOf(map))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMap, self).containsValue(value))

    @override
    @overload
    def values(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<V> com.google.common.collect.ImmutableBiMap.values()"""
        return 'ImmutableSet'._wrap(super(ImmutableBiMap, self).values())

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableBiMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableBiMap.toImmutableMap(keyFunction, valueFunction))

    @overload
    def merge(self, key: object, value: object, function: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_ImmutableMap, self).merge(key, value, function))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def putIfAbsent(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.putIfAbsent(K,V)"""
        return object._wrap(super(_ImmutableMap, self).putIfAbsent(key, value))

    @overload
    def put(self, k: object, v: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.put(K,V)"""
        return object._wrap(super(_ImmutableMap, self).put(k, v))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableMap._wrap(_ImmutableMap.copyOf(map))

    @overload
    def remove(self, o: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.remove(java.lang.Object)"""
        return object._wrap(super(_ImmutableMap, self).remove(o))

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMap.keySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMap, self).keySet())

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableBiMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector._wrap(_ImmutableBiMap.toImmutableMap(keyFunction, valueFunction, mergeFunction))

    @override
    @overload
    def asMultimap(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableMap.asMultimap()"""
        return 'ImmutableSetMultimap'._wrap(super(ImmutableMap, self).asMultimap())

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableBiMap._wrap(_ImmutableBiMap.copyOf(entries))

    @overload
    def getOrDefault(self, key: object, defaultValue: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_ImmutableMap, self).getOrDefault(key, defaultValue))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass()) 
 
 
# CLASS: com.google.common.collect.ImmutableSet$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.ImmutableSet as _ImmutableSet_Builder
_Builder = _ImmutableSet_Builder.Builder
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.lang.Integer as _int
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableSet.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableSet$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableSet$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet$Builder.add(E...)"""
        return 'Builder'._wrap(super(_Builder, self).add(elements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet$Builder.add(E)"""
        return 'Builder'._wrap(super(_Builder, self).add(element))

    @override
    @overload
    def build(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet$Builder.build()"""
        return 'ImmutableSet'._wrap(super(Builder, self).build())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.HashMultimap
import com.google.common.collect.HashMultimap as _HashMultimap
_HashMultimap = _HashMultimap
from pyquantum_helper import override
import java.lang.Integer as _int
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
 
class HashMultimap():
    """com.google.common.collect.HashMultimap"""
 
    @staticmethod
    def _wrap(java_value: _HashMultimap) -> 'HashMultimap':
        return HashMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _HashMultimap):
        """
        Dynamic initializer for HashMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_HashMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_HashMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'HashMultimap':
        """public static <K,V> com.google.common.collect.HashMultimap<K, V> com.google.common.collect.HashMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return HashMultimap._wrap(_HashMultimap.create(multimap))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create(expectedKeys: int, expectedValuesPerKey: int) -> 'HashMultimap':
        """public static <K,V> com.google.common.collect.HashMultimap<K, V> com.google.common.collect.HashMultimap.create(int,int)"""
        return HashMultimap._wrap(_HashMultimap.create(_int.valueOf(expectedKeys), _int.valueOf(expectedValuesPerKey)))

    @staticmethod
    @overload
    def create() -> 'HashMultimap':
        """public static <K,V> com.google.common.collect.HashMultimap<K, V> com.google.common.collect.HashMultimap.create()"""
        return HashMultimap._wrap(_HashMultimap.create()) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder$ListMultimapBuilder
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.ListMultimap as _ListMultimap
_ListMultimap = _ListMultimap
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_MultimapBuilderWithKeys
_MultimapBuilderWithKeys = _MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.lang.Integer as _int
import com.google.common.collect.MultimapBuilder as _MultimapBuilder
_MultimapBuilder = _MultimapBuilder
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_ListMultimapBuilder
_ListMultimapBuilder = _MultimapBuilder_ListMultimapBuilder.ListMultimapBuilder
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ListMultimapBuilder():
    """com.google.common.collect.MultimapBuilder.ListMultimapBuilder"""
 
    @staticmethod
    def _wrap(java_value: _ListMultimapBuilder) -> 'ListMultimapBuilder':
        return ListMultimapBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ListMultimapBuilder):
        """
        Dynamic initializer for ListMultimapBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ListMultimapBuilder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ListMultimapBuilder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def build(self, ):
        """public abstract <K extends K0,V extends V0> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.MultimapBuilder$ListMultimapBuilder.build()"""
        pass

    @staticmethod
    @overload
    def linkedHashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys(int)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.linkedHashKeys(_int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def hashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys(int)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.hashKeys(_int.valueOf(expectedKeys)))

    @overload
    def build(self, multimap: 'Multimap') -> 'ListMultimap':
        """public <K extends K0,V extends V0> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.MultimapBuilder$ListMultimapBuilder.build(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'ListMultimap'._wrap(super(_ListMultimapBuilder, self).build(multimap))

    @staticmethod
    @overload
    def treeKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Comparable> com.google.common.collect.MultimapBuilder.treeKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.treeKeys())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def enumKeys(keyClass: 'Class') -> 'MultimapBuilderWithKeys':
        """public static <K0 extends java.lang.Enum<K0>> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.enumKeys(java.lang.Class<K0>)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.enumKeys(keyClass))

    @staticmethod
    @overload
    def hashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.hashKeys())

    @staticmethod
    @overload
    def linkedHashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.linkedHashKeys())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def treeKeys(comparator: 'Comparator') -> 'MultimapBuilderWithKeys':
        """public static <K0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.treeKeys(java.util.Comparator<K0>)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.treeKeys(comparator))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Sets$SetView
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import com.google.common.collect.Sets as _Sets_SetView
_SetView = _Sets_SetView.SetView
import java.util.Set as _Set
_Set = _Set
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.AbstractSet as _AbstractSet
_AbstractSet = _AbstractSet
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
from typing import List
import java.util.Set as Set
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class SetView():
    """com.google.common.collect.Sets.SetView"""
 
    @staticmethod
    def _wrap(java_value: _SetView) -> 'SetView':
        return SetView(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SetView):
        """
        Dynamic initializer for SetView.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SetView__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SetView__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int._wrap(super(AbstractSet, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def contains(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_AbstractCollection, self).contains(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.Sets$SetView.iterator()"""
        pass

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_SetView, self).retainAll(elementsToKeep))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractSet, self).equals(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_SetView, self).addAll(newElements))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_SetView, self).removeIf(filter))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def copyInto(self, set: 'Set') -> 'Set':
        """public <S extends java.util.Set<E>> S com.google.common.collect.Sets$SetView.copyInto(S)"""
        return 'Set'._wrap(super(_SetView, self).copyInto(set))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'._wrap(super(Set, self).spliterator())

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.remove(java.lang.Object)"""
        return bool._wrap(super(_SetView, self).remove(object))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.Sets$SetView.clear()"""
        super(SetView, self).clear()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_SetView, self).removeAll(oldElements))

    @overload
    def immutableCopy(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<E> com.google.common.collect.Sets$SetView.immutableCopy()"""
        return 'ImmutableSet'._wrap(super(SetView, self).immutableCopy())

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.add(E)"""
        return bool._wrap(super(_SetView, self).add(e))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.Table
import com.google.common.collect.Table as _Table
_Table = _Table
from abc import abstractmethod, ABC
 
class Table():
    """com.google.common.collect.Table"""
 
    @staticmethod
    def _wrap(java_value: _Table) -> 'Table':
        return Table(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Table):
        """
        Dynamic initializer for Table.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Table__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Table__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def containsRow(self, rowKey: object):
        """public abstract boolean com.google.common.collect.Table.containsRow(java.lang.Object)"""
        pass

    @abstractmethod
    def put(self, rowKey: object, columnKey: object, value: object):
        """public abstract V com.google.common.collect.Table.put(R,C,V)"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Table.isEmpty()"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Table.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def columnKeySet(self, ):
        """public abstract java.util.Set<C> com.google.common.collect.Table.columnKeySet()"""
        pass

    @abstractmethod
    def containsColumn(self, columnKey: object):
        """public abstract boolean com.google.common.collect.Table.containsColumn(java.lang.Object)"""
        pass

    @abstractmethod
    def columnMap(self, ):
        """public abstract java.util.Map<C, java.util.Map<R, V>> com.google.common.collect.Table.columnMap()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.Table.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Table.hashCode()"""
        pass

    @abstractmethod
    def rowMap(self, ):
        """public abstract java.util.Map<R, java.util.Map<C, V>> com.google.common.collect.Table.rowMap()"""
        pass

    @abstractmethod
    def putAll(self, table: 'Table'):
        """public abstract void com.google.common.collect.Table.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        pass

    @abstractmethod
    def column(self, columnKey: object):
        """public abstract java.util.Map<R, V> com.google.common.collect.Table.column(C)"""
        pass

    @abstractmethod
    def row(self, rowKey: object):
        """public abstract java.util.Map<C, V> com.google.common.collect.Table.row(R)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Table.clear()"""
        pass

    @abstractmethod
    def rowKeySet(self, ):
        """public abstract java.util.Set<R> com.google.common.collect.Table.rowKeySet()"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Table.size()"""
        pass

    @abstractmethod
    def cellSet(self, ):
        """public abstract java.util.Set<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.Table.cellSet()"""
        pass

    @abstractmethod
    def remove(self, rowKey: object, columnKey: object):
        """public abstract V com.google.common.collect.Table.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Table.values()"""
        pass

    @abstractmethod
    def get(self, rowKey: object, columnKey: object):
        """public abstract V com.google.common.collect.Table.get(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def contains(self, rowKey: object, columnKey: object):
        """public abstract boolean com.google.common.collect.Table.contains(java.lang.Object,java.lang.Object)"""
        pass 
 
 
# CLASS: com.google.common.collect.Maps
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.util.HashMap as _HashMap
_HashMap = _HashMap
import java.util.concurrent.ConcurrentMap as ConcurrentMap
import java.util.Map.Entry as Entry
import com.google.common.collect.MapDifference as _MapDifference
_MapDifference = _MapDifference
import java.util.SortedMap as _SortedMap
_SortedMap = _SortedMap
import java.util.function.BinaryOperator as BinaryOperator
import java.util.NavigableMap as _NavigableMap
_NavigableMap = _NavigableMap
import java.util.SortedMap as SortedMap
from builtins import bool
import com.google.common.collect.SortedMapDifference as _SortedMapDifference
_SortedMapDifference = _SortedMapDifference
import java.util.NavigableSet as NavigableSet
import java.lang.Object as _object
import java.util.SortedSet as SortedSet
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.IdentityHashMap as IdentityHashMap
import com.google.common.base.Converter as _Converter
_Converter = _Converter
import java.util.LinkedHashMap as _LinkedHashMap
_LinkedHashMap = _LinkedHashMap
import java.util.Comparator as Comparator
import java.util.Map as _Map_Entry
_Entry = _Map_Entry.Entry
import java.util.Properties as Properties
import java.util.EnumMap as EnumMap
import java.util.TreeMap as _TreeMap
_TreeMap = _TreeMap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import java.util.NavigableMap as NavigableMap
import java.util.IdentityHashMap as _IdentityHashMap
_IdentityHashMap = _IdentityHashMap
import com.google.common.collect.BiMap as _BiMap
_BiMap = _BiMap
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
from builtins import str
import java.util.concurrent.ConcurrentMap as _ConcurrentMap
_ConcurrentMap = _ConcurrentMap
from pyquantum_helper import override
import java.util.LinkedHashMap as LinkedHashMap
import java.lang.Iterable as Iterable
import java.util.HashMap as HashMap
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.util.TreeMap as TreeMap
import java.util.Set as Set
import com.google.common.collect.Maps as _Maps
_Maps = _Maps
import java.lang.Integer as _int
import java.util.EnumMap as _EnumMap
_EnumMap = _EnumMap
import java.util.function.Function as Function
import java.util.Map as Map
import java.lang.Long as _long
 
class Maps():
    """com.google.common.collect.Maps"""
 
    @staticmethod
    def _wrap(java_value: _Maps) -> 'Maps':
        return Maps(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Maps):
        """
        Dynamic initializer for Maps.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Maps__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Maps__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def immutableEnumMap(map: 'Map') -> 'ImmutableMap':
        """public static <K extends java.lang.Enum<K>,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.immutableEnumMap(java.util.Map<K, ? extends V>)"""
        return ImmutableMap._wrap(_Maps.immutableEnumMap(map))

    @staticmethod
    @overload
    def toMap(keys: 'Iterable', valueFunction: 'Function') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.toMap(java.lang.Iterable<K>,com.google.common.base.Function<? super K, V>)"""
        return ImmutableMap._wrap(_Maps.toMap(keys, valueFunction))

    @staticmethod
    @overload
    def asMap(set: 'SortedSet', function: 'Function') -> 'SortedMap':
        """public static <K,V> java.util.SortedMap<K, V> com.google.common.collect.Maps.asMap(java.util.SortedSet<K>,com.google.common.base.Function<? super K, V>)"""
        return SortedMap._wrap(_Maps.asMap(set, function))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'SortedMap', entryPredicate: 'Predicate') -> 'SortedMap':
        """public static <K,V> java.util.SortedMap<K, V> com.google.common.collect.Maps.filterEntries(java.util.SortedMap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return SortedMap._wrap(_Maps.filterEntries(unfiltered, entryPredicate))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def difference(left: 'SortedMap', right: 'Map') -> 'SortedMapDifference':
        """public static <K,V> com.google.common.collect.SortedMapDifference<K, V> com.google.common.collect.Maps.difference(java.util.SortedMap<K, ? extends V>,java.util.Map<? extends K, ? extends V>)"""
        return SortedMapDifference._wrap(_Maps.difference(left, right))

    @staticmethod
    @overload
    def transformValues(fromMap: 'Map', function: 'Function') -> 'Map':
        """public static <K,V1,V2> java.util.Map<K, V2> com.google.common.collect.Maps.transformValues(java.util.Map<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return Map._wrap(_Maps.transformValues(fromMap, function))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def toImmutableEnumMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K extends java.lang.Enum<K>,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.Maps.toImmutableEnumMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_Maps.toImmutableEnumMap(keyFunction, valueFunction))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'NavigableMap', valuePredicate: 'Predicate') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.filterValues(java.util.NavigableMap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return NavigableMap._wrap(_Maps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def newIdentityHashMap() -> 'IdentityHashMap':
        """public static <K,V> java.util.IdentityHashMap<K, V> com.google.common.collect.Maps.newIdentityHashMap()"""
        return IdentityHashMap._wrap(_Maps.newIdentityHashMap())

    @staticmethod
    @overload
    def newTreeMap(comparator: 'Comparator') -> 'TreeMap':
        """public static <C,K extends C,V> java.util.TreeMap<K, V> com.google.common.collect.Maps.newTreeMap(java.util.Comparator<C>)"""
        return TreeMap._wrap(_Maps.newTreeMap(comparator))

    @staticmethod
    @overload
    def unmodifiableBiMap(bimap: 'BiMap') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.unmodifiableBiMap(com.google.common.collect.BiMap<? extends K, ? extends V>)"""
        return BiMap._wrap(_Maps.unmodifiableBiMap(bimap))

    @staticmethod
    @overload
    def newTreeMap(map: 'SortedMap') -> 'TreeMap':
        """public static <K,V> java.util.TreeMap<K, V> com.google.common.collect.Maps.newTreeMap(java.util.SortedMap<K, ? extends V>)"""
        return TreeMap._wrap(_Maps.newTreeMap(map))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def toImmutableEnumMap(keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K extends java.lang.Enum<K>,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.Maps.toImmutableEnumMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector._wrap(_Maps.toImmutableEnumMap(keyFunction, valueFunction, mergeFunction))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'BiMap', entryPredicate: 'Predicate') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.filterEntries(com.google.common.collect.BiMap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return BiMap._wrap(_Maps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def newLinkedHashMap(map: 'Map') -> 'LinkedHashMap':
        """public static <K,V> java.util.LinkedHashMap<K, V> com.google.common.collect.Maps.newLinkedHashMap(java.util.Map<? extends K, ? extends V>)"""
        return LinkedHashMap._wrap(_Maps.newLinkedHashMap(map))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'SortedMap', keyPredicate: 'Predicate') -> 'SortedMap':
        """public static <K,V> java.util.SortedMap<K, V> com.google.common.collect.Maps.filterKeys(java.util.SortedMap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return SortedMap._wrap(_Maps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def toMap(keys: 'Iterator', valueFunction: 'Function') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.toMap(java.util.Iterator<K>,com.google.common.base.Function<? super K, V>)"""
        return ImmutableMap._wrap(_Maps.toMap(keys, valueFunction))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'BiMap', keyPredicate: 'Predicate') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.filterKeys(com.google.common.collect.BiMap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return BiMap._wrap(_Maps.filterKeys(unfiltered, keyPredicate))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def fromProperties(properties: 'Properties') -> 'ImmutableMap':
        """public static com.google.common.collect.ImmutableMap<java.lang.String, java.lang.String> com.google.common.collect.Maps.fromProperties(java.util.Properties)"""
        return ImmutableMap._wrap(_Maps.fromProperties(properties))

    @staticmethod
    @overload
    def difference(left: 'Map', right: 'Map') -> 'MapDifference':
        """public static <K,V> com.google.common.collect.MapDifference<K, V> com.google.common.collect.Maps.difference(java.util.Map<? extends K, ? extends V>,java.util.Map<? extends K, ? extends V>)"""
        return MapDifference._wrap(_Maps.difference(left, right))

    @staticmethod
    @overload
    def newHashMap(map: 'Map') -> 'HashMap':
        """public static <K,V> java.util.HashMap<K, V> com.google.common.collect.Maps.newHashMap(java.util.Map<? extends K, ? extends V>)"""
        return HashMap._wrap(_Maps.newHashMap(map))

    @staticmethod
    @overload
    def immutableEntry(key: object, value: object) -> 'Entry.Map$Entry':
        """public static <K,V> java.util.Map$Entry<K, V> com.google.common.collect.Maps.immutableEntry(K,V)"""
        return Entry.Map$Entry._wrap(_Maps.immutableEntry(key, value))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def uniqueIndex(values: 'Iterator', keyFunction: 'Function') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.uniqueIndex(java.util.Iterator<V>,com.google.common.base.Function<? super V, K>)"""
        return ImmutableMap._wrap(_Maps.uniqueIndex(values, keyFunction))

    @staticmethod
    @overload
    def newLinkedHashMap() -> 'LinkedHashMap':
        """public static <K,V> java.util.LinkedHashMap<K, V> com.google.common.collect.Maps.newLinkedHashMap()"""
        return LinkedHashMap._wrap(_Maps.newLinkedHashMap())

    @staticmethod
    @overload
    def filterValues(unfiltered: 'Map', valuePredicate: 'Predicate') -> 'Map':
        """public static <K,V> java.util.Map<K, V> com.google.common.collect.Maps.filterValues(java.util.Map<K, V>,com.google.common.base.Predicate<? super V>)"""
        return Map._wrap(_Maps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def newHashMap() -> 'HashMap':
        """public static <K,V> java.util.HashMap<K, V> com.google.common.collect.Maps.newHashMap()"""
        return HashMap._wrap(_Maps.newHashMap())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def asMap(set: 'Set', function: 'Function') -> 'Map':
        """public static <K,V> java.util.Map<K, V> com.google.common.collect.Maps.asMap(java.util.Set<K>,com.google.common.base.Function<? super K, V>)"""
        return Map._wrap(_Maps.asMap(set, function))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'Map', keyPredicate: 'Predicate') -> 'Map':
        """public static <K,V> java.util.Map<K, V> com.google.common.collect.Maps.filterKeys(java.util.Map<K, V>,com.google.common.base.Predicate<? super K>)"""
        return Map._wrap(_Maps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def newEnumMap(map: 'Map') -> 'EnumMap':
        """public static <K extends java.lang.Enum<K>,V> java.util.EnumMap<K, V> com.google.common.collect.Maps.newEnumMap(java.util.Map<K, ? extends V>)"""
        return EnumMap._wrap(_Maps.newEnumMap(map))

    @staticmethod
    @overload
    def synchronizedBiMap(bimap: 'BiMap') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.synchronizedBiMap(com.google.common.collect.BiMap<K, V>)"""
        return BiMap._wrap(_Maps.synchronizedBiMap(bimap))

    @staticmethod
    @overload
    def transformValues(fromMap: 'SortedMap', function: 'Function') -> 'SortedMap':
        """public static <K,V1,V2> java.util.SortedMap<K, V2> com.google.common.collect.Maps.transformValues(java.util.SortedMap<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return SortedMap._wrap(_Maps.transformValues(fromMap, function))

    @staticmethod
    @overload
    def transformValues(fromMap: 'NavigableMap', function: 'Function') -> 'NavigableMap':
        """public static <K,V1,V2> java.util.NavigableMap<K, V2> com.google.common.collect.Maps.transformValues(java.util.NavigableMap<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return NavigableMap._wrap(_Maps.transformValues(fromMap, function))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'SortedMap', transformer: 'EntryTransformer') -> 'SortedMap':
        """public static <K,V1,V2> java.util.SortedMap<K, V2> com.google.common.collect.Maps.transformEntries(java.util.SortedMap<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return SortedMap._wrap(_Maps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def subMap(map: 'NavigableMap', range: 'Range') -> 'NavigableMap':
        """public static <K extends java.lang.Comparable<? super K>,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.subMap(java.util.NavigableMap<K, V>,com.google.common.collect.Range<K>)"""
        return NavigableMap._wrap(_Maps.subMap(map, range))

    @staticmethod
    @overload
    def synchronizedNavigableMap(navigableMap: 'NavigableMap') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.synchronizedNavigableMap(java.util.NavigableMap<K, V>)"""
        return NavigableMap._wrap(_Maps.synchronizedNavigableMap(navigableMap))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'Map', entryPredicate: 'Predicate') -> 'Map':
        """public static <K,V> java.util.Map<K, V> com.google.common.collect.Maps.filterEntries(java.util.Map<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return Map._wrap(_Maps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'NavigableMap', entryPredicate: 'Predicate') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.filterEntries(java.util.NavigableMap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return NavigableMap._wrap(_Maps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def difference(left: 'Map', right: 'Map', valueEquivalence: 'Equivalence') -> 'MapDifference':
        """public static <K,V> com.google.common.collect.MapDifference<K, V> com.google.common.collect.Maps.difference(java.util.Map<? extends K, ? extends V>,java.util.Map<? extends K, ? extends V>,com.google.common.base.Equivalence<? super V>)"""
        return MapDifference._wrap(_Maps.difference(left, right, valueEquivalence))

    @staticmethod
    @overload
    def asConverter(bimap: 'BiMap') -> 'base.Converter':
        """public static <A,B> com.google.common.base.Converter<A, B> com.google.common.collect.Maps.asConverter(com.google.common.collect.BiMap<A, B>)"""
        return base.Converter._wrap(_Maps.asConverter(bimap))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'NavigableMap', transformer: 'EntryTransformer') -> 'NavigableMap':
        """public static <K,V1,V2> java.util.NavigableMap<K, V2> com.google.common.collect.Maps.transformEntries(java.util.NavigableMap<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return NavigableMap._wrap(_Maps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'SortedMap', valuePredicate: 'Predicate') -> 'SortedMap':
        """public static <K,V> java.util.SortedMap<K, V> com.google.common.collect.Maps.filterValues(java.util.SortedMap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return SortedMap._wrap(_Maps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def asMap(set: 'NavigableSet', function: 'Function') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.asMap(java.util.NavigableSet<K>,com.google.common.base.Function<? super K, V>)"""
        return NavigableMap._wrap(_Maps.asMap(set, function))

    @staticmethod
    @overload
    def newLinkedHashMapWithExpectedSize(expectedSize: int) -> 'LinkedHashMap':
        """public static <K,V> java.util.LinkedHashMap<K, V> com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize(int)"""
        return LinkedHashMap._wrap(_Maps.newLinkedHashMapWithExpectedSize(_int.valueOf(expectedSize)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'Map', transformer: 'EntryTransformer') -> 'Map':
        """public static <K,V1,V2> java.util.Map<K, V2> com.google.common.collect.Maps.transformEntries(java.util.Map<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return Map._wrap(_Maps.transformEntries(fromMap, transformer))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'NavigableMap', keyPredicate: 'Predicate') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.filterKeys(java.util.NavigableMap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return NavigableMap._wrap(_Maps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def unmodifiableNavigableMap(map: 'NavigableMap') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.unmodifiableNavigableMap(java.util.NavigableMap<K, ? extends V>)"""
        return NavigableMap._wrap(_Maps.unmodifiableNavigableMap(map))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'BiMap', valuePredicate: 'Predicate') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.filterValues(com.google.common.collect.BiMap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return BiMap._wrap(_Maps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def uniqueIndex(values: 'Iterable', keyFunction: 'Function') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.uniqueIndex(java.lang.Iterable<V>,com.google.common.base.Function<? super V, K>)"""
        return ImmutableMap._wrap(_Maps.uniqueIndex(values, keyFunction))

    @staticmethod
    @overload
    def newHashMapWithExpectedSize(expectedSize: int) -> 'HashMap':
        """public static <K,V> java.util.HashMap<K, V> com.google.common.collect.Maps.newHashMapWithExpectedSize(int)"""
        return HashMap._wrap(_Maps.newHashMapWithExpectedSize(_int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def newEnumMap(type: 'Class') -> 'EnumMap':
        """public static <K extends java.lang.Enum<K>,V> java.util.EnumMap<K, V> com.google.common.collect.Maps.newEnumMap(java.lang.Class<K>)"""
        return EnumMap._wrap(_Maps.newEnumMap(type))

    @staticmethod
    @overload
    def newConcurrentMap() -> 'ConcurrentMap':
        """public static <K,V> java.util.concurrent.ConcurrentMap<K, V> com.google.common.collect.Maps.newConcurrentMap()"""
        return ConcurrentMap._wrap(_Maps.newConcurrentMap())

    @staticmethod
    @overload
    def newTreeMap() -> 'TreeMap':
        """public static <K extends java.lang.Comparable,V> java.util.TreeMap<K, V> com.google.common.collect.Maps.newTreeMap()"""
        return TreeMap._wrap(_Maps.newTreeMap()) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedMultiset$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.Comparator as Comparator
import java.lang.Integer as _int
import com.google.common.collect.ImmutableSortedMultiset as _ImmutableSortedMultiset_Builder
_Builder = _ImmutableSortedMultiset_Builder.Builder
from builtins import bool
import com.google.common.collect.ImmutableSortedMultiset as _ImmutableSortedMultiset
_ImmutableSortedMultiset = _ImmutableSortedMultiset
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableSortedMultiset.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.add(E)"""
        return 'Builder'._wrap(super(_Builder, self).add(element))

    @override
    @overload
    def build(self) -> 'ImmutableSortedMultiset':
        """public com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset$Builder.build()"""
        return 'ImmutableSortedMultiset'._wrap(super(Builder, self).build())

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @overload
    def addCopies(self, element: object, occurrences: int) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.addCopies(E,int)"""
        return 'Builder'._wrap(super(_Builder, self).addCopies(element, _int.valueOf(occurrences)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, comparator: 'Comparator'):
        """public com.google.common.collect.ImmutableSortedMultiset$Builder(java.util.Comparator<? super E>)"""
        val = _Builder(comparator)
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @overload
    def setCount(self, element: object, count: int) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.setCount(E,int)"""
        return 'Builder'._wrap(super(_Builder, self).setCount(element, _int.valueOf(count)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.add(E...)"""
        return 'Builder'._wrap(super(_Builder, self).add(elements))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.SortedSetMultimap
from pyquantum_helper import override
import com.google.common.collect.SortedSetMultimap as _SortedSetMultimap
_SortedSetMultimap = _SortedSetMultimap
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
import com.google.common.collect.SetMultimap as _SetMultimap
_SetMultimap = _SetMultimap
 
class SortedSetMultimap():
    """com.google.common.collect.SortedSetMultimap"""
 
    @staticmethod
    def _wrap(java_value: _SortedSetMultimap) -> 'SortedSetMultimap':
        return SortedSetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SortedSetMultimap):
        """
        Dynamic initializer for SortedSetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SortedSetMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SortedSetMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def removeAll(self, key: object):
        """public abstract java.util.SortedSet<V> com.google.common.collect.SortedSetMultimap.removeAll(java.lang.Object)"""
        pass

    @abstractmethod
    def keys(self, ):
        """public abstract com.google.common.collect.Multiset<K> com.google.common.collect.Multimap.keys()"""
        pass

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @abstractmethod
    def asMap(self, ):
        """public abstract java.util.Map<K, java.util.Collection<V>> com.google.common.collect.SortedSetMultimap.asMap()"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Multimap.isEmpty()"""
        pass

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> com.google.common.collect.Multimap.keySet()"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.put(K,V)"""
        pass

    @abstractmethod
    def containsEntry(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def replaceValues(self, key: object, values: 'Iterable'):
        """public abstract java.util.SortedSet<V> com.google.common.collect.SortedSetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def valueComparator(self, ):
        """public abstract java.util.Comparator<? super V> com.google.common.collect.SortedSetMultimap.valueComparator()"""
        pass

    @abstractmethod
    def remove(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def containsKey(self, key: object):
        """public abstract boolean com.google.common.collect.Multimap.containsKey(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.values()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multimap.hashCode()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.SetMultimap.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def putAll(self, key: object, values: 'Iterable'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def entries(self, ):
        """public abstract java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.SetMultimap.entries()"""
        pass

    @abstractmethod
    def get(self, key: object):
        """public abstract java.util.SortedSet<V> com.google.common.collect.SortedSetMultimap.get(K)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Multimap.clear()"""
        pass

    @abstractmethod
    def putAll(self, multimap: 'Multimap'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multimap.size()"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableSet
import com.google.common.collect.ForwardingSortedSet as _ForwardingSortedSet
_ForwardingSortedSet = _ForwardingSortedSet
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingNavigableSet as _ForwardingNavigableSet
_ForwardingNavigableSet = _ForwardingNavigableSet
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import com.google.common.collect.ForwardingSet as _ForwardingSet
_ForwardingSet = _ForwardingSet
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
from typing import List
import java.util.Comparator as Comparator
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingNavigableSet():
    """com.google.common.collect.ForwardingNavigableSet"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingNavigableSet) -> 'ForwardingNavigableSet':
        return ForwardingNavigableSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingNavigableSet):
        """
        Dynamic initializer for ForwardingNavigableSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingNavigableSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingNavigableSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.floor(E)"""
        return object._wrap(super(_ForwardingNavigableSet, self).floor(e))

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object._wrap(super(NavigableSet, self).removeLast())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingSet, self).equals(object))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object._wrap(super(NavigableSet, self).removeFirst())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int._wrap(super(ForwardingSet, self).hashCode())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.higher(E)"""
        return object._wrap(super(_ForwardingNavigableSet, self).higher(e))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.pollLast()"""
        return object._wrap(super(ForwardingNavigableSet, self).pollLast())

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.headSet(E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).headSet(toElement))

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingNavigableSet.descendingIterator()"""
        return 'Iterator'._wrap(super(ForwardingNavigableSet, self).descendingIterator())

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.ceiling(E)"""
        return object._wrap(super(_ForwardingNavigableSet, self).ceiling(e))

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingNavigableSet.headSet(E,boolean)"""
        return 'NavigableSet'._wrap(super(_ForwardingNavigableSet, self).headSet(toElement, _boolean.valueOf(inclusive)))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.pollFirst()"""
        return object._wrap(super(ForwardingNavigableSet, self).pollFirst())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.subSet(E,E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).subSet(fromElement, toElement))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(SortedSet, self).spliterator())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.first()"""
        return object._wrap(super(ForwardingSortedSet, self).first())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ForwardingSortedSet.comparator()"""
        return 'Comparator'._wrap(super(ForwardingSortedSet, self).comparator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.last()"""
        return object._wrap(super(ForwardingSortedSet, self).last())

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'._wrap(super(NavigableSet, self).reversed())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def descendingSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingNavigableSet.descendingSet()"""
        return 'NavigableSet'._wrap(super(ForwardingNavigableSet, self).descendingSet())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingNavigableSet.subSet(E,boolean,E,boolean)"""
        return 'NavigableSet'._wrap(super(_ForwardingNavigableSet, self).subSet(fromElement, _boolean.valueOf(fromInclusive), toElement, _boolean.valueOf(toInclusive)))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingNavigableSet.tailSet(E,boolean)"""
        return 'NavigableSet'._wrap(super(_ForwardingNavigableSet, self).tailSet(fromElement, _boolean.valueOf(inclusive)))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.lower(E)"""
        return object._wrap(super(_ForwardingNavigableSet, self).lower(e))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.tailSet(E)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSet, self).tailSet(fromElement))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.Iterables
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.base.Optional as _Optional
_Optional = _Optional
import com.google.common.collect.Iterables as _Iterables
_Iterables = _Iterables
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
from builtins import object
import java.lang.String as _String
_String = _String
from typing import List
import java.util.Comparator as Comparator
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Iterables():
    """com.google.common.collect.Iterables"""
 
    @staticmethod
    def _wrap(java_value: _Iterables) -> 'Iterables':
        return Iterables(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Iterables):
        """
        Dynamic initializer for Iterables.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Iterables__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Iterables__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def concat(*inputs: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends T>...)"""
        return Iterable._wrap(_Iterables.concat(inputs))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return Iterable._wrap(_Iterables.concat(a, b))

    @staticmethod
    @overload
    def unmodifiableIterable(iterable: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.unmodifiableIterable(java.lang.Iterable<? extends T>)"""
        return Iterable._wrap(_Iterables.unmodifiableIterable(iterable))

    @staticmethod
    @overload
    def find(iterable: 'Iterable', predicate: 'Predicate', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.find(java.lang.Iterable<? extends T>,com.google.common.base.Predicate<? super T>,T)"""
        return object._wrap(_Iterables.find(iterable, predicate, defaultValue))

    @staticmethod
    @overload
    def cycle(iterable: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.cycle(java.lang.Iterable<T>)"""
        return Iterable._wrap(_Iterables.cycle(iterable))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def get(iterable: 'Iterable', position: int, defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.get(java.lang.Iterable<? extends T>,int,T)"""
        return object._wrap(_Iterables.get(iterable, _int.valueOf(position), defaultValue))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def consumingIterable(iterable: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.consumingIterable(java.lang.Iterable<T>)"""
        return Iterable._wrap(_Iterables.consumingIterable(iterable))

    @staticmethod
    @overload
    def unmodifiableIterable(iterable: 'ImmutableCollection') -> 'Iterable':
        """public static <E> java.lang.Iterable<E> com.google.common.collect.Iterables.unmodifiableIterable(com.google.common.collect.ImmutableCollection<E>)"""
        return Iterable._wrap(_Iterables.unmodifiableIterable(iterable))

    @staticmethod
    @overload
    def limit(iterable: 'Iterable', limitSize: int) -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.limit(java.lang.Iterable<T>,int)"""
        return Iterable._wrap(_Iterables.limit(iterable, _int.valueOf(limitSize)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def tryFind(iterable: 'Iterable', predicate: 'Predicate') -> 'base.Optional':
        """public static <T> com.google.common.base.Optional<T> com.google.common.collect.Iterables.tryFind(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return base.Optional._wrap(_Iterables.tryFind(iterable, predicate))

    @staticmethod
    @overload
    def size(iterable: 'Iterable') -> int:
        """public static int com.google.common.collect.Iterables.size(java.lang.Iterable<?>)"""
        return int._wrap(_Iterables.size(iterable))

    @staticmethod
    @overload
    def getFirst(iterable: 'Iterable', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.getFirst(java.lang.Iterable<? extends T>,T)"""
        return object._wrap(_Iterables.getFirst(iterable, defaultValue))

    @staticmethod
    @overload
    def indexOf(iterable: 'Iterable', predicate: 'Predicate') -> int:
        """public static <T> int com.google.common.collect.Iterables.indexOf(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return int._wrap(_Iterables.indexOf(iterable, predicate))

    @staticmethod
    @overload
    def getLast(iterable: 'Iterable') -> object:
        """public static <T> T com.google.common.collect.Iterables.getLast(java.lang.Iterable<T>)"""
        return object._wrap(_Iterables.getLast(iterable))

    @staticmethod
    @overload
    def toString(iterable: 'Iterable') -> str:
        """public static java.lang.String com.google.common.collect.Iterables.toString(java.lang.Iterable<?>)"""
        return str._wrap(_Iterables.toString(iterable))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def mergeSorted(iterables: 'Iterable', comparator: 'Comparator') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.mergeSorted(java.lang.Iterable<? extends java.lang.Iterable<? extends T>>,java.util.Comparator<? super T>)"""
        return Iterable._wrap(_Iterables.mergeSorted(iterables, comparator))

    @staticmethod
    @overload
    def find(iterable: 'Iterable', predicate: 'Predicate') -> object:
        """public static <T> T com.google.common.collect.Iterables.find(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return object._wrap(_Iterables.find(iterable, predicate))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def skip(iterable: 'Iterable', numberToSkip: int) -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.skip(java.lang.Iterable<T>,int)"""
        return Iterable._wrap(_Iterables.skip(iterable, _int.valueOf(numberToSkip)))

    @staticmethod
    @overload
    def all(iterable: 'Iterable', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterables.all(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return bool._wrap(_Iterables.all(iterable, predicate))

    @staticmethod
    @overload
    def getOnlyElement(iterable: 'Iterable') -> object:
        """public static <T> T com.google.common.collect.Iterables.getOnlyElement(java.lang.Iterable<T>)"""
        return object._wrap(_Iterables.getOnlyElement(iterable))

    @staticmethod
    @overload
    def removeAll(removeFrom: 'Iterable', elementsToRemove: 'Collection') -> bool:
        """public static boolean com.google.common.collect.Iterables.removeAll(java.lang.Iterable<?>,java.util.Collection<?>)"""
        return bool._wrap(_Iterables.removeAll(removeFrom, elementsToRemove))

    @staticmethod
    @overload
    def contains(iterable: 'Iterable', element: object) -> bool:
        """public static boolean com.google.common.collect.Iterables.contains(java.lang.Iterable<?>,java.lang.Object)"""
        return bool._wrap(_Iterables.contains(iterable, element))

    @staticmethod
    @overload
    def retainAll(removeFrom: 'Iterable', elementsToRetain: 'Collection') -> bool:
        """public static boolean com.google.common.collect.Iterables.retainAll(java.lang.Iterable<?>,java.util.Collection<?>)"""
        return bool._wrap(_Iterables.retainAll(removeFrom, elementsToRetain))

    @staticmethod
    @overload
    def filter(unfiltered: 'Iterable', retainIfTrue: 'Predicate') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.filter(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return Iterable._wrap(_Iterables.filter(unfiltered, retainIfTrue))

    @staticmethod
    @overload
    def getOnlyElement(iterable: 'Iterable', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.getOnlyElement(java.lang.Iterable<? extends T>,T)"""
        return object._wrap(_Iterables.getOnlyElement(iterable, defaultValue))

    @staticmethod
    @overload
    def removeIf(removeFrom: 'Iterable', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterables.removeIf(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return bool._wrap(_Iterables.removeIf(removeFrom, predicate))

    @staticmethod
    @overload
    def elementsEqual(iterable1: 'Iterable', iterable2: 'Iterable') -> bool:
        """public static boolean com.google.common.collect.Iterables.elementsEqual(java.lang.Iterable<?>,java.lang.Iterable<?>)"""
        return bool._wrap(_Iterables.elementsEqual(iterable1, iterable2))

    @staticmethod
    @overload
    def isEmpty(iterable: 'Iterable') -> bool:
        """public static boolean com.google.common.collect.Iterables.isEmpty(java.lang.Iterable<?>)"""
        return bool._wrap(_Iterables.isEmpty(iterable))

    @staticmethod
    @overload
    def toArray(iterable: 'Iterable', type: 'Class') -> List[object]:
        """public static <T> T[] com.google.common.collect.Iterables.toArray(java.lang.Iterable<? extends T>,java.lang.Class<T>)"""
        return List[object]._wrap(_Iterables.toArray(iterable, type))

    @staticmethod
    @overload
    def any(iterable: 'Iterable', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterables.any(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return bool._wrap(_Iterables.any(iterable, predicate))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable', c: 'Iterable', d: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return Iterable._wrap(_Iterables.concat(a, b, c, d))

    @staticmethod
    @overload
    def transform(fromIterable: 'Iterable', function: 'Function') -> 'Iterable':
        """public static <F,T> java.lang.Iterable<T> com.google.common.collect.Iterables.transform(java.lang.Iterable<F>,com.google.common.base.Function<? super F, ? extends T>)"""
        return Iterable._wrap(_Iterables.transform(fromIterable, function))

    @staticmethod
    @overload
    def filter(unfiltered: 'Iterable', desiredType: 'Class') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.filter(java.lang.Iterable<?>,java.lang.Class<T>)"""
        return Iterable._wrap(_Iterables.filter(unfiltered, desiredType))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable', c: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return Iterable._wrap(_Iterables.concat(a, b, c))

    @staticmethod
    @overload
    def addAll(addTo: 'Collection', elementsToAdd: 'Iterable') -> bool:
        """public static <T> boolean com.google.common.collect.Iterables.addAll(java.util.Collection<T>,java.lang.Iterable<? extends T>)"""
        return bool._wrap(_Iterables.addAll(addTo, elementsToAdd))

    @staticmethod
    @overload
    def partition(iterable: 'Iterable', size: int) -> 'Iterable':
        """public static <T> java.lang.Iterable<java.util.List<T>> com.google.common.collect.Iterables.partition(java.lang.Iterable<T>,int)"""
        return Iterable._wrap(_Iterables.partition(iterable, _int.valueOf(size)))

    @staticmethod
    @overload
    def getLast(iterable: 'Iterable', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.getLast(java.lang.Iterable<? extends T>,T)"""
        return object._wrap(_Iterables.getLast(iterable, defaultValue))

    @staticmethod
    @overload
    def cycle(*elements: object) -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.cycle(T...)"""
        return Iterable._wrap(_Iterables.cycle(elements))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def frequency(iterable: 'Iterable', element: object) -> int:
        """public static int com.google.common.collect.Iterables.frequency(java.lang.Iterable<?>,java.lang.Object)"""
        return int._wrap(_Iterables.frequency(iterable, element))

    @staticmethod
    @overload
    def paddedPartition(iterable: 'Iterable', size: int) -> 'Iterable':
        """public static <T> java.lang.Iterable<java.util.List<T>> com.google.common.collect.Iterables.paddedPartition(java.lang.Iterable<T>,int)"""
        return Iterable._wrap(_Iterables.paddedPartition(iterable, _int.valueOf(size)))

    @staticmethod
    @overload
    def get(iterable: 'Iterable', position: int) -> object:
        """public static <T> T com.google.common.collect.Iterables.get(java.lang.Iterable<T>,int)"""
        return object._wrap(_Iterables.get(iterable, _int.valueOf(position)))

    @staticmethod
    @overload
    def concat(inputs: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends java.lang.Iterable<? extends T>>)"""
        return Iterable._wrap(_Iterables.concat(inputs)) 
 
 
# CLASS: com.google.common.collect.RangeMap
import com.google.common.collect.RangeMap as _RangeMap
_RangeMap = _RangeMap
from abc import abstractmethod, ABC
import java.lang.Comparable as Comparable
import java.util.function.BiFunction as BiFunction
 
class RangeMap():
    """com.google.common.collect.RangeMap"""
 
    @staticmethod
    def _wrap(java_value: _RangeMap) -> 'RangeMap':
        return RangeMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _RangeMap):
        """
        Dynamic initializer for RangeMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_RangeMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_RangeMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def asDescendingMapOfRanges(self, ):
        """public abstract java.util.Map<com.google.common.collect.Range<K>, V> com.google.common.collect.RangeMap.asDescendingMapOfRanges()"""
        pass

    @abstractmethod
    def equals(self, o: object):
        """public abstract boolean com.google.common.collect.RangeMap.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def merge(self, range: 'Range', value: object, remappingFunction: 'BiFunction'):
        """public abstract void com.google.common.collect.RangeMap.merge(com.google.common.collect.Range<K>,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        pass

    @abstractmethod
    def remove(self, range: 'Range'):
        """public abstract void com.google.common.collect.RangeMap.remove(com.google.common.collect.Range<K>)"""
        pass

    @abstractmethod
    def asMapOfRanges(self, ):
        """public abstract java.util.Map<com.google.common.collect.Range<K>, V> com.google.common.collect.RangeMap.asMapOfRanges()"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.RangeMap.toString()"""
        pass

    @abstractmethod
    def get(self, key: 'Comparable'):
        """public abstract V com.google.common.collect.RangeMap.get(K)"""
        pass

    @abstractmethod
    def putAll(self, rangeMap: 'RangeMap'):
        """public abstract void com.google.common.collect.RangeMap.putAll(com.google.common.collect.RangeMap<K, ? extends V>)"""
        pass

    @abstractmethod
    def subRangeMap(self, range: 'Range'):
        """public abstract com.google.common.collect.RangeMap<K, V> com.google.common.collect.RangeMap.subRangeMap(com.google.common.collect.Range<K>)"""
        pass

    @abstractmethod
    def getEntry(self, key: 'Comparable'):
        """public abstract java.util.Map$Entry<com.google.common.collect.Range<K>, V> com.google.common.collect.RangeMap.getEntry(K)"""
        pass

    @abstractmethod
    def putCoalescing(self, range: 'Range', value: object):
        """public abstract void com.google.common.collect.RangeMap.putCoalescing(com.google.common.collect.Range<K>,V)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.RangeMap.hashCode()"""
        pass

    @abstractmethod
    def span(self, ):
        """public abstract com.google.common.collect.Range<K> com.google.common.collect.RangeMap.span()"""
        pass

    @abstractmethod
    def put(self, range: 'Range', value: object):
        """public abstract void com.google.common.collect.RangeMap.put(com.google.common.collect.Range<K>,V)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.RangeMap.clear()"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingMapEntry
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
from builtins import object
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
import com.google.common.collect.ForwardingMapEntry as _ForwardingMapEntry
_ForwardingMapEntry = _ForwardingMapEntry
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingMapEntry():
    """com.google.common.collect.ForwardingMapEntry"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingMapEntry) -> 'ForwardingMapEntry':
        return ForwardingMapEntry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingMapEntry):
        """
        Dynamic initializer for ForwardingMapEntry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingMapEntry__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingMapEntry__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getKey(self) -> object:
        """public K com.google.common.collect.ForwardingMapEntry.getKey()"""
        return object._wrap(super(ForwardingMapEntry, self).getKey())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def setValue(self, value: object) -> object:
        """public V com.google.common.collect.ForwardingMapEntry.setValue(V)"""
        return object._wrap(super(_ForwardingMapEntry, self).setValue(value))

    @override
    @overload
    def getValue(self) -> object:
        """public V com.google.common.collect.ForwardingMapEntry.getValue()"""
        return object._wrap(super(ForwardingMapEntry, self).getValue())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMapEntry.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMapEntry, self).equals(object))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMapEntry.hashCode()"""
        return int._wrap(super(ForwardingMapEntry, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ConcurrentHashMultiset
import java.util.function.Predicate as Predicate
import com.google.common.collect.ConcurrentHashMultiset as _ConcurrentHashMultiset
_ConcurrentHashMultiset = _ConcurrentHashMultiset
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.concurrent.ConcurrentMap as ConcurrentMap
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import com.google.common.collect.AbstractMultiset as _AbstractMultiset
_AbstractMultiset = _AbstractMultiset
import java.util.Set as Set
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ConcurrentHashMultiset():
    """com.google.common.collect.ConcurrentHashMultiset"""
 
    @staticmethod
    def _wrap(java_value: _ConcurrentHashMultiset) -> 'ConcurrentHashMultiset':
        return ConcurrentHashMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ConcurrentHashMultiset):
        """
        Dynamic initializer for ConcurrentHashMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ConcurrentHashMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ConcurrentHashMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.add(E,int)"""
        return int._wrap(super(_ConcurrentHashMultiset, self).add(element, _int.valueOf(occurrences)))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str._wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'ConcurrentHashMultiset':
        """public static <E> com.google.common.collect.ConcurrentHashMultiset<E> com.google.common.collect.ConcurrentHashMultiset.create(java.lang.Iterable<? extends E>)"""
        return ConcurrentHashMultiset._wrap(_ConcurrentHashMultiset.create(elements))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def setCount(self, element: object, expectedOldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.ConcurrentHashMultiset.setCount(E,int,int)"""
        return bool._wrap(super(_ConcurrentHashMultiset, self).setCount(element, _int.valueOf(expectedOldCount), _int.valueOf(newCount)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def removeExactly(self, element: object, occurrences: int) -> bool:
        """public boolean com.google.common.collect.ConcurrentHashMultiset.removeExactly(java.lang.Object,int)"""
        return bool._wrap(super(_ConcurrentHashMultiset, self).removeExactly(element, _int.valueOf(occurrences)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).equals(object))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ConcurrentHashMultiset.isEmpty()"""
        return bool._wrap(super(ConcurrentHashMultiset, self).isEmpty())

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).remove(element))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.size()"""
        return int._wrap(super(ConcurrentHashMultiset, self).size())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ConcurrentHashMultiset.iterator()"""
        return 'Iterator'._wrap(super(ConcurrentHashMultiset, self).iterator())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.remove(java.lang.Object,int)"""
        return int._wrap(super(_ConcurrentHashMultiset, self).remove(element, _int.valueOf(occurrences)))

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_Multiset, self).forEachEntry(action)

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ConcurrentHashMultiset.clear()"""
        super(ConcurrentHashMultiset, self).clear()

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool._wrap(super(_AbstractMultiset, self).add(element))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.setCount(E,int)"""
        return int._wrap(super(_ConcurrentHashMultiset, self).setCount(element, _int.valueOf(count)))

    @staticmethod
    @overload
    def create(countMap: 'ConcurrentMap') -> 'ConcurrentHashMultiset':
        """public static <E> com.google.common.collect.ConcurrentHashMultiset<E> com.google.common.collect.ConcurrentHashMultiset.create(java.util.concurrent.ConcurrentMap<E, java.util.concurrent.atomic.AtomicInteger>)"""
        return ConcurrentHashMultiset._wrap(_ConcurrentHashMultiset.create(countMap))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def createEntrySet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ConcurrentHashMultiset.createEntrySet()"""
        return 'Set'._wrap(super(ConcurrentHashMultiset, self).createEntrySet())

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.count(java.lang.Object)"""
        return int._wrap(super(_ConcurrentHashMultiset, self).count(element))

    @staticmethod
    @overload
    def create() -> 'ConcurrentHashMultiset':
        """public static <E> com.google.common.collect.ConcurrentHashMultiset<E> com.google.common.collect.ConcurrentHashMultiset.create()"""
        return ConcurrentHashMultiset._wrap(_ConcurrentHashMultiset.create())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ConcurrentHashMultiset.toArray()"""
        return List[object]._wrap(super(ConcurrentHashMultiset, self).toArray())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ConcurrentHashMultiset.toArray(T[])"""
        return List[object]._wrap(super(_ConcurrentHashMultiset, self).toArray(array))

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int._wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).retainAll(elementsToRetain)) 
 
 
# CLASS: com.google.common.collect.TreeTraverser
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

from builtins import str
import com.google.common.collect.TreeTraverser as _TreeTraverser
_TreeTraverser = _TreeTraverser
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.FluentIterable as _FluentIterable
_FluentIterable = _FluentIterable
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class TreeTraverser():
    """com.google.common.collect.TreeTraverser"""
 
    @staticmethod
    def _wrap(java_value: _TreeTraverser) -> 'TreeTraverser':
        return TreeTraverser(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _TreeTraverser):
        """
        Dynamic initializer for TreeTraverser.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_TreeTraverser__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_TreeTraverser__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def postOrderTraversal(self, root: object) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<T> com.google.common.collect.TreeTraverser.postOrderTraversal(T)"""
        return 'FluentIterable'._wrap(super(_TreeTraverser, self).postOrderTraversal(root))

    @overload
    def breadthFirstTraversal(self, root: object) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<T> com.google.common.collect.TreeTraverser.breadthFirstTraversal(T)"""
        return 'FluentIterable'._wrap(super(_TreeTraverser, self).breadthFirstTraversal(root))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def __init__(self):
        """public com.google.common.collect.TreeTraverser()"""
        val = _TreeTraverser()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def using(nodeToChildrenFunction: 'Function') -> 'TreeTraverser':
        """public static <T> com.google.common.collect.TreeTraverser<T> com.google.common.collect.TreeTraverser.using(com.google.common.base.Function<T, ? extends java.lang.Iterable<T>>)"""
        return TreeTraverser._wrap(_TreeTraverser.using(nodeToChildrenFunction))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def preOrderTraversal(self, root: object) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<T> com.google.common.collect.TreeTraverser.preOrderTraversal(T)"""
        return 'FluentIterable'._wrap(super(_TreeTraverser, self).preOrderTraversal(root))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.google.common.collect.TreeTraverser()"""
        val = _TreeTraverser()
        self.__wrapper = val

    @abstractmethod
    def children(self, root: object):
        """public abstract java.lang.Iterable<T> com.google.common.collect.TreeTraverser.children(T)"""
        pass

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Interners$InternerBuilder
import com.google.common.collect.Interners as _Interners_InternerBuilder
_InternerBuilder = _Interners_InternerBuilder.InternerBuilder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.google.common.collect.Interner as _Interner
_Interner = _Interner
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class InternerBuilder():
    """com.google.common.collect.Interners.InternerBuilder"""
 
    @staticmethod
    def _wrap(java_value: _InternerBuilder) -> 'InternerBuilder':
        return InternerBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _InternerBuilder):
        """
        Dynamic initializer for InternerBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_InternerBuilder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_InternerBuilder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def concurrencyLevel(self, concurrencyLevel: int) -> 'InternerBuilder':
        """public com.google.common.collect.Interners$InternerBuilder com.google.common.collect.Interners$InternerBuilder.concurrencyLevel(int)"""
        return 'InternerBuilder'._wrap(super(_InternerBuilder, self).concurrencyLevel(_int.valueOf(concurrencyLevel)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def strong(self) -> 'InternerBuilder':
        """public com.google.common.collect.Interners$InternerBuilder com.google.common.collect.Interners$InternerBuilder.strong()"""
        return 'InternerBuilder'._wrap(super(InternerBuilder, self).strong())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def build(self) -> 'Interner':
        """public <E> com.google.common.collect.Interner<E> com.google.common.collect.Interners$InternerBuilder.build()"""
        return 'Interner'._wrap(super(InternerBuilder, self).build())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def weak(self) -> 'InternerBuilder':
        """public com.google.common.collect.Interners$InternerBuilder com.google.common.collect.Interners$InternerBuilder.weak()"""
        return 'InternerBuilder'._wrap(super(InternerBuilder, self).weak())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ArrayTable
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import com.google.common.collect.ArrayTable as _ArrayTable
_ArrayTable = _ArrayTable
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import java.util.Collection as Collection
from builtins import object
from typing import List
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ArrayTable():
    """com.google.common.collect.ArrayTable"""
 
    @staticmethod
    def _wrap(java_value: _ArrayTable) -> 'ArrayTable':
        return ArrayTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ArrayTable):
        """
        Dynamic initializer for ArrayTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ArrayTable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ArrayTable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def set(self, rowIndex: int, columnIndex: int, value: object) -> object:
        """public V com.google.common.collect.ArrayTable.set(int,int,V)"""
        return object._wrap(super(_ArrayTable, self).set(_int.valueOf(rowIndex), _int.valueOf(columnIndex), value))

    @overload
    def put(self, rowKey: object, columnKey: object, value: object) -> object:
        """public V com.google.common.collect.ArrayTable.put(R,C,V)"""
        return object._wrap(super(_ArrayTable, self).put(rowKey, columnKey, value))

    @overload
    def toArray(self, valueClass: 'Class') -> List[List[object]]:
        """public V[][] com.google.common.collect.ArrayTable.toArray(java.lang.Class<V>)"""
        return List[List[object]]._wrap(super(_ArrayTable, self).toArray(valueClass))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def remove(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ArrayTable.remove(java.lang.Object,java.lang.Object)"""
        return object._wrap(super(_ArrayTable, self).remove(rowKey, columnKey))

    @override
    @overload
    def cellSet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.ArrayTable.cellSet()"""
        return 'Set'._wrap(super(ArrayTable, self).cellSet())

    @override
    @overload
    def rowKeySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<R> com.google.common.collect.ArrayTable.rowKeySet()"""
        return 'ImmutableSet'._wrap(super(ArrayTable, self).rowKeySet())

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ArrayTable.values()"""
        return 'Collection'._wrap(super(ArrayTable, self).values())

    @overload
    def column(self, columnKey: object) -> 'Map':
        """public java.util.Map<R, V> com.google.common.collect.ArrayTable.column(C)"""
        return 'Map'._wrap(super(_ArrayTable, self).column(columnKey))

    @overload
    def containsColumn(self, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ArrayTable.containsColumn(java.lang.Object)"""
        return bool._wrap(super(_ArrayTable, self).containsColumn(columnKey))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def eraseAll(self):
        """public void com.google.common.collect.ArrayTable.eraseAll()"""
        super(ArrayTable, self).eraseAll()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def columnKeyList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<C> com.google.common.collect.ArrayTable.columnKeyList()"""
        return 'ImmutableList'._wrap(super(ArrayTable, self).columnKeyList())

    @override
    @overload
    def columnKeySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<C> com.google.common.collect.ArrayTable.columnKeySet()"""
        return 'ImmutableSet'._wrap(super(ArrayTable, self).columnKeySet())

    @overload
    def contains(self, rowKey: object, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ArrayTable.contains(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ArrayTable, self).contains(rowKey, columnKey))

    @overload
    def erase(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ArrayTable.erase(java.lang.Object,java.lang.Object)"""
        return object._wrap(super(_ArrayTable, self).erase(rowKey, columnKey))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ArrayTable.size()"""
        return int._wrap(super(ArrayTable, self).size())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def putAll(self, table: 'Table'):
        """public void com.google.common.collect.ArrayTable.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        super(_ArrayTable, self).putAll(table)

    @staticmethod
    @overload
    def create(table: 'Table') -> 'ArrayTable':
        """public static <R,C,V> com.google.common.collect.ArrayTable<R, C, V> com.google.common.collect.ArrayTable.create(com.google.common.collect.Table<R, C, ? extends V>)"""
        return ArrayTable._wrap(_ArrayTable.create(table))

    @overload
    def row(self, rowKey: object) -> 'Map':
        """public java.util.Map<C, V> com.google.common.collect.ArrayTable.row(R)"""
        return 'Map'._wrap(super(_ArrayTable, self).row(rowKey))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ArrayTable.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ArrayTable, self).containsValue(value))

    @staticmethod
    @overload
    def create(rowKeys: 'Iterable', columnKeys: 'Iterable') -> 'ArrayTable':
        """public static <R,C,V> com.google.common.collect.ArrayTable<R, C, V> com.google.common.collect.ArrayTable.create(java.lang.Iterable<? extends R>,java.lang.Iterable<? extends C>)"""
        return ArrayTable._wrap(_ArrayTable.create(rowKeys, columnKeys))

    @overload
    def at(self, rowIndex: int, columnIndex: int) -> object:
        """public V com.google.common.collect.ArrayTable.at(int,int)"""
        return object._wrap(super(_ArrayTable, self).at(_int.valueOf(rowIndex), _int.valueOf(columnIndex)))

    @override
    @overload
    def columnMap(self) -> 'Map':
        """public java.util.Map<C, java.util.Map<R, V>> com.google.common.collect.ArrayTable.columnMap()"""
        return 'Map'._wrap(super(ArrayTable, self).columnMap())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def containsRow(self, rowKey: object) -> bool:
        """public boolean com.google.common.collect.ArrayTable.containsRow(java.lang.Object)"""
        return bool._wrap(super(_ArrayTable, self).containsRow(rowKey))

    @overload
    def rowKeyList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<R> com.google.common.collect.ArrayTable.rowKeyList()"""
        return 'ImmutableList'._wrap(super(ArrayTable, self).rowKeyList())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def rowMap(self) -> 'Map':
        """public java.util.Map<R, java.util.Map<C, V>> com.google.common.collect.ArrayTable.rowMap()"""
        return 'Map'._wrap(super(ArrayTable, self).rowMap())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ArrayTable.clear()"""
        super(ArrayTable, self).clear()

    @overload
    def get(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ArrayTable.get(java.lang.Object,java.lang.Object)"""
        return object._wrap(super(_ArrayTable, self).get(rowKey, columnKey))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ArrayTable.isEmpty()"""
        return bool._wrap(super(ArrayTable, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.ImmutableTable
import com.google.common.collect.ImmutableTable as _ImmutableTable
_ImmutableTable = _ImmutableTable
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.ImmutableTable as _ImmutableTable_Builder
_Builder = _ImmutableTable_Builder.Builder
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.Table as _Table
_Table = _Table
from builtins import object
from abc import abstractmethod, ABC
import java.util.stream.Collector as Collector
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
import java.lang.Integer as _int
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import java.util.function.BinaryOperator as BinaryOperator
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
import java.util.function.Function as Function
from builtins import bool
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableTable():
    """com.google.common.collect.ImmutableTable"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableTable) -> 'ImmutableTable':
        return ImmutableTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableTable):
        """
        Dynamic initializer for ImmutableTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableTable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableTable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def rowKeySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<R> com.google.common.collect.ImmutableTable.rowKeySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableTable, self).rowKeySet())

    @overload
    def contains(self, rowKey: object, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ImmutableTable.contains(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ImmutableTable, self).contains(rowKey, columnKey))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableTable.values()"""
        return 'ImmutableCollection'._wrap(super(ImmutableTable, self).values())

    @staticmethod
    @overload
    def of() -> 'ImmutableTable':
        """public static <R,C,V> com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable.of()"""
        return ImmutableTable._wrap(_ImmutableTable.of())

    @overload
    def remove(self, rowKey: object, columnKey: object) -> object:
        """public final V com.google.common.collect.ImmutableTable.remove(java.lang.Object,java.lang.Object)"""
        return object._wrap(super(_ImmutableTable, self).remove(rowKey, columnKey))

    @abstractmethod
    def rowMap(self, ):
        """public abstract com.google.common.collect.ImmutableMap<R, java.util.Map<C, V>> com.google.common.collect.ImmutableTable.rowMap()"""
        pass

    @overload
    def row(self, rowKey: object) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<C, V> com.google.common.collect.ImmutableTable.row(R)"""
        return 'ImmutableMap'._wrap(super(_ImmutableTable, self).row(rowKey))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <R,C,V> com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable.builder()"""
        return Builder._wrap(_ImmutableTable.builder())

    @override
    @overload
    def putAll(self, table: 'Table'):
        """public final void com.google.common.collect.ImmutableTable.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        super(_ImmutableTable, self).putAll(table)

    @override
    @overload
    def columnKeySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<C> com.google.common.collect.ImmutableTable.columnKeySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableTable, self).columnKeySet())

    @abstractmethod
    def columnMap(self, ):
        """public abstract com.google.common.collect.ImmutableMap<C, java.util.Map<R, V>> com.google.common.collect.ImmutableTable.columnMap()"""
        pass

    @staticmethod
    @overload
    def toImmutableTable(rowFunction: 'Function', columnFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,R,C,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableTable<R, C, V>> com.google.common.collect.ImmutableTable.toImmutableTable(java.util.function.Function<? super T, ? extends R>,java.util.function.Function<? super T, ? extends C>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector._wrap(_ImmutableTable.toImmutableTable(rowFunction, columnFunction, valueFunction, mergeFunction))

    @overload
    def put(self, rowKey: object, columnKey: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableTable.put(R,C,V)"""
        return object._wrap(super(_ImmutableTable, self).put(rowKey, columnKey, value))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def of(rowKey: object, columnKey: object, value: object) -> 'ImmutableTable':
        """public static <R,C,V> com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable.of(R,C,V)"""
        return ImmutableTable._wrap(_ImmutableTable.of(rowKey, columnKey, value))

    @overload
    def column(self, columnKey: object) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<R, V> com.google.common.collect.ImmutableTable.column(C)"""
        return 'ImmutableMap'._wrap(super(_ImmutableTable, self).column(columnKey))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableTable.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ImmutableTable, self).containsValue(value))

    @staticmethod
    @overload
    def toImmutableTable(rowFunction: 'Function', columnFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,R,C,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableTable<R, C, V>> com.google.common.collect.ImmutableTable.toImmutableTable(java.util.function.Function<? super T, ? extends R>,java.util.function.Function<? super T, ? extends C>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableTable.toImmutableTable(rowFunction, columnFunction, valueFunction))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableTable.clear()"""
        super(ImmutableTable, self).clear()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Table.size()"""
        pass

    @staticmethod
    @overload
    def copyOf(table: 'Table') -> 'ImmutableTable':
        """public static <R,C,V> com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable.copyOf(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        return ImmutableTable._wrap(_ImmutableTable.copyOf(table))

    @override
    @overload
    def cellSet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.ImmutableTable.cellSet()"""
        return 'ImmutableSet'._wrap(super(ImmutableTable, self).cellSet()) 
 
 
# CLASS: com.google.common.collect.ImmutableRangeSet$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.lang.String as _String
_String = _String
import com.google.common.collect.ImmutableRangeSet as _ImmutableRangeSet
_ImmutableRangeSet = _ImmutableRangeSet
import java.lang.Integer as _int
import com.google.common.collect.ImmutableRangeSet as _ImmutableRangeSet_Builder
_Builder = _ImmutableRangeSet_Builder.Builder
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableRangeSet.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableRangeSet$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @overload
    def addAll(self, ranges: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableRangeSet$Builder<C> com.google.common.collect.ImmutableRangeSet$Builder.addAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(ranges))

    @overload
    def addAll(self, ranges: 'RangeSet') -> 'Builder':
        """public com.google.common.collect.ImmutableRangeSet$Builder<C> com.google.common.collect.ImmutableRangeSet$Builder.addAll(com.google.common.collect.RangeSet<C>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(ranges))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableRangeSet$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def add(self, range: 'Range') -> 'Builder':
        """public com.google.common.collect.ImmutableRangeSet$Builder<C> com.google.common.collect.ImmutableRangeSet$Builder.add(com.google.common.collect.Range<C>)"""
        return 'Builder'._wrap(super(_Builder, self).add(range))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def build(self) -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet$Builder.build()"""
        return 'ImmutableRangeSet'._wrap(super(Builder, self).build())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.EnumHashBiMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Map as _Map
_Map = _Map
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.lang.Enum as Enum
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import com.google.common.collect.EnumHashBiMap as _EnumHashBiMap
_EnumHashBiMap = _EnumHashBiMap
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import bool
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
from builtins import int
 
class EnumHashBiMap():
    """com.google.common.collect.EnumHashBiMap"""
 
    @staticmethod
    def _wrap(java_value: _EnumHashBiMap) -> 'EnumHashBiMap':
        return EnumHashBiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _EnumHashBiMap):
        """
        Dynamic initializer for EnumHashBiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_EnumHashBiMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_EnumHashBiMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def put(self, key: 'Enum', value: object) -> object:
        """public V com.google.common.collect.EnumHashBiMap.put(K,V)"""
        return object._wrap(super(_EnumHashBiMap, self).put(key, value))

    @overload
    def forcePut(self, key: 'Enum', value: object) -> object:
        """public V com.google.common.collect.EnumHashBiMap.forcePut(K,V)"""
        return object._wrap(super(_EnumHashBiMap, self).forcePut(key, value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def keyType(self) -> 'type.Class':
        """public java.lang.Class<K> com.google.common.collect.EnumHashBiMap.keyType()"""
        return 'type.Class'._wrap(super(EnumHashBiMap, self).keyType())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @staticmethod
    @overload
    def create(keyType: 'Class') -> 'EnumHashBiMap':
        """public static <K extends java.lang.Enum<K>,V> com.google.common.collect.EnumHashBiMap<K, V> com.google.common.collect.EnumHashBiMap.create(java.lang.Class<K>)"""
        return EnumHashBiMap._wrap(_EnumHashBiMap.create(keyType))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create(map: 'Map') -> 'EnumHashBiMap':
        """public static <K extends java.lang.Enum<K>,V> com.google.common.collect.EnumHashBiMap<K, V> com.google.common.collect.EnumHashBiMap.create(java.util.Map<K, ? extends V>)"""
        return EnumHashBiMap._wrap(_EnumHashBiMap.create(map))

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.ForwardingMap$StandardValues
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.Maps as _Maps_Values
_Values = _Maps_Values.Values
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import com.google.common.collect.ForwardingMap as _ForwardingMap_StandardValues
_StandardValues = _ForwardingMap_StandardValues.StandardValues
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardValues():
    """com.google.common.collect.ForwardingMap.StandardValues"""
 
    @staticmethod
    def _wrap(java_value: _StandardValues) -> 'StandardValues':
        return StandardValues(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardValues):
        """
        Dynamic initializer for StandardValues.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardValues__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardValues__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractCollection, self).addAll(arg0))

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Maps$Values.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_Values, self).retainAll(c))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<V> com.google.common.collect.Maps$Values.iterator()"""
        return 'Iterator'._wrap(super(Values, self).iterator())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Maps$Values.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_Values, self).removeAll(c))

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$Values.remove(java.lang.Object)"""
        return bool._wrap(super(_Values, self).remove(o))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'._wrap(super(Collection, self).spliterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$Values.size()"""
        return int._wrap(super(Values, self).size())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool._wrap(super(_AbstractCollection, self).add(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$Values.contains(java.lang.Object)"""
        return bool._wrap(super(_Values, self).contains(o))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public void com.google.common.collect.Maps$Values.forEach(java.util.function.Consumer<? super V>)"""
        super(_Values, self).forEach(action)

    @overload
    def __init__(self, this$0: 'ForwardingMap'):
        """public com.google.common.collect.ForwardingMap$StandardValues(com.google.common.collect.ForwardingMap)"""
        val = _StandardValues(this$0)
        self.__wrapper = val

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$Values.clear()"""
        super(Values, self).clear()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$Values.isEmpty()"""
        return bool._wrap(super(Values, self).isEmpty())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_SetMultimapBuilder
_SetMultimapBuilder = _MultimapBuilder_SetMultimapBuilder.SetMultimapBuilder
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_MultimapBuilderWithKeys
_MultimapBuilderWithKeys = _MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.lang.Integer as _int
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_SortedSetMultimapBuilder
_SortedSetMultimapBuilder = _MultimapBuilder_SortedSetMultimapBuilder.SortedSetMultimapBuilder
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_ListMultimapBuilder
_ListMultimapBuilder = _MultimapBuilder_ListMultimapBuilder.ListMultimapBuilder
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class MultimapBuilderWithKeys():
    """com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys"""
 
    @staticmethod
    def _wrap(java_value: _MultimapBuilderWithKeys) -> 'MultimapBuilderWithKeys':
        return MultimapBuilderWithKeys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _MultimapBuilderWithKeys):
        """
        Dynamic initializer for MultimapBuilderWithKeys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_MultimapBuilderWithKeys__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_MultimapBuilderWithKeys__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def hashSetValues(self, expectedValuesPerKey: int) -> 'SetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.hashSetValues(int)"""
        return 'SetMultimapBuilder'._wrap(super(_MultimapBuilderWithKeys, self).hashSetValues(_int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def linkedListValues(self) -> 'ListMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$ListMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.linkedListValues()"""
        return 'ListMultimapBuilder'._wrap(super(MultimapBuilderWithKeys, self).linkedListValues())

    @overload
    def enumSetValues(self, valueClass: 'Class') -> 'SetMultimapBuilder':
        """public <V0 extends java.lang.Enum<V0>> com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, V0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.enumSetValues(java.lang.Class<V0>)"""
        return 'SetMultimapBuilder'._wrap(super(_MultimapBuilderWithKeys, self).enumSetValues(valueClass))

    @overload
    def hashSetValues(self) -> 'SetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.hashSetValues()"""
        return 'SetMultimapBuilder'._wrap(super(MultimapBuilderWithKeys, self).hashSetValues())

    @overload
    def treeSetValues(self) -> 'SortedSetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder<K0, java.lang.Comparable> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.treeSetValues()"""
        return 'SortedSetMultimapBuilder'._wrap(super(MultimapBuilderWithKeys, self).treeSetValues())

    @overload
    def arrayListValues(self, expectedValuesPerKey: int) -> 'ListMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$ListMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.arrayListValues(int)"""
        return 'ListMultimapBuilder'._wrap(super(_MultimapBuilderWithKeys, self).arrayListValues(_int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def linkedHashSetValues(self, expectedValuesPerKey: int) -> 'SetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.linkedHashSetValues(int)"""
        return 'SetMultimapBuilder'._wrap(super(_MultimapBuilderWithKeys, self).linkedHashSetValues(_int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def treeSetValues(self, comparator: 'Comparator') -> 'SortedSetMultimapBuilder':
        """public <V0> com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder<K0, V0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.treeSetValues(java.util.Comparator<V0>)"""
        return 'SortedSetMultimapBuilder'._wrap(super(_MultimapBuilderWithKeys, self).treeSetValues(comparator))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def arrayListValues(self) -> 'ListMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$ListMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.arrayListValues()"""
        return 'ListMultimapBuilder'._wrap(super(MultimapBuilderWithKeys, self).arrayListValues())

    @overload
    def linkedHashSetValues(self) -> 'SetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.linkedHashSetValues()"""
        return 'SetMultimapBuilder'._wrap(super(MultimapBuilderWithKeys, self).linkedHashSetValues())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableClassToInstanceMap
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Map as _Map
_Map = _Map
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.util.Set as Set
import com.google.common.collect.ImmutableClassToInstanceMap as _ImmutableClassToInstanceMap_Builder
_Builder = _ImmutableClassToInstanceMap_Builder.Builder
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ImmutableClassToInstanceMap as _ImmutableClassToInstanceMap
_ImmutableClassToInstanceMap = _ImmutableClassToInstanceMap
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import java.util.function.Function as Function
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableClassToInstanceMap():
    """com.google.common.collect.ImmutableClassToInstanceMap"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableClassToInstanceMap) -> 'ImmutableClassToInstanceMap':
        return ImmutableClassToInstanceMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableClassToInstanceMap):
        """
        Dynamic initializer for ImmutableClassToInstanceMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableClassToInstanceMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableClassToInstanceMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @staticmethod
    @overload
    def of() -> 'ImmutableClassToInstanceMap':
        """public static <B> com.google.common.collect.ImmutableClassToInstanceMap<B> com.google.common.collect.ImmutableClassToInstanceMap.of()"""
        return ImmutableClassToInstanceMap._wrap(_ImmutableClassToInstanceMap.of())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ForwardingMap, self).putAll(map)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object._wrap(super(_ForwardingMap, self).put(key, value))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def putInstance(self, type: 'Class', value: object) -> object:
        """public <T extends B> T com.google.common.collect.ImmutableClassToInstanceMap.putInstance(java.lang.Class<T>,T)"""
        return object._wrap(super(_ImmutableClassToInstanceMap, self).putInstance(type, value))

    @staticmethod
    @overload
    def of(type: 'Class', value: object) -> 'ImmutableClassToInstanceMap':
        """public static <B,T extends B> com.google.common.collect.ImmutableClassToInstanceMap<B> com.google.common.collect.ImmutableClassToInstanceMap.of(java.lang.Class<T>,T)"""
        return ImmutableClassToInstanceMap._wrap(_ImmutableClassToInstanceMap.of(type, value))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsValue(value))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).entrySet())

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_Map, self).replaceAll(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).keySet())

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <B> com.google.common.collect.ImmutableClassToInstanceMap$Builder<B> com.google.common.collect.ImmutableClassToInstanceMap.builder()"""
        return Builder._wrap(_ImmutableClassToInstanceMap.builder())

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'._wrap(super(ForwardingMap, self).values())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableClassToInstanceMap':
        """public static <B,S extends B> com.google.common.collect.ImmutableClassToInstanceMap<B> com.google.common.collect.ImmutableClassToInstanceMap.copyOf(java.util.Map<? extends java.lang.Class<? extends S>, ? extends S>)"""
        return ImmutableClassToInstanceMap._wrap(_ImmutableClassToInstanceMap.copyOf(map))

    @overload
    def getInstance(self, type: 'Class') -> object:
        """public <T extends B> T com.google.common.collect.ImmutableClassToInstanceMap.getInstance(java.lang.Class<T>)"""
        return object._wrap(super(_ImmutableClassToInstanceMap, self).getInstance(type))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.ImmutableMultimap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset
_ImmutableMultiset = _ImmutableMultiset
import com.google.common.collect.ImmutableMultimap as _ImmutableMultimap_Builder
_Builder = _ImmutableMultimap_Builder.Builder
import java.util.function.BiConsumer as BiConsumer
import java.lang.Integer as _int
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
import java.lang.Long as _long
import com.google.common.collect.ImmutableMultimap as _ImmutableMultimap
_ImmutableMultimap = _ImmutableMultimap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableMultimap():
    """com.google.common.collect.ImmutableMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableMultimap) -> 'ImmutableMultimap':
        return ImmutableMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableMultimap):
        """
        Dynamic initializer for ImmutableMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def asMap(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, java.util.Collection<V>> com.google.common.collect.ImmutableMultimap.asMap()"""
        return 'ImmutableMap'._wrap(super(ImmutableMultimap, self).asMap())

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.copyOf(multimap))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ImmutableMultimap.size()"""
        return int._wrap(super(ImmutableMultimap, self).size())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'ImmutableCollection'._wrap(super(_ImmutableMultimap, self).replaceValues(key, values))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @abstractmethod
    def get(self, key: object):
        """public abstract com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.get(K)"""
        pass

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.copyOf(entries))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def put(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.put(K,V)"""
        return bool._wrap(super(_ImmutableMultimap, self).put(key, value))

    @abstractmethod
    def inverse(self, ):
        """public abstract com.google.common.collect.ImmutableMultimap<V, K> com.google.common.collect.ImmutableMultimap.inverse()"""
        pass

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.values()"""
        return 'ImmutableCollection'._wrap(super(ImmutableMultimap, self).values())

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).containsValue(value))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2, k3, v3))

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool._wrap(super(_ImmutableMultimap, self).putAll(multimap))

    @override
    @overload
    def keys(self) -> 'ImmutableMultiset':
        """public com.google.common.collect.ImmutableMultiset<K> com.google.common.collect.ImmutableMultimap.keys()"""
        return 'ImmutableMultiset'._wrap(super(ImmutableMultimap, self).keys())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V)"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of(k1, v1, k2, v2))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def removeAll(self, key: object) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.removeAll(java.lang.Object)"""
        return 'ImmutableCollection'._wrap(super(_ImmutableMultimap, self).removeAll(key))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool._wrap(super(_ImmutableMultimap, self).putAll(key, values))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.ImmutableMultimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_ImmutableMultimap, self).forEach(action)

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).remove(key, value))

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMultimap.keySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMultimap, self).keySet())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultimap, self).containsKey(key))

    @override
    @overload
    def entries(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableMultimap.entries()"""
        return 'ImmutableCollection'._wrap(super(ImmutableMultimap, self).entries())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMultimap.clear()"""
        super(ImmutableMultimap, self).clear()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def of() -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of()"""
        return ImmutableMultimap._wrap(_ImmutableMultimap.of())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap.builder()"""
        return Builder._wrap(_ImmutableMultimap.builder()) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.Multiset as _Multiset_Entry
_Entry = _Multiset_Entry.Entry
from builtins import type
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import com.google.common.collect.UnmodifiableIterator as _UnmodifiableIterator
_UnmodifiableIterator = _UnmodifiableIterator
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset_Builder
_Builder = _ImmutableMultiset_Builder.Builder
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.function.ToIntFunction as ToIntFunction
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
import com.google.common.collect.ImmutableSortedMultiset as _ImmutableSortedMultiset
_ImmutableSortedMultiset = _ImmutableSortedMultiset
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.Comparable as Comparable
from builtins import object
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset
_ImmutableMultiset = _ImmutableMultiset
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
from typing import List
import java.util.Comparator as Comparator
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import com.google.common.collect.ImmutableSortedMultiset as _ImmutableSortedMultiset_Builder
_Builder = _ImmutableSortedMultiset_Builder.Builder
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.util.function.Function as Function
import com.google.common.collect.SortedMultiset as _SortedMultiset
_SortedMultiset = _SortedMultiset
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ImmutableSortedMultiset():
    """com.google.common.collect.ImmutableSortedMultiset"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableSortedMultiset) -> 'ImmutableSortedMultiset':
        return ImmutableSortedMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableSortedMultiset):
        """
        Dynamic initializer for ImmutableSortedMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableSortedMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableSortedMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.copyOf(elements))

    @staticmethod
    @overload
    def toImmutableSortedMultiset(comparator: 'Comparator') -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSortedMultiset<E>> com.google.common.collect.ImmutableSortedMultiset.toImmutableSortedMultiset(java.util.Comparator<? super E>)"""
        return Collector._wrap(_ImmutableSortedMultiset.toImmutableSortedMultiset(comparator))

    @abstractmethod
    def lastEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.lastEntry()"""
        pass

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ImmutableCollection, self).remove(object))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object]._wrap(super(_ImmutableCollection, self).toArray(other))

    @abstractmethod
    def count(self, element: object):
        """public abstract int com.google.common.collect.Multiset.count(java.lang.Object)"""
        pass

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public final java.util.Comparator<? super E> com.google.common.collect.ImmutableSortedMultiset.comparator()"""
        return 'Comparator'._wrap(super(ImmutableSortedMultiset, self).comparator())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2, e3))

    @staticmethod
    @overload
    def naturalOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset.naturalOrder()"""
        return Builder._wrap(_ImmutableSortedMultiset.naturalOrder())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def iterator(self) -> 'UnmodifiableIterator':
        """public com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableMultiset.iterator()"""
        return 'UnmodifiableIterator'._wrap(super(ImmutableMultiset, self).iterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *remaining: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2, e3, e4, e5, e6, remaining))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(element))

    @overload
    def subMultiset(self, lowerBound: object, lowerBoundType: 'BoundType', upperBound: object, upperBoundType: 'BoundType') -> 'ImmutableSortedMultiset':
        """public com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.subMultiset(E,com.google.common.collect.BoundType,E,com.google.common.collect.BoundType)"""
        return 'ImmutableSortedMultiset'._wrap(super(_ImmutableSortedMultiset, self).subMultiset(lowerBound, lowerBoundType, upperBound, upperBoundType))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultiset.contains(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultiset, self).contains(object))

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset.orderedBy(java.util.Comparator<E>)"""
        return Builder._wrap(_ImmutableSortedMultiset.orderedBy(comparator))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.add(E,int)"""
        return int._wrap(super(_ImmutableMultiset, self).add(element, _int.valueOf(occurrences)))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object]._wrap(super(ImmutableCollection, self).toArray())

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(element))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterable') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(java.util.Comparator<? super E>,java.lang.Iterable<? extends E>)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.copyOf(comparator, elements))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.setCount(E,int)"""
        return int._wrap(super(_ImmutableMultiset, self).setCount(element, _int.valueOf(count)))

    @override
    @overload
    def pollLastEntry(self) -> 'Entry':
        """public final com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ImmutableSortedMultiset.pollLastEntry()"""
        return 'Entry'._wrap(super(ImmutableSortedMultiset, self).pollLastEntry())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableCollection.spliterator()"""
        return 'Spliterator'._wrap(super(ImmutableCollection, self).spliterator())

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2))

    @override
    @overload
    def descendingMultiset(self) -> 'ImmutableSortedMultiset':
        """public com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.descendingMultiset()"""
        return 'ImmutableSortedMultiset'._wrap(super(ImmutableSortedMultiset, self).descendingMultiset())

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable', e6: 'Comparable', *remaining: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2, e3, e4, e5, e6, remaining))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @staticmethod
    @overload
    def of() -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of()"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of())

    @abstractmethod
    def elementSet(self, ):
        """public abstract com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedMultiset.elementSet()"""
        pass

    @staticmethod
    @overload
    def reverseOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset.reverseOrder()"""
        return Builder._wrap(_ImmutableSortedMultiset.reverseOrder())

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).retainAll(elementsToKeep))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterator') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(java.util.Comparator<? super E>,java.util.Iterator<? extends E>)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.copyOf(comparator, elements))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2, e3, e4))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.copyOf(elements))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultiset, self).equals(object))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset.builder()"""
        return Builder._wrap(_ImmutableMultiset.builder())

    @abstractmethod
    def tailMultiset(self, lowerBound: object, boundType: 'BoundType'):
        """public abstract com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        pass

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool._wrap(super(_ImmutableCollection, self).add(e))

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSortedMultiset':
        """public static <Z> com.google.common.collect.ImmutableSortedMultiset<Z> com.google.common.collect.ImmutableSortedMultiset.copyOf(Z[])"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.copyOf(elements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2, e3))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2, e3))

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry':
        """public final com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ImmutableSortedMultiset.pollFirstEntry()"""
        return 'Entry'._wrap(super(ImmutableSortedMultiset, self).pollFirstEntry())

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultiset.setCount(E,int,int)"""
        return bool._wrap(super(_ImmutableMultiset, self).setCount(element, _int.valueOf(oldCount), _int.valueOf(newCount)))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E,E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def firstEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.firstEntry()"""
        pass

    @staticmethod
    @overload
    def of() -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of()"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E,E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2, e3, e4, e5))

    @staticmethod
    @overload
    def toImmutableMultiset(elementFunction: 'Function', countFunction: 'ToIntFunction') -> 'Collector':
        """public static <T,E> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMultiset<E>> com.google.common.collect.ImmutableSortedMultiset.toImmutableMultiset(java.util.function.Function<? super T, ? extends E>,java.util.function.ToIntFunction<? super T>)"""
        return Collector._wrap(_ImmutableSortedMultiset.toImmutableMultiset(elementFunction, countFunction))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMultiset.toString()"""
        return str._wrap(super(ImmutableMultiset, self).toString())

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.copyOf(elements))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.copyOf(elements))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ImmutableCollection, self).addAll(newElements))

    @override
    @overload
    def asList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableMultiset.asList()"""
        return 'ImmutableList'._wrap(super(ImmutableMultiset, self).asList())

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_Multiset, self).forEachEntry(action)

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMultiset.hashCode()"""
        return int._wrap(super(ImmutableMultiset, self).hashCode())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E,E,E,E...)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2, e3, e4, e5, e6, others))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.remove(java.lang.Object,int)"""
        return int._wrap(super(_ImmutableMultiset, self).remove(element, _int.valueOf(occurrences)))

    @staticmethod
    @overload
    def copyOfSorted(sortedMultiset: 'SortedMultiset') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOfSorted(com.google.common.collect.SortedMultiset<E>)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.copyOfSorted(sortedMultiset))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def toImmutableMultiset() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableMultiset<E>> com.google.common.collect.ImmutableSortedMultiset.toImmutableMultiset()"""
        return Collector._wrap(_ImmutableSortedMultiset.toImmutableMultiset())

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ImmutableMultiset.entrySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMultiset, self).entrySet())

    @staticmethod
    @overload
    def toImmutableSortedMultiset(comparator: 'Comparator', elementFunction: 'Function', countFunction: 'ToIntFunction') -> 'Collector':
        """public static <T,E> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSortedMultiset<E>> com.google.common.collect.ImmutableSortedMultiset.toImmutableSortedMultiset(java.util.Comparator<? super E>,java.util.function.Function<? super T, ? extends E>,java.util.function.ToIntFunction<? super T>)"""
        return Collector._wrap(_ImmutableSortedMultiset.toImmutableSortedMultiset(comparator, elementFunction, countFunction))

    @abstractmethod
    def headMultiset(self, upperBound: object, boundType: 'BoundType'):
        """public abstract com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        pass

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(E[])"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(elements: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(E[])"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.copyOf(elements))

    @staticmethod
    @overload
    def of(element: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(element))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E,E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E)"""
        return ImmutableSortedMultiset._wrap(_ImmutableSortedMultiset.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset.builder()"""
        return Builder._wrap(_ImmutableSortedMultiset.builder())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.ContiguousSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ImmutableSet as _ImmutableSet_Builder
_Builder = _ImmutableSet_Builder.Builder
import java.util.Collection as Collection
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet_Builder
_Builder = _ImmutableSortedSet_Builder.Builder
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
from builtins import str
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
import java.lang.String as _String
_String = _String
import java.lang.Comparable as Comparable
from builtins import object
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
from typing import List
import java.util.Comparator as Comparator
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet
_ImmutableSortedSet = _ImmutableSortedSet
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.ContiguousSet as _ContiguousSet
_ContiguousSet = _ContiguousSet
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ContiguousSet():
    """com.google.common.collect.ContiguousSet"""
 
    @staticmethod
    def _wrap(java_value: _ContiguousSet) -> 'ContiguousSet':
        return ContiguousSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ContiguousSet):
        """
        Dynamic initializer for ContiguousSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ContiguousSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ContiguousSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def naturalOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.naturalOrder()"""
        return Builder._wrap(_ImmutableSortedSet.naturalOrder())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object._wrap(super(NavigableSet, self).removeLast())

    @staticmethod
    @overload
    def of() -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of()"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of())

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3))

    @overload
    def headSet(self, toElement: 'Comparable', inclusive: bool) -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.headSet(C,boolean)"""
        return 'ContiguousSet'._wrap(super(_ContiguousSet, self).headSet(toElement, _boolean.valueOf(inclusive)))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3))

    @staticmethod
    @overload
    def closedOpen(lower: int, upper: int) -> 'ContiguousSet':
        """public static com.google.common.collect.ContiguousSet<java.lang.Integer> com.google.common.collect.ContiguousSet.closedOpen(int,int)"""
        return ContiguousSet._wrap(_ContiguousSet.closedOpen(_int.valueOf(lower), _int.valueOf(upper)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object]._wrap(super(_ImmutableCollection, self).toArray(other))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4, e5))

    @abstractmethod
    def contains(self, object: object):
        """public abstract boolean com.google.common.collect.ImmutableCollection.contains(java.lang.Object)"""
        pass

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object]._wrap(super(ImmutableCollection, self).toArray())

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.lower(E)"""
        return object._wrap(super(_ImmutableSortedSet, self).lower(e))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.orderedBy(java.util.Comparator<E>)"""
        return Builder._wrap(_ImmutableSortedSet.orderedBy(comparator))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def closed(lower: int, upper: int) -> 'ContiguousSet':
        """public static com.google.common.collect.ContiguousSet<java.lang.Long> com.google.common.collect.ContiguousSet.closed(long,long)"""
        return ContiguousSet._wrap(_ContiguousSet.closed(_long.valueOf(lower), _long.valueOf(upper)))

    @staticmethod
    @overload
    def toImmutableSortedSet(comparator: 'Comparator') -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSortedSet<E>> com.google.common.collect.ImmutableSortedSet.toImmutableSortedSet(java.util.Comparator<? super E>)"""
        return Collector._wrap(_ImmutableSortedSet.toImmutableSortedSet(comparator))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSortedSet':
        """public static <Z> com.google.common.collect.ImmutableSortedSet<Z> com.google.common.collect.ImmutableSortedSet.copyOf(Z[])"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).retainAll(elementsToKeep))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4, e5))

    @abstractmethod
    def range(self, lowerBoundType: 'BoundType', upperBoundType: 'BoundType'):
        """public abstract com.google.common.collect.Range<C> com.google.common.collect.ContiguousSet.range(com.google.common.collect.BoundType,com.google.common.collect.BoundType)"""
        pass

    @staticmethod
    @overload
    def reverseOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.reverseOrder()"""
        return Builder._wrap(_ImmutableSortedSet.reverseOrder())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Collection') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.util.Collection<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(comparator, elements))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(element))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ContiguousSet.builder()"""
        return Builder._wrap(_ContiguousSet.builder())

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.ceiling(E)"""
        return object._wrap(super(_ImmutableSortedSet, self).ceiling(e))

    @overload
    def subSet(self, fromElement: 'Comparable', toElement: 'Comparable') -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.subSet(C,C)"""
        return 'ContiguousSet'._wrap(super(_ContiguousSet, self).subSet(fromElement, toElement))

    @abstractmethod
    def intersection(self, other: 'ContiguousSet'):
        """public abstract com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.intersection(com.google.common.collect.ContiguousSet<C>)"""
        pass

    @abstractmethod
    def descendingIterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSortedSet.descendingIterator()"""
        pass

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'._wrap(super(NavigableSet, self).reversed())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableSet.hashCode()"""
        return int._wrap(super(ImmutableSet, self).hashCode())

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ImmutableCollection, self).addAll(newElements))

    @override
    @overload
    def descendingSet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.descendingSet()"""
        return 'ImmutableSortedSet'._wrap(super(ImmutableSortedSet, self).descendingSet())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ContiguousSet.toString()"""
        return str._wrap(super(ContiguousSet, self).toString())

    @overload
    def tailSet(self, fromElement: 'Comparable') -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.tailSet(C)"""
        return 'ContiguousSet'._wrap(super(_ContiguousSet, self).tailSet(fromElement))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2))

    @overload
    def headSet(self, toElement: 'Comparable') -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.headSet(C)"""
        return 'ContiguousSet'._wrap(super(_ContiguousSet, self).headSet(toElement))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableSortedSet.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def closedOpen(lower: int, upper: int) -> 'ContiguousSet':
        """public static com.google.common.collect.ContiguousSet<java.lang.Long> com.google.common.collect.ContiguousSet.closedOpen(long,long)"""
        return ContiguousSet._wrap(_ContiguousSet.closedOpen(_long.valueOf(lower), _long.valueOf(upper)))

    @staticmethod
    @overload
    def of() -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of()"""
        return ImmutableSet._wrap(_ImmutableSet.of())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of(element: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(element))

    @override
    @overload
    def pollFirst(self) -> object:
        """public final E com.google.common.collect.ImmutableSortedSet.pollFirst()"""
        return object._wrap(super(ImmutableSortedSet, self).pollFirst())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty())

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object._wrap(super(NavigableSet, self).removeFirst())

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.first()"""
        return object._wrap(super(ImmutableSortedSet, self).first())

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterable') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.lang.Iterable<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(comparator, elements))

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ImmutableCollection, self).remove(object))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.floor(E)"""
        return object._wrap(super(_ImmutableSortedSet, self).floor(e))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def create(range: 'Range', domain: 'DiscreteDomain') -> 'ContiguousSet':
        """public static <C extends java.lang.Comparable> com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.create(com.google.common.collect.Range<C>,com.google.common.collect.DiscreteDomain<C>)"""
        return ContiguousSet._wrap(_ContiguousSet.create(range, domain))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableSet, self).equals(object))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builder()"""
        return Builder._wrap(_ImmutableSet.builder())

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(element))

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.higher(E)"""
        return object._wrap(super(_ImmutableSortedSet, self).higher(e))

    @abstractmethod
    def range(self, ):
        """public abstract com.google.common.collect.Range<C> com.google.common.collect.ContiguousSet.range()"""
        pass

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable', e6: 'Comparable', *remaining: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, remaining))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4, e5))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(E[])"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4, e5, e6, others))

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool._wrap(super(_ImmutableCollection, self).add(e))

    @overload
    def subSet(self, fromElement: 'Comparable', fromInclusive: bool, toElement: 'Comparable', toInclusive: bool) -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.subSet(C,boolean,C,boolean)"""
        return 'ContiguousSet'._wrap(super(_ContiguousSet, self).subSet(fromElement, _boolean.valueOf(fromInclusive), toElement, _boolean.valueOf(toInclusive)))

    @overload
    def tailSet(self, fromElement: 'Comparable', inclusive: bool) -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.tailSet(C,boolean)"""
        return 'ContiguousSet'._wrap(super(_ContiguousSet, self).tailSet(fromElement, _boolean.valueOf(inclusive)))

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSortedSet.iterator()"""
        pass

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def pollLast(self) -> object:
        """public final E com.google.common.collect.ImmutableSortedSet.pollLast()"""
        return object._wrap(super(ImmutableSortedSet, self).pollLast())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ImmutableSortedSet.comparator()"""
        return 'Comparator'._wrap(super(ImmutableSortedSet, self).comparator())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @staticmethod
    @overload
    def toImmutableSet() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSet<E>> com.google.common.collect.ImmutableSortedSet.toImmutableSet()"""
        return Collector._wrap(_ImmutableSortedSet.toImmutableSet())

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2))

    @staticmethod
    @overload
    def closed(lower: int, upper: int) -> 'ContiguousSet':
        """public static com.google.common.collect.ContiguousSet<java.lang.Integer> com.google.common.collect.ContiguousSet.closed(int,int)"""
        return ContiguousSet._wrap(_ContiguousSet.closed(_int.valueOf(lower), _int.valueOf(upper)))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterator') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.util.Iterator<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(comparator, elements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableSortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(ImmutableSortedSet, self).spliterator())

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @staticmethod
    @overload
    def copyOfSorted(sortedSet: 'SortedSet') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOfSorted(java.util.SortedSet<E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOfSorted(sortedSet))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *remaining: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, remaining))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def copyOf(elements: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(E[])"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableSet.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.last()"""
        return object._wrap(super(ImmutableSortedSet, self).last()) 
 
 
# CLASS: com.google.common.collect.Iterators
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import com.google.common.collect.UnmodifiableIterator as _UnmodifiableIterator
_UnmodifiableIterator = _UnmodifiableIterator
import java.util.Enumeration as Enumeration
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.Enumeration as _Enumeration
_Enumeration = _Enumeration
import com.google.common.collect.Iterators as _Iterators
_Iterators = _Iterators
import java.lang.Object as _object
import com.google.common.base.Optional as _Optional
_Optional = _Optional
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import java.lang.Integer as _int
import java.lang.Long as _long
from builtins import int
import com.google.common.collect.PeekingIterator as _PeekingIterator
_PeekingIterator = _PeekingIterator
import java.lang.Class as _Class
_Class = _Class
 
class Iterators():
    """com.google.common.collect.Iterators"""
 
    @staticmethod
    def _wrap(java_value: _Iterators) -> 'Iterators':
        return Iterators(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Iterators):
        """
        Dynamic initializer for Iterators.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Iterators__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Iterators__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def concat(*inputs: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends T>...)"""
        return Iterator._wrap(_Iterators.concat(inputs))

    @staticmethod
    @overload
    def cycle(iterable: 'Iterable') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.cycle(java.lang.Iterable<T>)"""
        return Iterator._wrap(_Iterators.cycle(iterable))

    @staticmethod
    @overload
    def getLast(iterator: 'Iterator', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.getLast(java.util.Iterator<? extends T>,T)"""
        return object._wrap(_Iterators.getLast(iterator, defaultValue))

    @staticmethod
    @overload
    def consumingIterator(iterator: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.consumingIterator(java.util.Iterator<T>)"""
        return Iterator._wrap(_Iterators.consumingIterator(iterator))

    @staticmethod
    @overload
    def find(iterator: 'Iterator', predicate: 'Predicate', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.find(java.util.Iterator<? extends T>,com.google.common.base.Predicate<? super T>,T)"""
        return object._wrap(_Iterators.find(iterator, predicate, defaultValue))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def concat(a: 'Iterator', b: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends T>,java.util.Iterator<? extends T>)"""
        return Iterator._wrap(_Iterators.concat(a, b))

    @staticmethod
    @overload
    def unmodifiableIterator(iterator: 'UnmodifiableIterator') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.unmodifiableIterator(com.google.common.collect.UnmodifiableIterator<T>)"""
        return UnmodifiableIterator._wrap(_Iterators.unmodifiableIterator(iterator))

    @staticmethod
    @overload
    def size(iterator: 'Iterator') -> int:
        """public static int com.google.common.collect.Iterators.size(java.util.Iterator<?>)"""
        return int._wrap(_Iterators.size(iterator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def all(iterator: 'Iterator', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterators.all(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return bool._wrap(_Iterators.all(iterator, predicate))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def mergeSorted(iterators: 'Iterable', comparator: 'Comparator') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.mergeSorted(java.lang.Iterable<? extends java.util.Iterator<? extends T>>,java.util.Comparator<? super T>)"""
        return UnmodifiableIterator._wrap(_Iterators.mergeSorted(iterators, comparator))

    @staticmethod
    @overload
    def get(iterator: 'Iterator', position: int) -> object:
        """public static <T> T com.google.common.collect.Iterators.get(java.util.Iterator<T>,int)"""
        return object._wrap(_Iterators.get(iterator, _int.valueOf(position)))

    @staticmethod
    @overload
    def removeAll(removeFrom: 'Iterator', elementsToRemove: 'Collection') -> bool:
        """public static boolean com.google.common.collect.Iterators.removeAll(java.util.Iterator<?>,java.util.Collection<?>)"""
        return bool._wrap(_Iterators.removeAll(removeFrom, elementsToRemove))

    @staticmethod
    @overload
    def elementsEqual(iterator1: 'Iterator', iterator2: 'Iterator') -> bool:
        """public static boolean com.google.common.collect.Iterators.elementsEqual(java.util.Iterator<?>,java.util.Iterator<?>)"""
        return bool._wrap(_Iterators.elementsEqual(iterator1, iterator2))

    @staticmethod
    @overload
    def peekingIterator(iterator: 'Iterator') -> 'PeekingIterator':
        """public static <T> com.google.common.collect.PeekingIterator<T> com.google.common.collect.Iterators.peekingIterator(java.util.Iterator<? extends T>)"""
        return PeekingIterator._wrap(_Iterators.peekingIterator(iterator))

    @staticmethod
    @overload
    def concat(a: 'Iterator', b: 'Iterator', c: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends T>,java.util.Iterator<? extends T>,java.util.Iterator<? extends T>)"""
        return Iterator._wrap(_Iterators.concat(a, b, c))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def getOnlyElement(iterator: 'Iterator', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.getOnlyElement(java.util.Iterator<? extends T>,T)"""
        return object._wrap(_Iterators.getOnlyElement(iterator, defaultValue))

    @staticmethod
    @overload
    def asEnumeration(iterator: 'Iterator') -> 'Enumeration':
        """public static <T> java.util.Enumeration<T> com.google.common.collect.Iterators.asEnumeration(java.util.Iterator<T>)"""
        return Enumeration._wrap(_Iterators.asEnumeration(iterator))

    @staticmethod
    @overload
    def get(iterator: 'Iterator', position: int, defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.get(java.util.Iterator<? extends T>,int,T)"""
        return object._wrap(_Iterators.get(iterator, _int.valueOf(position), defaultValue))

    @staticmethod
    @overload
    def forEnumeration(enumeration: 'Enumeration') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.forEnumeration(java.util.Enumeration<T>)"""
        return UnmodifiableIterator._wrap(_Iterators.forEnumeration(enumeration))

    @staticmethod
    @overload
    def removeIf(removeFrom: 'Iterator', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterators.removeIf(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return bool._wrap(_Iterators.removeIf(removeFrom, predicate))

    @staticmethod
    @overload
    def concat(inputs: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends java.util.Iterator<? extends T>>)"""
        return Iterator._wrap(_Iterators.concat(inputs))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def paddedPartition(iterator: 'Iterator', size: int) -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<java.util.List<T>> com.google.common.collect.Iterators.paddedPartition(java.util.Iterator<T>,int)"""
        return UnmodifiableIterator._wrap(_Iterators.paddedPartition(iterator, _int.valueOf(size)))

    @staticmethod
    @overload
    def forArray(*array: object) -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.forArray(T...)"""
        return UnmodifiableIterator._wrap(_Iterators.forArray(array))

    @staticmethod
    @overload
    def toArray(iterator: 'Iterator', type: 'Class') -> List[object]:
        """public static <T> T[] com.google.common.collect.Iterators.toArray(java.util.Iterator<? extends T>,java.lang.Class<T>)"""
        return List[object]._wrap(_Iterators.toArray(iterator, type))

    @staticmethod
    @overload
    def cycle(*elements: object) -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.cycle(T...)"""
        return Iterator._wrap(_Iterators.cycle(elements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def tryFind(iterator: 'Iterator', predicate: 'Predicate') -> 'base.Optional':
        """public static <T> com.google.common.base.Optional<T> com.google.common.collect.Iterators.tryFind(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return base.Optional._wrap(_Iterators.tryFind(iterator, predicate))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def filter(unfiltered: 'Iterator', desiredType: 'Class') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.filter(java.util.Iterator<?>,java.lang.Class<T>)"""
        return UnmodifiableIterator._wrap(_Iterators.filter(unfiltered, desiredType))

    @staticmethod
    @overload
    def filter(unfiltered: 'Iterator', retainIfTrue: 'Predicate') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.filter(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return UnmodifiableIterator._wrap(_Iterators.filter(unfiltered, retainIfTrue))

    @staticmethod
    @overload
    def find(iterator: 'Iterator', predicate: 'Predicate') -> object:
        """public static <T> T com.google.common.collect.Iterators.find(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return object._wrap(_Iterators.find(iterator, predicate))

    @staticmethod
    @overload
    def advance(iterator: 'Iterator', numberToAdvance: int) -> int:
        """public static int com.google.common.collect.Iterators.advance(java.util.Iterator<?>,int)"""
        return int._wrap(_Iterators.advance(iterator, _int.valueOf(numberToAdvance)))

    @staticmethod
    @overload
    def contains(iterator: 'Iterator', element: object) -> bool:
        """public static boolean com.google.common.collect.Iterators.contains(java.util.Iterator<?>,java.lang.Object)"""
        return bool._wrap(_Iterators.contains(iterator, element))

    @staticmethod
    @overload
    def transform(fromIterator: 'Iterator', function: 'Function') -> 'Iterator':
        """public static <F,T> java.util.Iterator<T> com.google.common.collect.Iterators.transform(java.util.Iterator<F>,com.google.common.base.Function<? super F, ? extends T>)"""
        return Iterator._wrap(_Iterators.transform(fromIterator, function))

    @staticmethod
    @overload
    def any(iterator: 'Iterator', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterators.any(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return bool._wrap(_Iterators.any(iterator, predicate))

    @staticmethod
    @overload
    def toString(iterator: 'Iterator') -> str:
        """public static java.lang.String com.google.common.collect.Iterators.toString(java.util.Iterator<?>)"""
        return str._wrap(_Iterators.toString(iterator))

    @staticmethod
    @overload
    def unmodifiableIterator(iterator: 'Iterator') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.unmodifiableIterator(java.util.Iterator<? extends T>)"""
        return UnmodifiableIterator._wrap(_Iterators.unmodifiableIterator(iterator))

    @staticmethod
    @overload
    def getOnlyElement(iterator: 'Iterator') -> object:
        """public static <T> T com.google.common.collect.Iterators.getOnlyElement(java.util.Iterator<T>)"""
        return object._wrap(_Iterators.getOnlyElement(iterator))

    @staticmethod
    @overload
    def limit(iterator: 'Iterator', limitSize: int) -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.limit(java.util.Iterator<T>,int)"""
        return Iterator._wrap(_Iterators.limit(iterator, _int.valueOf(limitSize)))

    @staticmethod
    @overload
    def frequency(iterator: 'Iterator', element: object) -> int:
        """public static int com.google.common.collect.Iterators.frequency(java.util.Iterator<?>,java.lang.Object)"""
        return int._wrap(_Iterators.frequency(iterator, element))

    @staticmethod
    @overload
    def addAll(addTo: 'Collection', iterator: 'Iterator') -> bool:
        """public static <T> boolean com.google.common.collect.Iterators.addAll(java.util.Collection<T>,java.util.Iterator<? extends T>)"""
        return bool._wrap(_Iterators.addAll(addTo, iterator))

    @staticmethod
    @overload
    def retainAll(removeFrom: 'Iterator', elementsToRetain: 'Collection') -> bool:
        """public static boolean com.google.common.collect.Iterators.retainAll(java.util.Iterator<?>,java.util.Collection<?>)"""
        return bool._wrap(_Iterators.retainAll(removeFrom, elementsToRetain))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def partition(iterator: 'Iterator', size: int) -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<java.util.List<T>> com.google.common.collect.Iterators.partition(java.util.Iterator<T>,int)"""
        return UnmodifiableIterator._wrap(_Iterators.partition(iterator, _int.valueOf(size)))

    @staticmethod
    @overload
    def indexOf(iterator: 'Iterator', predicate: 'Predicate') -> int:
        """public static <T> int com.google.common.collect.Iterators.indexOf(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return int._wrap(_Iterators.indexOf(iterator, predicate))

    @staticmethod
    @overload
    def concat(a: 'Iterator', b: 'Iterator', c: 'Iterator', d: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends T>,java.util.Iterator<? extends T>,java.util.Iterator<? extends T>,java.util.Iterator<? extends T>)"""
        return Iterator._wrap(_Iterators.concat(a, b, c, d))

    @staticmethod
    @overload
    def getNext(iterator: 'Iterator', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.getNext(java.util.Iterator<? extends T>,T)"""
        return object._wrap(_Iterators.getNext(iterator, defaultValue))

    @staticmethod
    @overload
    def getLast(iterator: 'Iterator') -> object:
        """public static <T> T com.google.common.collect.Iterators.getLast(java.util.Iterator<T>)"""
        return object._wrap(_Iterators.getLast(iterator))

    @staticmethod
    @overload
    def peekingIterator(iterator: 'PeekingIterator') -> 'PeekingIterator':
        """public static <T> com.google.common.collect.PeekingIterator<T> com.google.common.collect.Iterators.peekingIterator(com.google.common.collect.PeekingIterator<T>)"""
        return PeekingIterator._wrap(_Iterators.peekingIterator(iterator))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def singletonIterator(value: object) -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.singletonIterator(T)"""
        return UnmodifiableIterator._wrap(_Iterators.singletonIterator(value)) 
 
 
# CLASS: com.google.common.collect.SetMultimap
from pyquantum_helper import override
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
import java.lang.Iterable as Iterable
import com.google.common.collect.SetMultimap as _SetMultimap
_SetMultimap = _SetMultimap
from abc import abstractmethod, ABC
 
class SetMultimap():
    """com.google.common.collect.SetMultimap"""
 
    @staticmethod
    def _wrap(java_value: _SetMultimap) -> 'SetMultimap':
        return SetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SetMultimap):
        """
        Dynamic initializer for SetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SetMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SetMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def keys(self, ):
        """public abstract com.google.common.collect.Multiset<K> com.google.common.collect.Multimap.keys()"""
        pass

    @abstractmethod
    def asMap(self, ):
        """public abstract java.util.Map<K, java.util.Collection<V>> com.google.common.collect.SetMultimap.asMap()"""
        pass

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Multimap.isEmpty()"""
        pass

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> com.google.common.collect.Multimap.keySet()"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.put(K,V)"""
        pass

    @abstractmethod
    def containsEntry(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def remove(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def containsKey(self, key: object):
        """public abstract boolean com.google.common.collect.Multimap.containsKey(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.values()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multimap.hashCode()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.SetMultimap.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def putAll(self, key: object, values: 'Iterable'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def entries(self, ):
        """public abstract java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.SetMultimap.entries()"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Multimap.clear()"""
        pass

    @abstractmethod
    def replaceValues(self, key: object, values: 'Iterable'):
        """public abstract java.util.Set<V> com.google.common.collect.SetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def get(self, key: object):
        """public abstract java.util.Set<V> com.google.common.collect.SetMultimap.get(K)"""
        pass

    @abstractmethod
    def removeAll(self, key: object):
        """public abstract java.util.Set<V> com.google.common.collect.SetMultimap.removeAll(java.lang.Object)"""
        pass

    @abstractmethod
    def putAll(self, multimap: 'Multimap'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multimap.size()"""
        pass 
 
 
# CLASS: com.google.common.collect.ImmutableBiMap$Builder
import com.google.common.collect.ImmutableBiMap as _ImmutableBiMap
_ImmutableBiMap = _ImmutableBiMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.ImmutableBiMap as _ImmutableBiMap_Builder
_Builder = _ImmutableBiMap_Builder.Builder
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Integer as _int
import java.util.Map as Map
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableBiMap.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(entries))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def putAll(self, map: 'Map') -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.putAll(java.util.Map<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(map))

    @override
    @overload
    def buildKeepingLast(self) -> 'ImmutableBiMap':
        """public com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap$Builder.buildKeepingLast()"""
        return 'ImmutableBiMap'._wrap(super(Builder, self).buildKeepingLast())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).put(entry))

    @override
    @overload
    def build(self) -> 'ImmutableBiMap':
        """public com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap$Builder.build()"""
        return 'ImmutableBiMap'._wrap(super(Builder, self).build())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def orderEntriesByValue(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.orderEntriesByValue(java.util.Comparator<? super V>)"""
        return 'Builder'._wrap(super(_Builder, self).orderEntriesByValue(valueComparator))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableBiMap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.put(K,V)"""
        return 'Builder'._wrap(super(_Builder, self).put(key, value))

    @override
    @overload
    def buildOrThrow(self) -> 'ImmutableBiMap':
        """public com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap$Builder.buildOrThrow()"""
        return 'ImmutableBiMap'._wrap(super(Builder, self).buildOrThrow())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableBiMap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingObject
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Integer as _int
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.lang.String as _String
_String = _String
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingObject():
    """com.google.common.collect.ForwardingObject"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingObject) -> 'ForwardingObject':
        return ForwardingObject(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingObject):
        """
        Dynamic initializer for ForwardingObject.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingObject__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingObject__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Maps$EntryTransformer
import com.google.common.collect.Maps as _Maps_EntryTransformer
_EntryTransformer = _Maps_EntryTransformer.EntryTransformer
from abc import abstractmethod, ABC
 
class EntryTransformer():
    """com.google.common.collect.Maps.EntryTransformer"""
 
    @staticmethod
    def _wrap(java_value: _EntryTransformer) -> 'EntryTransformer':
        return EntryTransformer(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _EntryTransformer):
        """
        Dynamic initializer for EntryTransformer.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_EntryTransformer__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_EntryTransformer__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def transformEntry(self, key: object, value: object):
        """public abstract V2 com.google.common.collect.Maps$EntryTransformer.transformEntry(K,V1)"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingQueue
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.google.common.collect.ForwardingQueue as _ForwardingQueue
_ForwardingQueue = _ForwardingQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingQueue():
    """com.google.common.collect.ForwardingQueue"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingQueue) -> 'ForwardingQueue':
        return ForwardingQueue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingQueue):
        """
        Dynamic initializer for ForwardingQueue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingQueue__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingQueue__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'._wrap(super(Collection, self).spliterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def remove(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.remove()"""
        return object._wrap(super(ForwardingQueue, self).remove())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def element(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.element()"""
        return object._wrap(super(ForwardingQueue, self).element())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.peek()"""
        return object._wrap(super(ForwardingQueue, self).peek())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.poll()"""
        return object._wrap(super(ForwardingQueue, self).poll())

    @overload
    def offer(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingQueue.offer(E)"""
        return bool._wrap(super(_ForwardingQueue, self).offer(o))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Streams$FunctionWithIndex
from abc import abstractmethod, ABC
import com.google.common.collect.Streams as _Streams_FunctionWithIndex
_FunctionWithIndex = _Streams_FunctionWithIndex.FunctionWithIndex
 
class FunctionWithIndex():
    """com.google.common.collect.Streams.FunctionWithIndex"""
 
    @staticmethod
    def _wrap(java_value: _FunctionWithIndex) -> 'FunctionWithIndex':
        return FunctionWithIndex(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _FunctionWithIndex):
        """
        Dynamic initializer for FunctionWithIndex.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_FunctionWithIndex__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_FunctionWithIndex__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, from: object, index: int):
        """public abstract R com.google.common.collect.Streams$FunctionWithIndex.apply(T,long)"""
        pass 
 
 
# CLASS: com.google.common.collect.MapDifference$ValueDifference
import com.google.common.collect.MapDifference as _MapDifference_ValueDifference
_ValueDifference = _MapDifference_ValueDifference.ValueDifference
from abc import abstractmethod, ABC
 
class ValueDifference():
    """com.google.common.collect.MapDifference.ValueDifference"""
 
    @staticmethod
    def _wrap(java_value: _ValueDifference) -> 'ValueDifference':
        return ValueDifference(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ValueDifference):
        """
        Dynamic initializer for ValueDifference.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ValueDifference__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ValueDifference__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def equals(self, other: object):
        """public abstract boolean com.google.common.collect.MapDifference$ValueDifference.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.MapDifference$ValueDifference.hashCode()"""
        pass

    @abstractmethod
    def leftValue(self, ):
        """public abstract V com.google.common.collect.MapDifference$ValueDifference.leftValue()"""
        pass

    @abstractmethod
    def rightValue(self, ):
        """public abstract V com.google.common.collect.MapDifference$ValueDifference.rightValue()"""
        pass 
 
 
# CLASS: com.google.common.collect.Table$Cell
import com.google.common.collect.Table as _Table_Cell
_Cell = _Table_Cell.Cell
from abc import abstractmethod, ABC
 
class Cell():
    """com.google.common.collect.Table.Cell"""
 
    @staticmethod
    def _wrap(java_value: _Cell) -> 'Cell':
        return Cell(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Cell):
        """
        Dynamic initializer for Cell.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Cell__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Cell__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def getColumnKey(self, ):
        """public abstract C com.google.common.collect.Table$Cell.getColumnKey()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Table$Cell.hashCode()"""
        pass

    @abstractmethod
    def getRowKey(self, ):
        """public abstract R com.google.common.collect.Table$Cell.getRowKey()"""
        pass

    @abstractmethod
    def getValue(self, ):
        """public abstract V com.google.common.collect.Table$Cell.getValue()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.Table$Cell.equals(java.lang.Object)"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMultiset$StandardDescendingMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.Multiset as _Multiset_Entry
_Entry = _Multiset_Entry.Entry
from builtins import type
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.google.common.collect.ForwardingMultiset as _ForwardingMultiset
_ForwardingMultiset = _ForwardingMultiset
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.Iterator as Iterator
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
from typing import List
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import com.google.common.collect.DescendingMultiset as _DescendingMultiset
_DescendingMultiset = _DescendingMultiset
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.SortedMultiset as _SortedMultiset
_SortedMultiset = _SortedMultiset
import com.google.common.collect.ForwardingSortedMultiset as _ForwardingSortedMultiset_StandardDescendingMultiset
_StandardDescendingMultiset = _ForwardingSortedMultiset_StandardDescendingMultiset.StandardDescendingMultiset
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class StandardDescendingMultiset():
    """com.google.common.collect.ForwardingSortedMultiset.StandardDescendingMultiset"""
 
    @staticmethod
    def _wrap(java_value: _StandardDescendingMultiset) -> 'StandardDescendingMultiset':
        return StandardDescendingMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardDescendingMultiset):
        """
        Dynamic initializer for StandardDescendingMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardDescendingMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardDescendingMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def pollFirstEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.DescendingMultiset.pollFirstEntry()"""
        return 'Entry'._wrap(super(DescendingMultiset, self).pollFirstEntry())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.DescendingMultiset.iterator()"""
        return 'Iterator'._wrap(super(DescendingMultiset, self).iterator())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultiset, self).equals(object))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.DescendingMultiset.comparator()"""
        return 'Comparator'._wrap(super(DescendingMultiset, self).comparator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def firstEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.DescendingMultiset.firstEntry()"""
        return 'Entry'._wrap(super(DescendingMultiset, self).firstEntry())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def pollLastEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.DescendingMultiset.pollLastEntry()"""
        return 'Entry'._wrap(super(DescendingMultiset, self).pollLastEntry())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.DescendingMultiset.toString()"""
        return str._wrap(super(DescendingMultiset, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.setCount(E,int,int)"""
        return bool._wrap(super(_ForwardingMultiset, self).setCount(element, _int.valueOf(oldCount), _int.valueOf(newCount)))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.add(E,int)"""
        return int._wrap(super(_ForwardingMultiset, self).add(element, _int.valueOf(occurrences)))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.setCount(E,int)"""
        return int._wrap(super(_ForwardingMultiset, self).setCount(element, _int.valueOf(count)))

    @overload
    def __init__(self, this$0: 'ForwardingSortedMultiset'):
        """public com.google.common.collect.ForwardingSortedMultiset$StandardDescendingMultiset(com.google.common.collect.ForwardingSortedMultiset)"""
        val = _StandardDescendingMultiset(this$0)
        self.__wrapper = val

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @overload
    def tailMultiset(self, fromElement: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.DescendingMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'._wrap(super(_DescendingMultiset, self).tailMultiset(fromElement, boundType))

    @overload
    def headMultiset(self, toElement: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.DescendingMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'._wrap(super(_DescendingMultiset, self).headMultiset(toElement, boundType))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.DescendingMultiset.toArray()"""
        return List[object]._wrap(super(DescendingMultiset, self).toArray())

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_Multiset, self).forEachEntry(action)

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultiset.hashCode()"""
        return int._wrap(super(ForwardingMultiset, self).hashCode())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def subMultiset(self, fromElement: object, fromBoundType: 'BoundType', toElement: object, toBoundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.DescendingMultiset.subMultiset(E,com.google.common.collect.BoundType,E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'._wrap(super(_DescendingMultiset, self).subMultiset(fromElement, fromBoundType, toElement, toBoundType))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def descendingMultiset(self) -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.DescendingMultiset.descendingMultiset()"""
        return 'SortedMultiset'._wrap(super(DescendingMultiset, self).descendingMultiset())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingMultiset.count(java.lang.Object)"""
        return int._wrap(super(_ForwardingMultiset, self).count(element))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.DescendingMultiset.entrySet()"""
        return 'Set'._wrap(super(DescendingMultiset, self).entrySet())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.remove(java.lang.Object,int)"""
        return int._wrap(super(_ForwardingMultiset, self).remove(element, _int.valueOf(occurrences)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.DescendingMultiset.toArray(T[])"""
        return List[object]._wrap(super(_DescendingMultiset, self).toArray(array))

    @override
    @overload
    def elementSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.DescendingMultiset.elementSet()"""
        return 'NavigableSet'._wrap(super(DescendingMultiset, self).elementSet())

    @override
    @overload
    def lastEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.DescendingMultiset.lastEntry()"""
        return 'Entry'._wrap(super(DescendingMultiset, self).lastEntry()) 
 
 
# CLASS: com.google.common.collect.ImmutableMultimap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import com.google.common.collect.ImmutableMultimap as _ImmutableMultimap_Builder
_Builder = _ImmutableMultimap_Builder.Builder
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
import com.google.common.collect.ImmutableMultimap as _ImmutableMultimap
_ImmutableMultimap = _ImmutableMultimap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableMultimap.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableMultimap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).put(entry))

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(entries))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def orderValuesBy(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.orderValuesBy(java.util.Comparator<? super V>)"""
        return 'Builder'._wrap(super(_Builder, self).orderValuesBy(valueComparator))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def orderKeysBy(self, keyComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.orderKeysBy(java.util.Comparator<? super K>)"""
        return 'Builder'._wrap(super(_Builder, self).orderKeysBy(keyComparator))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.put(K,V)"""
        return 'Builder'._wrap(super(_Builder, self).put(key, value))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def putAll(self, key: object, *values: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.putAll(K,V...)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(key, values))

    @overload
    def build(self) -> 'ImmutableMultimap':
        """public com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap$Builder.build()"""
        return 'ImmutableMultimap'._wrap(super(Builder, self).build())

    @overload
    def putAll(self, key: object, values: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.putAll(K,java.lang.Iterable<? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(key, values))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableMultimap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @overload
    def putAll(self, multimap: 'Multimap') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(multimap))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingMap$StandardEntrySet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import com.google.common.collect.Maps as _Maps_EntrySet
_EntrySet = _Maps_EntrySet.EntrySet
from abc import abstractmethod, ABC
import java.util.Set as _Set
_Set = _Set
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
from builtins import bool
import com.google.common.collect.ForwardingMap as _ForwardingMap_StandardEntrySet
_StandardEntrySet = _ForwardingMap_StandardEntrySet.StandardEntrySet
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.AbstractSet as _AbstractSet
_AbstractSet = _AbstractSet
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
from typing import List
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardEntrySet():
    """com.google.common.collect.ForwardingMap.StandardEntrySet"""
 
    @staticmethod
    def _wrap(java_value: _StandardEntrySet) -> 'StandardEntrySet':
        return StandardEntrySet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardEntrySet):
        """
        Dynamic initializer for StandardEntrySet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardEntrySet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardEntrySet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int._wrap(super(AbstractSet, self).hashCode())

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.remove(java.lang.Object)"""
        return bool._wrap(super(_EntrySet, self).remove(o))

    @abstractmethod
    def iterator(self, ):
        """public abstract java.util.Iterator<E> java.util.AbstractCollection.iterator()"""
        pass

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$EntrySet.size()"""
        return int._wrap(super(EntrySet, self).size())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_EntrySet, self).retainAll(c))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractSet, self).equals(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.isEmpty()"""
        return bool._wrap(super(EntrySet, self).isEmpty())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool._wrap(super(_AbstractCollection, self).add(arg0))

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.contains(java.lang.Object)"""
        return bool._wrap(super(_EntrySet, self).contains(o))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_EntrySet, self).removeAll(c))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$EntrySet.clear()"""
        super(EntrySet, self).clear()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'._wrap(super(Set, self).spliterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.ImmutableSetMultimap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import com.google.common.collect.ImmutableSetMultimap as _ImmutableSetMultimap
_ImmutableSetMultimap = _ImmutableSetMultimap
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import com.google.common.collect.ImmutableSetMultimap as _ImmutableSetMultimap_Builder
_Builder = _ImmutableSetMultimap_Builder.Builder
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableSetMultimap.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, multimap: 'Multimap') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(multimap))

    @overload
    def orderKeysBy(self, keyComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.orderKeysBy(java.util.Comparator<? super K>)"""
        return 'Builder'._wrap(super(_Builder, self).orderKeysBy(keyComparator))

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.put(K,V)"""
        return 'Builder'._wrap(super(_Builder, self).put(key, value))

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(entries))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableSetMultimap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).put(entry))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def orderValuesBy(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.orderValuesBy(java.util.Comparator<? super V>)"""
        return 'Builder'._wrap(super(_Builder, self).orderValuesBy(valueComparator))

    @override
    @overload
    def build(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.build()"""
        return 'ImmutableSetMultimap'._wrap(super(Builder, self).build())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def putAll(self, key: object, *values: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.putAll(K,V...)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(key, values))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def putAll(self, key: object, values: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.putAll(K,java.lang.Iterable<? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(key, values))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableSetMultimap$Builder()"""
        val = _Builder()
        self.__wrapper = val 
 
 
# CLASS: com.google.common.collect.ImmutableRangeSet
from builtins import str
import com.google.common.collect.AbstractRangeSet as _AbstractRangeSet
_AbstractRangeSet = _AbstractRangeSet
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.RangeSet as _RangeSet
_RangeSet = _RangeSet
import java.lang.Iterable as Iterable
import java.lang.Comparable as Comparable
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableRangeSet as _ImmutableRangeSet
_ImmutableRangeSet = _ImmutableRangeSet
import java.lang.Integer as _int
import com.google.common.collect.Range as _Range
_Range = _Range
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet
_ImmutableSortedSet = _ImmutableSortedSet
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
import com.google.common.collect.ImmutableRangeSet as _ImmutableRangeSet_Builder
_Builder = _ImmutableRangeSet_Builder.Builder
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableRangeSet():
    """com.google.common.collect.ImmutableRangeSet"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableRangeSet) -> 'ImmutableRangeSet':
        return ImmutableRangeSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableRangeSet):
        """
        Dynamic initializer for ImmutableRangeSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableRangeSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableRangeSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ImmutableRangeSet.isEmpty()"""
        return bool._wrap(super(ImmutableRangeSet, self).isEmpty())

    @overload
    def encloses(self, otherRange: 'Range') -> bool:
        """public boolean com.google.common.collect.ImmutableRangeSet.encloses(com.google.common.collect.Range<C>)"""
        return bool._wrap(super(_ImmutableRangeSet, self).encloses(otherRange))

    @override
    @overload
    def removeAll(self, other: 'RangeSet'):
        """public void com.google.common.collect.ImmutableRangeSet.removeAll(com.google.common.collect.RangeSet<C>)"""
        super(_ImmutableRangeSet, self).removeAll(other)

    @staticmethod
    @overload
    def copyOf(ranges: 'Iterable') -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.copyOf(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return ImmutableRangeSet._wrap(_ImmutableRangeSet.copyOf(ranges))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractRangeSet.hashCode()"""
        return int._wrap(super(AbstractRangeSet, self).hashCode())

    @overload
    def intersects(self, otherRange: 'Range') -> bool:
        """public boolean com.google.common.collect.ImmutableRangeSet.intersects(com.google.common.collect.Range<C>)"""
        return bool._wrap(super(_ImmutableRangeSet, self).intersects(otherRange))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.ImmutableRangeSet$Builder<C> com.google.common.collect.ImmutableRangeSet.builder()"""
        return Builder._wrap(_ImmutableRangeSet.builder())

    @override
    @overload
    def asRanges(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Range<C>> com.google.common.collect.ImmutableRangeSet.asRanges()"""
        return 'ImmutableSet'._wrap(super(ImmutableRangeSet, self).asRanges())

    @override
    @overload
    def asDescendingSetOfRanges(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Range<C>> com.google.common.collect.ImmutableRangeSet.asDescendingSetOfRanges()"""
        return 'ImmutableSet'._wrap(super(ImmutableRangeSet, self).asDescendingSetOfRanges())

    @override
    @overload
    def complement(self) -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.complement()"""
        return 'ImmutableRangeSet'._wrap(super(ImmutableRangeSet, self).complement())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def toImmutableRangeSet() -> 'Collector':
        """public static <E extends java.lang.Comparable<? super E>> java.util.stream.Collector<com.google.common.collect.Range<E>, ?, com.google.common.collect.ImmutableRangeSet<E>> com.google.common.collect.ImmutableRangeSet.toImmutableRangeSet()"""
        return Collector._wrap(_ImmutableRangeSet.toImmutableRangeSet())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def span(self) -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.ImmutableRangeSet.span()"""
        return 'Range'._wrap(super(ImmutableRangeSet, self).span())

    @staticmethod
    @overload
    def of() -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.of()"""
        return ImmutableRangeSet._wrap(_ImmutableRangeSet.of())

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractRangeSet.toString()"""
        return str._wrap(super(AbstractRangeSet, self).toString())

    @staticmethod
    @overload
    def copyOf(rangeSet: 'RangeSet') -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.copyOf(com.google.common.collect.RangeSet<C>)"""
        return ImmutableRangeSet._wrap(_ImmutableRangeSet.copyOf(rangeSet))

    @overload
    def enclosesAll(self, other: 'Iterable') -> bool:
        """public default boolean com.google.common.collect.RangeSet.enclosesAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return bool._wrap(super(_RangeSet, self).enclosesAll(other))

    @staticmethod
    @overload
    def unionOf(ranges: 'Iterable') -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.unionOf(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return ImmutableRangeSet._wrap(_ImmutableRangeSet.unionOf(ranges))

    @override
    @overload
    def addAll(self, other: 'Iterable'):
        """public void com.google.common.collect.ImmutableRangeSet.addAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(_ImmutableRangeSet, self).addAll(other)

    @override
    @overload
    def addAll(self, other: 'RangeSet'):
        """public void com.google.common.collect.ImmutableRangeSet.addAll(com.google.common.collect.RangeSet<C>)"""
        super(_ImmutableRangeSet, self).addAll(other)

    @overload
    def union(self, other: 'RangeSet') -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.union(com.google.common.collect.RangeSet<C>)"""
        return 'ImmutableRangeSet'._wrap(super(_ImmutableRangeSet, self).union(other))

    @staticmethod
    @overload
    def of(range: 'Range') -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.of(com.google.common.collect.Range<C>)"""
        return ImmutableRangeSet._wrap(_ImmutableRangeSet.of(range))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def subRangeSet(self, range: 'Range') -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.subRangeSet(com.google.common.collect.Range<C>)"""
        return 'ImmutableRangeSet'._wrap(super(_ImmutableRangeSet, self).subRangeSet(range))

    @overload
    def rangeContaining(self, value: 'Comparable') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.ImmutableRangeSet.rangeContaining(C)"""
        return 'Range'._wrap(super(_ImmutableRangeSet, self).rangeContaining(value))

    @override
    @overload
    def removeAll(self, other: 'Iterable'):
        """public void com.google.common.collect.ImmutableRangeSet.removeAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(_ImmutableRangeSet, self).removeAll(other)

    @override
    @overload
    def remove(self, range: 'Range'):
        """public void com.google.common.collect.ImmutableRangeSet.remove(com.google.common.collect.Range<C>)"""
        super(_ImmutableRangeSet, self).remove(range)

    @overload
    def intersection(self, other: 'RangeSet') -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.intersection(com.google.common.collect.RangeSet<C>)"""
        return 'ImmutableRangeSet'._wrap(super(_ImmutableRangeSet, self).intersection(other))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def difference(self, other: 'RangeSet') -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.difference(com.google.common.collect.RangeSet<C>)"""
        return 'ImmutableRangeSet'._wrap(super(_ImmutableRangeSet, self).difference(other))

    @override
    @overload
    def add(self, range: 'Range'):
        """public void com.google.common.collect.ImmutableRangeSet.add(com.google.common.collect.Range<C>)"""
        super(_ImmutableRangeSet, self).add(range)

    @overload
    def asSet(self, domain: 'DiscreteDomain') -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<C> com.google.common.collect.ImmutableRangeSet.asSet(com.google.common.collect.DiscreteDomain<C>)"""
        return 'ImmutableSortedSet'._wrap(super(_ImmutableRangeSet, self).asSet(domain)) 
 
 
# CLASS: com.google.common.collect.ImmutableList$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import com.google.common.collect.ImmutableList as _ImmutableList_Builder
_Builder = _ImmutableList_Builder.Builder
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableList.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList$Builder.add(E...)"""
        return 'Builder'._wrap(super(_Builder, self).add(elements))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableList$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList$Builder.add(E)"""
        return 'Builder'._wrap(super(_Builder, self).add(element))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def build(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList$Builder.build()"""
        return 'ImmutableList'._wrap(super(Builder, self).build())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableList$Builder()"""
        val = _Builder()
        self.__wrapper = val 
 
 
# CLASS: com.google.common.collect.ImmutableListMultimap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Integer as _int
import com.google.common.collect.ImmutableListMultimap as _ImmutableListMultimap_Builder
_Builder = _ImmutableListMultimap_Builder.Builder
from builtins import bool
import java.lang.Long as _long
import com.google.common.collect.ImmutableListMultimap as _ImmutableListMultimap
_ImmutableListMultimap = _ImmutableListMultimap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableListMultimap.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.put(K,V)"""
        return 'Builder'._wrap(super(_Builder, self).put(key, value))

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).put(entry))

    @overload
    def putAll(self, multimap: 'Multimap') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(multimap))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableListMultimap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(entries))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def orderValuesBy(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.orderValuesBy(java.util.Comparator<? super V>)"""
        return 'Builder'._wrap(super(_Builder, self).orderValuesBy(valueComparator))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableListMultimap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def putAll(self, key: object, *values: object) -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.putAll(K,V...)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(key, values))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def putAll(self, key: object, values: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.putAll(K,java.lang.Iterable<? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(key, values))

    @overload
    def orderKeysBy(self, keyComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.orderKeysBy(java.util.Comparator<? super K>)"""
        return 'Builder'._wrap(super(_Builder, self).orderKeysBy(keyComparator))

    @override
    @overload
    def build(self) -> 'ImmutableListMultimap':
        """public com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap$Builder.build()"""
        return 'ImmutableListMultimap'._wrap(super(Builder, self).build())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.HashMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
import com.google.common.collect.HashMultiset as _HashMultiset
_HashMultiset = _HashMultiset
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
from typing import List
import com.google.common.collect.AbstractMultiset as _AbstractMultiset
_AbstractMultiset = _AbstractMultiset
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class HashMultiset():
    """com.google.common.collect.HashMultiset"""
 
    @staticmethod
    def _wrap(java_value: _HashMultiset) -> 'HashMultiset':
        return HashMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _HashMultiset):
        """
        Dynamic initializer for HashMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_HashMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_HashMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str._wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'HashMultiset':
        """public static <E> com.google.common.collect.HashMultiset<E> com.google.common.collect.HashMultiset.create(java.lang.Iterable<? extends E>)"""
        return HashMultiset._wrap(_HashMultiset.create(elements))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).equals(object))

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).remove(element))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @staticmethod
    @overload
    def create(distinctElements: int) -> 'HashMultiset':
        """public static <E> com.google.common.collect.HashMultiset<E> com.google.common.collect.HashMultiset.create(int)"""
        return HashMultiset._wrap(_HashMultiset.create(_int.valueOf(distinctElements)))

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool._wrap(super(_AbstractMultiset, self).add(element))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def create() -> 'HashMultiset':
        """public static <E> com.google.common.collect.HashMultiset<E> com.google.common.collect.HashMultiset.create()"""
        return HashMultiset._wrap(_HashMultiset.create())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int._wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).retainAll(elementsToRetain)) 
 
 
# CLASS: com.google.common.collect.AbstractSequentialIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.UnmodifiableIterator as _UnmodifiableIterator
_UnmodifiableIterator = _UnmodifiableIterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.lang.Integer as _int
import com.google.common.collect.AbstractSequentialIterator as _AbstractSequentialIterator
_AbstractSequentialIterator = _AbstractSequentialIterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class AbstractSequentialIterator():
    """com.google.common.collect.AbstractSequentialIterator"""
 
    @staticmethod
    def _wrap(java_value: _AbstractSequentialIterator) -> 'AbstractSequentialIterator':
        return AbstractSequentialIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _AbstractSequentialIterator):
        """
        Dynamic initializer for AbstractSequentialIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_AbstractSequentialIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_AbstractSequentialIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def remove(self):
        """public final void com.google.common.collect.UnmodifiableIterator.remove()"""
        super(UnmodifiableIterator, self).remove()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def hasNext(self) -> bool:
        """public final boolean com.google.common.collect.AbstractSequentialIterator.hasNext()"""
        return bool._wrap(super(AbstractSequentialIterator, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def next(self) -> object:
        """public final T com.google.common.collect.AbstractSequentialIterator.next()"""
        return object._wrap(super(AbstractSequentialIterator, self).next())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ComputationException
from builtins import str
import java.lang.StackTraceElement as _StackTraceElement
_StackTraceElement = _StackTraceElement
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.io.PrintWriter as PrintWriter
import java.lang.String as _String
_String = _String
import java.lang.StackTraceElement as StackTraceElement
import com.google.common.collect.ComputationException as _ComputationException
_ComputationException = _ComputationException
from typing import List
import java.io.PrintStream as PrintStream
import java.lang.Integer as _int
import java.lang.Throwable as _Throwable
_Throwable = _Throwable
import java.lang.Throwable as Throwable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ComputationException():
    """com.google.common.collect.ComputationException"""
 
    @staticmethod
    def _wrap(java_value: _ComputationException) -> 'ComputationException':
        return ComputationException(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ComputationException):
        """
        Dynamic initializer for ComputationException.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ComputationException__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ComputationException__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getLocalizedMessage(self) -> str:
        """public java.lang.String java.lang.Throwable.getLocalizedMessage()"""
        return str._wrap(super(Throwable, self).getLocalizedMessage())

    @overload
    def __init__(self, cause: 'Throwable'):
        """public com.google.common.collect.ComputationException(java.lang.Throwable)"""
        val = _ComputationException(cause)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def getCause(self) -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.getCause()"""
        return 'Throwable'._wrap(super(Throwable, self).getCause())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def printStackTrace(self, arg0: 'PrintWriter'):
        """public void java.lang.Throwable.printStackTrace(java.io.PrintWriter)"""
        super(_Throwable, self).printStackTrace(arg0)

    @override
    @overload
    def fillInStackTrace(self) -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.fillInStackTrace()"""
        return 'Throwable'._wrap(super(Throwable, self).fillInStackTrace())

    @override
    @overload
    def printStackTrace(self):
        """public void java.lang.Throwable.printStackTrace()"""
        super(Throwable, self).printStackTrace()

    @override
    @overload
    def getSuppressed(self) -> List['Throwable']:
        """public final synchronized java.lang.Throwable[] java.lang.Throwable.getSuppressed()"""
        return List['Throwable']._wrap(super(Throwable, self).getSuppressed())

    @override
    @overload
    def getMessage(self) -> str:
        """public java.lang.String java.lang.Throwable.getMessage()"""
        return str._wrap(super(Throwable, self).getMessage())

    @override
    @overload
    def printStackTrace(self, arg0: 'PrintStream'):
        """public void java.lang.Throwable.printStackTrace(java.io.PrintStream)"""
        super(_Throwable, self).printStackTrace(arg0)

    @overload
    def initCause(self, arg0: 'Throwable') -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.initCause(java.lang.Throwable)"""
        return 'Throwable'._wrap(super(_Throwable, self).initCause(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def getStackTrace(self) -> List['StackTraceElement']:
        """public java.lang.StackTraceElement[] java.lang.Throwable.getStackTrace()"""
        return List['StackTraceElement']._wrap(super(Throwable, self).getStackTrace())

    @override
    @overload
    def addSuppressed(self, arg0: 'Throwable'):
        """public final synchronized void java.lang.Throwable.addSuppressed(java.lang.Throwable)"""
        super(_Throwable, self).addSuppressed(arg0)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def setStackTrace(self, arg0: 'StackTraceElement'):
        """public void java.lang.Throwable.setStackTrace(java.lang.StackTraceElement[])"""
        super(_Throwable, self).setStackTrace(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Throwable.toString()"""
        return str._wrap(super(Throwable, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingMap$StandardKeySet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Set as _Set
_Set = _Set
import java.util.Spliterator as Spliterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.AbstractSet as _AbstractSet
_AbstractSet = _AbstractSet
import com.google.common.collect.Sets as _Sets_ImprovedAbstractSet
_ImprovedAbstractSet = _Sets_ImprovedAbstractSet.ImprovedAbstractSet
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import com.google.common.collect.ForwardingMap as _ForwardingMap_StandardKeySet
_StandardKeySet = _ForwardingMap_StandardKeySet.StandardKeySet
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.Maps as _Maps_KeySet
_KeySet = _Maps_KeySet.KeySet
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardKeySet():
    """com.google.common.collect.ForwardingMap.StandardKeySet"""
 
    @staticmethod
    def _wrap(java_value: _StandardKeySet) -> 'StandardKeySet':
        return StandardKeySet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardKeySet):
        """
        Dynamic initializer for StandardKeySet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardKeySet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardKeySet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$KeySet.clear()"""
        super(KeySet, self).clear()

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int._wrap(super(AbstractSet, self).hashCode())

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.contains(java.lang.Object)"""
        return bool._wrap(super(_KeySet, self).contains(o))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$KeySet.size()"""
        return int._wrap(super(KeySet, self).size())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.google.common.collect.Maps$KeySet.iterator()"""
        return 'Iterator'._wrap(super(KeySet, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractSet, self).equals(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.isEmpty()"""
        return bool._wrap(super(KeySet, self).isEmpty())

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).removeAll(c))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public void com.google.common.collect.Maps$KeySet.forEach(java.util.function.Consumer<? super K>)"""
        super(_KeySet, self).forEach(action)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool._wrap(super(_AbstractCollection, self).add(arg0))

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.remove(java.lang.Object)"""
        return bool._wrap(super(_KeySet, self).remove(o))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def __init__(self, this$0: 'ForwardingMap'):
        """public com.google.common.collect.ForwardingMap$StandardKeySet(com.google.common.collect.ForwardingMap)"""
        val = _StandardKeySet(this$0)
        self.__wrapper = val

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'._wrap(super(Set, self).spliterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.ArrayListMultimap
from pyquantum_helper import override
import java.lang.Integer as _int
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ArrayListMultimap as _ArrayListMultimap
_ArrayListMultimap = _ArrayListMultimap
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
 
class ArrayListMultimap():
    """com.google.common.collect.ArrayListMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ArrayListMultimap) -> 'ArrayListMultimap':
        return ArrayListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ArrayListMultimap):
        """
        Dynamic initializer for ArrayListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ArrayListMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ArrayListMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def create() -> 'ArrayListMultimap':
        """public static <K,V> com.google.common.collect.ArrayListMultimap<K, V> com.google.common.collect.ArrayListMultimap.create()"""
        return ArrayListMultimap._wrap(_ArrayListMultimap.create())

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'ArrayListMultimap':
        """public static <K,V> com.google.common.collect.ArrayListMultimap<K, V> com.google.common.collect.ArrayListMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ArrayListMultimap._wrap(_ArrayListMultimap.create(multimap))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def trimToSize(self):
        """public void com.google.common.collect.ArrayListMultimap.trimToSize()"""
        super(ArrayListMultimap, self).trimToSize()

    @staticmethod
    @overload
    def create(expectedKeys: int, expectedValuesPerKey: int) -> 'ArrayListMultimap':
        """public static <K,V> com.google.common.collect.ArrayListMultimap<K, V> com.google.common.collect.ArrayListMultimap.create(int,int)"""
        return ArrayListMultimap._wrap(_ArrayListMultimap.create(_int.valueOf(expectedKeys), _int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.Streams$DoubleFunctionWithIndex
import com.google.common.collect.Streams as _Streams_DoubleFunctionWithIndex
_DoubleFunctionWithIndex = _Streams_DoubleFunctionWithIndex.DoubleFunctionWithIndex
from abc import abstractmethod, ABC
 
class DoubleFunctionWithIndex():
    """com.google.common.collect.Streams.DoubleFunctionWithIndex"""
 
    @staticmethod
    def _wrap(java_value: _DoubleFunctionWithIndex) -> 'DoubleFunctionWithIndex':
        return DoubleFunctionWithIndex(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _DoubleFunctionWithIndex):
        """
        Dynamic initializer for DoubleFunctionWithIndex.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_DoubleFunctionWithIndex__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_DoubleFunctionWithIndex__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, from: float, index: int):
        """public abstract R com.google.common.collect.Streams$DoubleFunctionWithIndex.apply(double,long)"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingList
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
import java.util.ListIterator as _ListIterator
_ListIterator = _ListIterator
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
import java.util.function.UnaryOperator as UnaryOperator
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.List as _List
_List = _List
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import java.util.ListIterator as ListIterator
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.google.common.collect.ForwardingList as _ForwardingList
_ForwardingList = _ForwardingList
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.util.List as List
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingList():
    """com.google.common.collect.ForwardingList"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingList) -> 'ForwardingList':
        return ForwardingList(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingList):
        """
        Dynamic initializer for ForwardingList.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingList__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingList__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def subList(self, fromIndex: int, toIndex: int) -> 'List':
        """public java.util.List<E> com.google.common.collect.ForwardingList.subList(int,int)"""
        return 'List'._wrap(super(_ForwardingList, self).subList(_int.valueOf(fromIndex), _int.valueOf(toIndex)))

    @overload
    def remove(self, index: int) -> object:
        """public E com.google.common.collect.ForwardingList.remove(int)"""
        return object._wrap(super(_ForwardingList, self).remove(_int.valueOf(index)))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def replaceAll(self, arg0: 'UnaryOperator'):
        """public default void java.util.List.replaceAll(java.util.function.UnaryOperator<E>)"""
        super(_List, self).replaceAll(arg0)

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.List.getFirst()"""
        return object._wrap(super(List, self).getFirst())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.List.removeLast()"""
        return object._wrap(super(List, self).removeLast())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingList.hashCode()"""
        return int._wrap(super(ForwardingList, self).hashCode())

    @overload
    def lastIndexOf(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingList.lastIndexOf(java.lang.Object)"""
        return int._wrap(super(_ForwardingList, self).lastIndexOf(element))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def sort(self, arg0: 'Comparator'):
        """public default void java.util.List.sort(java.util.Comparator<? super E>)"""
        super(_List, self).sort(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.List.getLast()"""
        return object._wrap(super(List, self).getLast())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def indexOf(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingList.indexOf(java.lang.Object)"""
        return int._wrap(super(_ForwardingList, self).indexOf(element))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingList.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingList, self).equals(object))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.List.addFirst(E)"""
        super(_List, self).addFirst(arg0)

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def listIterator(self) -> 'ListIterator':
        """public java.util.ListIterator<E> com.google.common.collect.ForwardingList.listIterator()"""
        return 'ListIterator'._wrap(super(ForwardingList, self).listIterator())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @overload
    def listIterator(self, index: int) -> 'ListIterator':
        """public java.util.ListIterator<E> com.google.common.collect.ForwardingList.listIterator(int)"""
        return 'ListIterator'._wrap(super(_ForwardingList, self).listIterator(_int.valueOf(index)))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def addAll(self, index: int, elements: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingList.addAll(int,java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingList, self).addAll(_int.valueOf(index), elements))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.List.removeFirst()"""
        return object._wrap(super(List, self).removeFirst())

    @override
    @overload
    def reversed(self) -> 'List':
        """public default java.util.List<E> java.util.List.reversed()"""
        return 'List'._wrap(super(List, self).reversed())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def add(self, index: int, element: object):
        """public void com.google.common.collect.ForwardingList.add(int,E)"""
        super(_ForwardingList, self).add(_int.valueOf(index), element)

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.List.spliterator()"""
        return 'Spliterator'._wrap(super(List, self).spliterator())

    @overload
    def set(self, index: int, element: object) -> object:
        """public E com.google.common.collect.ForwardingList.set(int,E)"""
        return object._wrap(super(_ForwardingList, self).set(_int.valueOf(index), element))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def get(self, index: int) -> object:
        """public E com.google.common.collect.ForwardingList.get(int)"""
        return object._wrap(super(_ForwardingList, self).get(_int.valueOf(index)))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.List.addLast(E)"""
        super(_List, self).addLast(arg0) 
 
 
# CLASS: com.google.common.collect.ForwardingMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Map as _Map
_Map = _Map
import java.util.Collection as Collection
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import java.util.function.Function as Function
from builtins import bool
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingMap():
    """com.google.common.collect.ForwardingMap"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingMap) -> 'ForwardingMap':
        return ForwardingMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingMap):
        """
        Dynamic initializer for ForwardingMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ForwardingMap, self).putAll(map)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object._wrap(super(_ForwardingMap, self).put(key, value))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsValue(value))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).entrySet())

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_Map, self).replaceAll(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).keySet())

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'._wrap(super(ForwardingMap, self).values())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.MutableClassToInstanceMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import com.google.common.collect.MutableClassToInstanceMap as _MutableClassToInstanceMap
_MutableClassToInstanceMap = _MutableClassToInstanceMap
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Map as _Map
_Map = _Map
import java.util.Collection as Collection
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class MutableClassToInstanceMap():
    """com.google.common.collect.MutableClassToInstanceMap"""
 
    @staticmethod
    def _wrap(java_value: _MutableClassToInstanceMap) -> 'MutableClassToInstanceMap':
        return MutableClassToInstanceMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _MutableClassToInstanceMap):
        """
        Dynamic initializer for MutableClassToInstanceMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_MutableClassToInstanceMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_MutableClassToInstanceMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @overload
    def putInstance(self, type: 'Class', value: object) -> object:
        """public <T extends B> T com.google.common.collect.MutableClassToInstanceMap.putInstance(java.lang.Class<T>,T)"""
        return object._wrap(super(_MutableClassToInstanceMap, self).putInstance(type, value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def create(backingMap: 'Map') -> 'MutableClassToInstanceMap':
        """public static <B> com.google.common.collect.MutableClassToInstanceMap<B> com.google.common.collect.MutableClassToInstanceMap.create(java.util.Map<java.lang.Class<? extends B>, B>)"""
        return MutableClassToInstanceMap._wrap(_MutableClassToInstanceMap.create(backingMap))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def put(self, key: 'Class', value: object) -> object:
        """public B com.google.common.collect.MutableClassToInstanceMap.put(java.lang.Class<? extends B>,B)"""
        return object._wrap(super(_MutableClassToInstanceMap, self).put(key, value))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsValue(value))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.MutableClassToInstanceMap.putAll(java.util.Map<? extends java.lang.Class<? extends B>, ? extends B>)"""
        super(_MutableClassToInstanceMap, self).putAll(map)

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<java.lang.Class<? extends B>, B>> com.google.common.collect.MutableClassToInstanceMap.entrySet()"""
        return 'Set'._wrap(super(MutableClassToInstanceMap, self).entrySet())

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_Map, self).replaceAll(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @staticmethod
    @overload
    def create() -> 'MutableClassToInstanceMap':
        """public static <B> com.google.common.collect.MutableClassToInstanceMap<B> com.google.common.collect.MutableClassToInstanceMap.create()"""
        return MutableClassToInstanceMap._wrap(_MutableClassToInstanceMap.create())

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).keySet())

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'._wrap(super(ForwardingMap, self).values())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @overload
    def getInstance(self, type: 'Class') -> object:
        """public <T extends B> T com.google.common.collect.MutableClassToInstanceMap.getInstance(java.lang.Class<T>)"""
        return object._wrap(super(_MutableClassToInstanceMap, self).getInstance(type))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.ImmutableRangeMap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
import com.google.common.collect.ImmutableRangeMap as _ImmutableRangeMap_Builder
_Builder = _ImmutableRangeMap_Builder.Builder
from builtins import bool
import java.lang.Long as _long
import com.google.common.collect.ImmutableRangeMap as _ImmutableRangeMap
_ImmutableRangeMap = _ImmutableRangeMap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableRangeMap.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableRangeMap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def put(self, range: 'Range', value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableRangeMap$Builder<K, V> com.google.common.collect.ImmutableRangeMap$Builder.put(com.google.common.collect.Range<K>,V)"""
        return 'Builder'._wrap(super(_Builder, self).put(range, value))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def build(self) -> 'ImmutableRangeMap':
        """public com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap$Builder.build()"""
        return 'ImmutableRangeMap'._wrap(super(Builder, self).build())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableRangeMap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @overload
    def putAll(self, rangeMap: 'RangeMap') -> 'Builder':
        """public com.google.common.collect.ImmutableRangeMap$Builder<K, V> com.google.common.collect.ImmutableRangeMap$Builder.putAll(com.google.common.collect.RangeMap<K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(rangeMap))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.MinMaxPriorityQueue
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.AbstractQueue as _AbstractQueue
_AbstractQueue = _AbstractQueue
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import com.google.common.collect.MinMaxPriorityQueue as _MinMaxPriorityQueue
_MinMaxPriorityQueue = _MinMaxPriorityQueue
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.google.common.collect.MinMaxPriorityQueue as _MinMaxPriorityQueue_Builder
_Builder = _MinMaxPriorityQueue_Builder.Builder
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class MinMaxPriorityQueue():
    """com.google.common.collect.MinMaxPriorityQueue"""
 
    @staticmethod
    def _wrap(java_value: _MinMaxPriorityQueue) -> 'MinMaxPriorityQueue':
        return MinMaxPriorityQueue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _MinMaxPriorityQueue):
        """
        Dynamic initializer for MinMaxPriorityQueue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_MinMaxPriorityQueue__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_MinMaxPriorityQueue__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.MinMaxPriorityQueue.size()"""
        return int._wrap(super(MinMaxPriorityQueue, self).size())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.MinMaxPriorityQueue.add(E)"""
        return bool._wrap(super(_MinMaxPriorityQueue, self).add(element))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def contains(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_AbstractCollection, self).contains(arg0))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def peekFirst(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.peekFirst()"""
        return object._wrap(super(MinMaxPriorityQueue, self).peekFirst())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'._wrap(super(Collection, self).spliterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def retainAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).retainAll(arg0))

    @override
    @overload
    def remove(self) -> object:
        """public E java.util.AbstractQueue.remove()"""
        return object._wrap(super(AbstractQueue, self).remove())

    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.MinMaxPriorityQueue.comparator()"""
        return 'Comparator'._wrap(super(MinMaxPriorityQueue, self).comparator())

    @overload
    def offer(self, element: object) -> bool:
        """public boolean com.google.common.collect.MinMaxPriorityQueue.offer(E)"""
        return bool._wrap(super(_MinMaxPriorityQueue, self).offer(element))

    @staticmethod
    @overload
    def create(initialContents: 'Iterable') -> 'MinMaxPriorityQueue':
        """public static <E extends java.lang.Comparable<E>> com.google.common.collect.MinMaxPriorityQueue<E> com.google.common.collect.MinMaxPriorityQueue.create(java.lang.Iterable<? extends E>)"""
        return MinMaxPriorityQueue._wrap(_MinMaxPriorityQueue.create(initialContents))

    @staticmethod
    @overload
    def create() -> 'MinMaxPriorityQueue':
        """public static <E extends java.lang.Comparable<E>> com.google.common.collect.MinMaxPriorityQueue<E> com.google.common.collect.MinMaxPriorityQueue.create()"""
        return MinMaxPriorityQueue._wrap(_MinMaxPriorityQueue.create())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.MinMaxPriorityQueue.clear()"""
        super(MinMaxPriorityQueue, self).clear()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.MinMaxPriorityQueue.toArray()"""
        return List[object]._wrap(super(MinMaxPriorityQueue, self).toArray())

    @overload
    def removeFirst(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.removeFirst()"""
        return object._wrap(super(MinMaxPriorityQueue, self).removeFirst())

    @staticmethod
    @overload
    def expectedSize(expectedSize: int) -> 'Builder':
        """public static com.google.common.collect.MinMaxPriorityQueue$Builder<java.lang.Comparable> com.google.common.collect.MinMaxPriorityQueue.expectedSize(int)"""
        return Builder._wrap(_MinMaxPriorityQueue.expectedSize(_int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def maximumSize(maximumSize: int) -> 'Builder':
        """public static com.google.common.collect.MinMaxPriorityQueue$Builder<java.lang.Comparable> com.google.common.collect.MinMaxPriorityQueue.maximumSize(int)"""
        return Builder._wrap(_MinMaxPriorityQueue.maximumSize(_int.valueOf(maximumSize)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public boolean com.google.common.collect.MinMaxPriorityQueue.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_MinMaxPriorityQueue, self).addAll(newElements))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def element(self) -> object:
        """public E java.util.AbstractQueue.element()"""
        return object._wrap(super(AbstractQueue, self).element())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.poll()"""
        return object._wrap(super(MinMaxPriorityQueue, self).poll())

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.peek()"""
        return object._wrap(super(MinMaxPriorityQueue, self).peek())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def removeLast(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.removeLast()"""
        return object._wrap(super(MinMaxPriorityQueue, self).removeLast())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.MinMaxPriorityQueue.iterator()"""
        return 'Iterator'._wrap(super(MinMaxPriorityQueue, self).iterator())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.pollLast()"""
        return object._wrap(super(MinMaxPriorityQueue, self).pollLast())

    @overload
    def removeAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).removeAll(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.pollFirst()"""
        return object._wrap(super(MinMaxPriorityQueue, self).pollFirst())

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <B> com.google.common.collect.MinMaxPriorityQueue$Builder<B> com.google.common.collect.MinMaxPriorityQueue.orderedBy(java.util.Comparator<B>)"""
        return Builder._wrap(_MinMaxPriorityQueue.orderedBy(comparator))

    @overload
    def peekLast(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.peekLast()"""
        return object._wrap(super(MinMaxPriorityQueue, self).peekLast())

    @overload
    def remove(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_AbstractCollection, self).remove(arg0))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.TreeBasedTable
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.SortedSet as SortedSet
import java.util.Comparator as Comparator
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.SortedMap as _SortedMap
_SortedMap = _SortedMap
import com.google.common.collect.TreeBasedTable as _TreeBasedTable
_TreeBasedTable = _TreeBasedTable
import java.util.SortedMap as SortedMap
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
 
class TreeBasedTable():
    """com.google.common.collect.TreeBasedTable"""
 
    @staticmethod
    def _wrap(java_value: _TreeBasedTable) -> 'TreeBasedTable':
        return TreeBasedTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _TreeBasedTable):
        """
        Dynamic initializer for TreeBasedTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_TreeBasedTable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_TreeBasedTable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def create() -> 'TreeBasedTable':
        """public static <R extends java.lang.Comparable,C extends java.lang.Comparable,V> com.google.common.collect.TreeBasedTable<R, C, V> com.google.common.collect.TreeBasedTable.create()"""
        return TreeBasedTable._wrap(_TreeBasedTable.create())

    @overload
    def rowComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super R> com.google.common.collect.TreeBasedTable.rowComparator()"""
        return 'Comparator'._wrap(super(TreeBasedTable, self).rowComparator())

    @override
    @overload
    def rowKeySet(self) -> 'SortedSet':
        """public java.util.SortedSet<R> com.google.common.collect.TreeBasedTable.rowKeySet()"""
        return 'SortedSet'._wrap(super(TreeBasedTable, self).rowKeySet())

    @override
    @overload
    def rowMap(self) -> 'SortedMap':
        """public java.util.SortedMap<R, java.util.Map<C, V>> com.google.common.collect.TreeBasedTable.rowMap()"""
        return 'SortedMap'._wrap(super(TreeBasedTable, self).rowMap())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def row(self, rowKey: object) -> 'SortedMap':
        """public java.util.SortedMap<C, V> com.google.common.collect.TreeBasedTable.row(R)"""
        return 'SortedMap'._wrap(super(_TreeBasedTable, self).row(rowKey))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def columnComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super C> com.google.common.collect.TreeBasedTable.columnComparator()"""
        return 'Comparator'._wrap(super(TreeBasedTable, self).columnComparator())

    @staticmethod
    @overload
    def create(rowComparator: 'Comparator', columnComparator: 'Comparator') -> 'TreeBasedTable':
        """public static <R,C,V> com.google.common.collect.TreeBasedTable<R, C, V> com.google.common.collect.TreeBasedTable.create(java.util.Comparator<? super R>,java.util.Comparator<? super C>)"""
        return TreeBasedTable._wrap(_TreeBasedTable.create(rowComparator, columnComparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create(table: 'TreeBasedTable') -> 'TreeBasedTable':
        """public static <R,C,V> com.google.common.collect.TreeBasedTable<R, C, V> com.google.common.collect.TreeBasedTable.create(com.google.common.collect.TreeBasedTable<R, C, ? extends V>)"""
        return TreeBasedTable._wrap(_TreeBasedTable.create(table)) 
 
 
# CLASS: com.google.common.collect.ForwardingCollection
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingCollection():
    """com.google.common.collect.ForwardingCollection"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingCollection) -> 'ForwardingCollection':
        return ForwardingCollection(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingCollection):
        """
        Dynamic initializer for ForwardingCollection.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingCollection__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingCollection__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'._wrap(super(Collection, self).spliterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.LinkedListMultimap
from pyquantum_helper import override
import com.google.common.collect.LinkedListMultimap as _LinkedListMultimap
_LinkedListMultimap = _LinkedListMultimap
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.List as _List
_List = _List
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.util.List as List
import java.lang.Class as _Class
_Class = _Class
 
class LinkedListMultimap():
    """com.google.common.collect.LinkedListMultimap"""
 
    @staticmethod
    def _wrap(java_value: _LinkedListMultimap) -> 'LinkedListMultimap':
        return LinkedListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _LinkedListMultimap):
        """
        Dynamic initializer for LinkedListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_LinkedListMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_LinkedListMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.LinkedListMultimap.isEmpty()"""
        return bool._wrap(super(LinkedListMultimap, self).isEmpty())

    @override
    @overload
    def entries(self) -> 'List':
        """public java.util.List<java.util.Map$Entry<K, V>> com.google.common.collect.LinkedListMultimap.entries()"""
        return 'List'._wrap(super(LinkedListMultimap, self).entries())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.LinkedListMultimap.size()"""
        return int._wrap(super(LinkedListMultimap, self).size())

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'LinkedListMultimap':
        """public static <K,V> com.google.common.collect.LinkedListMultimap<K, V> com.google.common.collect.LinkedListMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return LinkedListMultimap._wrap(_LinkedListMultimap.create(multimap))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @overload
    def get(self, key: object) -> 'List':
        """public java.util.List<V> com.google.common.collect.LinkedListMultimap.get(K)"""
        return 'List'._wrap(super(_LinkedListMultimap, self).get(key))

    @overload
    def removeAll(self, key: object) -> 'List':
        """public java.util.List<V> com.google.common.collect.LinkedListMultimap.removeAll(java.lang.Object)"""
        return 'List'._wrap(super(_LinkedListMultimap, self).removeAll(key))

    @staticmethod
    @overload
    def create() -> 'LinkedListMultimap':
        """public static <K,V> com.google.common.collect.LinkedListMultimap<K, V> com.google.common.collect.LinkedListMultimap.create()"""
        return LinkedListMultimap._wrap(_LinkedListMultimap.create())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'List':
        """public java.util.List<V> com.google.common.collect.LinkedListMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'List'._wrap(super(_LinkedListMultimap, self).replaceValues(key, values))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.LinkedListMultimap.put(K,V)"""
        return bool._wrap(super(_LinkedListMultimap, self).put(key, value))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.LinkedListMultimap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_LinkedListMultimap, self).containsValue(value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def create(expectedKeys: int) -> 'LinkedListMultimap':
        """public static <K,V> com.google.common.collect.LinkedListMultimap<K, V> com.google.common.collect.LinkedListMultimap.create(int)"""
        return LinkedListMultimap._wrap(_LinkedListMultimap.create(_int.valueOf(expectedKeys)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.LinkedListMultimap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_LinkedListMultimap, self).containsKey(key))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.LinkedListMultimap.clear()"""
        super(LinkedListMultimap, self).clear()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def values(self) -> 'List':
        """public java.util.List<V> com.google.common.collect.LinkedListMultimap.values()"""
        return 'List'._wrap(super(LinkedListMultimap, self).values()) 
 
 
# CLASS: com.google.common.collect.EnumMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.EnumMultiset as _EnumMultiset
_EnumMultiset = _EnumMultiset
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.lang.Enum as Enum
import com.google.common.collect.AbstractMultiset as _AbstractMultiset
_AbstractMultiset = _AbstractMultiset
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
import java.lang.Class as _Class
_Class = _Class
 
class EnumMultiset():
    """com.google.common.collect.EnumMultiset"""
 
    @staticmethod
    def _wrap(java_value: _EnumMultiset) -> 'EnumMultiset':
        return EnumMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _EnumMultiset):
        """
        Dynamic initializer for EnumMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_EnumMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_EnumMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.EnumMultiset.count(java.lang.Object)"""
        return int._wrap(super(_EnumMultiset, self).count(element))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str._wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.EnumMultiset.remove(java.lang.Object,int)"""
        return int._wrap(super(_EnumMultiset, self).remove(element, _int.valueOf(occurrences)))

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).equals(object))

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).remove(element))

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'EnumMultiset':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.EnumMultiset<E> com.google.common.collect.EnumMultiset.create(java.lang.Iterable<E>)"""
        return EnumMultiset._wrap(_EnumMultiset.create(elements))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @overload
    def setCount(self, element: 'Enum', count: int) -> int:
        """public int com.google.common.collect.EnumMultiset.setCount(E,int)"""
        return int._wrap(super(_EnumMultiset, self).setCount(element, _int.valueOf(count)))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.EnumMultiset.clear()"""
        super(EnumMultiset, self).clear()

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool._wrap(super(_AbstractMultiset, self).add(element))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def create(elements: 'Iterable', type: 'Class') -> 'EnumMultiset':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.EnumMultiset<E> com.google.common.collect.EnumMultiset.create(java.lang.Iterable<E>,java.lang.Class<E>)"""
        return EnumMultiset._wrap(_EnumMultiset.create(elements, type))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.EnumMultiset.iterator()"""
        return 'Iterator'._wrap(super(EnumMultiset, self).iterator())

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.EnumMultiset.size()"""
        return int._wrap(super(EnumMultiset, self).size())

    @staticmethod
    @overload
    def create(type: 'Class') -> 'EnumMultiset':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.EnumMultiset<E> com.google.common.collect.EnumMultiset.create(java.lang.Class<E>)"""
        return EnumMultiset._wrap(_EnumMultiset.create(type))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public void com.google.common.collect.EnumMultiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_EnumMultiset, self).forEachEntry(action)

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int._wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).retainAll(elementsToRetain))

    @overload
    def add(self, element: 'Enum', occurrences: int) -> int:
        """public int com.google.common.collect.EnumMultiset.add(E,int)"""
        return int._wrap(super(_EnumMultiset, self).add(element, _int.valueOf(occurrences))) 
 
 
# CLASS: com.google.common.collect.ForwardingMultiset$StandardElementSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingMultiset as _ForwardingMultiset_StandardElementSet
_StandardElementSet = _ForwardingMultiset_StandardElementSet.StandardElementSet
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.AbstractSet as _AbstractSet
_AbstractSet = _AbstractSet
import com.google.common.collect.Sets as _Sets_ImprovedAbstractSet
_ImprovedAbstractSet = _Sets_ImprovedAbstractSet.ImprovedAbstractSet
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.Multisets as _Multisets_ElementSet
_ElementSet = _Multisets_ElementSet.ElementSet
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardElementSet():
    """com.google.common.collect.ForwardingMultiset.StandardElementSet"""
 
    @staticmethod
    def _wrap(java_value: _StandardElementSet) -> 'StandardElementSet':
        return StandardElementSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardElementSet):
        """
        Dynamic initializer for StandardElementSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardElementSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardElementSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.contains(java.lang.Object)"""
        return bool._wrap(super(_ElementSet, self).contains(o))

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int._wrap(super(AbstractSet, self).hashCode())

    @overload
    def containsAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ElementSet, self).containsAll(c))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractSet, self).equals(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingMultiset$StandardElementSet.iterator()"""
        return 'Iterator'._wrap(super(StandardElementSet, self).iterator())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.isEmpty()"""
        return bool._wrap(super(ElementSet, self).isEmpty())

    @overload
    def __init__(self, this$0: 'ForwardingMultiset'):
        """public com.google.common.collect.ForwardingMultiset$StandardElementSet(com.google.common.collect.ForwardingMultiset)"""
        val = _StandardElementSet(this$0)
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool._wrap(super(_AbstractCollection, self).add(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Multisets$ElementSet.size()"""
        return int._wrap(super(ElementSet, self).size())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.remove(java.lang.Object)"""
        return bool._wrap(super(_ElementSet, self).remove(o))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'._wrap(super(Set, self).spliterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Multisets$ElementSet.clear()"""
        super(ElementSet, self).clear() 
 
 
# CLASS: com.google.common.collect.TreeRangeSet
from builtins import str
import com.google.common.collect.AbstractRangeSet as _AbstractRangeSet
_AbstractRangeSet = _AbstractRangeSet
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.RangeSet as _RangeSet
_RangeSet = _RangeSet
import java.lang.Iterable as Iterable
import java.lang.Comparable as Comparable
import java.lang.String as _String
_String = _String
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import java.lang.Integer as _int
import com.google.common.collect.Range as _Range
_Range = _Range
import com.google.common.collect.TreeRangeSet as _TreeRangeSet
_TreeRangeSet = _TreeRangeSet
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class TreeRangeSet():
    """com.google.common.collect.TreeRangeSet"""
 
    @staticmethod
    def _wrap(java_value: _TreeRangeSet) -> 'TreeRangeSet':
        return TreeRangeSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _TreeRangeSet):
        """
        Dynamic initializer for TreeRangeSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_TreeRangeSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_TreeRangeSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def asRanges(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Range<C>> com.google.common.collect.TreeRangeSet.asRanges()"""
        return 'Set'._wrap(super(TreeRangeSet, self).asRanges())

    @overload
    def enclosesAll(self, other: 'Iterable') -> bool:
        """public default boolean com.google.common.collect.RangeSet.enclosesAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return bool._wrap(super(_RangeSet, self).enclosesAll(other))

    @override
    @overload
    def addAll(self, ranges: 'Iterable'):
        """public default void com.google.common.collect.RangeSet.addAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(_RangeSet, self).addAll(ranges)

    @override
    @overload
    def remove(self, rangeToRemove: 'Range'):
        """public void com.google.common.collect.TreeRangeSet.remove(com.google.common.collect.Range<C>)"""
        super(_TreeRangeSet, self).remove(rangeToRemove)

    @staticmethod
    @overload
    def create() -> 'TreeRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.TreeRangeSet<C> com.google.common.collect.TreeRangeSet.create()"""
        return TreeRangeSet._wrap(_TreeRangeSet.create())

    @override
    @overload
    def asDescendingSetOfRanges(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Range<C>> com.google.common.collect.TreeRangeSet.asDescendingSetOfRanges()"""
        return 'Set'._wrap(super(TreeRangeSet, self).asDescendingSetOfRanges())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def encloses(self, range: 'Range') -> bool:
        """public boolean com.google.common.collect.TreeRangeSet.encloses(com.google.common.collect.Range<C>)"""
        return bool._wrap(super(_TreeRangeSet, self).encloses(range))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractRangeSet.hashCode()"""
        return int._wrap(super(AbstractRangeSet, self).hashCode())

    @overload
    def rangeContaining(self, value: 'Comparable') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.TreeRangeSet.rangeContaining(C)"""
        return 'Range'._wrap(super(_TreeRangeSet, self).rangeContaining(value))

    @override
    @overload
    def span(self) -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.TreeRangeSet.span()"""
        return 'Range'._wrap(super(TreeRangeSet, self).span())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def add(self, rangeToAdd: 'Range'):
        """public void com.google.common.collect.TreeRangeSet.add(com.google.common.collect.Range<C>)"""
        super(_TreeRangeSet, self).add(rangeToAdd)

    @overload
    def intersects(self, range: 'Range') -> bool:
        """public boolean com.google.common.collect.TreeRangeSet.intersects(com.google.common.collect.Range<C>)"""
        return bool._wrap(super(_TreeRangeSet, self).intersects(range))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create(ranges: 'Iterable') -> 'TreeRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.TreeRangeSet<C> com.google.common.collect.TreeRangeSet.create(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return TreeRangeSet._wrap(_TreeRangeSet.create(ranges))

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractRangeSet.toString()"""
        return str._wrap(super(AbstractRangeSet, self).toString())

    @staticmethod
    @overload
    def create(rangeSet: 'RangeSet') -> 'TreeRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.TreeRangeSet<C> com.google.common.collect.TreeRangeSet.create(com.google.common.collect.RangeSet<C>)"""
        return TreeRangeSet._wrap(_TreeRangeSet.create(rangeSet))

    @override
    @overload
    def complement(self) -> 'RangeSet':
        """public com.google.common.collect.RangeSet<C> com.google.common.collect.TreeRangeSet.complement()"""
        return 'RangeSet'._wrap(super(TreeRangeSet, self).complement())

    @override
    @overload
    def removeAll(self, ranges: 'Iterable'):
        """public default void com.google.common.collect.RangeSet.removeAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(_RangeSet, self).removeAll(ranges)

    @overload
    def subRangeSet(self, view: 'Range') -> 'RangeSet':
        """public com.google.common.collect.RangeSet<C> com.google.common.collect.TreeRangeSet.subRangeSet(com.google.common.collect.Range<C>)"""
        return 'RangeSet'._wrap(super(_TreeRangeSet, self).subRangeSet(view)) 
 
 
# CLASS: com.google.common.collect.Streams$LongFunctionWithIndex
import com.google.common.collect.Streams as _Streams_LongFunctionWithIndex
_LongFunctionWithIndex = _Streams_LongFunctionWithIndex.LongFunctionWithIndex
from abc import abstractmethod, ABC
 
class LongFunctionWithIndex():
    """com.google.common.collect.Streams.LongFunctionWithIndex"""
 
    @staticmethod
    def _wrap(java_value: _LongFunctionWithIndex) -> 'LongFunctionWithIndex':
        return LongFunctionWithIndex(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _LongFunctionWithIndex):
        """
        Dynamic initializer for LongFunctionWithIndex.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_LongFunctionWithIndex__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_LongFunctionWithIndex__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, from: int, index: int):
        """public abstract R com.google.common.collect.Streams$LongFunctionWithIndex.apply(long,long)"""
        pass 
 
 
# CLASS: com.google.common.collect.ObjectArrays
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import com.google.common.collect.ObjectArrays as _ObjectArrays
_ObjectArrays = _ObjectArrays
from builtins import object
import java.lang.String as _String
_String = _String
from typing import List
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ObjectArrays():
    """com.google.common.collect.ObjectArrays"""
 
    @staticmethod
    def _wrap(java_value: _ObjectArrays) -> 'ObjectArrays':
        return ObjectArrays(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ObjectArrays):
        """
        Dynamic initializer for ObjectArrays.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ObjectArrays__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ObjectArrays__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def concat(array: 'Object', element: object) -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.concat(T[],T)"""
        return List[object]._wrap(_ObjectArrays.concat(array, element))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def newArray(type: 'Class', length: int) -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.newArray(java.lang.Class<T>,int)"""
        return List[object]._wrap(_ObjectArrays.newArray(type, _int.valueOf(length)))

    @staticmethod
    @overload
    def concat(first: 'Object', second: 'Object', type: 'Class') -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.concat(T[],T[],java.lang.Class<T>)"""
        return List[object]._wrap(_ObjectArrays.concat(first, second, type))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def concat(element: object, array: 'Object') -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.concat(T,T[])"""
        return List[object]._wrap(_ObjectArrays.concat(element, array))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def newArray(reference: 'Object', length: int) -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.newArray(T[],int)"""
        return List[object]._wrap(_ObjectArrays.newArray(reference, _int.valueOf(length)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.MinMaxPriorityQueue$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.lang.String as _String
_String = _String
import com.google.common.collect.MinMaxPriorityQueue as _MinMaxPriorityQueue
_MinMaxPriorityQueue = _MinMaxPriorityQueue
import java.lang.Integer as _int
import com.google.common.collect.MinMaxPriorityQueue as _MinMaxPriorityQueue_Builder
_Builder = _MinMaxPriorityQueue_Builder.Builder
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.MinMaxPriorityQueue.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def expectedSize(self, expectedSize: int) -> 'Builder':
        """public com.google.common.collect.MinMaxPriorityQueue$Builder<B> com.google.common.collect.MinMaxPriorityQueue$Builder.expectedSize(int)"""
        return 'Builder'._wrap(super(_Builder, self).expectedSize(_int.valueOf(expectedSize)))

    @overload
    def create(self, initialContents: 'Iterable') -> 'MinMaxPriorityQueue':
        """public <T extends B> com.google.common.collect.MinMaxPriorityQueue<T> com.google.common.collect.MinMaxPriorityQueue$Builder.create(java.lang.Iterable<? extends T>)"""
        return 'MinMaxPriorityQueue'._wrap(super(_Builder, self).create(initialContents))

    @overload
    def maximumSize(self, maximumSize: int) -> 'Builder':
        """public com.google.common.collect.MinMaxPriorityQueue$Builder<B> com.google.common.collect.MinMaxPriorityQueue$Builder.maximumSize(int)"""
        return 'Builder'._wrap(super(_Builder, self).maximumSize(_int.valueOf(maximumSize)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def create(self) -> 'MinMaxPriorityQueue':
        """public <T extends B> com.google.common.collect.MinMaxPriorityQueue<T> com.google.common.collect.MinMaxPriorityQueue$Builder.create()"""
        return 'MinMaxPriorityQueue'._wrap(super(Builder, self).create())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedMap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Integer as _int
import com.google.common.collect.ImmutableSortedMap as _ImmutableSortedMap
_ImmutableSortedMap = _ImmutableSortedMap
import com.google.common.collect.ImmutableSortedMap as _ImmutableSortedMap_Builder
_Builder = _ImmutableSortedMap_Builder.Builder
import java.util.Map as Map
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableSortedMap.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(entries))

    @overload
    def putAll(self, map: 'Map') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.putAll(java.util.Map<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(map))

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.put(K,V)"""
        return 'Builder'._wrap(super(_Builder, self).put(key, value))

    @override
    @overload
    def build(self) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap$Builder.build()"""
        return 'ImmutableSortedMap'._wrap(super(Builder, self).build())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).put(entry))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def __init__(self, comparator: 'Comparator'):
        """public com.google.common.collect.ImmutableSortedMap$Builder(java.util.Comparator<? super K>)"""
        val = _Builder(comparator)
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def buildOrThrow(self) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap$Builder.buildOrThrow()"""
        return 'ImmutableSortedMap'._wrap(super(Builder, self).buildOrThrow())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def buildKeepingLast(self) -> 'ImmutableSortedMap':
        """public final com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap$Builder.buildKeepingLast()"""
        return 'ImmutableSortedMap'._wrap(super(Builder, self).buildKeepingLast())

    @overload
    def orderEntriesByValue(self, valueComparator: 'Comparator') -> 'Builder':
        """public final com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.orderEntriesByValue(java.util.Comparator<? super V>)"""
        return 'Builder'._wrap(super(_Builder, self).orderEntriesByValue(valueComparator))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.BoundType
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.google.common.collect.BoundType as _BoundType
_BoundType = _BoundType
from typing import List
import java.lang.Enum as Enum
import java.lang.String as _string
import java.lang.Enum as _Enum
_Enum = _Enum
import java.lang.Integer as _int
import java.util.Optional as _Optional
_Optional = _Optional
import java.util.Optional as Optional
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class BoundType():
    """com.google.common.collect.BoundType"""
 
    @staticmethod
    def _wrap(java_value: _BoundType) -> 'BoundType':
        return BoundType(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _BoundType):
        """
        Dynamic initializer for BoundType.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_BoundType__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_BoundType__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def valueOf(name: str) -> 'BoundType':
        """public static com.google.common.collect.BoundType com.google.common.collect.BoundType.valueOf(java.lang.String)"""
        return BoundType._wrap(_BoundType.valueOf(name))

    @override
    @overload
    def hashCode(self) -> int:
        """public final int java.lang.Enum.hashCode()"""
        return int._wrap(super(Enum, self).hashCode())

    @staticmethod
    @overload
    def valueOf(arg0: 'Class', arg1: str) -> 'Enum':
        """public static <T extends java.lang.Enum<T>> T java.lang.Enum.valueOf(java.lang.Class<T>,java.lang.String)"""
        return Enum._wrap(_Enum.valueOf(arg0, arg1))

    @override
    @overload
    def name(self) -> str:
        """public final java.lang.String java.lang.Enum.name()"""
        return str._wrap(super(Enum, self).name())

    @override
    @overload
    def describeConstable(self) -> 'Optional':
        """public final java.util.Optional<java.lang.Enum$EnumDesc<E>> java.lang.Enum.describeConstable()"""
        return 'Optional'._wrap(super(Enum, self).describeConstable())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def values() -> List['BoundType']:
        """public static com.google.common.collect.BoundType[] com.google.common.collect.BoundType.values()"""
        return List[BoundType]._wrap(_BoundType.values())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Enum.toString()"""
        return str._wrap(super(Enum, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def ordinal(self) -> int:
        """public final int java.lang.Enum.ordinal()"""
        return int._wrap(super(Enum, self).ordinal())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def getDeclaringClass(self) -> 'type.Class':
        """public final java.lang.Class<E> java.lang.Enum.getDeclaringClass()"""
        return 'type.Class'._wrap(super(Enum, self).getDeclaringClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, arg0: object) -> bool:
        """public final boolean java.lang.Enum.equals(java.lang.Object)"""
        return bool._wrap(super(_Enum, self).equals(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def compareTo(self, arg0: 'Enum') -> int:
        """public final int java.lang.Enum.compareTo(E)"""
        return int._wrap(super(_Enum, self).compareTo(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.ImmutableList
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import java.util.Collection as Collection
import com.google.common.collect.UnmodifiableIterator as _UnmodifiableIterator
_UnmodifiableIterator = _UnmodifiableIterator
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import com.google.common.collect.ImmutableList as _ImmutableList_Builder
_Builder = _ImmutableList_Builder.Builder
import java.util.Spliterator as Spliterator
from builtins import bool
from builtins import str
import java.util.function.UnaryOperator as UnaryOperator
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import com.google.common.collect.UnmodifiableListIterator as _UnmodifiableListIterator
_UnmodifiableListIterator = _UnmodifiableListIterator
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.List as _List
_List = _List
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
from typing import List
import java.util.Comparator as Comparator
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
import java.util.List as List
 
class ImmutableList():
    """com.google.common.collect.ImmutableList"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableList) -> 'ImmutableList':
        return ImmutableList(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableList):
        """
        Dynamic initializer for ImmutableList.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableList__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableList__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def sort(self, c: 'Comparator'):
        """public final void com.google.common.collect.ImmutableList.sort(java.util.Comparator<? super E>)"""
        super(_ImmutableList, self).sort(c)

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.List.getFirst()"""
        return object._wrap(super(List, self).getFirst())

    @overload
    def equals(self, obj: object) -> bool:
        """public boolean com.google.common.collect.ImmutableList.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableList, self).equals(obj))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.List.removeLast()"""
        return object._wrap(super(List, self).removeLast())

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ImmutableCollection, self).remove(object))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object]._wrap(super(_ImmutableCollection, self).toArray(other))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def asList(self) -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.asList()"""
        return 'ImmutableList'._wrap(super(ImmutableList, self).asList())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object]._wrap(super(ImmutableCollection, self).toArray())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableList.spliterator()"""
        return 'Spliterator'._wrap(super(ImmutableList, self).spliterator())

    @staticmethod
    @overload
    def sortedCopyOf(elements: 'Iterable') -> 'ImmutableList':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.sortedCopyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableList._wrap(_ImmutableList.sortedCopyOf(elements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4, e5))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object, e9: object, e10: object, e11: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E,E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11))

    @override
    @overload
    def replaceAll(self, operator: 'UnaryOperator'):
        """public final void com.google.common.collect.ImmutableList.replaceAll(java.util.function.UnaryOperator<E>)"""
        super(_ImmutableList, self).replaceAll(operator)

    @override
    @overload
    def listIterator(self) -> 'UnmodifiableListIterator':
        """public com.google.common.collect.UnmodifiableListIterator<E> com.google.common.collect.ImmutableList.listIterator()"""
        return 'UnmodifiableListIterator'._wrap(super(ImmutableList, self).listIterator())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableList.hashCode()"""
        return int._wrap(super(ImmutableList, self).hashCode())

    @overload
    def addAll(self, index: int, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableList.addAll(int,java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ImmutableList, self).addAll(_int.valueOf(index), newElements))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.List.removeFirst()"""
        return object._wrap(super(List, self).removeFirst())

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def add(self, index: int, element: object):
        """public final void com.google.common.collect.ImmutableList.add(int,E)"""
        super(_ImmutableList, self).add(_int.valueOf(index), element)

    @override
    @overload
    def iterator(self) -> 'UnmodifiableIterator':
        """public com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableList.iterator()"""
        return 'UnmodifiableIterator'._wrap(super(ImmutableList, self).iterator())

    @overload
    def remove(self, index: int) -> object:
        """public final E com.google.common.collect.ImmutableList.remove(int)"""
        return object._wrap(super(_ImmutableList, self).remove(_int.valueOf(index)))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableList._wrap(_ImmutableList.copyOf(elements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def toImmutableList() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableList<E>> com.google.common.collect.ImmutableList.toImmutableList()"""
        return Collector._wrap(_ImmutableList.toImmutableList())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList.builder()"""
        return Builder._wrap(_ImmutableList.builder())

    @overload
    def indexOf(self, object: object) -> int:
        """public int com.google.common.collect.ImmutableList.indexOf(java.lang.Object)"""
        return int._wrap(super(_ImmutableList, self).indexOf(object))

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool._wrap(super(_ImmutableCollection, self).add(e))

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableList._wrap(_ImmutableList.copyOf(elements))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.copyOf(E[])"""
        return ImmutableList._wrap(_ImmutableList.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableList._wrap(_ImmutableList.copyOf(elements))

    @overload
    def subList(self, fromIndex: int, toIndex: int) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.subList(int,int)"""
        return 'ImmutableList'._wrap(super(_ImmutableList, self).subList(_int.valueOf(fromIndex), _int.valueOf(toIndex)))

    @staticmethod
    @overload
    def of() -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of()"""
        return ImmutableList._wrap(_ImmutableList.of())

    @staticmethod
    @overload
    def sortedCopyOf(comparator: 'Comparator', elements: 'Iterable') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.sortedCopyOf(java.util.Comparator<? super E>,java.lang.Iterable<? extends E>)"""
        return ImmutableList._wrap(_ImmutableList.sortedCopyOf(comparator, elements))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E)"""
        return ImmutableList._wrap(_ImmutableList.of(element))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableList.contains(java.lang.Object)"""
        return bool._wrap(super(_ImmutableList, self).contains(object))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object, e9: object, e10: object, e11: object, e12: object, *others: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E,E,E,E,E,E...)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, others))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.List.getLast()"""
        return object._wrap(super(List, self).getLast())

    @overload
    def listIterator(self, index: int) -> 'UnmodifiableListIterator':
        """public com.google.common.collect.UnmodifiableListIterator<E> com.google.common.collect.ImmutableList.listIterator(int)"""
        return 'UnmodifiableListIterator'._wrap(super(_ImmutableList, self).listIterator(_int.valueOf(index)))

    @overload
    def set(self, index: int, element: object) -> object:
        """public final E com.google.common.collect.ImmutableList.set(int,E)"""
        return object._wrap(super(_ImmutableList, self).set(_int.valueOf(index), element))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableList.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.List.addFirst(E)"""
        super(_List, self).addFirst(arg0)

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ImmutableCollection, self).addAll(newElements))

    @abstractmethod
    def get(self, arg0: int):
        """public abstract E java.util.List.get(int)"""
        pass

    @overload
    def reverse(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.reverse()"""
        return 'ImmutableList'._wrap(super(ImmutableList, self).reverse())

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object, e9: object, e10: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4, e5, e6))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def reversed(self) -> 'List':
        """public default java.util.List<E> java.util.List.reversed()"""
        return 'List'._wrap(super(List, self).reversed())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4, e5, e6, e7))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object, e9: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8, e9))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E)"""
        return ImmutableList._wrap(_ImmutableList.of(e1, e2))

    @override
    @overload
    def forEach(self, consumer: 'Consumer'):
        """public void com.google.common.collect.ImmutableList.forEach(java.util.function.Consumer<? super E>)"""
        super(_ImmutableList, self).forEach(consumer)

    @overload
    def lastIndexOf(self, object: object) -> int:
        """public int com.google.common.collect.ImmutableList.lastIndexOf(java.lang.Object)"""
        return int._wrap(super(_ImmutableList, self).lastIndexOf(object))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.List.addLast(E)"""
        super(_List, self).addLast(arg0) 
 
 
# CLASS: com.google.common.collect.HashBasedTable
import com.google.common.collect.HashBasedTable as _HashBasedTable
_HashBasedTable = _HashBasedTable
from pyquantum_helper import override
import java.lang.Integer as _int
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
 
class HashBasedTable():
    """com.google.common.collect.HashBasedTable"""
 
    @staticmethod
    def _wrap(java_value: _HashBasedTable) -> 'HashBasedTable':
        return HashBasedTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _HashBasedTable):
        """
        Dynamic initializer for HashBasedTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_HashBasedTable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_HashBasedTable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def create(expectedRows: int, expectedCellsPerRow: int) -> 'HashBasedTable':
        """public static <R,C,V> com.google.common.collect.HashBasedTable<R, C, V> com.google.common.collect.HashBasedTable.create(int,int)"""
        return HashBasedTable._wrap(_HashBasedTable.create(_int.valueOf(expectedRows), _int.valueOf(expectedCellsPerRow)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def create() -> 'HashBasedTable':
        """public static <R,C,V> com.google.common.collect.HashBasedTable<R, C, V> com.google.common.collect.HashBasedTable.create()"""
        return HashBasedTable._wrap(_HashBasedTable.create())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create(table: 'Table') -> 'HashBasedTable':
        """public static <R,C,V> com.google.common.collect.HashBasedTable<R, C, V> com.google.common.collect.HashBasedTable.create(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        return HashBasedTable._wrap(_HashBasedTable.create(table)) 
 
 
# CLASS: com.google.common.collect.Collections2
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
import java.lang.String as _String
_String = _String
import com.google.common.collect.Collections2 as _Collections2
_Collections2 = _Collections2
import java.util.Comparator as Comparator
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Collections2():
    """com.google.common.collect.Collections2"""
 
    @staticmethod
    def _wrap(java_value: _Collections2) -> 'Collections2':
        return Collections2(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Collections2):
        """
        Dynamic initializer for Collections2.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Collections2__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Collections2__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def orderedPermutations(elements: 'Iterable') -> 'Collection':
        """public static <E extends java.lang.Comparable<? super E>> java.util.Collection<java.util.List<E>> com.google.common.collect.Collections2.orderedPermutations(java.lang.Iterable<E>)"""
        return Collection._wrap(_Collections2.orderedPermutations(elements))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def permutations(elements: 'Collection') -> 'Collection':
        """public static <E> java.util.Collection<java.util.List<E>> com.google.common.collect.Collections2.permutations(java.util.Collection<E>)"""
        return Collection._wrap(_Collections2.permutations(elements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def orderedPermutations(elements: 'Iterable', comparator: 'Comparator') -> 'Collection':
        """public static <E> java.util.Collection<java.util.List<E>> com.google.common.collect.Collections2.orderedPermutations(java.lang.Iterable<E>,java.util.Comparator<? super E>)"""
        return Collection._wrap(_Collections2.orderedPermutations(elements, comparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def transform(fromCollection: 'Collection', function: 'Function') -> 'Collection':
        """public static <F,T> java.util.Collection<T> com.google.common.collect.Collections2.transform(java.util.Collection<F>,com.google.common.base.Function<? super F, T>)"""
        return Collection._wrap(_Collections2.transform(fromCollection, function))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def filter(unfiltered: 'Collection', predicate: 'Predicate') -> 'Collection':
        """public static <E> java.util.Collection<E> com.google.common.collect.Collections2.filter(java.util.Collection<E>,com.google.common.base.Predicate<? super E>)"""
        return Collection._wrap(_Collections2.filter(unfiltered, predicate))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableRangeMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Comparable as Comparable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.stream.Collector as Collector
import java.util.function.BiFunction as BiFunction
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.util.Map.Entry as Entry
import java.lang.Integer as _int
import com.google.common.collect.Range as _Range
_Range = _Range
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import java.util.Map as _Map_Entry
_Entry = _Map_Entry.Entry
import com.google.common.collect.ImmutableRangeMap as _ImmutableRangeMap_Builder
_Builder = _ImmutableRangeMap_Builder.Builder
import java.util.function.Function as Function
from builtins import bool
import java.lang.Long as _long
import com.google.common.collect.ImmutableRangeMap as _ImmutableRangeMap
_ImmutableRangeMap = _ImmutableRangeMap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableRangeMap():
    """com.google.common.collect.ImmutableRangeMap"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableRangeMap) -> 'ImmutableRangeMap':
        return ImmutableRangeMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableRangeMap):
        """
        Dynamic initializer for ImmutableRangeMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableRangeMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableRangeMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableRangeMap$Builder<K, V> com.google.common.collect.ImmutableRangeMap.builder()"""
        return Builder._wrap(_ImmutableRangeMap.builder())

    @override
    @overload
    def merge(self, range: 'Range', value: object, remappingFunction: 'BiFunction'):
        """public final void com.google.common.collect.ImmutableRangeMap.merge(com.google.common.collect.Range<K>,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        super(_ImmutableRangeMap, self).merge(range, value, remappingFunction)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def copyOf(rangeMap: 'RangeMap') -> 'ImmutableRangeMap':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap.copyOf(com.google.common.collect.RangeMap<K, ? extends V>)"""
        return ImmutableRangeMap._wrap(_ImmutableRangeMap.copyOf(rangeMap))

    @staticmethod
    @overload
    def toImmutableRangeMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K extends java.lang.Comparable<? super K>,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableRangeMap<K, V>> com.google.common.collect.ImmutableRangeMap.toImmutableRangeMap(java.util.function.Function<? super T, com.google.common.collect.Range<K>>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector._wrap(_ImmutableRangeMap.toImmutableRangeMap(keyFunction, valueFunction))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableRangeMap.hashCode()"""
        return int._wrap(super(ImmutableRangeMap, self).hashCode())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def remove(self, range: 'Range'):
        """public final void com.google.common.collect.ImmutableRangeMap.remove(com.google.common.collect.Range<K>)"""
        super(_ImmutableRangeMap, self).remove(range)

    @overload
    def get(self, key: 'Comparable') -> object:
        """public V com.google.common.collect.ImmutableRangeMap.get(K)"""
        return object._wrap(super(_ImmutableRangeMap, self).get(key))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def equals(self, o: object) -> bool:
        """public boolean com.google.common.collect.ImmutableRangeMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableRangeMap, self).equals(o))

    @override
    @overload
    def span(self) -> 'Range':
        """public com.google.common.collect.Range<K> com.google.common.collect.ImmutableRangeMap.span()"""
        return 'Range'._wrap(super(ImmutableRangeMap, self).span())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableRangeMap.clear()"""
        super(ImmutableRangeMap, self).clear()

    @override
    @overload
    def asMapOfRanges(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<com.google.common.collect.Range<K>, V> com.google.common.collect.ImmutableRangeMap.asMapOfRanges()"""
        return 'ImmutableMap'._wrap(super(ImmutableRangeMap, self).asMapOfRanges())

    @override
    @overload
    def putCoalescing(self, range: 'Range', value: object):
        """public final void com.google.common.collect.ImmutableRangeMap.putCoalescing(com.google.common.collect.Range<K>,V)"""
        super(_ImmutableRangeMap, self).putCoalescing(range, value)

    @overload
    def subRangeMap(self, range: 'Range') -> 'ImmutableRangeMap':
        """public com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap.subRangeMap(com.google.common.collect.Range<K>)"""
        return 'ImmutableRangeMap'._wrap(super(_ImmutableRangeMap, self).subRangeMap(range))

    @override
    @overload
    def put(self, range: 'Range', value: object):
        """public final void com.google.common.collect.ImmutableRangeMap.put(com.google.common.collect.Range<K>,V)"""
        super(_ImmutableRangeMap, self).put(range, value)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def asDescendingMapOfRanges(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<com.google.common.collect.Range<K>, V> com.google.common.collect.ImmutableRangeMap.asDescendingMapOfRanges()"""
        return 'ImmutableMap'._wrap(super(ImmutableRangeMap, self).asDescendingMapOfRanges())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableRangeMap.toString()"""
        return str._wrap(super(ImmutableRangeMap, self).toString())

    @override
    @overload
    def putAll(self, rangeMap: 'RangeMap'):
        """public final void com.google.common.collect.ImmutableRangeMap.putAll(com.google.common.collect.RangeMap<K, ? extends V>)"""
        super(_ImmutableRangeMap, self).putAll(rangeMap)

    @staticmethod
    @overload
    def of() -> 'ImmutableRangeMap':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap.of()"""
        return ImmutableRangeMap._wrap(_ImmutableRangeMap.of())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def of(range: 'Range', value: object) -> 'ImmutableRangeMap':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap.of(com.google.common.collect.Range<K>,V)"""
        return ImmutableRangeMap._wrap(_ImmutableRangeMap.of(range, value))

    @overload
    def getEntry(self, key: 'Comparable') -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<com.google.common.collect.Range<K>, V> com.google.common.collect.ImmutableRangeMap.getEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_ImmutableRangeMap, self).getEntry(key)) 
 
 
# CLASS: com.google.common.collect.ForwardingDeque
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
import com.google.common.collect.ForwardingQueue as _ForwardingQueue
_ForwardingQueue = _ForwardingQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import com.google.common.collect.ForwardingDeque as _ForwardingDeque
_ForwardingDeque = _ForwardingDeque
import java.util.Deque as Deque
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Collection as _Collection
_Collection = _Collection
import java.util.Deque as _Deque
_Deque = _Deque
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingDeque():
    """com.google.common.collect.ForwardingDeque"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingDeque) -> 'ForwardingDeque':
        return ForwardingDeque(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingDeque):
        """
        Dynamic initializer for ForwardingDeque.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingDeque__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingDeque__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.getLast()"""
        return object._wrap(super(ForwardingDeque, self).getLast())

    @override
    @overload
    def removeLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.removeLast()"""
        return object._wrap(super(ForwardingDeque, self).removeLast())

    @overload
    def offerFirst(self, e: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.offerFirst(E)"""
        return bool._wrap(super(_ForwardingDeque, self).offerFirst(e))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def peekLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.peekLast()"""
        return object._wrap(super(ForwardingDeque, self).peekLast())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def remove(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.remove()"""
        return object._wrap(super(ForwardingQueue, self).remove())

    @override
    @overload
    def addFirst(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.addFirst(E)"""
        super(_ForwardingDeque, self).addFirst(e)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def removeFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.removeFirst()"""
        return object._wrap(super(ForwardingDeque, self).removeFirst())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.peek()"""
        return object._wrap(super(ForwardingQueue, self).peek())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @override
    @overload
    def push(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.push(E)"""
        super(_ForwardingDeque, self).push(e)

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.poll()"""
        return object._wrap(super(ForwardingQueue, self).poll())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pollFirst()"""
        return object._wrap(super(ForwardingDeque, self).pollFirst())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingDeque.descendingIterator()"""
        return 'Iterator'._wrap(super(ForwardingDeque, self).descendingIterator())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def addLast(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.addLast(E)"""
        super(_ForwardingDeque, self).addLast(e)

    @overload
    def removeLastOccurrence(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.removeLastOccurrence(java.lang.Object)"""
        return bool._wrap(super(_ForwardingDeque, self).removeLastOccurrence(o))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @override
    @overload
    def reversed(self) -> 'Deque':
        """public default java.util.Deque<E> java.util.Deque.reversed()"""
        return 'Deque'._wrap(super(Deque, self).reversed())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def pop(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pop()"""
        return object._wrap(super(ForwardingDeque, self).pop())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'._wrap(super(Collection, self).spliterator())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def removeFirstOccurrence(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.removeFirstOccurrence(java.lang.Object)"""
        return bool._wrap(super(_ForwardingDeque, self).removeFirstOccurrence(o))

    @override
    @overload
    def peekFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.peekFirst()"""
        return object._wrap(super(ForwardingDeque, self).peekFirst())

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @overload
    def offerLast(self, e: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.offerLast(E)"""
        return bool._wrap(super(_ForwardingDeque, self).offerLast(e))

    @override
    @overload
    def element(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.element()"""
        return object._wrap(super(ForwardingQueue, self).element())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pollLast()"""
        return object._wrap(super(ForwardingDeque, self).pollLast())

    @override
    @overload
    def getFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.getFirst()"""
        return object._wrap(super(ForwardingDeque, self).getFirst())

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def offer(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingQueue.offer(E)"""
        return bool._wrap(super(_ForwardingQueue, self).offer(o))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.ForwardingIterator
from builtins import str
import com.google.common.collect.ForwardingIterator as _ForwardingIterator
_ForwardingIterator = _ForwardingIterator
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.lang.Integer as _int
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingIterator():
    """com.google.common.collect.ForwardingIterator"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingIterator) -> 'ForwardingIterator':
        return ForwardingIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingIterator):
        """
        Dynamic initializer for ForwardingIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def next(self) -> object:
        """public T com.google.common.collect.ForwardingIterator.next()"""
        return object._wrap(super(ForwardingIterator, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.google.common.collect.ForwardingIterator.hasNext()"""
        return bool._wrap(super(ForwardingIterator, self).hasNext())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def remove(self):
        """public void com.google.common.collect.ForwardingIterator.remove()"""
        super(ForwardingIterator, self).remove()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import com.google.common.collect.UnmodifiableIterator as _UnmodifiableIterator
_UnmodifiableIterator = _UnmodifiableIterator
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset_Builder
_Builder = _ImmutableMultiset_Builder.Builder
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.function.ToIntFunction as ToIntFunction
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset
_ImmutableMultiset = _ImmutableMultiset
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
from typing import List
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.util.function.Function as Function
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ImmutableMultiset():
    """com.google.common.collect.ImmutableMultiset"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableMultiset) -> 'ImmutableMultiset':
        return ImmutableMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableMultiset):
        """
        Dynamic initializer for ImmutableMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.copyOf(elements))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ImmutableCollection, self).remove(object))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object]._wrap(super(_ImmutableCollection, self).toArray(other))

    @abstractmethod
    def count(self, element: object):
        """public abstract int com.google.common.collect.Multiset.count(java.lang.Object)"""
        pass

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2, e3))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def iterator(self) -> 'UnmodifiableIterator':
        """public com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableMultiset.iterator()"""
        return 'UnmodifiableIterator'._wrap(super(ImmutableMultiset, self).iterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(element))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultiset.contains(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultiset, self).contains(object))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.add(E,int)"""
        return int._wrap(super(_ImmutableMultiset, self).add(element, _int.valueOf(occurrences)))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object]._wrap(super(ImmutableCollection, self).toArray())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.setCount(E,int)"""
        return int._wrap(super(_ImmutableMultiset, self).setCount(element, _int.valueOf(count)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableCollection.spliterator()"""
        return 'Spliterator'._wrap(super(ImmutableCollection, self).spliterator())

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @staticmethod
    @overload
    def of() -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of()"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of())

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableMultiset, self).equals(object))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset.builder()"""
        return Builder._wrap(_ImmutableMultiset.builder())

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool._wrap(super(_ImmutableCollection, self).add(e))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2, e3, e4))

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultiset.setCount(E,int,int)"""
        return bool._wrap(super(_ImmutableMultiset, self).setCount(element, _int.valueOf(oldCount), _int.valueOf(newCount)))

    @staticmethod
    @overload
    def toImmutableMultiset(elementFunction: 'Function', countFunction: 'ToIntFunction') -> 'Collector':
        """public static <T,E> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMultiset<E>> com.google.common.collect.ImmutableMultiset.toImmutableMultiset(java.util.function.Function<? super T, ? extends E>,java.util.function.ToIntFunction<? super T>)"""
        return Collector._wrap(_ImmutableMultiset.toImmutableMultiset(elementFunction, countFunction))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E,E)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMultiset.toString()"""
        return str._wrap(super(ImmutableMultiset, self).toString())

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.copyOf(elements))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @staticmethod
    @overload
    def toImmutableMultiset() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableMultiset<E>> com.google.common.collect.ImmutableMultiset.toImmutableMultiset()"""
        return Collector._wrap(_ImmutableMultiset.toImmutableMultiset())

    @abstractmethod
    def elementSet(self, ):
        """public abstract com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableMultiset.elementSet()"""
        pass

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ImmutableCollection, self).addAll(newElements))

    @override
    @overload
    def asList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableMultiset.asList()"""
        return 'ImmutableList'._wrap(super(ImmutableMultiset, self).asList())

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_Multiset, self).forEachEntry(action)

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMultiset.hashCode()"""
        return int._wrap(super(ImmutableMultiset, self).hashCode())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.remove(java.lang.Object,int)"""
        return int._wrap(super(_ImmutableMultiset, self).remove(element, _int.valueOf(occurrences)))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E,E,E,E...)"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.of(e1, e2, e3, e4, e5, e6, others))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeAll(oldElements))

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ImmutableMultiset.entrySet()"""
        return 'ImmutableSet'._wrap(super(ImmutableMultiset, self).entrySet())

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(E[])"""
        return ImmutableMultiset._wrap(_ImmutableMultiset.copyOf(elements))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.TreeMultimap
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.NavigableMap as NavigableMap
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
import com.google.common.collect.TreeMultimap as _TreeMultimap
_TreeMultimap = _TreeMultimap
import java.util.Comparator as Comparator
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.NavigableMap as _NavigableMap
_NavigableMap = _NavigableMap
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
 
class TreeMultimap():
    """com.google.common.collect.TreeMultimap"""
 
    @staticmethod
    def _wrap(java_value: _TreeMultimap) -> 'TreeMultimap':
        return TreeMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _TreeMultimap):
        """
        Dynamic initializer for TreeMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_TreeMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_TreeMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def create(keyComparator: 'Comparator', valueComparator: 'Comparator') -> 'TreeMultimap':
        """public static <K,V> com.google.common.collect.TreeMultimap<K, V> com.google.common.collect.TreeMultimap.create(java.util.Comparator<? super K>,java.util.Comparator<? super V>)"""
        return TreeMultimap._wrap(_TreeMultimap.create(keyComparator, valueComparator))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'TreeMultimap':
        """public static <K extends java.lang.Comparable,V extends java.lang.Comparable> com.google.common.collect.TreeMultimap<K, V> com.google.common.collect.TreeMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return TreeMultimap._wrap(_TreeMultimap.create(multimap))

    @overload
    def keyComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.TreeMultimap.keyComparator()"""
        return 'Comparator'._wrap(super(TreeMultimap, self).keyComparator())

    @override
    @overload
    def asMap(self) -> 'NavigableMap':
        """public java.util.NavigableMap<K, java.util.Collection<V>> com.google.common.collect.TreeMultimap.asMap()"""
        return 'NavigableMap'._wrap(super(TreeMultimap, self).asMap())

    @overload
    def get(self, key: object) -> 'NavigableSet':
        """public java.util.NavigableSet<V> com.google.common.collect.TreeMultimap.get(K)"""
        return 'NavigableSet'._wrap(super(_TreeMultimap, self).get(key))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def valueComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super V> com.google.common.collect.TreeMultimap.valueComparator()"""
        return 'Comparator'._wrap(super(TreeMultimap, self).valueComparator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def create() -> 'TreeMultimap':
        """public static <K extends java.lang.Comparable,V extends java.lang.Comparable> com.google.common.collect.TreeMultimap<K, V> com.google.common.collect.TreeMultimap.create()"""
        return TreeMultimap._wrap(_TreeMultimap.create())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def keySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.TreeMultimap.keySet()"""
        return 'NavigableSet'._wrap(super(TreeMultimap, self).keySet()) 
 
 
# CLASS: com.google.common.collect.MapMaker
import com.google.common.collect.MapMaker as _MapMaker
_MapMaker = _MapMaker
from builtins import str
import java.util.concurrent.ConcurrentMap as _ConcurrentMap
_ConcurrentMap = _ConcurrentMap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.concurrent.ConcurrentMap as ConcurrentMap
import java.lang.String as _String
_String = _String
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class MapMaker():
    """com.google.common.collect.MapMaker"""
 
    @staticmethod
    def _wrap(java_value: _MapMaker) -> 'MapMaker':
        return MapMaker(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _MapMaker):
        """
        Dynamic initializer for MapMaker.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_MapMaker__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_MapMaker__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def weakValues(self) -> 'MapMaker':
        """public com.google.common.collect.MapMaker com.google.common.collect.MapMaker.weakValues()"""
        return 'MapMaker'._wrap(super(MapMaker, self).weakValues())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.MapMaker()"""
        val = _MapMaker()
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.MapMaker.toString()"""
        return str._wrap(super(MapMaker, self).toString())

    @overload
    def makeMap(self) -> 'ConcurrentMap':
        """public <K,V> java.util.concurrent.ConcurrentMap<K, V> com.google.common.collect.MapMaker.makeMap()"""
        return 'ConcurrentMap'._wrap(super(MapMaker, self).makeMap())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def initialCapacity(self, initialCapacity: int) -> 'MapMaker':
        """public com.google.common.collect.MapMaker com.google.common.collect.MapMaker.initialCapacity(int)"""
        return 'MapMaker'._wrap(super(_MapMaker, self).initialCapacity(_int.valueOf(initialCapacity)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def concurrencyLevel(self, concurrencyLevel: int) -> 'MapMaker':
        """public com.google.common.collect.MapMaker com.google.common.collect.MapMaker.concurrencyLevel(int)"""
        return 'MapMaker'._wrap(super(_MapMaker, self).concurrencyLevel(_int.valueOf(concurrencyLevel)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.google.common.collect.MapMaker()"""
        val = _MapMaker()
        self.__wrapper = val

    @overload
    def weakKeys(self) -> 'MapMaker':
        """public com.google.common.collect.MapMaker com.google.common.collect.MapMaker.weakKeys()"""
        return 'MapMaker'._wrap(super(MapMaker, self).weakKeys())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ComparisonChain
import java.lang.Boolean as Boolean
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
from abc import abstractmethod, ABC
import java.lang.Comparable as Comparable
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
import com.google.common.collect.ComparisonChain as _ComparisonChain
_ComparisonChain = _ComparisonChain
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ComparisonChain():
    """com.google.common.collect.ComparisonChain"""
 
    @staticmethod
    def _wrap(java_value: _ComparisonChain) -> 'ComparisonChain':
        return ComparisonChain(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ComparisonChain):
        """
        Dynamic initializer for ComparisonChain.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ComparisonChain__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ComparisonChain__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def compareTrueFirst(self, left: bool, right: bool):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compareTrueFirst(boolean,boolean)"""
        pass

    @abstractmethod
    def result(self, ):
        """public abstract int com.google.common.collect.ComparisonChain.result()"""
        pass

    @overload
    def compare(self, left: 'Boolean', right: 'Boolean') -> 'ComparisonChain':
        """public final com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(java.lang.Boolean,java.lang.Boolean)"""
        return 'ComparisonChain'._wrap(super(_ComparisonChain, self).compare(left, right))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @abstractmethod
    def compare(self, left: int, right: int):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(long,long)"""
        pass

    @abstractmethod
    def compareFalseFirst(self, left: bool, right: bool):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compareFalseFirst(boolean,boolean)"""
        pass

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @abstractmethod
    def compare(self, left: int, right: int):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(int,int)"""
        pass

    @abstractmethod
    def compare(self, left: 'Comparable', right: 'Comparable'):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(java.lang.Comparable<?>,java.lang.Comparable<?>)"""
        pass

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @abstractmethod
    def compare(self, left: float, right: float):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(float,float)"""
        pass

    @abstractmethod
    def compare(self, left: object, right: object, comparator: 'Comparator'):
        """public abstract <T> com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(T,T,java.util.Comparator<T>)"""
        pass

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def compare(self, left: float, right: float):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(double,double)"""
        pass

    @staticmethod
    @overload
    def start() -> 'ComparisonChain':
        """public static com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.start()"""
        return ComparisonChain._wrap(_ComparisonChain.start())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Queues
import java.util.concurrent.LinkedBlockingQueue as LinkedBlockingQueue
import java.util.concurrent.PriorityBlockingQueue as PriorityBlockingQueue
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.Queues as _Queues
_Queues = _Queues
import java.util.Collection as Collection
import java.util.concurrent.SynchronousQueue as _SynchronousQueue
_SynchronousQueue = _SynchronousQueue
import java.util.concurrent.LinkedBlockingQueue as _LinkedBlockingQueue
_LinkedBlockingQueue = _LinkedBlockingQueue
import java.util.concurrent.ArrayBlockingQueue as ArrayBlockingQueue
import java.util.concurrent.ConcurrentLinkedQueue as _ConcurrentLinkedQueue
_ConcurrentLinkedQueue = _ConcurrentLinkedQueue
import java.util.concurrent.ConcurrentLinkedQueue as ConcurrentLinkedQueue
import java.util.concurrent.SynchronousQueue as SynchronousQueue
from builtins import bool
import java.util.concurrent.ArrayBlockingQueue as _ArrayBlockingQueue
_ArrayBlockingQueue = _ArrayBlockingQueue
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import java.util.PriorityQueue as _PriorityQueue
_PriorityQueue = _PriorityQueue
import java.util.Deque as Deque
import java.lang.Iterable as Iterable
import java.time.Duration as Duration
import java.lang.String as _String
_String = _String
import java.util.Queue as Queue
import java.util.concurrent.BlockingQueue as BlockingQueue
import java.util.Queue as _Queue
_Queue = _Queue
import java.util.concurrent.LinkedBlockingDeque as _LinkedBlockingDeque
_LinkedBlockingDeque = _LinkedBlockingDeque
import java.util.Deque as _Deque
_Deque = _Deque
import java.lang.Integer as _int
import java.util.concurrent.TimeUnit as TimeUnit
import java.util.ArrayDeque as _ArrayDeque
_ArrayDeque = _ArrayDeque
import java.util.PriorityQueue as PriorityQueue
import java.util.ArrayDeque as ArrayDeque
import java.util.concurrent.PriorityBlockingQueue as _PriorityBlockingQueue
_PriorityBlockingQueue = _PriorityBlockingQueue
import java.lang.Long as _long
from builtins import int
import java.util.concurrent.LinkedBlockingDeque as LinkedBlockingDeque
import java.lang.Class as _Class
_Class = _Class
 
class Queues():
    """com.google.common.collect.Queues"""
 
    @staticmethod
    def _wrap(java_value: _Queues) -> 'Queues':
        return Queues(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Queues):
        """
        Dynamic initializer for Queues.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Queues__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Queues__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def drain(q: 'BlockingQueue', buffer: 'Collection', numElements: int, timeout: int, unit: 'TimeUnit') -> int:
        """public static <E> int com.google.common.collect.Queues.drain(java.util.concurrent.BlockingQueue<E>,java.util.Collection<? super E>,int,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return int._wrap(_Queues.drain(q, buffer, _int.valueOf(numElements), _long.valueOf(timeout), unit))

    @staticmethod
    @overload
    def newLinkedBlockingQueue(capacity: int) -> 'LinkedBlockingQueue':
        """public static <E> java.util.concurrent.LinkedBlockingQueue<E> com.google.common.collect.Queues.newLinkedBlockingQueue(int)"""
        return LinkedBlockingQueue._wrap(_Queues.newLinkedBlockingQueue(_int.valueOf(capacity)))

    @staticmethod
    @overload
    def synchronizedQueue(queue: 'Queue') -> 'Queue':
        """public static <E> java.util.Queue<E> com.google.common.collect.Queues.synchronizedQueue(java.util.Queue<E>)"""
        return Queue._wrap(_Queues.synchronizedQueue(queue))

    @staticmethod
    @overload
    def drainUninterruptibly(q: 'BlockingQueue', buffer: 'Collection', numElements: int, timeout: int, unit: 'TimeUnit') -> int:
        """public static <E> int com.google.common.collect.Queues.drainUninterruptibly(java.util.concurrent.BlockingQueue<E>,java.util.Collection<? super E>,int,long,java.util.concurrent.TimeUnit)"""
        return int._wrap(_Queues.drainUninterruptibly(q, buffer, _int.valueOf(numElements), _long.valueOf(timeout), unit))

    @staticmethod
    @overload
    def newSynchronousQueue() -> 'SynchronousQueue':
        """public static <E> java.util.concurrent.SynchronousQueue<E> com.google.common.collect.Queues.newSynchronousQueue()"""
        return SynchronousQueue._wrap(_Queues.newSynchronousQueue())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def drain(q: 'BlockingQueue', buffer: 'Collection', numElements: int, timeout: 'Duration') -> int:
        """public static <E> int com.google.common.collect.Queues.drain(java.util.concurrent.BlockingQueue<E>,java.util.Collection<? super E>,int,java.time.Duration) throws java.lang.InterruptedException"""
        return int._wrap(_Queues.drain(q, buffer, _int.valueOf(numElements), timeout))

    @staticmethod
    @overload
    def newPriorityQueue(elements: 'Iterable') -> 'PriorityQueue':
        """public static <E extends java.lang.Comparable> java.util.PriorityQueue<E> com.google.common.collect.Queues.newPriorityQueue(java.lang.Iterable<? extends E>)"""
        return PriorityQueue._wrap(_Queues.newPriorityQueue(elements))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def newLinkedBlockingQueue(elements: 'Iterable') -> 'LinkedBlockingQueue':
        """public static <E> java.util.concurrent.LinkedBlockingQueue<E> com.google.common.collect.Queues.newLinkedBlockingQueue(java.lang.Iterable<? extends E>)"""
        return LinkedBlockingQueue._wrap(_Queues.newLinkedBlockingQueue(elements))

    @staticmethod
    @overload
    def newPriorityBlockingQueue() -> 'PriorityBlockingQueue':
        """public static <E extends java.lang.Comparable> java.util.concurrent.PriorityBlockingQueue<E> com.google.common.collect.Queues.newPriorityBlockingQueue()"""
        return PriorityBlockingQueue._wrap(_Queues.newPriorityBlockingQueue())

    @staticmethod
    @overload
    def newPriorityQueue() -> 'PriorityQueue':
        """public static <E extends java.lang.Comparable> java.util.PriorityQueue<E> com.google.common.collect.Queues.newPriorityQueue()"""
        return PriorityQueue._wrap(_Queues.newPriorityQueue())

    @staticmethod
    @overload
    def newLinkedBlockingDeque(capacity: int) -> 'LinkedBlockingDeque':
        """public static <E> java.util.concurrent.LinkedBlockingDeque<E> com.google.common.collect.Queues.newLinkedBlockingDeque(int)"""
        return LinkedBlockingDeque._wrap(_Queues.newLinkedBlockingDeque(_int.valueOf(capacity)))

    @staticmethod
    @overload
    def newLinkedBlockingDeque() -> 'LinkedBlockingDeque':
        """public static <E> java.util.concurrent.LinkedBlockingDeque<E> com.google.common.collect.Queues.newLinkedBlockingDeque()"""
        return LinkedBlockingDeque._wrap(_Queues.newLinkedBlockingDeque())

    @staticmethod
    @overload
    def newArrayBlockingQueue(capacity: int) -> 'ArrayBlockingQueue':
        """public static <E> java.util.concurrent.ArrayBlockingQueue<E> com.google.common.collect.Queues.newArrayBlockingQueue(int)"""
        return ArrayBlockingQueue._wrap(_Queues.newArrayBlockingQueue(_int.valueOf(capacity)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def synchronizedDeque(deque: 'Deque') -> 'Deque':
        """public static <E> java.util.Deque<E> com.google.common.collect.Queues.synchronizedDeque(java.util.Deque<E>)"""
        return Deque._wrap(_Queues.synchronizedDeque(deque))

    @staticmethod
    @overload
    def newArrayDeque(elements: 'Iterable') -> 'ArrayDeque':
        """public static <E> java.util.ArrayDeque<E> com.google.common.collect.Queues.newArrayDeque(java.lang.Iterable<? extends E>)"""
        return ArrayDeque._wrap(_Queues.newArrayDeque(elements))

    @staticmethod
    @overload
    def newLinkedBlockingQueue() -> 'LinkedBlockingQueue':
        """public static <E> java.util.concurrent.LinkedBlockingQueue<E> com.google.common.collect.Queues.newLinkedBlockingQueue()"""
        return LinkedBlockingQueue._wrap(_Queues.newLinkedBlockingQueue())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def newConcurrentLinkedQueue() -> 'ConcurrentLinkedQueue':
        """public static <E> java.util.concurrent.ConcurrentLinkedQueue<E> com.google.common.collect.Queues.newConcurrentLinkedQueue()"""
        return ConcurrentLinkedQueue._wrap(_Queues.newConcurrentLinkedQueue())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def newLinkedBlockingDeque(elements: 'Iterable') -> 'LinkedBlockingDeque':
        """public static <E> java.util.concurrent.LinkedBlockingDeque<E> com.google.common.collect.Queues.newLinkedBlockingDeque(java.lang.Iterable<? extends E>)"""
        return LinkedBlockingDeque._wrap(_Queues.newLinkedBlockingDeque(elements))

    @staticmethod
    @overload
    def newArrayDeque() -> 'ArrayDeque':
        """public static <E> java.util.ArrayDeque<E> com.google.common.collect.Queues.newArrayDeque()"""
        return ArrayDeque._wrap(_Queues.newArrayDeque())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def newPriorityBlockingQueue(elements: 'Iterable') -> 'PriorityBlockingQueue':
        """public static <E extends java.lang.Comparable> java.util.concurrent.PriorityBlockingQueue<E> com.google.common.collect.Queues.newPriorityBlockingQueue(java.lang.Iterable<? extends E>)"""
        return PriorityBlockingQueue._wrap(_Queues.newPriorityBlockingQueue(elements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def newConcurrentLinkedQueue(elements: 'Iterable') -> 'ConcurrentLinkedQueue':
        """public static <E> java.util.concurrent.ConcurrentLinkedQueue<E> com.google.common.collect.Queues.newConcurrentLinkedQueue(java.lang.Iterable<? extends E>)"""
        return ConcurrentLinkedQueue._wrap(_Queues.newConcurrentLinkedQueue(elements))

    @staticmethod
    @overload
    def drainUninterruptibly(q: 'BlockingQueue', buffer: 'Collection', numElements: int, timeout: 'Duration') -> int:
        """public static <E> int com.google.common.collect.Queues.drainUninterruptibly(java.util.concurrent.BlockingQueue<E>,java.util.Collection<? super E>,int,java.time.Duration)"""
        return int._wrap(_Queues.drainUninterruptibly(q, buffer, _int.valueOf(numElements), timeout))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.MoreCollectors
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.lang.Integer as _int
import com.google.common.collect.MoreCollectors as _MoreCollectors
_MoreCollectors = _MoreCollectors
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class MoreCollectors():
    """com.google.common.collect.MoreCollectors"""
 
    @staticmethod
    def _wrap(java_value: _MoreCollectors) -> 'MoreCollectors':
        return MoreCollectors(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _MoreCollectors):
        """
        Dynamic initializer for MoreCollectors.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_MoreCollectors__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_MoreCollectors__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def toOptional() -> 'Collector':
        """public static <T> java.util.stream.Collector<T, ?, java.util.Optional<T>> com.google.common.collect.MoreCollectors.toOptional()"""
        return Collector._wrap(_MoreCollectors.toOptional())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def onlyElement() -> 'Collector':
        """public static <T> java.util.stream.Collector<T, ?, T> com.google.common.collect.MoreCollectors.onlyElement()"""
        return Collector._wrap(_MoreCollectors.onlyElement())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.RangeSet
import com.google.common.collect.RangeSet as _RangeSet
_RangeSet = _RangeSet
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
import java.lang.Comparable as Comparable
from builtins import bool
 
class RangeSet():
    """com.google.common.collect.RangeSet"""
 
    @staticmethod
    def _wrap(java_value: _RangeSet) -> 'RangeSet':
        return RangeSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _RangeSet):
        """
        Dynamic initializer for RangeSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_RangeSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_RangeSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def intersects(self, otherRange: 'Range'):
        """public abstract boolean com.google.common.collect.RangeSet.intersects(com.google.common.collect.Range<C>)"""
        pass

    @abstractmethod
    def rangeContaining(self, value: 'Comparable'):
        """public abstract com.google.common.collect.Range<C> com.google.common.collect.RangeSet.rangeContaining(C)"""
        pass

    @overload
    def enclosesAll(self, other: 'Iterable') -> bool:
        """public default boolean com.google.common.collect.RangeSet.enclosesAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return bool._wrap(super(_RangeSet, self).enclosesAll(other))

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.RangeSet.hashCode()"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.RangeSet.isEmpty()"""
        pass

    @abstractmethod
    def removeAll(self, other: 'RangeSet'):
        """public abstract void com.google.common.collect.RangeSet.removeAll(com.google.common.collect.RangeSet<C>)"""
        pass

    @abstractmethod
    def addAll(self, other: 'RangeSet'):
        """public abstract void com.google.common.collect.RangeSet.addAll(com.google.common.collect.RangeSet<C>)"""
        pass

    @abstractmethod
    def asRanges(self, ):
        """public abstract java.util.Set<com.google.common.collect.Range<C>> com.google.common.collect.RangeSet.asRanges()"""
        pass

    @abstractmethod
    def remove(self, range: 'Range'):
        """public abstract void com.google.common.collect.RangeSet.remove(com.google.common.collect.Range<C>)"""
        pass

    @abstractmethod
    def asDescendingSetOfRanges(self, ):
        """public abstract java.util.Set<com.google.common.collect.Range<C>> com.google.common.collect.RangeSet.asDescendingSetOfRanges()"""
        pass

    @abstractmethod
    def subRangeSet(self, view: 'Range'):
        """public abstract com.google.common.collect.RangeSet<C> com.google.common.collect.RangeSet.subRangeSet(com.google.common.collect.Range<C>)"""
        pass

    @abstractmethod
    def span(self, ):
        """public abstract com.google.common.collect.Range<C> com.google.common.collect.RangeSet.span()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.RangeSet.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.RangeSet.toString()"""
        pass

    @abstractmethod
    def contains(self, value: 'Comparable'):
        """public abstract boolean com.google.common.collect.RangeSet.contains(C)"""
        pass

    @abstractmethod
    def enclosesAll(self, other: 'RangeSet'):
        """public abstract boolean com.google.common.collect.RangeSet.enclosesAll(com.google.common.collect.RangeSet<C>)"""
        pass

    @abstractmethod
    def complement(self, ):
        """public abstract com.google.common.collect.RangeSet<C> com.google.common.collect.RangeSet.complement()"""
        pass

    @abstractmethod
    def add(self, range: 'Range'):
        """public abstract void com.google.common.collect.RangeSet.add(com.google.common.collect.Range<C>)"""
        pass

    @overload
    def addAll(self, ranges: 'Iterable'):
        """public default void com.google.common.collect.RangeSet.addAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(_RangeSet, self).addAll(ranges)

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.RangeSet.clear()"""
        pass

    @overload
    def removeAll(self, ranges: 'Iterable'):
        """public default void com.google.common.collect.RangeSet.removeAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(_RangeSet, self).removeAll(ranges)

    @abstractmethod
    def encloses(self, otherRange: 'Range'):
        """public abstract boolean com.google.common.collect.RangeSet.encloses(com.google.common.collect.Range<C>)"""
        pass 
 
 
# CLASS: com.google.common.collect.UnmodifiableIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.UnmodifiableIterator as _UnmodifiableIterator
_UnmodifiableIterator = _UnmodifiableIterator
import java.lang.String as _String
_String = _String
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.lang.Integer as _int
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class UnmodifiableIterator():
    """com.google.common.collect.UnmodifiableIterator"""
 
    @staticmethod
    def _wrap(java_value: _UnmodifiableIterator) -> 'UnmodifiableIterator':
        return UnmodifiableIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _UnmodifiableIterator):
        """
        Dynamic initializer for UnmodifiableIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_UnmodifiableIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_UnmodifiableIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def remove(self):
        """public final void com.google.common.collect.UnmodifiableIterator.remove()"""
        super(UnmodifiableIterator, self).remove()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @abstractmethod
    def next(self, ):
        """public abstract E java.util.Iterator.next()"""
        pass

    @abstractmethod
    def hasNext(self, ):
        """public abstract boolean java.util.Iterator.hasNext()"""
        pass

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.RowSortedTable
import com.google.common.collect.Table as _Table
_Table = _Table
from abc import abstractmethod, ABC
import com.google.common.collect.RowSortedTable as _RowSortedTable
_RowSortedTable = _RowSortedTable
 
class RowSortedTable():
    """com.google.common.collect.RowSortedTable"""
 
    @staticmethod
    def _wrap(java_value: _RowSortedTable) -> 'RowSortedTable':
        return RowSortedTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _RowSortedTable):
        """
        Dynamic initializer for RowSortedTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_RowSortedTable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_RowSortedTable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def containsRow(self, rowKey: object):
        """public abstract boolean com.google.common.collect.Table.containsRow(java.lang.Object)"""
        pass

    @abstractmethod
    def put(self, rowKey: object, columnKey: object, value: object):
        """public abstract V com.google.common.collect.Table.put(R,C,V)"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Table.isEmpty()"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Table.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def columnKeySet(self, ):
        """public abstract java.util.Set<C> com.google.common.collect.Table.columnKeySet()"""
        pass

    @abstractmethod
    def containsColumn(self, columnKey: object):
        """public abstract boolean com.google.common.collect.Table.containsColumn(java.lang.Object)"""
        pass

    @abstractmethod
    def rowKeySet(self, ):
        """public abstract java.util.SortedSet<R> com.google.common.collect.RowSortedTable.rowKeySet()"""
        pass

    @abstractmethod
    def columnMap(self, ):
        """public abstract java.util.Map<C, java.util.Map<R, V>> com.google.common.collect.Table.columnMap()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.Table.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Table.hashCode()"""
        pass

    @abstractmethod
    def rowMap(self, ):
        """public abstract java.util.SortedMap<R, java.util.Map<C, V>> com.google.common.collect.RowSortedTable.rowMap()"""
        pass

    @abstractmethod
    def putAll(self, table: 'Table'):
        """public abstract void com.google.common.collect.Table.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        pass

    @abstractmethod
    def column(self, columnKey: object):
        """public abstract java.util.Map<R, V> com.google.common.collect.Table.column(C)"""
        pass

    @abstractmethod
    def row(self, rowKey: object):
        """public abstract java.util.Map<C, V> com.google.common.collect.Table.row(R)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Table.clear()"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Table.size()"""
        pass

    @abstractmethod
    def cellSet(self, ):
        """public abstract java.util.Set<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.Table.cellSet()"""
        pass

    @abstractmethod
    def remove(self, rowKey: object, columnKey: object):
        """public abstract V com.google.common.collect.Table.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Table.values()"""
        pass

    @abstractmethod
    def get(self, rowKey: object, columnKey: object):
        """public abstract V com.google.common.collect.Table.get(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def contains(self, rowKey: object, columnKey: object):
        """public abstract boolean com.google.common.collect.Table.contains(java.lang.Object,java.lang.Object)"""
        pass 
 
 
# CLASS: com.google.common.collect.FluentIterable
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.FluentIterable as _FluentIterable
_FluentIterable = _FluentIterable
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import com.google.common.base.Optional as _Optional
_Optional = _Optional
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
from typing import List
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset
_ImmutableMultiset = _ImmutableMultiset
import java.util.Comparator as Comparator
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet
_ImmutableSortedSet = _ImmutableSortedSet
import java.util.stream.Stream as Stream
import java.lang.Long as _long
import com.google.common.collect.ImmutableListMultimap as _ImmutableListMultimap
_ImmutableListMultimap = _ImmutableListMultimap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class FluentIterable():
    """com.google.common.collect.FluentIterable"""
 
    @staticmethod
    def _wrap(java_value: _FluentIterable) -> 'FluentIterable':
        return FluentIterable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _FluentIterable):
        """
        Dynamic initializer for FluentIterable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_FluentIterable__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_FluentIterable__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def of() -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.of()"""
        return FluentIterable._wrap(_FluentIterable.of())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def skip(self, numberToSkip: int) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.skip(int)"""
        return 'FluentIterable'._wrap(super(_FluentIterable, self).skip(_int.valueOf(numberToSkip)))

    @overload
    def get(self, position: int) -> object:
        """public final E com.google.common.collect.FluentIterable.get(int)"""
        return object._wrap(super(_FluentIterable, self).get(_int.valueOf(position)))

    @overload
    def toMap(self, valueFunction: 'Function') -> 'ImmutableMap':
        """public final <V> com.google.common.collect.ImmutableMap<E, V> com.google.common.collect.FluentIterable.toMap(com.google.common.base.Function<? super E, V>)"""
        return 'ImmutableMap'._wrap(super(_FluentIterable, self).toMap(valueFunction))

    @overload
    def append(self, *elements: object) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.append(E...)"""
        return 'FluentIterable'._wrap(super(_FluentIterable, self).append(elements))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'._wrap(super(Iterable, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def first(self) -> 'base.Optional':
        """public final com.google.common.base.Optional<E> com.google.common.collect.FluentIterable.first()"""
        return 'base.Optional'._wrap(super(FluentIterable, self).first())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.FluentIterable.toString()"""
        return str._wrap(super(FluentIterable, self).toString())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def toSortedSet(self, comparator: 'Comparator') -> 'ImmutableSortedSet':
        """public final com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.FluentIterable.toSortedSet(java.util.Comparator<? super E>)"""
        return 'ImmutableSortedSet'._wrap(super(_FluentIterable, self).toSortedSet(comparator))

    @staticmethod
    @overload
    def concat(inputs: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends java.lang.Iterable<? extends T>>)"""
        return FluentIterable._wrap(_FluentIterable.concat(inputs))

    @abstractmethod
    def iterator(self, ):
        """public abstract java.util.Iterator<T> java.lang.Iterable.iterator()"""
        pass

    @overload
    def toSortedList(self, comparator: 'Comparator') -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<E> com.google.common.collect.FluentIterable.toSortedList(java.util.Comparator<? super E>)"""
        return 'ImmutableList'._wrap(super(_FluentIterable, self).toSortedList(comparator))

    @overload
    def append(self, other: 'Iterable') -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.append(java.lang.Iterable<? extends E>)"""
        return 'FluentIterable'._wrap(super(_FluentIterable, self).append(other))

    @overload
    def contains(self, target: object) -> bool:
        """public final boolean com.google.common.collect.FluentIterable.contains(java.lang.Object)"""
        return bool._wrap(super(_FluentIterable, self).contains(target))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable', c: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return FluentIterable._wrap(_FluentIterable.concat(a, b, c))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable', c: 'Iterable', d: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return FluentIterable._wrap(_FluentIterable.concat(a, b, c, d))

    @staticmethod
    @overload
    def from(elements: 'Object') -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.from(E[])"""
        return FluentIterable._wrap(_FluentIterable.from(elements))

    @overload
    def firstMatch(self, predicate: 'Predicate') -> 'base.Optional':
        """public final com.google.common.base.Optional<E> com.google.common.collect.FluentIterable.firstMatch(com.google.common.base.Predicate<? super E>)"""
        return 'base.Optional'._wrap(super(_FluentIterable, self).firstMatch(predicate))

    @overload
    def anyMatch(self, predicate: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.FluentIterable.anyMatch(com.google.common.base.Predicate<? super E>)"""
        return bool._wrap(super(_FluentIterable, self).anyMatch(predicate))

    @overload
    def isEmpty(self) -> bool:
        """public final boolean com.google.common.collect.FluentIterable.isEmpty()"""
        return bool._wrap(super(FluentIterable, self).isEmpty())

    @staticmethod
    @overload
    def of(element: object, *elements: object) -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.of(E,E...)"""
        return FluentIterable._wrap(_FluentIterable.of(element, elements))

    @overload
    def last(self) -> 'base.Optional':
        """public final com.google.common.base.Optional<E> com.google.common.collect.FluentIterable.last()"""
        return 'base.Optional'._wrap(super(FluentIterable, self).last())

    @overload
    def cycle(self) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.cycle()"""
        return 'FluentIterable'._wrap(super(FluentIterable, self).cycle())

    @overload
    def toList(self) -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<E> com.google.common.collect.FluentIterable.toList()"""
        return 'ImmutableList'._wrap(super(FluentIterable, self).toList())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def filter(self, predicate: 'Predicate') -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.filter(com.google.common.base.Predicate<? super E>)"""
        return 'FluentIterable'._wrap(super(_FluentIterable, self).filter(predicate))

    @overload
    def filter(self, type: 'Class') -> 'FluentIterable':
        """public final <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.filter(java.lang.Class<T>)"""
        return 'FluentIterable'._wrap(super(_FluentIterable, self).filter(type))

    @overload
    def uniqueIndex(self, keyFunction: 'Function') -> 'ImmutableMap':
        """public final <K> com.google.common.collect.ImmutableMap<K, E> com.google.common.collect.FluentIterable.uniqueIndex(com.google.common.base.Function<? super E, K>)"""
        return 'ImmutableMap'._wrap(super(_FluentIterable, self).uniqueIndex(keyFunction))

    @overload
    def size(self) -> int:
        """public final int com.google.common.collect.FluentIterable.size()"""
        return int._wrap(super(FluentIterable, self).size())

    @overload
    def allMatch(self, predicate: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.FluentIterable.allMatch(com.google.common.base.Predicate<? super E>)"""
        return bool._wrap(super(_FluentIterable, self).allMatch(predicate))

    @overload
    def stream(self) -> 'Stream':
        """public final java.util.stream.Stream<E> com.google.common.collect.FluentIterable.stream()"""
        return 'Stream'._wrap(super(FluentIterable, self).stream())

    @overload
    def transform(self, function: 'Function') -> 'FluentIterable':
        """public final <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.transform(com.google.common.base.Function<? super E, T>)"""
        return 'FluentIterable'._wrap(super(_FluentIterable, self).transform(function))

    @overload
    def index(self, keyFunction: 'Function') -> 'ImmutableListMultimap':
        """public final <K> com.google.common.collect.ImmutableListMultimap<K, E> com.google.common.collect.FluentIterable.index(com.google.common.base.Function<? super E, K>)"""
        return 'ImmutableListMultimap'._wrap(super(_FluentIterable, self).index(keyFunction))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return FluentIterable._wrap(_FluentIterable.concat(a, b))

    @staticmethod
    @overload
    def from(iterable: 'Iterable') -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.from(java.lang.Iterable<E>)"""
        return FluentIterable._wrap(_FluentIterable.from(iterable))

    @overload
    def toMultiset(self) -> 'ImmutableMultiset':
        """public final com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.FluentIterable.toMultiset()"""
        return 'ImmutableMultiset'._wrap(super(FluentIterable, self).toMultiset())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def join(self, joiner: 'Joiner') -> str:
        """public final java.lang.String com.google.common.collect.FluentIterable.join(com.google.common.base.Joiner)"""
        return str._wrap(super(_FluentIterable, self).join(joiner))

    @overload
    def toArray(self, type: 'Class') -> List[object]:
        """public final E[] com.google.common.collect.FluentIterable.toArray(java.lang.Class<E>)"""
        return List[object]._wrap(super(_FluentIterable, self).toArray(type))

    @overload
    def transformAndConcat(self, function: 'Function') -> 'FluentIterable':
        """public <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.transformAndConcat(com.google.common.base.Function<? super E, ? extends java.lang.Iterable<? extends T>>)"""
        return 'FluentIterable'._wrap(super(_FluentIterable, self).transformAndConcat(function))

    @staticmethod
    @overload
    def concat(*inputs: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends T>...)"""
        return FluentIterable._wrap(_FluentIterable.concat(inputs))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def from(iterable: 'FluentIterable') -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.from(com.google.common.collect.FluentIterable<E>)"""
        return FluentIterable._wrap(_FluentIterable.from(iterable))

    @overload
    def copyInto(self, collection: 'Collection') -> 'Collection':
        """public final <C extends java.util.Collection<? super E>> C com.google.common.collect.FluentIterable.copyInto(C)"""
        return 'Collection'._wrap(super(_FluentIterable, self).copyInto(collection))

    @overload
    def toSet(self) -> 'ImmutableSet':
        """public final com.google.common.collect.ImmutableSet<E> com.google.common.collect.FluentIterable.toSet()"""
        return 'ImmutableSet'._wrap(super(FluentIterable, self).toSet())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def limit(self, maxSize: int) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.limit(int)"""
        return 'FluentIterable'._wrap(super(_FluentIterable, self).limit(_int.valueOf(maxSize))) 
 
 
# CLASS: com.google.common.collect.ImmutableMap$Builder
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.ImmutableMap as _ImmutableMap_Builder
_Builder = _ImmutableMap_Builder.Builder
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Integer as _int
import com.google.common.collect.ImmutableMap as _ImmutableMap
_ImmutableMap = _ImmutableMap
import java.util.Map as Map
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableMap.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, map: 'Map') -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.putAll(java.util.Map<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(map))

    @overload
    def orderEntriesByValue(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.orderEntriesByValue(java.util.Comparator<? super V>)"""
        return 'Builder'._wrap(super(_Builder, self).orderEntriesByValue(valueComparator))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.put(K,V)"""
        return 'Builder'._wrap(super(_Builder, self).put(key, value))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(entries))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableMap$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @overload
    def buildOrThrow(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap$Builder.buildOrThrow()"""
        return 'ImmutableMap'._wrap(super(Builder, self).buildOrThrow())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def buildKeepingLast(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap$Builder.buildKeepingLast()"""
        return 'ImmutableMap'._wrap(super(Builder, self).buildKeepingLast())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).put(entry))

    @overload
    def build(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap$Builder.build()"""
        return 'ImmutableMap'._wrap(super(Builder, self).build())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode())

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableMap$Builder()"""
        val = _Builder()
        self.__wrapper = val 
 
 
# CLASS: com.google.common.collect.TreeMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import com.google.common.collect.TreeMultiset as _TreeMultiset
_TreeMultiset = _TreeMultiset
import java.util.Spliterator as Spliterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import com.google.common.collect.AbstractMultiset as _AbstractMultiset
_AbstractMultiset = _AbstractMultiset
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.SortedMultiset as _SortedMultiset
_SortedMultiset = _SortedMultiset
import java.lang.Long as _long
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
import java.lang.Class as _Class
_Class = _Class
 
class TreeMultiset():
    """com.google.common.collect.TreeMultiset"""
 
    @staticmethod
    def _wrap(java_value: _TreeMultiset) -> 'TreeMultiset':
        return TreeMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _TreeMultiset):
        """
        Dynamic initializer for TreeMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_TreeMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_TreeMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def tailMultiset(self, lowerBound: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.TreeMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'._wrap(super(_TreeMultiset, self).tailMultiset(lowerBound, boundType))

    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.TreeMultiset.add(E,int)"""
        return int._wrap(super(_TreeMultiset, self).add(element, _int.valueOf(occurrences)))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def create(comparator: 'Comparator') -> 'TreeMultiset':
        """public static <E> com.google.common.collect.TreeMultiset<E> com.google.common.collect.TreeMultiset.create(java.util.Comparator<? super E>)"""
        return TreeMultiset._wrap(_TreeMultiset.create(comparator))

    @overload
    def headMultiset(self, upperBound: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.TreeMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'._wrap(super(_TreeMultiset, self).headMultiset(upperBound, boundType))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str._wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.TreeMultiset.remove(java.lang.Object,int)"""
        return int._wrap(super(_TreeMultiset, self).remove(element, _int.valueOf(occurrences)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public void com.google.common.collect.TreeMultiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_TreeMultiset, self).forEachEntry(action)

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).equals(object))

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).remove(element))

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'TreeMultiset':
        """public static <E extends java.lang.Comparable> com.google.common.collect.TreeMultiset<E> com.google.common.collect.TreeMultiset.create(java.lang.Iterable<? extends E>)"""
        return TreeMultiset._wrap(_TreeMultiset.create(elements))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.TreeMultiset.setCount(E,int,int)"""
        return bool._wrap(super(_TreeMultiset, self).setCount(element, _int.valueOf(oldCount), _int.valueOf(newCount)))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.TreeMultiset.clear()"""
        super(TreeMultiset, self).clear()

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.TreeMultiset.setCount(E,int)"""
        return int._wrap(super(_TreeMultiset, self).setCount(element, _int.valueOf(count)))

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.TreeMultiset.count(java.lang.Object)"""
        return int._wrap(super(_TreeMultiset, self).count(element))

    @staticmethod
    @overload
    def create() -> 'TreeMultiset':
        """public static <E extends java.lang.Comparable> com.google.common.collect.TreeMultiset<E> com.google.common.collect.TreeMultiset.create()"""
        return TreeMultiset._wrap(_TreeMultiset.create())

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool._wrap(super(_AbstractMultiset, self).add(element))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.TreeMultiset.iterator()"""
        return 'Iterator'._wrap(super(TreeMultiset, self).iterator())

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.TreeMultiset.size()"""
        return int._wrap(super(TreeMultiset, self).size())

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int._wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).retainAll(elementsToRetain)) 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMap$StandardKeySet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.ForwardingSortedMap as _ForwardingSortedMap_StandardKeySet
_StandardKeySet = _ForwardingSortedMap_StandardKeySet.StandardKeySet
import java.util.function.IntFunction as IntFunction
import com.google.common.collect.Maps as _Maps_SortedKeySet
_SortedKeySet = _Maps_SortedKeySet.SortedKeySet
import java.lang.Object as _object
import java.util.AbstractSet as _AbstractSet
_AbstractSet = _AbstractSet
import com.google.common.collect.Sets as _Sets_ImprovedAbstractSet
_ImprovedAbstractSet = _Sets_ImprovedAbstractSet.ImprovedAbstractSet
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.Maps as _Maps_KeySet
_KeySet = _Maps_KeySet.KeySet
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardKeySet():
    """com.google.common.collect.ForwardingSortedMap.StandardKeySet"""
 
    @staticmethod
    def _wrap(java_value: _StandardKeySet) -> 'StandardKeySet':
        return StandardKeySet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardKeySet):
        """
        Dynamic initializer for StandardKeySet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardKeySet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardKeySet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.SortedSet.removeFirst()"""
        return object._wrap(super(SortedSet, self).removeFirst())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$KeySet.clear()"""
        super(KeySet, self).clear()

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int._wrap(super(AbstractSet, self).hashCode())

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.contains(java.lang.Object)"""
        return bool._wrap(super(_KeySet, self).contains(o))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$SortedKeySet.headSet(K)"""
        return 'SortedSet'._wrap(super(_SortedKeySet, self).headSet(toElement))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$KeySet.size()"""
        return int._wrap(super(KeySet, self).size())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.google.common.collect.Maps$KeySet.iterator()"""
        return 'Iterator'._wrap(super(KeySet, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractSet, self).equals(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.isEmpty()"""
        return bool._wrap(super(KeySet, self).isEmpty())

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def first(self) -> object:
        """public K com.google.common.collect.Maps$SortedKeySet.first()"""
        return object._wrap(super(SortedKeySet, self).first())

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$SortedKeySet.tailSet(K)"""
        return 'SortedSet'._wrap(super(_SortedKeySet, self).tailSet(fromElement))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public void com.google.common.collect.Maps$KeySet.forEach(java.util.function.Consumer<? super K>)"""
        super(_KeySet, self).forEach(action)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @overload
    def __init__(self, this$0: 'ForwardingSortedMap'):
        """public com.google.common.collect.ForwardingSortedMap$StandardKeySet(com.google.common.collect.ForwardingSortedMap)"""
        val = _StandardKeySet(this$0)
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool._wrap(super(_AbstractCollection, self).add(arg0))

    @override
    @overload
    def last(self) -> object:
        """public K com.google.common.collect.Maps$SortedKeySet.last()"""
        return object._wrap(super(SortedKeySet, self).last())

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.remove(java.lang.Object)"""
        return bool._wrap(super(_KeySet, self).remove(o))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(SortedSet, self).spliterator())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.SortedSet.removeLast()"""
        return object._wrap(super(SortedSet, self).removeLast())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def reversed(self) -> 'SortedSet':
        """public default java.util.SortedSet<E> java.util.SortedSet.reversed()"""
        return 'SortedSet'._wrap(super(SortedSet, self).reversed())

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$SortedKeySet.subSet(K,K)"""
        return 'SortedSet'._wrap(super(_SortedKeySet, self).subSet(fromElement, toElement))

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.Maps$SortedKeySet.comparator()"""
        return 'Comparator'._wrap(super(SortedKeySet, self).comparator()) 
 
 
# CLASS: com.google.common.collect.ListMultimap
import com.google.common.collect.ListMultimap as _ListMultimap
_ListMultimap = _ListMultimap
from pyquantum_helper import override
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
 
class ListMultimap():
    """com.google.common.collect.ListMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ListMultimap) -> 'ListMultimap':
        return ListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ListMultimap):
        """
        Dynamic initializer for ListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ListMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ListMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def keys(self, ):
        """public abstract com.google.common.collect.Multiset<K> com.google.common.collect.Multimap.keys()"""
        pass

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @abstractmethod
    def removeAll(self, key: object):
        """public abstract java.util.List<V> com.google.common.collect.ListMultimap.removeAll(java.lang.Object)"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Multimap.isEmpty()"""
        pass

    @abstractmethod
    def asMap(self, ):
        """public abstract java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ListMultimap.asMap()"""
        pass

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> com.google.common.collect.Multimap.keySet()"""
        pass

    @abstractmethod
    def get(self, key: object):
        """public abstract java.util.List<V> com.google.common.collect.ListMultimap.get(K)"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.put(K,V)"""
        pass

    @abstractmethod
    def entries(self, ):
        """public abstract java.util.Collection<java.util.Map$Entry<K, V>> com.google.common.collect.Multimap.entries()"""
        pass

    @abstractmethod
    def containsEntry(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def replaceValues(self, key: object, values: 'Iterable'):
        """public abstract java.util.List<V> com.google.common.collect.ListMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def remove(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def containsKey(self, key: object):
        """public abstract boolean com.google.common.collect.Multimap.containsKey(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.values()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multimap.hashCode()"""
        pass

    @abstractmethod
    def putAll(self, key: object, values: 'Iterable'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.ListMultimap.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Multimap.clear()"""
        pass

    @abstractmethod
    def putAll(self, multimap: 'Multimap'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multimap.size()"""
        pass 
 
 
# CLASS: com.google.common.collect.ImmutableCollection
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
from typing import List
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableCollection():
    """com.google.common.collect.ImmutableCollection"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableCollection) -> 'ImmutableCollection':
        return ImmutableCollection(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableCollection):
        """
        Dynamic initializer for ImmutableCollection.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableCollection__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableCollection__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool._wrap(super(_ImmutableCollection, self).add(e))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ImmutableCollection, self).remove(object))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object]._wrap(super(_ImmutableCollection, self).toArray(other))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @overload
    def asList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableCollection.asList()"""
        return 'ImmutableList'._wrap(super(ImmutableCollection, self).asList())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @abstractmethod
    def contains(self, object: object):
        """public abstract boolean com.google.common.collect.ImmutableCollection.contains(java.lang.Object)"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object]._wrap(super(ImmutableCollection, self).toArray())

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableCollection.iterator()"""
        pass

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ImmutableCollection, self).addAll(newElements))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableCollection.spliterator()"""
        return 'Spliterator'._wrap(super(ImmutableCollection, self).spliterator())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeAll(oldElements))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.Multiset as _Multiset_Entry
_Entry = _Multiset_Entry.Entry
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import com.google.common.collect.ForwardingSortedMultiset as _ForwardingSortedMultiset
_ForwardingSortedMultiset = _ForwardingSortedMultiset
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import com.google.common.collect.ForwardingMultiset as _ForwardingMultiset
_ForwardingMultiset = _ForwardingMultiset
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.SortedMultiset as _SortedMultiset
_SortedMultiset = _SortedMultiset
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ForwardingSortedMultiset():
    """com.google.common.collect.ForwardingSortedMultiset"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingSortedMultiset) -> 'ForwardingSortedMultiset':
        return ForwardingSortedMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingSortedMultiset):
        """
        Dynamic initializer for ForwardingSortedMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingSortedMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingSortedMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ForwardingMultiset.entrySet()"""
        return 'Set'._wrap(super(ForwardingMultiset, self).entrySet())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultiset, self).equals(object))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def lastEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ForwardingSortedMultiset.lastEntry()"""
        return 'Entry'._wrap(super(ForwardingSortedMultiset, self).lastEntry())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ForwardingSortedMultiset.comparator()"""
        return 'Comparator'._wrap(super(ForwardingSortedMultiset, self).comparator())

    @overload
    def headMultiset(self, upperBound: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.ForwardingSortedMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'._wrap(super(_ForwardingSortedMultiset, self).headMultiset(upperBound, boundType))

    @override
    @overload
    def pollLastEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ForwardingSortedMultiset.pollLastEntry()"""
        return 'Entry'._wrap(super(ForwardingSortedMultiset, self).pollLastEntry())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.setCount(E,int,int)"""
        return bool._wrap(super(_ForwardingMultiset, self).setCount(element, _int.valueOf(oldCount), _int.valueOf(newCount)))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.add(E,int)"""
        return int._wrap(super(_ForwardingMultiset, self).add(element, _int.valueOf(occurrences)))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.setCount(E,int)"""
        return int._wrap(super(_ForwardingMultiset, self).setCount(element, _int.valueOf(count)))

    @override
    @overload
    def elementSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingSortedMultiset.elementSet()"""
        return 'NavigableSet'._wrap(super(ForwardingSortedMultiset, self).elementSet())

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'._wrap(super(ForwardingCollection, self).iterator())

    @overload
    def subMultiset(self, lowerBound: object, lowerBoundType: 'BoundType', upperBound: object, upperBoundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.ForwardingSortedMultiset.subMultiset(E,com.google.common.collect.BoundType,E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'._wrap(super(_ForwardingSortedMultiset, self).subMultiset(lowerBound, lowerBoundType, upperBound, upperBoundType))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object]._wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ForwardingSortedMultiset.pollFirstEntry()"""
        return 'Entry'._wrap(super(ForwardingSortedMultiset, self).pollFirstEntry())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(_Multiset, self).forEachEntry(action)

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultiset.hashCode()"""
        return int._wrap(super(ForwardingMultiset, self).hashCode())

    @override
    @overload
    def firstEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ForwardingSortedMultiset.firstEntry()"""
        return 'Entry'._wrap(super(ForwardingSortedMultiset, self).firstEntry())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def descendingMultiset(self) -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.ForwardingSortedMultiset.descendingMultiset()"""
        return 'SortedMultiset'._wrap(super(ForwardingSortedMultiset, self).descendingMultiset())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingMultiset.count(java.lang.Object)"""
        return int._wrap(super(_ForwardingMultiset, self).count(element))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object]._wrap(super(_ForwardingCollection, self).toArray(array))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def tailMultiset(self, lowerBound: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.ForwardingSortedMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'._wrap(super(_ForwardingSortedMultiset, self).tailMultiset(lowerBound, boundType))

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.remove(java.lang.Object,int)"""
        return int._wrap(super(_ForwardingMultiset, self).remove(element, _int.valueOf(occurrences)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.UnmodifiableListIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.ListIterator as _ListIterator
_ListIterator = _ListIterator
import com.google.common.collect.UnmodifiableListIterator as _UnmodifiableListIterator
_UnmodifiableListIterator = _UnmodifiableListIterator
import com.google.common.collect.UnmodifiableIterator as _UnmodifiableIterator
_UnmodifiableIterator = _UnmodifiableIterator
import java.lang.String as _String
_String = _String
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.lang.Integer as _int
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class UnmodifiableListIterator():
    """com.google.common.collect.UnmodifiableListIterator"""
 
    @staticmethod
    def _wrap(java_value: _UnmodifiableListIterator) -> 'UnmodifiableListIterator':
        return UnmodifiableListIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _UnmodifiableListIterator):
        """
        Dynamic initializer for UnmodifiableListIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_UnmodifiableListIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_UnmodifiableListIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def nextIndex(self, ):
        """public abstract int java.util.ListIterator.nextIndex()"""
        pass

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @abstractmethod
    def previousIndex(self, ):
        """public abstract int java.util.ListIterator.previousIndex()"""
        pass

    @abstractmethod
    def previous(self, ):
        """public abstract E java.util.ListIterator.previous()"""
        pass

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @abstractmethod
    def next(self, ):
        """public abstract E java.util.ListIterator.next()"""
        pass

    @override
    @overload
    def remove(self):
        """public final void com.google.common.collect.UnmodifiableIterator.remove()"""
        super(UnmodifiableIterator, self).remove()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @abstractmethod
    def hasPrevious(self, ):
        """public abstract boolean java.util.ListIterator.hasPrevious()"""
        pass

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @abstractmethod
    def hasNext(self, ):
        """public abstract boolean java.util.ListIterator.hasNext()"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def set(self, e: object):
        """public final void com.google.common.collect.UnmodifiableListIterator.set(E)"""
        super(_UnmodifiableListIterator, self).set(e)

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def add(self, e: object):
        """public final void com.google.common.collect.UnmodifiableListIterator.add(E)"""
        super(_UnmodifiableListIterator, self).add(e)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.LinkedHashMultimap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import com.google.common.collect.LinkedHashMultimap as _LinkedHashMultimap
_LinkedHashMultimap = _LinkedHashMultimap
import java.lang.Integer as _int
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
 
class LinkedHashMultimap():
    """com.google.common.collect.LinkedHashMultimap"""
 
    @staticmethod
    def _wrap(java_value: _LinkedHashMultimap) -> 'LinkedHashMultimap':
        return LinkedHashMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _LinkedHashMultimap):
        """
        Dynamic initializer for LinkedHashMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_LinkedHashMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_LinkedHashMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'Set':
        """public java.util.Set<V> com.google.common.collect.LinkedHashMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'Set'._wrap(super(_LinkedHashMultimap, self).replaceValues(key, values))

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'LinkedHashMultimap':
        """public static <K,V> com.google.common.collect.LinkedHashMultimap<K, V> com.google.common.collect.LinkedHashMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return LinkedHashMultimap._wrap(_LinkedHashMultimap.create(multimap))

    @staticmethod
    @overload
    def create(expectedKeys: int, expectedValuesPerKey: int) -> 'LinkedHashMultimap':
        """public static <K,V> com.google.common.collect.LinkedHashMultimap<K, V> com.google.common.collect.LinkedHashMultimap.create(int,int)"""
        return LinkedHashMultimap._wrap(_LinkedHashMultimap.create(_int.valueOf(expectedKeys), _int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.LinkedHashMultimap.keySet()"""
        return 'Set'._wrap(super(LinkedHashMultimap, self).keySet())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.LinkedHashMultimap.values()"""
        return 'Collection'._wrap(super(LinkedHashMultimap, self).values())

    @staticmethod
    @overload
    def create() -> 'LinkedHashMultimap':
        """public static <K,V> com.google.common.collect.LinkedHashMultimap<K, V> com.google.common.collect.LinkedHashMultimap.create()"""
        return LinkedHashMultimap._wrap(_LinkedHashMultimap.create())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.LinkedHashMultimap.clear()"""
        super(LinkedHashMultimap, self).clear()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def entries(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.LinkedHashMultimap.entries()"""
        return 'Set'._wrap(super(LinkedHashMultimap, self).entries()) 
 
 
# CLASS: com.google.common.collect.ImmutableTable$Builder
import com.google.common.collect.ImmutableTable as _ImmutableTable
_ImmutableTable = _ImmutableTable
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.ImmutableTable as _ImmutableTable_Builder
_Builder = _ImmutableTable_Builder.Builder
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableTable.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def orderColumnsBy(self, columnComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.orderColumnsBy(java.util.Comparator<? super C>)"""
        return 'Builder'._wrap(super(_Builder, self).orderColumnsBy(columnComparator))

    @overload
    def put(self, cell: 'Cell') -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.put(com.google.common.collect.Table$Cell<? extends R, ? extends C, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).put(cell))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableTable$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def buildOrThrow(self) -> 'ImmutableTable':
        """public com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable$Builder.buildOrThrow()"""
        return 'ImmutableTable'._wrap(super(Builder, self).buildOrThrow())

    @overload
    def putAll(self, table: 'Table') -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        return 'Builder'._wrap(super(_Builder, self).putAll(table))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @overload
    def put(self, rowKey: object, columnKey: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.put(R,C,V)"""
        return 'Builder'._wrap(super(_Builder, self).put(rowKey, columnKey, value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableTable$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def orderRowsBy(self, rowComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.orderRowsBy(java.util.Comparator<? super R>)"""
        return 'Builder'._wrap(super(_Builder, self).orderRowsBy(rowComparator))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def build(self) -> 'ImmutableTable':
        """public com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable$Builder.build()"""
        return 'ImmutableTable'._wrap(super(Builder, self).build())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Streams
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.stream.DoubleStream as _DoubleStream
_DoubleStream = _DoubleStream
import java.util.stream.IntStream as _IntStream
_IntStream = _IntStream
import java.util.OptionalInt as OptionalInt
import java.util.stream.LongStream as LongStream
import java.util.Optional as _Optional
_Optional = _Optional
import java.util.stream.DoubleStream as DoubleStream
import java.util.OptionalLong as _OptionalLong
_OptionalLong = _OptionalLong
import java.util.stream.IntStream as IntStream
import java.util.OptionalInt as _OptionalInt
_OptionalInt = _OptionalInt
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import com.google.common.collect.Streams as _Streams
_Streams = _Streams
import java.util.Iterator as Iterator
import java.util.OptionalDouble as _OptionalDouble
_OptionalDouble = _OptionalDouble
import java.util.stream.LongStream as _LongStream
_LongStream = _LongStream
import java.util.OptionalLong as OptionalLong
import java.util.OptionalDouble as OptionalDouble
import java.util.function.BiConsumer as BiConsumer
import java.lang.Integer as _int
import java.util.Optional as Optional
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Streams():
    """com.google.common.collect.Streams"""
 
    @staticmethod
    def _wrap(java_value: _Streams) -> 'Streams':
        return Streams(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Streams):
        """
        Dynamic initializer for Streams.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Streams__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Streams__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def findLast(stream: 'Stream') -> 'Optional':
        """public static <T> java.util.Optional<T> com.google.common.collect.Streams.findLast(java.util.stream.Stream<T>)"""
        return Optional._wrap(_Streams.findLast(stream))

    @staticmethod
    @overload
    def forEachPair(streamA: 'Stream', streamB: 'Stream', consumer: 'BiConsumer'):
        """public static <A,B> void com.google.common.collect.Streams.forEachPair(java.util.stream.Stream<A>,java.util.stream.Stream<B>,java.util.function.BiConsumer<? super A, ? super B>)"""
        _Streams.forEachPair(streamA, streamB, consumer)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def findLast(stream: 'LongStream') -> 'OptionalLong':
        """public static java.util.OptionalLong com.google.common.collect.Streams.findLast(java.util.stream.LongStream)"""
        return OptionalLong._wrap(_Streams.findLast(stream))

    @staticmethod
    @overload
    def findLast(stream: 'IntStream') -> 'OptionalInt':
        """public static java.util.OptionalInt com.google.common.collect.Streams.findLast(java.util.stream.IntStream)"""
        return OptionalInt._wrap(_Streams.findLast(stream))

    @staticmethod
    @overload
    def stream(optional: 'Optional') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(com.google.common.base.Optional<T>)"""
        return Stream._wrap(_Streams.stream(optional))

    @staticmethod
    @overload
    def concat(*streams: 'Stream') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.concat(java.util.stream.Stream<? extends T>...)"""
        return Stream._wrap(_Streams.concat(streams))

    @staticmethod
    @overload
    def concat(*streams: 'DoubleStream') -> 'DoubleStream':
        """public static java.util.stream.DoubleStream com.google.common.collect.Streams.concat(java.util.stream.DoubleStream...)"""
        return DoubleStream._wrap(_Streams.concat(streams))

    @staticmethod
    @overload
    def stream(optional: 'OptionalDouble') -> 'DoubleStream':
        """public static java.util.stream.DoubleStream com.google.common.collect.Streams.stream(java.util.OptionalDouble)"""
        return DoubleStream._wrap(_Streams.stream(optional))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def stream(optional: 'OptionalLong') -> 'LongStream':
        """public static java.util.stream.LongStream com.google.common.collect.Streams.stream(java.util.OptionalLong)"""
        return LongStream._wrap(_Streams.stream(optional))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def stream(iterable: 'Iterable') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(java.lang.Iterable<T>)"""
        return Stream._wrap(_Streams.stream(iterable))

    @staticmethod
    @overload
    def mapWithIndex(stream: 'DoubleStream', function: 'DoubleFunctionWithIndex') -> 'Stream':
        """public static <R> java.util.stream.Stream<R> com.google.common.collect.Streams.mapWithIndex(java.util.stream.DoubleStream,com.google.common.collect.Streams$DoubleFunctionWithIndex<R>)"""
        return Stream._wrap(_Streams.mapWithIndex(stream, function))

    @staticmethod
    @overload
    def mapWithIndex(stream: 'IntStream', function: 'IntFunctionWithIndex') -> 'Stream':
        """public static <R> java.util.stream.Stream<R> com.google.common.collect.Streams.mapWithIndex(java.util.stream.IntStream,com.google.common.collect.Streams$IntFunctionWithIndex<R>)"""
        return Stream._wrap(_Streams.mapWithIndex(stream, function))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def mapWithIndex(stream: 'LongStream', function: 'LongFunctionWithIndex') -> 'Stream':
        """public static <R> java.util.stream.Stream<R> com.google.common.collect.Streams.mapWithIndex(java.util.stream.LongStream,com.google.common.collect.Streams$LongFunctionWithIndex<R>)"""
        return Stream._wrap(_Streams.mapWithIndex(stream, function))

    @staticmethod
    @overload
    def findLast(stream: 'DoubleStream') -> 'OptionalDouble':
        """public static java.util.OptionalDouble com.google.common.collect.Streams.findLast(java.util.stream.DoubleStream)"""
        return OptionalDouble._wrap(_Streams.findLast(stream))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def stream(optional: 'Optional') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(java.util.Optional<T>)"""
        return Stream._wrap(_Streams.stream(optional))

    @staticmethod
    @overload
    def stream(collection: 'Collection') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(java.util.Collection<T>)"""
        return Stream._wrap(_Streams.stream(collection))

    @staticmethod
    @overload
    def zip(streamA: 'Stream', streamB: 'Stream', function: 'BiFunction') -> 'Stream':
        """public static <A,B,R> java.util.stream.Stream<R> com.google.common.collect.Streams.zip(java.util.stream.Stream<A>,java.util.stream.Stream<B>,java.util.function.BiFunction<? super A, ? super B, R>)"""
        return Stream._wrap(_Streams.zip(streamA, streamB, function))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def stream(optional: 'OptionalInt') -> 'IntStream':
        """public static java.util.stream.IntStream com.google.common.collect.Streams.stream(java.util.OptionalInt)"""
        return IntStream._wrap(_Streams.stream(optional))

    @staticmethod
    @overload
    def concat(*streams: 'IntStream') -> 'IntStream':
        """public static java.util.stream.IntStream com.google.common.collect.Streams.concat(java.util.stream.IntStream...)"""
        return IntStream._wrap(_Streams.concat(streams))

    @staticmethod
    @overload
    def stream(iterator: 'Iterator') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(java.util.Iterator<T>)"""
        return Stream._wrap(_Streams.stream(iterator))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def concat(*streams: 'LongStream') -> 'LongStream':
        """public static java.util.stream.LongStream com.google.common.collect.Streams.concat(java.util.stream.LongStream...)"""
        return LongStream._wrap(_Streams.concat(streams))

    @staticmethod
    @overload
    def mapWithIndex(stream: 'Stream', function: 'FunctionWithIndex') -> 'Stream':
        """public static <T,R> java.util.stream.Stream<R> com.google.common.collect.Streams.mapWithIndex(java.util.stream.Stream<T>,com.google.common.collect.Streams$FunctionWithIndex<? super T, ? extends R>)"""
        return Stream._wrap(_Streams.mapWithIndex(stream, function))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Multisets
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
import java.util.function.Supplier as Supplier
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
import com.google.common.collect.Multiset as _Multiset_Entry
_Entry = _Multiset_Entry.Entry
from builtins import type
import com.google.common.collect.Multisets as _Multisets
_Multisets = _Multisets
import java.lang.Iterable as Iterable
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.stream.Collector as _Collector
_Collector = _Collector
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset
_ImmutableMultiset = _ImmutableMultiset
import java.lang.Integer as _int
import java.util.function.ToIntFunction as ToIntFunction
import java.util.function.Function as Function
import com.google.common.collect.SortedMultiset as _SortedMultiset
_SortedMultiset = _SortedMultiset
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Multisets():
    """com.google.common.collect.Multisets"""
 
    @staticmethod
    def _wrap(java_value: _Multisets) -> 'Multisets':
        return Multisets(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Multisets):
        """
        Dynamic initializer for Multisets.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Multisets__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Multisets__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copyHighestCountFirst(multiset: 'Multiset') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.Multisets.copyHighestCountFirst(com.google.common.collect.Multiset<E>)"""
        return ImmutableMultiset._wrap(_Multisets.copyHighestCountFirst(multiset))

    @staticmethod
    @overload
    def toMultiset(elementFunction: 'Function', countFunction: 'ToIntFunction', multisetSupplier: 'Supplier') -> 'Collector':
        """public static <T,E,M extends com.google.common.collect.Multiset<E>> java.util.stream.Collector<T, ?, M> com.google.common.collect.Multisets.toMultiset(java.util.function.Function<? super T, E>,java.util.function.ToIntFunction<? super T>,java.util.function.Supplier<M>)"""
        return Collector._wrap(_Multisets.toMultiset(elementFunction, countFunction, multisetSupplier))

    @staticmethod
    @overload
    def filter(unfiltered: 'Multiset', predicate: 'Predicate') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.filter(com.google.common.collect.Multiset<E>,com.google.common.base.Predicate<? super E>)"""
        return Multiset._wrap(_Multisets.filter(unfiltered, predicate))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def immutableEntry(e: object, n: int) -> 'Entry':
        """public static <E> com.google.common.collect.Multiset$Entry<E> com.google.common.collect.Multisets.immutableEntry(E,int)"""
        return Entry._wrap(_Multisets.immutableEntry(e, _int.valueOf(n)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def removeOccurrences(multisetToModify: 'Multiset', occurrencesToRemove: 'Iterable') -> bool:
        """public static boolean com.google.common.collect.Multisets.removeOccurrences(com.google.common.collect.Multiset<?>,java.lang.Iterable<?>)"""
        return bool._wrap(_Multisets.removeOccurrences(multisetToModify, occurrencesToRemove))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def unmodifiableSortedMultiset(sortedMultiset: 'SortedMultiset') -> 'SortedMultiset':
        """public static <E> com.google.common.collect.SortedMultiset<E> com.google.common.collect.Multisets.unmodifiableSortedMultiset(com.google.common.collect.SortedMultiset<E>)"""
        return SortedMultiset._wrap(_Multisets.unmodifiableSortedMultiset(sortedMultiset))

    @staticmethod
    @overload
    def unmodifiableMultiset(multiset: 'ImmutableMultiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.unmodifiableMultiset(com.google.common.collect.ImmutableMultiset<E>)"""
        return Multiset._wrap(_Multisets.unmodifiableMultiset(multiset))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def removeOccurrences(multisetToModify: 'Multiset', occurrencesToRemove: 'Multiset') -> bool:
        """public static boolean com.google.common.collect.Multisets.removeOccurrences(com.google.common.collect.Multiset<?>,com.google.common.collect.Multiset<?>)"""
        return bool._wrap(_Multisets.removeOccurrences(multisetToModify, occurrencesToRemove))

    @staticmethod
    @overload
    def retainOccurrences(multisetToModify: 'Multiset', multisetToRetain: 'Multiset') -> bool:
        """public static boolean com.google.common.collect.Multisets.retainOccurrences(com.google.common.collect.Multiset<?>,com.google.common.collect.Multiset<?>)"""
        return bool._wrap(_Multisets.retainOccurrences(multisetToModify, multisetToRetain))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def sum(multiset1: 'Multiset', multiset2: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.sum(com.google.common.collect.Multiset<? extends E>,com.google.common.collect.Multiset<? extends E>)"""
        return Multiset._wrap(_Multisets.sum(multiset1, multiset2))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def containsOccurrences(superMultiset: 'Multiset', subMultiset: 'Multiset') -> bool:
        """public static boolean com.google.common.collect.Multisets.containsOccurrences(com.google.common.collect.Multiset<?>,com.google.common.collect.Multiset<?>)"""
        return bool._wrap(_Multisets.containsOccurrences(superMultiset, subMultiset))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def difference(multiset1: 'Multiset', multiset2: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.difference(com.google.common.collect.Multiset<E>,com.google.common.collect.Multiset<?>)"""
        return Multiset._wrap(_Multisets.difference(multiset1, multiset2))

    @staticmethod
    @overload
    def union(multiset1: 'Multiset', multiset2: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.union(com.google.common.collect.Multiset<? extends E>,com.google.common.collect.Multiset<? extends E>)"""
        return Multiset._wrap(_Multisets.union(multiset1, multiset2))

    @staticmethod
    @overload
    def intersection(multiset1: 'Multiset', multiset2: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.intersection(com.google.common.collect.Multiset<E>,com.google.common.collect.Multiset<?>)"""
        return Multiset._wrap(_Multisets.intersection(multiset1, multiset2))

    @staticmethod
    @overload
    def unmodifiableMultiset(multiset: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.unmodifiableMultiset(com.google.common.collect.Multiset<? extends E>)"""
        return Multiset._wrap(_Multisets.unmodifiableMultiset(multiset))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.PeekingIterator
from pyquantum_helper import override
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from abc import abstractmethod, ABC
import com.google.common.collect.PeekingIterator as _PeekingIterator
_PeekingIterator = _PeekingIterator
import java.util.function.Consumer as Consumer
 
class PeekingIterator():
    """com.google.common.collect.PeekingIterator"""
 
    @staticmethod
    def _wrap(java_value: _PeekingIterator) -> 'PeekingIterator':
        return PeekingIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _PeekingIterator):
        """
        Dynamic initializer for PeekingIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_PeekingIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_PeekingIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @abstractmethod
    def next(self, ):
        """public abstract E com.google.common.collect.PeekingIterator.next()"""
        pass

    @abstractmethod
    def peek(self, ):
        """public abstract E com.google.common.collect.PeekingIterator.peek()"""
        pass

    @abstractmethod
    def remove(self, ):
        """public abstract void com.google.common.collect.PeekingIterator.remove()"""
        pass

    @abstractmethod
    def hasNext(self, ):
        """public abstract boolean java.util.Iterator.hasNext()"""
        pass 
 
 
# CLASS: com.google.common.collect.ClassToInstanceMap
import com.google.common.collect.ClassToInstanceMap as _ClassToInstanceMap
_ClassToInstanceMap = _ClassToInstanceMap
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import java.util.Map as _Map
_Map = _Map
from abc import abstractmethod, ABC
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.function.BiConsumer as BiConsumer
import java.util.function.Function as Function
from builtins import bool
import java.util.Map as Map
 
class ClassToInstanceMap():
    """com.google.common.collect.ClassToInstanceMap"""
 
    @staticmethod
    def _wrap(java_value: _ClassToInstanceMap) -> 'ClassToInstanceMap':
        return ClassToInstanceMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ClassToInstanceMap):
        """
        Dynamic initializer for ClassToInstanceMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ClassToInstanceMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ClassToInstanceMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean java.util.Map.isEmpty()"""
        pass

    @abstractmethod
    def putAll(self, arg0: 'Map'):
        """public abstract void java.util.Map.putAll(java.util.Map<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def put(self, arg0: object, arg1: object):
        """public abstract V java.util.Map.put(K,V)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void java.util.Map.clear()"""
        pass

    @abstractmethod
    def get(self, arg0: object):
        """public abstract V java.util.Map.get(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, arg0: object):
        """public abstract boolean java.util.Map.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def remove(self, arg0: object):
        """public abstract V java.util.Map.remove(java.lang.Object)"""
        pass

    @abstractmethod
    def putInstance(self, type: 'Class', value: object):
        """public abstract <T extends B> T com.google.common.collect.ClassToInstanceMap.putInstance(java.lang.Class<T>,T)"""
        pass

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @abstractmethod
    def getInstance(self, type: 'Class'):
        """public abstract <T extends B> T com.google.common.collect.ClassToInstanceMap.getInstance(java.lang.Class<T>)"""
        pass

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_Map, self).replaceAll(arg0)

    @abstractmethod
    def containsKey(self, arg0: object):
        """public abstract boolean java.util.Map.containsKey(java.lang.Object)"""
        pass

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> java.util.Map.keySet()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int java.util.Map.hashCode()"""
        pass

    @abstractmethod
    def entrySet(self, ):
        """public abstract java.util.Set<java.util.Map$Entry<K, V>> java.util.Map.entrySet()"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.Map.size()"""
        pass

    @abstractmethod
    def equals(self, arg0: object):
        """public abstract boolean java.util.Map.equals(java.lang.Object)"""
        pass

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> java.util.Map.values()"""
        pass

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.Interners
from pyquantum_helper import import_once as _import_once
import com.google.common.collect.Interners as _Interners_InternerBuilder
_InternerBuilder = _Interners_InternerBuilder.InternerBuilder
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.String as _String
_String = _String
import com.google.common.collect.Interner as _Interner
_Interner = _Interner
import com.google.common.base.Function as _Function
_Function = _Function
import java.lang.Integer as _int
import com.google.common.collect.Interners as _Interners
_Interners = _Interners
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Interners():
    """com.google.common.collect.Interners"""
 
    @staticmethod
    def _wrap(java_value: _Interners) -> 'Interners':
        return Interners(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Interners):
        """
        Dynamic initializer for Interners.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Interners__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Interners__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def newWeakInterner() -> 'Interner':
        """public static <E> com.google.common.collect.Interner<E> com.google.common.collect.Interners.newWeakInterner()"""
        return Interner._wrap(_Interners.newWeakInterner())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def newStrongInterner() -> 'Interner':
        """public static <E> com.google.common.collect.Interner<E> com.google.common.collect.Interners.newStrongInterner()"""
        return Interner._wrap(_Interners.newStrongInterner())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def asFunction(interner: 'Interner') -> 'base.Function':
        """public static <E> com.google.common.base.Function<E, E> com.google.common.collect.Interners.asFunction(com.google.common.collect.Interner<E>)"""
        return base.Function._wrap(_Interners.asFunction(interner))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def newBuilder() -> 'InternerBuilder':
        """public static com.google.common.collect.Interners$InternerBuilder com.google.common.collect.Interners.newBuilder()"""
        return InternerBuilder._wrap(_Interners.newBuilder())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Sets
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.util.TreeSet as _TreeSet
_TreeSet = _TreeSet
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.TreeSet as TreeSet
import com.google.common.collect.Sets as _Sets_SetView
_SetView = _Sets_SetView.SetView
import java.util.Set as _Set
_Set = _Set
import java.util.EnumSet as _EnumSet
_EnumSet = _EnumSet
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from builtins import str
import java.util.NavigableSet as NavigableSet
from pyquantum_helper import override
import java.util.HashSet as HashSet
import java.lang.Object as _object
import java.util.LinkedHashSet as _LinkedHashSet
_LinkedHashSet = _LinkedHashSet
import java.lang.Iterable as Iterable
import java.util.concurrent.CopyOnWriteArraySet as CopyOnWriteArraySet
import java.util.SortedSet as SortedSet
from builtins import object
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.LinkedHashSet as LinkedHashSet
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.lang.Enum as Enum
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.lang.Integer as _int
import java.util.EnumSet as EnumSet
import java.util.concurrent.CopyOnWriteArraySet as _CopyOnWriteArraySet
_CopyOnWriteArraySet = _CopyOnWriteArraySet
import com.google.common.collect.Sets as _Sets
_Sets = _Sets
import java.util.HashSet as _HashSet
_HashSet = _HashSet
import java.util.Map as Map
import java.lang.Long as _long
import java.util.List as List
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Sets():
    """com.google.common.collect.Sets"""
 
    @staticmethod
    def _wrap(java_value: _Sets) -> 'Sets':
        return Sets(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Sets):
        """
        Dynamic initializer for Sets.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Sets__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Sets__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def newCopyOnWriteArraySet() -> 'CopyOnWriteArraySet':
        """public static <E> java.util.concurrent.CopyOnWriteArraySet<E> com.google.common.collect.Sets.newCopyOnWriteArraySet()"""
        return CopyOnWriteArraySet._wrap(_Sets.newCopyOnWriteArraySet())

    @staticmethod
    @overload
    def newSetFromMap(map: 'Map') -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.newSetFromMap(java.util.Map<E, java.lang.Boolean>)"""
        return Set._wrap(_Sets.newSetFromMap(map))

    @staticmethod
    @overload
    def newTreeSet() -> 'TreeSet':
        """public static <E extends java.lang.Comparable> java.util.TreeSet<E> com.google.common.collect.Sets.newTreeSet()"""
        return TreeSet._wrap(_Sets.newTreeSet())

    @staticmethod
    @overload
    def toImmutableEnumSet() -> 'Collector':
        """public static <E extends java.lang.Enum<E>> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSet<E>> com.google.common.collect.Sets.toImmutableEnumSet()"""
        return Collector._wrap(_Sets.toImmutableEnumSet())

    @staticmethod
    @overload
    def newLinkedHashSet() -> 'LinkedHashSet':
        """public static <E> java.util.LinkedHashSet<E> com.google.common.collect.Sets.newLinkedHashSet()"""
        return LinkedHashSet._wrap(_Sets.newLinkedHashSet())

    @staticmethod
    @overload
    def newConcurrentHashSet() -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.newConcurrentHashSet()"""
        return Set._wrap(_Sets.newConcurrentHashSet())

    @staticmethod
    @overload
    def symmetricDifference(set1: 'Set', set2: 'Set') -> 'SetView':
        """public static <E> com.google.common.collect.Sets$SetView<E> com.google.common.collect.Sets.symmetricDifference(java.util.Set<? extends E>,java.util.Set<? extends E>)"""
        return SetView._wrap(_Sets.symmetricDifference(set1, set2))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def combinations(set: 'Set', size: int) -> 'Set':
        """public static <E> java.util.Set<java.util.Set<E>> com.google.common.collect.Sets.combinations(java.util.Set<E>,int)"""
        return Set._wrap(_Sets.combinations(set, _int.valueOf(size)))

    @staticmethod
    @overload
    def newIdentityHashSet() -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.newIdentityHashSet()"""
        return Set._wrap(_Sets.newIdentityHashSet())

    @staticmethod
    @overload
    def complementOf(collection: 'Collection', type: 'Class') -> 'EnumSet':
        """public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> com.google.common.collect.Sets.complementOf(java.util.Collection<E>,java.lang.Class<E>)"""
        return EnumSet._wrap(_Sets.complementOf(collection, type))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def subSet(set: 'NavigableSet', range: 'Range') -> 'NavigableSet':
        """public static <K extends java.lang.Comparable<? super K>> java.util.NavigableSet<K> com.google.common.collect.Sets.subSet(java.util.NavigableSet<K>,com.google.common.collect.Range<K>)"""
        return NavigableSet._wrap(_Sets.subSet(set, range))

    @staticmethod
    @overload
    def cartesianProduct(sets: 'List') -> 'Set':
        """public static <B> java.util.Set<java.util.List<B>> com.google.common.collect.Sets.cartesianProduct(java.util.List<? extends java.util.Set<? extends B>>)"""
        return Set._wrap(_Sets.cartesianProduct(sets))

    @staticmethod
    @overload
    def immutableEnumSet(anElement: 'Enum', *otherElements: 'Enum') -> 'ImmutableSet':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.ImmutableSet<E> com.google.common.collect.Sets.immutableEnumSet(E,E...)"""
        return ImmutableSet._wrap(_Sets.immutableEnumSet(anElement, otherElements))

    @staticmethod
    @overload
    def newEnumSet(iterable: 'Iterable', elementType: 'Class') -> 'EnumSet':
        """public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> com.google.common.collect.Sets.newEnumSet(java.lang.Iterable<E>,java.lang.Class<E>)"""
        return EnumSet._wrap(_Sets.newEnumSet(iterable, elementType))

    @staticmethod
    @overload
    def union(set1: 'Set', set2: 'Set') -> 'SetView':
        """public static <E> com.google.common.collect.Sets$SetView<E> com.google.common.collect.Sets.union(java.util.Set<? extends E>,java.util.Set<? extends E>)"""
        return SetView._wrap(_Sets.union(set1, set2))

    @staticmethod
    @overload
    def newHashSet(elements: 'Iterator') -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSet(java.util.Iterator<? extends E>)"""
        return HashSet._wrap(_Sets.newHashSet(elements))

    @staticmethod
    @overload
    def newHashSet() -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSet()"""
        return HashSet._wrap(_Sets.newHashSet())

    @staticmethod
    @overload
    def newLinkedHashSetWithExpectedSize(expectedSize: int) -> 'LinkedHashSet':
        """public static <E> java.util.LinkedHashSet<E> com.google.common.collect.Sets.newLinkedHashSetWithExpectedSize(int)"""
        return LinkedHashSet._wrap(_Sets.newLinkedHashSetWithExpectedSize(_int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def newTreeSet(comparator: 'Comparator') -> 'TreeSet':
        """public static <E> java.util.TreeSet<E> com.google.common.collect.Sets.newTreeSet(java.util.Comparator<? super E>)"""
        return TreeSet._wrap(_Sets.newTreeSet(comparator))

    @staticmethod
    @overload
    def newLinkedHashSet(elements: 'Iterable') -> 'LinkedHashSet':
        """public static <E> java.util.LinkedHashSet<E> com.google.common.collect.Sets.newLinkedHashSet(java.lang.Iterable<? extends E>)"""
        return LinkedHashSet._wrap(_Sets.newLinkedHashSet(elements))

    @staticmethod
    @overload
    def filter(unfiltered: 'NavigableSet', predicate: 'Predicate') -> 'NavigableSet':
        """public static <E> java.util.NavigableSet<E> com.google.common.collect.Sets.filter(java.util.NavigableSet<E>,com.google.common.base.Predicate<? super E>)"""
        return NavigableSet._wrap(_Sets.filter(unfiltered, predicate))

    @staticmethod
    @overload
    def newCopyOnWriteArraySet(elements: 'Iterable') -> 'CopyOnWriteArraySet':
        """public static <E> java.util.concurrent.CopyOnWriteArraySet<E> com.google.common.collect.Sets.newCopyOnWriteArraySet(java.lang.Iterable<? extends E>)"""
        return CopyOnWriteArraySet._wrap(_Sets.newCopyOnWriteArraySet(elements))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def intersection(set1: 'Set', set2: 'Set') -> 'SetView':
        """public static <E> com.google.common.collect.Sets$SetView<E> com.google.common.collect.Sets.intersection(java.util.Set<E>,java.util.Set<?>)"""
        return SetView._wrap(_Sets.intersection(set1, set2))

    @staticmethod
    @overload
    def newHashSetWithExpectedSize(expectedSize: int) -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSetWithExpectedSize(int)"""
        return HashSet._wrap(_Sets.newHashSetWithExpectedSize(_int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def newHashSet(elements: 'Iterable') -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSet(java.lang.Iterable<? extends E>)"""
        return HashSet._wrap(_Sets.newHashSet(elements))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def unmodifiableNavigableSet(set: 'NavigableSet') -> 'NavigableSet':
        """public static <E> java.util.NavigableSet<E> com.google.common.collect.Sets.unmodifiableNavigableSet(java.util.NavigableSet<E>)"""
        return NavigableSet._wrap(_Sets.unmodifiableNavigableSet(set))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def complementOf(collection: 'Collection') -> 'EnumSet':
        """public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> com.google.common.collect.Sets.complementOf(java.util.Collection<E>)"""
        return EnumSet._wrap(_Sets.complementOf(collection))

    @staticmethod
    @overload
    def filter(unfiltered: 'SortedSet', predicate: 'Predicate') -> 'SortedSet':
        """public static <E> java.util.SortedSet<E> com.google.common.collect.Sets.filter(java.util.SortedSet<E>,com.google.common.base.Predicate<? super E>)"""
        return SortedSet._wrap(_Sets.filter(unfiltered, predicate))

    @staticmethod
    @overload
    def synchronizedNavigableSet(navigableSet: 'NavigableSet') -> 'NavigableSet':
        """public static <E> java.util.NavigableSet<E> com.google.common.collect.Sets.synchronizedNavigableSet(java.util.NavigableSet<E>)"""
        return NavigableSet._wrap(_Sets.synchronizedNavigableSet(navigableSet))

    @staticmethod
    @overload
    def immutableEnumSet(elements: 'Iterable') -> 'ImmutableSet':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.ImmutableSet<E> com.google.common.collect.Sets.immutableEnumSet(java.lang.Iterable<E>)"""
        return ImmutableSet._wrap(_Sets.immutableEnumSet(elements))

    @staticmethod
    @overload
    def newTreeSet(elements: 'Iterable') -> 'TreeSet':
        """public static <E extends java.lang.Comparable> java.util.TreeSet<E> com.google.common.collect.Sets.newTreeSet(java.lang.Iterable<? extends E>)"""
        return TreeSet._wrap(_Sets.newTreeSet(elements))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def newHashSet(*elements: object) -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSet(E...)"""
        return HashSet._wrap(_Sets.newHashSet(elements))

    @staticmethod
    @overload
    def newConcurrentHashSet(elements: 'Iterable') -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.newConcurrentHashSet(java.lang.Iterable<? extends E>)"""
        return Set._wrap(_Sets.newConcurrentHashSet(elements))

    @staticmethod
    @overload
    def difference(set1: 'Set', set2: 'Set') -> 'SetView':
        """public static <E> com.google.common.collect.Sets$SetView<E> com.google.common.collect.Sets.difference(java.util.Set<E>,java.util.Set<?>)"""
        return SetView._wrap(_Sets.difference(set1, set2))

    @staticmethod
    @overload
    def filter(unfiltered: 'Set', predicate: 'Predicate') -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.filter(java.util.Set<E>,com.google.common.base.Predicate<? super E>)"""
        return Set._wrap(_Sets.filter(unfiltered, predicate))

    @staticmethod
    @overload
    def powerSet(set: 'Set') -> 'Set':
        """public static <E> java.util.Set<java.util.Set<E>> com.google.common.collect.Sets.powerSet(java.util.Set<E>)"""
        return Set._wrap(_Sets.powerSet(set))

    @staticmethod
    @overload
    def cartesianProduct(*sets: 'Set') -> 'Set':
        """public static <B> java.util.Set<java.util.List<B>> com.google.common.collect.Sets.cartesianProduct(java.util.Set<? extends B>...)"""
        return Set._wrap(_Sets.cartesianProduct(sets))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Streams$IntFunctionWithIndex
import com.google.common.collect.Streams as _Streams_IntFunctionWithIndex
_IntFunctionWithIndex = _Streams_IntFunctionWithIndex.IntFunctionWithIndex
from abc import abstractmethod, ABC
 
class IntFunctionWithIndex():
    """com.google.common.collect.Streams.IntFunctionWithIndex"""
 
    @staticmethod
    def _wrap(java_value: _IntFunctionWithIndex) -> 'IntFunctionWithIndex':
        return IntFunctionWithIndex(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _IntFunctionWithIndex):
        """
        Dynamic initializer for IntFunctionWithIndex.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_IntFunctionWithIndex__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_IntFunctionWithIndex__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, from: int, index: int):
        """public abstract R com.google.common.collect.Streams$IntFunctionWithIndex.apply(int,long)"""
        pass 
 
 
# CLASS: com.google.common.collect.MapDifference
import com.google.common.collect.MapDifference as _MapDifference
_MapDifference = _MapDifference
from abc import abstractmethod, ABC
 
class MapDifference():
    """com.google.common.collect.MapDifference"""
 
    @staticmethod
    def _wrap(java_value: _MapDifference) -> 'MapDifference':
        return MapDifference(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _MapDifference):
        """
        Dynamic initializer for MapDifference.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_MapDifference__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_MapDifference__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def entriesDiffering(self, ):
        """public abstract java.util.Map<K, com.google.common.collect.MapDifference$ValueDifference<V>> com.google.common.collect.MapDifference.entriesDiffering()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.MapDifference.hashCode()"""
        pass

    @abstractmethod
    def entriesOnlyOnLeft(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesOnlyOnLeft()"""
        pass

    @abstractmethod
    def areEqual(self, ):
        """public abstract boolean com.google.common.collect.MapDifference.areEqual()"""
        pass

    @abstractmethod
    def entriesInCommon(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesInCommon()"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.MapDifference.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def entriesOnlyOnRight(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesOnlyOnRight()"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMap
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Map as _Map
_Map = _Map
import java.util.Collection as Collection
import java.util.SequencedSet as _SequencedSet
_SequencedSet = _SequencedSet
import java.util.Set as _Set
_Set = _Set
import java.util.SequencedCollection as SequencedCollection
import java.util.Map.Entry as Entry
import java.util.SortedMap as _SortedMap
_SortedMap = _SortedMap
import java.util.SortedMap as SortedMap
import java.util.SequencedSet as SequencedSet
from builtins import bool
import java.util.SequencedMap as _SequencedMap
_SequencedMap = _SequencedMap
from builtins import str
from pyquantum_helper import override
import java.util.SequencedCollection as _SequencedCollection
_SequencedCollection = _SequencedCollection
import java.lang.Object as _object
import com.google.common.collect.ForwardingSortedMap as _ForwardingSortedMap
_ForwardingSortedMap = _ForwardingSortedMap
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.Map as _Map_Entry
_Entry = _Map_Entry.Entry
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import java.util.function.Function as Function
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingSortedMap():
    """com.google.common.collect.ForwardingSortedMap"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingSortedMap) -> 'ForwardingSortedMap':
        return ForwardingSortedMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingSortedMap):
        """
        Dynamic initializer for ForwardingSortedMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingSortedMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingSortedMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @overload
    def putFirst(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putFirst(K,V)"""
        return object._wrap(super(_SortedMap, self).putFirst(arg0, arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @overload
    def subMap(self, fromKey: object, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.subMap(K,K)"""
        return 'SortedMap'._wrap(super(_ForwardingSortedMap, self).subMap(fromKey, toKey))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def sequencedKeySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<K> java.util.SequencedMap.sequencedKeySet()"""
        return 'SequencedSet'._wrap(super(SequencedMap, self).sequencedKeySet())

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(_ForwardingMap, self).putAll(map)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object._wrap(super(_ForwardingMap, self).put(key, value))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def pollLastEntry(self) -> 'Entry.Map$Entry':
        """public default java.util.Map$Entry<K, V> java.util.SequencedMap.pollLastEntry()"""
        return 'Entry.Map$Entry'._wrap(super(SequencedMap, self).pollLastEntry())

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry.Map$Entry':
        """public default java.util.Map$Entry<K, V> java.util.SequencedMap.pollFirstEntry()"""
        return 'Entry.Map$Entry'._wrap(super(SequencedMap, self).pollFirstEntry())

    @override
    @overload
    def firstKey(self) -> object:
        """public K com.google.common.collect.ForwardingSortedMap.firstKey()"""
        return object._wrap(super(ForwardingSortedMap, self).firstKey())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @override
    @overload
    def lastKey(self) -> object:
        """public K com.google.common.collect.ForwardingSortedMap.lastKey()"""
        return object._wrap(super(ForwardingSortedMap, self).lastKey())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsValue(value))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def firstEntry(self) -> 'Entry.Map$Entry':
        """public default java.util.Map$Entry<K, V> java.util.SequencedMap.firstEntry()"""
        return 'Entry.Map$Entry'._wrap(super(SequencedMap, self).firstEntry())

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.ForwardingSortedMap.comparator()"""
        return 'Comparator'._wrap(super(ForwardingSortedMap, self).comparator())

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).entrySet())

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(_Map, self).replaceAll(arg0)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def sequencedEntrySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<java.util.Map$Entry<K, V>> java.util.SequencedMap.sequencedEntrySet()"""
        return 'SequencedSet'._wrap(super(SequencedMap, self).sequencedEntrySet())

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'._wrap(super(ForwardingMap, self).keySet())

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'._wrap(super(ForwardingMap, self).values())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def headMap(self, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.headMap(K)"""
        return 'SortedMap'._wrap(super(_ForwardingSortedMap, self).headMap(toKey))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @overload
    def putLast(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putLast(K,V)"""
        return object._wrap(super(_SortedMap, self).putLast(arg0, arg1))

    @override
    @overload
    def lastEntry(self) -> 'Entry.Map$Entry':
        """public default java.util.Map$Entry<K, V> java.util.SequencedMap.lastEntry()"""
        return 'Entry.Map$Entry'._wrap(super(SequencedMap, self).lastEntry())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def reversed(self) -> 'SortedMap':
        """public default java.util.SortedMap<K, V> java.util.SortedMap.reversed()"""
        return 'SortedMap'._wrap(super(SortedMap, self).reversed())

    @overload
    def tailMap(self, fromKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.tailMap(K)"""
        return 'SortedMap'._wrap(super(_ForwardingSortedMap, self).tailMap(fromKey))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def sequencedValues(self) -> 'SequencedCollection':
        """public default java.util.SequencedCollection<V> java.util.SequencedMap.sequencedValues()"""
        return 'SequencedCollection'._wrap(super(SequencedMap, self).sequencedValues())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.LinkedHashMultiset
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
from builtins import bool
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
import com.google.common.collect.LinkedHashMultiset as _LinkedHashMultiset
_LinkedHashMultiset = _LinkedHashMultiset
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.lang.String as _String
_String = _String
from builtins import object
from typing import List
import com.google.common.collect.AbstractMultiset as _AbstractMultiset
_AbstractMultiset = _AbstractMultiset
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class LinkedHashMultiset():
    """com.google.common.collect.LinkedHashMultiset"""
 
    @staticmethod
    def _wrap(java_value: _LinkedHashMultiset) -> 'LinkedHashMultiset':
        return LinkedHashMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _LinkedHashMultiset):
        """
        Dynamic initializer for LinkedHashMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_LinkedHashMultiset__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_LinkedHashMultiset__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def create() -> 'LinkedHashMultiset':
        """public static <E> com.google.common.collect.LinkedHashMultiset<E> com.google.common.collect.LinkedHashMultiset.create()"""
        return LinkedHashMultiset._wrap(_LinkedHashMultiset.create())

    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str._wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'._wrap(super(Multiset, self).spliterator())

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).equals(object))

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool._wrap(super(_AbstractMultiset, self).remove(element))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool._wrap(super(_AbstractMultiset, self).add(element))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'LinkedHashMultiset':
        """public static <E> com.google.common.collect.LinkedHashMultiset<E> com.google.common.collect.LinkedHashMultiset.create(java.lang.Iterable<? extends E>)"""
        return LinkedHashMultiset._wrap(_LinkedHashMultiset.create(elements))

    @staticmethod
    @overload
    def create(distinctElements: int) -> 'LinkedHashMultiset':
        """public static <E> com.google.common.collect.LinkedHashMultiset<E> com.google.common.collect.LinkedHashMultiset.create(int)"""
        return LinkedHashMultiset._wrap(_LinkedHashMultiset.create(_int.valueOf(distinctElements)))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(_Multiset, self).forEach(action)

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int._wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractMultiset, self).retainAll(elementsToRetain)) 
 
 
# CLASS: com.google.common.collect.ForwardingListIterator
from builtins import str
import com.google.common.collect.ForwardingIterator as _ForwardingIterator
_ForwardingIterator = _ForwardingIterator
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.Consumer as Consumer
import java.lang.Integer as _int
import com.google.common.collect.ForwardingListIterator as _ForwardingListIterator
_ForwardingListIterator = _ForwardingListIterator
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingListIterator():
    """com.google.common.collect.ForwardingListIterator"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingListIterator) -> 'ForwardingListIterator':
        return ForwardingListIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingListIterator):
        """
        Dynamic initializer for ForwardingListIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingListIterator__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingListIterator__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def next(self) -> object:
        """public T com.google.common.collect.ForwardingIterator.next()"""
        return object._wrap(super(ForwardingIterator, self).next())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def previousIndex(self) -> int:
        """public int com.google.common.collect.ForwardingListIterator.previousIndex()"""
        return int._wrap(super(ForwardingListIterator, self).previousIndex())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def add(self, element: object):
        """public void com.google.common.collect.ForwardingListIterator.add(E)"""
        super(_ForwardingListIterator, self).add(element)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def nextIndex(self) -> int:
        """public int com.google.common.collect.ForwardingListIterator.nextIndex()"""
        return int._wrap(super(ForwardingListIterator, self).nextIndex())

    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.google.common.collect.ForwardingIterator.hasNext()"""
        return bool._wrap(super(ForwardingIterator, self).hasNext())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(_Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def set(self, element: object):
        """public void com.google.common.collect.ForwardingListIterator.set(E)"""
        super(_ForwardingListIterator, self).set(element)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def remove(self):
        """public void com.google.common.collect.ForwardingIterator.remove()"""
        super(ForwardingIterator, self).remove()

    @override
    @overload
    def previous(self) -> object:
        """public E com.google.common.collect.ForwardingListIterator.previous()"""
        return object._wrap(super(ForwardingListIterator, self).previous())

    @override
    @overload
    def hasPrevious(self) -> bool:
        """public boolean com.google.common.collect.ForwardingListIterator.hasPrevious()"""
        return bool._wrap(super(ForwardingListIterator, self).hasPrevious())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingSetMultimap
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
import com.google.common.collect.ForwardingMultimap as _ForwardingMultimap
_ForwardingMultimap = _ForwardingMultimap
from builtins import type
import java.util.Map as _Map
_Map = _Map
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
import java.lang.String as _String
_String = _String
import java.util.Set as _Set
_Set = _Set
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
from builtins import bool
import java.util.Map as Map
import com.google.common.collect.ForwardingSetMultimap as _ForwardingSetMultimap
_ForwardingSetMultimap = _ForwardingSetMultimap
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingSetMultimap():
    """com.google.common.collect.ForwardingSetMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingSetMultimap) -> 'ForwardingSetMultimap':
        return ForwardingSetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingSetMultimap):
        """
        Dynamic initializer for ForwardingSetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingSetMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingSetMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def asMap(self) -> 'Map':
        """public java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ForwardingMultimap.asMap()"""
        return 'Map'._wrap(super(ForwardingMultimap, self).asMap())

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool._wrap(super(_ForwardingMultimap, self).putAll(multimap))

    @override
    @overload
    def keys(self) -> 'Multiset':
        """public com.google.common.collect.Multiset<K> com.google.common.collect.ForwardingMultimap.keys()"""
        return 'Multiset'._wrap(super(ForwardingMultimap, self).keys())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.size()"""
        return int._wrap(super(ForwardingMultimap, self).size())

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool._wrap(super(_ForwardingMultimap, self).putAll(key, values))

    @overload
    def containsEntry(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsEntry(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsEntry(key, value))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.put(K,V)"""
        return bool._wrap(super(_ForwardingMultimap, self).put(key, value))

    @overload
    def removeAll(self, key: object) -> 'Set':
        """public java.util.Set<V> com.google.common.collect.ForwardingSetMultimap.removeAll(java.lang.Object)"""
        return 'Set'._wrap(super(_ForwardingSetMultimap, self).removeAll(key))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.values()"""
        return 'Collection'._wrap(super(ForwardingMultimap, self).values())

    @overload
    def __init__(self):
        """public com.google.common.collect.ForwardingSetMultimap()"""
        val = _ForwardingSetMultimap()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMultimap.clear()"""
        super(ForwardingMultimap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).equals(object))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMultimap.keySet()"""
        return 'Set'._wrap(super(ForwardingMultimap, self).keySet())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsKey(key))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).remove(key, value))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsValue(value))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'Set':
        """public java.util.Set<V> com.google.common.collect.ForwardingSetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'Set'._wrap(super(_ForwardingSetMultimap, self).replaceValues(key, values))

    @overload
    def get(self, key: object) -> 'Set':
        """public java.util.Set<V> com.google.common.collect.ForwardingSetMultimap.get(K)"""
        return 'Set'._wrap(super(_ForwardingSetMultimap, self).get(key))

    @override
    @overload
    def entries(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingSetMultimap.entries()"""
        return 'Set'._wrap(super(ForwardingSetMultimap, self).entries())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ForwardingSetMultimap()"""
        val = _ForwardingSetMultimap()
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.hashCode()"""
        return int._wrap(super(ForwardingMultimap, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.isEmpty()"""
        return bool._wrap(super(ForwardingMultimap, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.Multimaps
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.util.function.Supplier as Supplier
import com.google.common.collect.ListMultimap as _ListMultimap
_ListMultimap = _ListMultimap
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
from builtins import bool
import com.google.common.collect.Multimaps as _Multimaps
_Multimaps = _Multimaps
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.SortedSetMultimap as _SortedSetMultimap
_SortedSetMultimap = _SortedSetMultimap
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.lang.Integer as _int
import com.google.common.collect.SetMultimap as _SetMultimap
_SetMultimap = _SetMultimap
import java.util.function.Function as Function
import java.util.Map as Map
import java.lang.Long as _long
import com.google.common.collect.ImmutableListMultimap as _ImmutableListMultimap
_ImmutableListMultimap = _ImmutableListMultimap
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Multimaps():
    """com.google.common.collect.Multimaps"""
 
    @staticmethod
    def _wrap(java_value: _Multimaps) -> 'Multimaps':
        return Multimaps(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Multimaps):
        """
        Dynamic initializer for Multimaps.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Multimaps__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Multimaps__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def filterKeys(unfiltered: 'ListMultimap', keyPredicate: 'Predicate') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.filterKeys(com.google.common.collect.ListMultimap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return ListMultimap._wrap(_Multimaps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def index(values: 'Iterable', keyFunction: 'Function') -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.Multimaps.index(java.lang.Iterable<V>,com.google.common.base.Function<? super V, K>)"""
        return ImmutableListMultimap._wrap(_Multimaps.index(values, keyFunction))

    @staticmethod
    @overload
    def toMultimap(keyFunction: 'Function', valueFunction: 'Function', multimapSupplier: 'Supplier') -> 'Collector':
        """public static <T,K,V,M extends com.google.common.collect.Multimap<K, V>> java.util.stream.Collector<T, ?, M> com.google.common.collect.Multimaps.toMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.Supplier<M>)"""
        return Collector._wrap(_Multimaps.toMultimap(keyFunction, valueFunction, multimapSupplier))

    @staticmethod
    @overload
    def unmodifiableSetMultimap(delegate: 'ImmutableSetMultimap') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableSetMultimap(com.google.common.collect.ImmutableSetMultimap<K, V>)"""
        return SetMultimap._wrap(_Multimaps.unmodifiableSetMultimap(delegate))

    @staticmethod
    @overload
    def unmodifiableListMultimap(delegate: 'ImmutableListMultimap') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableListMultimap(com.google.common.collect.ImmutableListMultimap<K, V>)"""
        return ListMultimap._wrap(_Multimaps.unmodifiableListMultimap(delegate))

    @staticmethod
    @overload
    def asMap(multimap: 'SortedSetMultimap') -> 'Map':
        """public static <K,V> java.util.Map<K, java.util.SortedSet<V>> com.google.common.collect.Multimaps.asMap(com.google.common.collect.SortedSetMultimap<K, V>)"""
        return Map._wrap(_Multimaps.asMap(multimap))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'Multimap', valuePredicate: 'Predicate') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.filterValues(com.google.common.collect.Multimap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return Multimap._wrap(_Multimaps.filterValues(unfiltered, valuePredicate))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def asMap(multimap: 'Multimap') -> 'Map':
        """public static <K,V> java.util.Map<K, java.util.Collection<V>> com.google.common.collect.Multimaps.asMap(com.google.common.collect.Multimap<K, V>)"""
        return Map._wrap(_Multimaps.asMap(multimap))

    @staticmethod
    @overload
    def synchronizedMultimap(multimap: 'Multimap') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.synchronizedMultimap(com.google.common.collect.Multimap<K, V>)"""
        return Multimap._wrap(_Multimaps.synchronizedMultimap(multimap))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @staticmethod
    @overload
    def synchronizedSetMultimap(multimap: 'SetMultimap') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.synchronizedSetMultimap(com.google.common.collect.SetMultimap<K, V>)"""
        return SetMultimap._wrap(_Multimaps.synchronizedSetMultimap(multimap))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def asMap(multimap: 'ListMultimap') -> 'Map':
        """public static <K,V> java.util.Map<K, java.util.List<V>> com.google.common.collect.Multimaps.asMap(com.google.common.collect.ListMultimap<K, V>)"""
        return Map._wrap(_Multimaps.asMap(multimap))

    @staticmethod
    @overload
    def synchronizedSortedSetMultimap(multimap: 'SortedSetMultimap') -> 'SortedSetMultimap':
        """public static <K,V> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.Multimaps.synchronizedSortedSetMultimap(com.google.common.collect.SortedSetMultimap<K, V>)"""
        return SortedSetMultimap._wrap(_Multimaps.synchronizedSortedSetMultimap(multimap))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'ListMultimap', transformer: 'EntryTransformer') -> 'ListMultimap':
        """public static <K,V1,V2> com.google.common.collect.ListMultimap<K, V2> com.google.common.collect.Multimaps.transformEntries(com.google.common.collect.ListMultimap<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return ListMultimap._wrap(_Multimaps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'SetMultimap', valuePredicate: 'Predicate') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.filterValues(com.google.common.collect.SetMultimap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return SetMultimap._wrap(_Multimaps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def unmodifiableSortedSetMultimap(delegate: 'SortedSetMultimap') -> 'SortedSetMultimap':
        """public static <K,V> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableSortedSetMultimap(com.google.common.collect.SortedSetMultimap<K, V>)"""
        return SortedSetMultimap._wrap(_Multimaps.unmodifiableSortedSetMultimap(delegate))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'Multimap', entryPredicate: 'Predicate') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.filterEntries(com.google.common.collect.Multimap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return Multimap._wrap(_Multimaps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'Multimap', transformer: 'EntryTransformer') -> 'Multimap':
        """public static <K,V1,V2> com.google.common.collect.Multimap<K, V2> com.google.common.collect.Multimaps.transformEntries(com.google.common.collect.Multimap<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return Multimap._wrap(_Multimaps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def unmodifiableSetMultimap(delegate: 'SetMultimap') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableSetMultimap(com.google.common.collect.SetMultimap<K, V>)"""
        return SetMultimap._wrap(_Multimaps.unmodifiableSetMultimap(delegate))

    @staticmethod
    @overload
    def unmodifiableListMultimap(delegate: 'ListMultimap') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableListMultimap(com.google.common.collect.ListMultimap<K, V>)"""
        return ListMultimap._wrap(_Multimaps.unmodifiableListMultimap(delegate))

    @staticmethod
    @overload
    def unmodifiableMultimap(delegate: 'Multimap') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.unmodifiableMultimap(com.google.common.collect.Multimap<K, V>)"""
        return Multimap._wrap(_Multimaps.unmodifiableMultimap(delegate))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def newListMultimap(map: 'Map', factory: 'Supplier') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.newListMultimap(java.util.Map<K, java.util.Collection<V>>,com.google.common.base.Supplier<? extends java.util.List<V>>)"""
        return ListMultimap._wrap(_Multimaps.newListMultimap(map, factory))

    @staticmethod
    @overload
    def unmodifiableMultimap(delegate: 'ImmutableMultimap') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.unmodifiableMultimap(com.google.common.collect.ImmutableMultimap<K, V>)"""
        return Multimap._wrap(_Multimaps.unmodifiableMultimap(delegate))

    @staticmethod
    @overload
    def synchronizedListMultimap(multimap: 'ListMultimap') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.synchronizedListMultimap(com.google.common.collect.ListMultimap<K, V>)"""
        return ListMultimap._wrap(_Multimaps.synchronizedListMultimap(multimap))

    @staticmethod
    @overload
    def forMap(map: 'Map') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.forMap(java.util.Map<K, V>)"""
        return SetMultimap._wrap(_Multimaps.forMap(map))

    @staticmethod
    @overload
    def asMap(multimap: 'SetMultimap') -> 'Map':
        """public static <K,V> java.util.Map<K, java.util.Set<V>> com.google.common.collect.Multimaps.asMap(com.google.common.collect.SetMultimap<K, V>)"""
        return Map._wrap(_Multimaps.asMap(multimap))

    @staticmethod
    @overload
    def newSortedSetMultimap(map: 'Map', factory: 'Supplier') -> 'SortedSetMultimap':
        """public static <K,V> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.Multimaps.newSortedSetMultimap(java.util.Map<K, java.util.Collection<V>>,com.google.common.base.Supplier<? extends java.util.SortedSet<V>>)"""
        return SortedSetMultimap._wrap(_Multimaps.newSortedSetMultimap(map, factory))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def index(values: 'Iterator', keyFunction: 'Function') -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.Multimaps.index(java.util.Iterator<V>,com.google.common.base.Function<? super V, K>)"""
        return ImmutableListMultimap._wrap(_Multimaps.index(values, keyFunction))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'SetMultimap', keyPredicate: 'Predicate') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.filterKeys(com.google.common.collect.SetMultimap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return SetMultimap._wrap(_Multimaps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def newMultimap(map: 'Map', factory: 'Supplier') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.newMultimap(java.util.Map<K, java.util.Collection<V>>,com.google.common.base.Supplier<? extends java.util.Collection<V>>)"""
        return Multimap._wrap(_Multimaps.newMultimap(map, factory))

    @staticmethod
    @overload
    def invertFrom(source: 'Multimap', dest: 'Multimap') -> 'Multimap':
        """public static <K,V,M extends com.google.common.collect.Multimap<K, V>> M com.google.common.collect.Multimaps.invertFrom(com.google.common.collect.Multimap<? extends V, ? extends K>,M)"""
        return Multimap._wrap(_Multimaps.invertFrom(source, dest))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'Multimap', keyPredicate: 'Predicate') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.filterKeys(com.google.common.collect.Multimap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return Multimap._wrap(_Multimaps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def transformValues(fromMultimap: 'ListMultimap', function: 'Function') -> 'ListMultimap':
        """public static <K,V1,V2> com.google.common.collect.ListMultimap<K, V2> com.google.common.collect.Multimaps.transformValues(com.google.common.collect.ListMultimap<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return ListMultimap._wrap(_Multimaps.transformValues(fromMultimap, function))

    @staticmethod
    @overload
    def transformValues(fromMultimap: 'Multimap', function: 'Function') -> 'Multimap':
        """public static <K,V1,V2> com.google.common.collect.Multimap<K, V2> com.google.common.collect.Multimaps.transformValues(com.google.common.collect.Multimap<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return Multimap._wrap(_Multimaps.transformValues(fromMultimap, function))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def newSetMultimap(map: 'Map', factory: 'Supplier') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.newSetMultimap(java.util.Map<K, java.util.Collection<V>>,com.google.common.base.Supplier<? extends java.util.Set<V>>)"""
        return SetMultimap._wrap(_Multimaps.newSetMultimap(map, factory))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'SetMultimap', entryPredicate: 'Predicate') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.filterEntries(com.google.common.collect.SetMultimap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return SetMultimap._wrap(_Multimaps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def flatteningToMultimap(keyFunction: 'Function', valueFunction: 'Function', multimapSupplier: 'Supplier') -> 'Collector':
        """public static <T,K,V,M extends com.google.common.collect.Multimap<K, V>> java.util.stream.Collector<T, ?, M> com.google.common.collect.Multimaps.flatteningToMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends V>>,java.util.function.Supplier<M>)"""
        return Collector._wrap(_Multimaps.flatteningToMultimap(keyFunction, valueFunction, multimapSupplier))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableMap$StandardNavigableKeySet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.Maps as _Maps_NavigableKeySet
_NavigableKeySet = _Maps_NavigableKeySet.NavigableKeySet
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import com.google.common.collect.Maps as _Maps_SortedKeySet
_SortedKeySet = _Maps_SortedKeySet.SortedKeySet
import java.util.AbstractSet as _AbstractSet
_AbstractSet = _AbstractSet
import com.google.common.collect.Sets as _Sets_ImprovedAbstractSet
_ImprovedAbstractSet = _Sets_ImprovedAbstractSet.ImprovedAbstractSet
import com.google.common.collect.ForwardingNavigableMap as _ForwardingNavigableMap_StandardNavigableKeySet
_StandardNavigableKeySet = _ForwardingNavigableMap_StandardNavigableKeySet.StandardNavigableKeySet
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
from typing import List
import java.util.Comparator as Comparator
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.Maps as _Maps_KeySet
_KeySet = _Maps_KeySet.KeySet
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardNavigableKeySet():
    """com.google.common.collect.ForwardingNavigableMap.StandardNavigableKeySet"""
 
    @staticmethod
    def _wrap(java_value: _StandardNavigableKeySet) -> 'StandardNavigableKeySet':
        return StandardNavigableKeySet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardNavigableKeySet):
        """
        Dynamic initializer for StandardNavigableKeySet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardNavigableKeySet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardNavigableKeySet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$NavigableKeySet.headSet(K)"""
        return 'SortedSet'._wrap(super(_NavigableKeySet, self).headSet(toElement))

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int._wrap(super(AbstractSet, self).hashCode())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object._wrap(super(NavigableSet, self).removeLast())

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object._wrap(super(NavigableSet, self).removeFirst())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def pollLast(self) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.pollLast()"""
        return object._wrap(super(NavigableKeySet, self).pollLast())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$KeySet.size()"""
        return int._wrap(super(KeySet, self).size())

    @override
    @overload
    def pollFirst(self) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.pollFirst()"""
        return object._wrap(super(NavigableKeySet, self).pollFirst())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.google.common.collect.Maps$KeySet.iterator()"""
        return 'Iterator'._wrap(super(KeySet, self).iterator())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractSet, self).equals(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def first(self) -> object:
        """public K com.google.common.collect.Maps$SortedKeySet.first()"""
        return object._wrap(super(SortedKeySet, self).first())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public void com.google.common.collect.Maps$KeySet.forEach(java.util.function.Consumer<? super K>)"""
        super(_KeySet, self).forEach(action)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$NavigableKeySet.headSet(K,boolean)"""
        return 'NavigableSet'._wrap(super(_NavigableKeySet, self).headSet(toElement, _boolean.valueOf(inclusive)))

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool._wrap(super(_AbstractCollection, self).add(arg0))

    @override
    @overload
    def last(self) -> object:
        """public K com.google.common.collect.Maps$SortedKeySet.last()"""
        return object._wrap(super(SortedKeySet, self).last())

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.remove(java.lang.Object)"""
        return bool._wrap(super(_KeySet, self).remove(o))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(SortedSet, self).spliterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def lower(self, e: object) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.lower(K)"""
        return object._wrap(super(_NavigableKeySet, self).lower(e))

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$NavigableKeySet.tailSet(K)"""
        return 'SortedSet'._wrap(super(_NavigableKeySet, self).tailSet(fromElement))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$KeySet.clear()"""
        super(KeySet, self).clear()

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.contains(java.lang.Object)"""
        return bool._wrap(super(_KeySet, self).contains(o))

    @override
    @overload
    def descendingSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$NavigableKeySet.descendingSet()"""
        return 'NavigableSet'._wrap(super(NavigableKeySet, self).descendingSet())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @overload
    def higher(self, e: object) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.higher(K)"""
        return object._wrap(super(_NavigableKeySet, self).higher(e))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.isEmpty()"""
        return bool._wrap(super(KeySet, self).isEmpty())

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'._wrap(super(NavigableSet, self).reversed())

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$NavigableKeySet.tailSet(K,boolean)"""
        return 'NavigableSet'._wrap(super(_NavigableKeySet, self).tailSet(fromElement, _boolean.valueOf(inclusive)))

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.google.common.collect.Maps$NavigableKeySet.descendingIterator()"""
        return 'Iterator'._wrap(super(NavigableKeySet, self).descendingIterator())

    @overload
    def __init__(self, this$0: 'ForwardingNavigableMap'):
        """public com.google.common.collect.ForwardingNavigableMap$StandardNavigableKeySet(com.google.common.collect.ForwardingNavigableMap)"""
        val = _StandardNavigableKeySet(this$0)
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$NavigableKeySet.subSet(K,K)"""
        return 'SortedSet'._wrap(super(_NavigableKeySet, self).subSet(fromElement, toElement))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @overload
    def floor(self, e: object) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.floor(K)"""
        return object._wrap(super(_NavigableKeySet, self).floor(e))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$NavigableKeySet.subSet(K,boolean,K,boolean)"""
        return 'NavigableSet'._wrap(super(_NavigableKeySet, self).subSet(fromElement, _boolean.valueOf(fromInclusive), toElement, _boolean.valueOf(toInclusive)))

    @overload
    def ceiling(self, e: object) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.ceiling(K)"""
        return object._wrap(super(_NavigableKeySet, self).ceiling(e))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.Maps$SortedKeySet.comparator()"""
        return 'Comparator'._wrap(super(SortedKeySet, self).comparator()) 
 
 
# CLASS: com.google.common.collect.Range
from builtins import str
import java.util.function.Predicate as Predicate
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
import java.lang.String as _String
_String = _String
import java.lang.Comparable as Comparable
import com.google.common.base.Predicate as _Predicate
_Predicate = _Predicate
import java.util.function.Predicate as _Predicate
_Predicate = _Predicate
import com.google.common.collect.BoundType as _BoundType
_BoundType = _BoundType
import java.lang.Integer as _int
import com.google.common.collect.Range as _Range
_Range = _Range
import java.lang.Comparable as _Comparable
_Comparable = _Comparable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Range():
    """com.google.common.collect.Range"""
 
    @staticmethod
    def _wrap(java_value: _Range) -> 'Range':
        return Range(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Range):
        """
        Dynamic initializer for Range.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Range__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Range__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def or(self, arg0: 'Predicate') -> 'Predicate':
        """public default java.util.function.Predicate<T> java.util.function.Predicate.or(java.util.function.Predicate<? super T>)"""
        return 'Predicate'._wrap(super(_Predicate, self).or(arg0))

    @overload
    def encloses(self, other: 'Range') -> bool:
        """public boolean com.google.common.collect.Range.encloses(com.google.common.collect.Range<C>)"""
        return bool._wrap(super(_Range, self).encloses(other))

    @staticmethod
    @overload
    def openClosed(lower: 'Comparable', upper: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.openClosed(C,C)"""
        return Range._wrap(_Range.openClosed(lower, upper))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Range.isEmpty()"""
        return bool._wrap(super(Range, self).isEmpty())

    @overload
    def hasLowerBound(self) -> bool:
        """public boolean com.google.common.collect.Range.hasLowerBound()"""
        return bool._wrap(super(Range, self).hasLowerBound())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.Range.hashCode()"""
        return int._wrap(super(Range, self).hashCode())

    @staticmethod
    @overload
    def atMost(endpoint: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.atMost(C)"""
        return Range._wrap(_Range.atMost(endpoint))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def lessThan(endpoint: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.lessThan(C)"""
        return Range._wrap(_Range.lessThan(endpoint))

    @overload
    def span(self, other: 'Range') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.Range.span(com.google.common.collect.Range<C>)"""
        return 'Range'._wrap(super(_Range, self).span(other))

    @overload
    def hasUpperBound(self) -> bool:
        """public boolean com.google.common.collect.Range.hasUpperBound()"""
        return bool._wrap(super(Range, self).hasUpperBound())

    @staticmethod
    @overload
    def range(lower: 'Comparable', lowerType: 'BoundType', upper: 'Comparable', upperType: 'BoundType') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.range(C,com.google.common.collect.BoundType,C,com.google.common.collect.BoundType)"""
        return Range._wrap(_Range.range(lower, lowerType, upper, upperType))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def and(self, arg0: 'Predicate') -> 'Predicate':
        """public default java.util.function.Predicate<T> java.util.function.Predicate.and(java.util.function.Predicate<? super T>)"""
        return 'Predicate'._wrap(super(_Predicate, self).and(arg0))

    @overload
    def lowerEndpoint(self) -> 'Comparable':
        """public C com.google.common.collect.Range.lowerEndpoint()"""
        return 'Comparable'._wrap(super(Range, self).lowerEndpoint())

    @staticmethod
    @overload
    def encloseAll(values: 'Iterable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.encloseAll(java.lang.Iterable<C>)"""
        return Range._wrap(_Range.encloseAll(values))

    @staticmethod
    @overload
    def singleton(value: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.singleton(C)"""
        return Range._wrap(_Range.singleton(value))

    @staticmethod
    @overload
    def upTo(endpoint: 'Comparable', boundType: 'BoundType') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.upTo(C,com.google.common.collect.BoundType)"""
        return Range._wrap(_Range.upTo(endpoint, boundType))

    @staticmethod
    @overload
    def greaterThan(endpoint: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.greaterThan(C)"""
        return Range._wrap(_Range.greaterThan(endpoint))

    @overload
    def lowerBoundType(self) -> 'BoundType':
        """public com.google.common.collect.BoundType com.google.common.collect.Range.lowerBoundType()"""
        return 'BoundType'._wrap(super(Range, self).lowerBoundType())

    @overload
    def upperEndpoint(self) -> 'Comparable':
        """public C com.google.common.collect.Range.upperEndpoint()"""
        return 'Comparable'._wrap(super(Range, self).upperEndpoint())

    @overload
    def apply(self, input: 'Comparable') -> bool:
        """public boolean com.google.common.collect.Range.apply(C)"""
        return bool._wrap(super(_Range, self).apply(input))

    @staticmethod
    @overload
    def closed(lower: 'Comparable', upper: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.closed(C,C)"""
        return Range._wrap(_Range.closed(lower, upper))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def open(lower: 'Comparable', upper: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.open(C,C)"""
        return Range._wrap(_Range.open(lower, upper))

    @overload
    def containsAll(self, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.Range.containsAll(java.lang.Iterable<? extends C>)"""
        return bool._wrap(super(_Range, self).containsAll(values))

    @overload
    def contains(self, value: 'Comparable') -> bool:
        """public boolean com.google.common.collect.Range.contains(C)"""
        return bool._wrap(super(_Range, self).contains(value))

    @staticmethod
    @overload
    def closedOpen(lower: 'Comparable', upper: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.closedOpen(C,C)"""
        return Range._wrap(_Range.closedOpen(lower, upper))

    @overload
    def canonical(self, domain: 'DiscreteDomain') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.Range.canonical(com.google.common.collect.DiscreteDomain<C>)"""
        return 'Range'._wrap(super(_Range, self).canonical(domain))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.Range.equals(java.lang.Object)"""
        return bool._wrap(super(_Range, self).equals(object))

    @overload
    def intersection(self, connectedRange: 'Range') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.Range.intersection(com.google.common.collect.Range<C>)"""
        return 'Range'._wrap(super(_Range, self).intersection(connectedRange))

    @overload
    def test(self, input: object) -> bool:
        """public default boolean com.google.common.base.Predicate.test(T)"""
        return bool._wrap(super(_base.Predicate, self).test(input))

    @override
    @overload
    def negate(self) -> 'Predicate':
        """public default java.util.function.Predicate<T> java.util.function.Predicate.negate()"""
        return 'Predicate'._wrap(super(Predicate, self).negate())

    @overload
    def isConnected(self, other: 'Range') -> bool:
        """public boolean com.google.common.collect.Range.isConnected(com.google.common.collect.Range<C>)"""
        return bool._wrap(super(_Range, self).isConnected(other))

    @overload
    def gap(self, otherRange: 'Range') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.Range.gap(com.google.common.collect.Range<C>)"""
        return 'Range'._wrap(super(_Range, self).gap(otherRange))

    @staticmethod
    @overload
    def downTo(endpoint: 'Comparable', boundType: 'BoundType') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.downTo(C,com.google.common.collect.BoundType)"""
        return Range._wrap(_Range.downTo(endpoint, boundType))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def atLeast(endpoint: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.atLeast(C)"""
        return Range._wrap(_Range.atLeast(endpoint))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.Range.toString()"""
        return str._wrap(super(Range, self).toString())

    @overload
    def upperBoundType(self) -> 'BoundType':
        """public com.google.common.collect.BoundType com.google.common.collect.Range.upperBoundType()"""
        return 'BoundType'._wrap(super(Range, self).upperBoundType())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def all() -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.all()"""
        return Range._wrap(_Range.all()) 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableSet$StandardDescendingSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.Sets as _Sets_DescendingSet
_DescendingSet = _Sets_DescendingSet.DescendingSet
import com.google.common.collect.ForwardingSet as _ForwardingSet
_ForwardingSet = _ForwardingSet
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import com.google.common.collect.ForwardingCollection as _ForwardingCollection
_ForwardingCollection = _ForwardingCollection
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
from builtins import str
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
import com.google.common.collect.ForwardingNavigableSet as _ForwardingNavigableSet_StandardDescendingSet
_StandardDescendingSet = _ForwardingNavigableSet_StandardDescendingSet.StandardDescendingSet
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
import java.lang.String as _String
_String = _String
from builtins import object
import java.util.Iterator as Iterator
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
from typing import List
import java.util.Comparator as Comparator
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardDescendingSet():
    """com.google.common.collect.ForwardingNavigableSet.StandardDescendingSet"""
 
    @staticmethod
    def _wrap(java_value: _StandardDescendingSet) -> 'StandardDescendingSet':
        return StandardDescendingSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardDescendingSet):
        """
        Dynamic initializer for StandardDescendingSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardDescendingSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardDescendingSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object._wrap(super(NavigableSet, self).removeLast())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingSet, self).equals(object))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object._wrap(super(NavigableSet, self).removeFirst())

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.ceiling(E)"""
        return object._wrap(super(_DescendingSet, self).ceiling(e))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int._wrap(super(ForwardingSet, self).hashCode())

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.Sets$DescendingSet.subSet(E,boolean,E,boolean)"""
        return 'NavigableSet'._wrap(super(_DescendingSet, self).subSet(fromElement, _boolean.valueOf(fromInclusive), toElement, _boolean.valueOf(toInclusive)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.pollFirst()"""
        return object._wrap(super(DescendingSet, self).pollFirst())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.Sets$DescendingSet.comparator()"""
        return 'Comparator'._wrap(super(DescendingSet, self).comparator())

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.Sets$DescendingSet.tailSet(E,boolean)"""
        return 'NavigableSet'._wrap(super(_DescendingSet, self).tailSet(fromElement, _boolean.valueOf(inclusive)))

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).remove(object))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int._wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool._wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool._wrap(super(_ForwardingCollection, self).contains(object))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(SortedSet, self).spliterator())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.Sets$DescendingSet.iterator()"""
        return 'Iterator'._wrap(super(DescendingSet, self).iterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.Sets$DescendingSet.toString()"""
        return str._wrap(super(DescendingSet, self).toString())

    @override
    @overload
    def descendingSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.Sets$DescendingSet.descendingSet()"""
        return 'NavigableSet'._wrap(super(DescendingSet, self).descendingSet())

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.Sets$DescendingSet.tailSet(E)"""
        return 'SortedSet'._wrap(super(_DescendingSet, self).tailSet(fromElement))

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.pollLast()"""
        return object._wrap(super(DescendingSet, self).pollLast())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.Sets$DescendingSet.toArray()"""
        return List[object]._wrap(super(DescendingSet, self).toArray())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.first()"""
        return object._wrap(super(DescendingSet, self).first())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.Sets$DescendingSet.toArray(T[])"""
        return List[object]._wrap(super(_DescendingSet, self).toArray(array))

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'._wrap(super(NavigableSet, self).reversed())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool._wrap(super(_ForwardingCollection, self).add(element))

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.floor(E)"""
        return object._wrap(super(_DescendingSet, self).floor(e))

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.Sets$DescendingSet.headSet(E)"""
        return 'SortedSet'._wrap(super(_DescendingSet, self).headSet(toElement))

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.higher(E)"""
        return object._wrap(super(_DescendingSet, self).higher(e))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.lower(E)"""
        return object._wrap(super(_DescendingSet, self).lower(e))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ForwardingCollection, self).removeAll(collection))

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.Sets$DescendingSet.headSet(E,boolean)"""
        return 'NavigableSet'._wrap(super(_DescendingSet, self).headSet(toElement, _boolean.valueOf(inclusive)))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.last()"""
        return object._wrap(super(DescendingSet, self).last())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self, this$0: 'ForwardingNavigableSet'):
        """public com.google.common.collect.ForwardingNavigableSet$StandardDescendingSet(com.google.common.collect.ForwardingNavigableSet)"""
        val = _StandardDescendingSet(this$0)
        self.__wrapper = val

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.Sets$DescendingSet.subSet(E,E)"""
        return 'SortedSet'._wrap(super(_DescendingSet, self).subSet(fromElement, toElement))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.Sets$DescendingSet.descendingIterator()"""
        return 'Iterator'._wrap(super(DescendingSet, self).descendingIterator()) 
 
 
# CLASS: com.google.common.collect.EnumBiMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Map as _Map
_Map = _Map
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ForwardingMap as _ForwardingMap
_ForwardingMap = _ForwardingMap
import com.google.common.collect.EnumBiMap as _EnumBiMap
_EnumBiMap = _EnumBiMap
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import bool
import java.lang.Long as _long
import java.lang.Class as _Class
_Class = _Class
from builtins import int
 
class EnumBiMap():
    """com.google.common.collect.EnumBiMap"""
 
    @staticmethod
    def _wrap(java_value: _EnumBiMap) -> 'EnumBiMap':
        return EnumBiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _EnumBiMap):
        """
        Dynamic initializer for EnumBiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_EnumBiMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_EnumBiMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).containsKey(key))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int._wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def create(keyType: 'Class', valueType: 'Class') -> 'EnumBiMap':
        """public static <K extends java.lang.Enum<K>,V extends java.lang.Enum<V>> com.google.common.collect.EnumBiMap<K, V> com.google.common.collect.EnumBiMap.create(java.lang.Class<K>,java.lang.Class<V>)"""
        return EnumBiMap._wrap(_EnumBiMap.create(keyType, valueType))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool._wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def valueType(self) -> 'type.Class':
        """public java.lang.Class<V> com.google.common.collect.EnumBiMap.valueType()"""
        return 'type.Class'._wrap(super(EnumBiMap, self).valueType())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int._wrap(super(ForwardingMap, self).size())

    @staticmethod
    @overload
    def create(map: 'Map') -> 'EnumBiMap':
        """public static <K extends java.lang.Enum<K>,V extends java.lang.Enum<V>> com.google.common.collect.EnumBiMap<K, V> com.google.common.collect.EnumBiMap.create(java.util.Map<K, V>)"""
        return EnumBiMap._wrap(_EnumBiMap.create(map))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object._wrap(super(_Map, self).replace(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).compute(arg0, arg1))

    @overload
    def keyType(self) -> 'type.Class':
        """public java.lang.Class<K> com.google.common.collect.EnumBiMap.keyType()"""
        return 'type.Class'._wrap(super(EnumBiMap, self).keyType())

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool._wrap(super(_Map, self).replace(arg0, arg1, arg2))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object._wrap(super(_Map, self).getOrDefault(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object._wrap(super(_ForwardingMap, self).get(key))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object._wrap(super(_Map, self).putIfAbsent(arg0, arg1))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_Map, self).remove(arg0, arg1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMap, self).equals(object))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).merge(arg0, arg1, arg2))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object._wrap(super(_Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Map, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.ForwardingSortedSetMultimap
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.ForwardingMultimap as _ForwardingMultimap
_ForwardingMultimap = _ForwardingMultimap
from builtins import type
import java.util.Map as _Map
_Map = _Map
import com.google.common.collect.ForwardingObject as _ForwardingObject
_ForwardingObject = _ForwardingObject
import java.util.Collection as Collection
import java.util.Set as _Set
_Set = _Set
import com.google.common.collect.Multimap as _Multimap
_Multimap = _Multimap
import com.google.common.collect.ForwardingSortedSetMultimap as _ForwardingSortedSetMultimap
_ForwardingSortedSetMultimap = _ForwardingSortedSetMultimap
from builtins import bool
import com.google.common.collect.ForwardingSetMultimap as _ForwardingSetMultimap
_ForwardingSetMultimap = _ForwardingSetMultimap
import com.google.common.collect.Multiset as _Multiset
_Multiset = _Multiset
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.SortedSet as SortedSet
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.function.BiConsumer as BiConsumer
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ForwardingSortedSetMultimap():
    """com.google.common.collect.ForwardingSortedSetMultimap"""
 
    @staticmethod
    def _wrap(java_value: _ForwardingSortedSetMultimap) -> 'ForwardingSortedSetMultimap':
        return ForwardingSortedSetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ForwardingSortedSetMultimap):
        """
        Dynamic initializer for ForwardingSortedSetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ForwardingSortedSetMultimap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ForwardingSortedSetMultimap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def asMap(self) -> 'Map':
        """public java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ForwardingMultimap.asMap()"""
        return 'Map'._wrap(super(ForwardingMultimap, self).asMap())

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool._wrap(super(_ForwardingMultimap, self).putAll(multimap))

    @override
    @overload
    def keys(self) -> 'Multiset':
        """public com.google.common.collect.Multiset<K> com.google.common.collect.ForwardingMultimap.keys()"""
        return 'Multiset'._wrap(super(ForwardingMultimap, self).keys())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.size()"""
        return int._wrap(super(ForwardingMultimap, self).size())

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool._wrap(super(_ForwardingMultimap, self).putAll(key, values))

    @overload
    def containsEntry(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsEntry(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsEntry(key, value))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def valueComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super V> com.google.common.collect.ForwardingSortedSetMultimap.valueComparator()"""
        return 'Comparator'._wrap(super(ForwardingSortedSetMultimap, self).valueComparator())

    @overload
    def removeAll(self, key: object) -> 'SortedSet':
        """public java.util.SortedSet<V> com.google.common.collect.ForwardingSortedSetMultimap.removeAll(java.lang.Object)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSetMultimap, self).removeAll(key))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.put(K,V)"""
        return bool._wrap(super(_ForwardingMultimap, self).put(key, value))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.values()"""
        return 'Collection'._wrap(super(ForwardingMultimap, self).values())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMultimap.clear()"""
        super(ForwardingMultimap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.equals(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).equals(object))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMultimap.keySet()"""
        return 'Set'._wrap(super(ForwardingMultimap, self).keySet())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsKey(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsKey(key))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).remove(key, value))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(_Multimap, self).forEach(action)

    @overload
    def get(self, key: object) -> 'SortedSet':
        """public java.util.SortedSet<V> com.google.common.collect.ForwardingSortedSetMultimap.get(K)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSetMultimap, self).get(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str._wrap(super(ForwardingObject, self).toString())

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'SortedSet':
        """public java.util.SortedSet<V> com.google.common.collect.ForwardingSortedSetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'SortedSet'._wrap(super(_ForwardingSortedSetMultimap, self).replaceValues(key, values))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsValue(java.lang.Object)"""
        return bool._wrap(super(_ForwardingMultimap, self).containsValue(value))

    @override
    @overload
    def entries(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingSetMultimap.entries()"""
        return 'Set'._wrap(super(ForwardingSetMultimap, self).entries())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.hashCode()"""
        return int._wrap(super(ForwardingMultimap, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.isEmpty()"""
        return bool._wrap(super(ForwardingMultimap, self).isEmpty()) 
 
 
# CLASS: com.google.common.collect.Lists
from pyquantum_helper import import_once as _import_once
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.util.concurrent.CopyOnWriteArrayList as CopyOnWriteArrayList
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ImmutableList as _ImmutableList
_ImmutableList = _ImmutableList
import java.lang.String as _string
import java.util.ArrayList as ArrayList
from builtins import bool
from builtins import str
import java.lang.CharSequence as CharSequence
from pyquantum_helper import override
import java.lang.Object as _object
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.List as _List
_List = _List
import java.util.Iterator as Iterator
import com.google.common.collect.Lists as _Lists
_Lists = _Lists
import java.util.LinkedList as _LinkedList
_LinkedList = _LinkedList
import java.util.ArrayList as _ArrayList
_ArrayList = _ArrayList
import java.lang.Integer as _int
import java.util.LinkedList as LinkedList
import java.util.concurrent.CopyOnWriteArrayList as _CopyOnWriteArrayList
_CopyOnWriteArrayList = _CopyOnWriteArrayList
import java.lang.Long as _long
import java.util.List as List
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Lists():
    """com.google.common.collect.Lists"""
 
    @staticmethod
    def _wrap(java_value: _Lists) -> 'Lists':
        return Lists(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Lists):
        """
        Dynamic initializer for Lists.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Lists__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Lists__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def cartesianProduct(lists: 'List') -> 'List':
        """public static <B> java.util.List<java.util.List<B>> com.google.common.collect.Lists.cartesianProduct(java.util.List<? extends java.util.List<? extends B>>)"""
        return List._wrap(_Lists.cartesianProduct(lists))

    @staticmethod
    @overload
    def newArrayList(elements: 'Iterable') -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayList(java.lang.Iterable<? extends E>)"""
        return ArrayList._wrap(_Lists.newArrayList(elements))

    @staticmethod
    @overload
    def partition(list: 'List', size: int) -> 'List':
        """public static <T> java.util.List<java.util.List<T>> com.google.common.collect.Lists.partition(java.util.List<T>,int)"""
        return List._wrap(_Lists.partition(list, _int.valueOf(size)))

    @staticmethod
    @overload
    def newArrayListWithCapacity(initialArraySize: int) -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayListWithCapacity(int)"""
        return ArrayList._wrap(_Lists.newArrayListWithCapacity(_int.valueOf(initialArraySize)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def newCopyOnWriteArrayList() -> 'CopyOnWriteArrayList':
        """public static <E> java.util.concurrent.CopyOnWriteArrayList<E> com.google.common.collect.Lists.newCopyOnWriteArrayList()"""
        return CopyOnWriteArrayList._wrap(_Lists.newCopyOnWriteArrayList())

    @staticmethod
    @overload
    def newArrayListWithExpectedSize(estimatedSize: int) -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayListWithExpectedSize(int)"""
        return ArrayList._wrap(_Lists.newArrayListWithExpectedSize(_int.valueOf(estimatedSize)))

    @staticmethod
    @overload
    def newLinkedList(elements: 'Iterable') -> 'LinkedList':
        """public static <E> java.util.LinkedList<E> com.google.common.collect.Lists.newLinkedList(java.lang.Iterable<? extends E>)"""
        return LinkedList._wrap(_Lists.newLinkedList(elements))

    @staticmethod
    @overload
    def reverse(list: 'List') -> 'List':
        """public static <T> java.util.List<T> com.google.common.collect.Lists.reverse(java.util.List<T>)"""
        return List._wrap(_Lists.reverse(list))

    @staticmethod
    @overload
    def asList(first: object, second: object, rest: 'Object') -> 'List':
        """public static <E> java.util.List<E> com.google.common.collect.Lists.asList(E,E,E[])"""
        return List._wrap(_Lists.asList(first, second, rest))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def newLinkedList() -> 'LinkedList':
        """public static <E> java.util.LinkedList<E> com.google.common.collect.Lists.newLinkedList()"""
        return LinkedList._wrap(_Lists.newLinkedList())

    @staticmethod
    @overload
    def newArrayList(*elements: object) -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayList(E...)"""
        return ArrayList._wrap(_Lists.newArrayList(elements))

    @staticmethod
    @overload
    def newCopyOnWriteArrayList(elements: 'Iterable') -> 'CopyOnWriteArrayList':
        """public static <E> java.util.concurrent.CopyOnWriteArrayList<E> com.google.common.collect.Lists.newCopyOnWriteArrayList(java.lang.Iterable<? extends E>)"""
        return CopyOnWriteArrayList._wrap(_Lists.newCopyOnWriteArrayList(elements))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @staticmethod
    @overload
    def cartesianProduct(*lists: 'List') -> 'List':
        """public static <B> java.util.List<java.util.List<B>> com.google.common.collect.Lists.cartesianProduct(java.util.List<? extends B>...)"""
        return List._wrap(_Lists.cartesianProduct(lists))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def newArrayList(elements: 'Iterator') -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayList(java.util.Iterator<? extends E>)"""
        return ArrayList._wrap(_Lists.newArrayList(elements))

    @staticmethod
    @overload
    def charactersOf(string: str) -> 'ImmutableList':
        """public static com.google.common.collect.ImmutableList<java.lang.Character> com.google.common.collect.Lists.charactersOf(java.lang.String)"""
        return ImmutableList._wrap(_Lists.charactersOf(string))

    @staticmethod
    @overload
    def transform(fromList: 'List', function: 'Function') -> 'List':
        """public static <F,T> java.util.List<T> com.google.common.collect.Lists.transform(java.util.List<F>,com.google.common.base.Function<? super F, ? extends T>)"""
        return List._wrap(_Lists.transform(fromList, function))

    @staticmethod
    @overload
    def charactersOf(sequence: 'CharSequence') -> 'List':
        """public static java.util.List<java.lang.Character> com.google.common.collect.Lists.charactersOf(java.lang.CharSequence)"""
        return List._wrap(_Lists.charactersOf(sequence))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def asList(first: object, rest: 'Object') -> 'List':
        """public static <E> java.util.List<E> com.google.common.collect.Lists.asList(E,E[])"""
        return List._wrap(_Lists.asList(first, rest))

    @staticmethod
    @overload
    def newArrayList() -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayList()"""
        return ArrayList._wrap(_Lists.newArrayList())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMultiset$StandardElementSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.util.Collection as Collection
import com.google.common.collect.SortedMultisets as _SortedMultisets_NavigableElementSet
_NavigableElementSet = _SortedMultisets_NavigableElementSet.NavigableElementSet
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import java.util.Iterator as _Iterator
_Iterator = _Iterator
from builtins import bool
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from builtins import str
import com.google.common.collect.ForwardingSortedMultiset as _ForwardingSortedMultiset_StandardElementSet
_StandardElementSet = _ForwardingSortedMultiset_StandardElementSet.StandardElementSet
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import com.google.common.collect.SortedMultisets as _SortedMultisets_ElementSet
_ElementSet = _SortedMultisets_ElementSet.ElementSet
import java.util.AbstractSet as _AbstractSet
_AbstractSet = _AbstractSet
import com.google.common.collect.Sets as _Sets_ImprovedAbstractSet
_ImprovedAbstractSet = _Sets_ImprovedAbstractSet.ImprovedAbstractSet
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
from typing import List
import java.util.Comparator as Comparator
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import com.google.common.collect.Multisets as _Multisets_ElementSet
_ElementSet = _Multisets_ElementSet.ElementSet
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class StandardElementSet():
    """com.google.common.collect.ForwardingSortedMultiset.StandardElementSet"""
 
    @staticmethod
    def _wrap(java_value: _StandardElementSet) -> 'StandardElementSet':
        return StandardElementSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _StandardElementSet):
        """
        Dynamic initializer for StandardElementSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_StandardElementSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_StandardElementSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int._wrap(super(AbstractSet, self).hashCode())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object._wrap(super(NavigableSet, self).removeLast())

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object._wrap(super(NavigableSet, self).removeFirst())

    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.pollFirst()"""
        return object._wrap(super(NavigableElementSet, self).pollFirst())

    @overload
    def containsAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ElementSet, self).containsAll(c))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.lower(E)"""
        return object._wrap(super(_NavigableElementSet, self).lower(e))

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.SortedMultisets$ElementSet.comparator()"""
        return 'Comparator'._wrap(super(ElementSet, self).comparator())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool._wrap(super(_AbstractSet, self).equals(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.isEmpty()"""
        return bool._wrap(super(ElementSet, self).isEmpty())

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.SortedMultisets$NavigableElementSet.tailSet(E,boolean)"""
        return 'NavigableSet'._wrap(super(_NavigableElementSet, self).tailSet(fromElement, _boolean.valueOf(inclusive)))

    @overload
    def __init__(self, this$0: 'ForwardingSortedMultiset'):
        """public com.google.common.collect.ForwardingSortedMultiset$StandardElementSet(com.google.common.collect.ForwardingSortedMultiset)"""
        val = _StandardElementSet(this$0)
        self.__wrapper = val

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.SortedMultisets$ElementSet.last()"""
        return object._wrap(super(ElementSet, self).last())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool._wrap(super(_AbstractCollection, self).add(arg0))

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.SortedMultisets$NavigableElementSet.descendingIterator()"""
        return 'Iterator'._wrap(super(NavigableElementSet, self).descendingIterator())

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.SortedMultisets$ElementSet.first()"""
        return object._wrap(super(ElementSet, self).first())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_Collection, self).removeIf(arg0))

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.SortedMultisets$ElementSet.tailSet(E)"""
        return 'SortedSet'._wrap(super(_ElementSet, self).tailSet(fromElement))

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.SortedMultisets$ElementSet.headSet(E)"""
        return 'SortedSet'._wrap(super(_ElementSet, self).headSet(toElement))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.SortedMultisets$NavigableElementSet.subSet(E,boolean,E,boolean)"""
        return 'NavigableSet'._wrap(super(_NavigableElementSet, self).subSet(fromElement, _boolean.valueOf(fromInclusive), toElement, _boolean.valueOf(toInclusive)))

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.remove(java.lang.Object)"""
        return bool._wrap(super(_ElementSet, self).remove(o))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(SortedSet, self).spliterator())

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.SortedMultisets$NavigableElementSet.headSet(E,boolean)"""
        return 'NavigableSet'._wrap(super(_NavigableElementSet, self).headSet(toElement, _boolean.valueOf(inclusive)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Multisets$ElementSet.clear()"""
        super(ElementSet, self).clear()

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.contains(java.lang.Object)"""
        return bool._wrap(super(_ElementSet, self).contains(o))

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.higher(E)"""
        return object._wrap(super(_NavigableElementSet, self).higher(e))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object]._wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'._wrap(super(NavigableSet, self).reversed())

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.pollLast()"""
        return object._wrap(super(NavigableElementSet, self).pollLast())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.SortedMultisets$ElementSet.subSet(E,E)"""
        return 'SortedSet'._wrap(super(_ElementSet, self).subSet(fromElement, toElement))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.SortedMultisets$ElementSet.iterator()"""
        return 'Iterator'._wrap(super(ElementSet, self).iterator())

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.floor(E)"""
        return object._wrap(super(_NavigableElementSet, self).floor(e))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object]._wrap(super(_AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Multisets$ElementSet.size()"""
        return int._wrap(super(ElementSet, self).size())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def descendingSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.SortedMultisets$NavigableElementSet.descendingSet()"""
        return 'NavigableSet'._wrap(super(NavigableElementSet, self).descendingSet())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.ceiling(E)"""
        return object._wrap(super(_NavigableElementSet, self).ceiling(e)) 
 
 
# CLASS: com.google.common.collect.TreeRangeMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.util.Map as _Map
_Map = _Map
import com.google.common.collect.TreeRangeMap as _TreeRangeMap
_TreeRangeMap = _TreeRangeMap
import java.lang.Comparable as Comparable
from builtins import object
import java.lang.String as _String
_String = _String
import java.util.function.BiFunction as BiFunction
import java.util.Map.Entry as Entry
import java.lang.Integer as _int
import com.google.common.collect.Range as _Range
_Range = _Range
import com.google.common.collect.RangeMap as _RangeMap
_RangeMap = _RangeMap
import java.util.Map as _Map_Entry
_Entry = _Map_Entry.Entry
from builtins import bool
import java.util.Map as Map
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class TreeRangeMap():
    """com.google.common.collect.TreeRangeMap"""
 
    @staticmethod
    def _wrap(java_value: _TreeRangeMap) -> 'TreeRangeMap':
        return TreeRangeMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _TreeRangeMap):
        """
        Dynamic initializer for TreeRangeMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_TreeRangeMap__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_TreeRangeMap__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def merge(self, range: 'Range', value: object, remappingFunction: 'BiFunction'):
        """public void com.google.common.collect.TreeRangeMap.merge(com.google.common.collect.Range<K>,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        super(_TreeRangeMap, self).merge(range, value, remappingFunction)

    @overload
    def equals(self, o: object) -> bool:
        """public boolean com.google.common.collect.TreeRangeMap.equals(java.lang.Object)"""
        return bool._wrap(super(_TreeRangeMap, self).equals(o))

    @staticmethod
    @overload
    def create() -> 'TreeRangeMap':
        """public static <K extends java.lang.Comparable,V> com.google.common.collect.TreeRangeMap<K, V> com.google.common.collect.TreeRangeMap.create()"""
        return TreeRangeMap._wrap(_TreeRangeMap.create())

    @override
    @overload
    def put(self, range: 'Range', value: object):
        """public void com.google.common.collect.TreeRangeMap.put(com.google.common.collect.Range<K>,V)"""
        super(_TreeRangeMap, self).put(range, value)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def asMapOfRanges(self) -> 'Map':
        """public java.util.Map<com.google.common.collect.Range<K>, V> com.google.common.collect.TreeRangeMap.asMapOfRanges()"""
        return 'Map'._wrap(super(TreeRangeMap, self).asMapOfRanges())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def putCoalescing(self, range: 'Range', value: object):
        """public void com.google.common.collect.TreeRangeMap.putCoalescing(com.google.common.collect.Range<K>,V)"""
        super(_TreeRangeMap, self).putCoalescing(range, value)

    @override
    @overload
    def putAll(self, rangeMap: 'RangeMap'):
        """public void com.google.common.collect.TreeRangeMap.putAll(com.google.common.collect.RangeMap<K, ? extends V>)"""
        super(_TreeRangeMap, self).putAll(rangeMap)

    @override
    @overload
    def asDescendingMapOfRanges(self) -> 'Map':
        """public java.util.Map<com.google.common.collect.Range<K>, V> com.google.common.collect.TreeRangeMap.asDescendingMapOfRanges()"""
        return 'Map'._wrap(super(TreeRangeMap, self).asDescendingMapOfRanges())

    @overload
    def getEntry(self, key: 'Comparable') -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<com.google.common.collect.Range<K>, V> com.google.common.collect.TreeRangeMap.getEntry(K)"""
        return 'Entry.Map$Entry'._wrap(super(_TreeRangeMap, self).getEntry(key))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def subRangeMap(self, subRange: 'Range') -> 'RangeMap':
        """public com.google.common.collect.RangeMap<K, V> com.google.common.collect.TreeRangeMap.subRangeMap(com.google.common.collect.Range<K>)"""
        return 'RangeMap'._wrap(super(_TreeRangeMap, self).subRangeMap(subRange))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.TreeRangeMap.toString()"""
        return str._wrap(super(TreeRangeMap, self).toString())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.TreeRangeMap.clear()"""
        super(TreeRangeMap, self).clear()

    @override
    @overload
    def remove(self, rangeToRemove: 'Range'):
        """public void com.google.common.collect.TreeRangeMap.remove(com.google.common.collect.Range<K>)"""
        super(_TreeRangeMap, self).remove(rangeToRemove)

    @overload
    def get(self, key: 'Comparable') -> object:
        """public V com.google.common.collect.TreeRangeMap.get(K)"""
        return object._wrap(super(_TreeRangeMap, self).get(key))

    @override
    @overload
    def span(self) -> 'Range':
        """public com.google.common.collect.Range<K> com.google.common.collect.TreeRangeMap.span()"""
        return 'Range'._wrap(super(TreeRangeMap, self).span())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.TreeRangeMap.hashCode()"""
        return int._wrap(super(TreeRangeMap, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.Tables
from pyquantum_helper import import_once as _import_once
import com.google.common.collect.Table as _Table_Cell
_Cell = _Table_Cell.Cell
try:
    from pygcommon import base
except ImportError:
    base = _import_once("pygcommon.base")

import java.util.function.Supplier as Supplier
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import com.google.common.collect.Table as _Table
_Table = _Table
import java.lang.Object as _object
from builtins import type
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.lang.Integer as _int
import java.util.function.BinaryOperator as BinaryOperator
import com.google.common.collect.Tables as _Tables
_Tables = _Tables
import java.util.function.Function as Function
import java.util.Map as Map
import com.google.common.collect.RowSortedTable as _RowSortedTable
_RowSortedTable = _RowSortedTable
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Tables():
    """com.google.common.collect.Tables"""
 
    @staticmethod
    def _wrap(java_value: _Tables) -> 'Tables':
        return Tables(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Tables):
        """
        Dynamic initializer for Tables.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Tables__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Tables__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def synchronizedTable(table: 'Table') -> 'Table':
        """public static <R,C,V> com.google.common.collect.Table<R, C, V> com.google.common.collect.Tables.synchronizedTable(com.google.common.collect.Table<R, C, V>)"""
        return Table._wrap(_Tables.synchronizedTable(table))

    @staticmethod
    @overload
    def toTable(rowFunction: 'Function', columnFunction: 'Function', valueFunction: 'Function', tableSupplier: 'Supplier') -> 'Collector':
        """public static <T,R,C,V,I extends com.google.common.collect.Table<R, C, V>> java.util.stream.Collector<T, ?, I> com.google.common.collect.Tables.toTable(java.util.function.Function<? super T, ? extends R>,java.util.function.Function<? super T, ? extends C>,java.util.function.Function<? super T, ? extends V>,java.util.function.Supplier<I>)"""
        return Collector._wrap(_Tables.toTable(rowFunction, columnFunction, valueFunction, tableSupplier))

    @staticmethod
    @overload
    def newCustomTable(backingMap: 'Map', factory: 'Supplier') -> 'Table':
        """public static <R,C,V> com.google.common.collect.Table<R, C, V> com.google.common.collect.Tables.newCustomTable(java.util.Map<R, java.util.Map<C, V>>,com.google.common.base.Supplier<? extends java.util.Map<C, V>>)"""
        return Table._wrap(_Tables.newCustomTable(backingMap, factory))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @staticmethod
    @overload
    def toTable(rowFunction: 'Function', columnFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator', tableSupplier: 'Supplier') -> 'Collector':
        """public static <T,R,C,V,I extends com.google.common.collect.Table<R, C, V>> java.util.stream.Collector<T, ?, I> com.google.common.collect.Tables.toTable(java.util.function.Function<? super T, ? extends R>,java.util.function.Function<? super T, ? extends C>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>,java.util.function.Supplier<I>)"""
        return Collector._wrap(_Tables.toTable(rowFunction, columnFunction, valueFunction, mergeFunction, tableSupplier))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def transpose(table: 'Table') -> 'Table':
        """public static <R,C,V> com.google.common.collect.Table<C, R, V> com.google.common.collect.Tables.transpose(com.google.common.collect.Table<R, C, V>)"""
        return Table._wrap(_Tables.transpose(table))

    @staticmethod
    @overload
    def unmodifiableTable(table: 'Table') -> 'Table':
        """public static <R,C,V> com.google.common.collect.Table<R, C, V> com.google.common.collect.Tables.unmodifiableTable(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        return Table._wrap(_Tables.unmodifiableTable(table))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def transformValues(fromTable: 'Table', function: 'Function') -> 'Table':
        """public static <R,C,V1,V2> com.google.common.collect.Table<R, C, V2> com.google.common.collect.Tables.transformValues(com.google.common.collect.Table<R, C, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return Table._wrap(_Tables.transformValues(fromTable, function))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def immutableCell(rowKey: object, columnKey: object, value: object) -> 'Cell':
        """public static <R,C,V> com.google.common.collect.Table$Cell<R, C, V> com.google.common.collect.Tables.immutableCell(R,C,V)"""
        return Cell._wrap(_Tables.immutableCell(rowKey, columnKey, value))

    @staticmethod
    @overload
    def unmodifiableRowSortedTable(table: 'RowSortedTable') -> 'RowSortedTable':
        """public static <R,C,V> com.google.common.collect.RowSortedTable<R, C, V> com.google.common.collect.Tables.unmodifiableRowSortedTable(com.google.common.collect.RowSortedTable<R, ? extends C, ? extends V>)"""
        return RowSortedTable._wrap(_Tables.unmodifiableRowSortedTable(table))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableMultiset$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
import java.lang.Object as _object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.String as _String
_String = _String
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset_Builder
_Builder = _ImmutableMultiset_Builder.Builder
import java.util.Iterator as Iterator
import com.google.common.collect.ImmutableMultiset as _ImmutableMultiset
_ImmutableMultiset = _ImmutableMultiset
import java.lang.Integer as _int
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class Builder():
    """com.google.common.collect.ImmutableMultiset.Builder"""
 
    @staticmethod
    def _wrap(java_value: _Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_Builder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_Builder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def build(self) -> 'ImmutableMultiset':
        """public com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset$Builder.build()"""
        return 'ImmutableMultiset'._wrap(super(Builder, self).build())

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.add(E...)"""
        return 'Builder'._wrap(super(_Builder, self).add(elements))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableMultiset$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def setCount(self, element: object, count: int) -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.setCount(E,int)"""
        return 'Builder'._wrap(super(_Builder, self).setCount(element, _int.valueOf(count)))

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableMultiset$Builder()"""
        val = _Builder()
        self.__wrapper = val

    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.add(E)"""
        return 'Builder'._wrap(super(_Builder, self).add(element))

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'._wrap(super(_Builder, self).addAll(elements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def addCopies(self, element: object, occurrences: int) -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.addCopies(E,int)"""
        return 'Builder'._wrap(super(_Builder, self).addCopies(element, _int.valueOf(occurrences)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder$SetMultimapBuilder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import java.lang.Object as _object
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_SetMultimapBuilder
_SetMultimapBuilder = _MultimapBuilder_SetMultimapBuilder.SetMultimapBuilder
from abc import abstractmethod, ABC
import java.lang.String as _String
_String = _String
import java.util.Comparator as Comparator
import com.google.common.collect.MultimapBuilder as _MultimapBuilder_MultimapBuilderWithKeys
_MultimapBuilderWithKeys = _MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.lang.Integer as _int
import com.google.common.collect.MultimapBuilder as _MultimapBuilder
_MultimapBuilder = _MultimapBuilder
import com.google.common.collect.SetMultimap as _SetMultimap
_SetMultimap = _SetMultimap
from builtins import bool
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class SetMultimapBuilder():
    """com.google.common.collect.MultimapBuilder.SetMultimapBuilder"""
 
    @staticmethod
    def _wrap(java_value: _SetMultimapBuilder) -> 'SetMultimapBuilder':
        return SetMultimapBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _SetMultimapBuilder):
        """
        Dynamic initializer for SetMultimapBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_SetMultimapBuilder__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_SetMultimapBuilder__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def linkedHashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys(int)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.linkedHashKeys(_int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def hashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys(int)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.hashKeys(_int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def treeKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Comparable> com.google.common.collect.MultimapBuilder.treeKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.treeKeys())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str._wrap(super(object, self).toString())

    @staticmethod
    @overload
    def enumKeys(keyClass: 'Class') -> 'MultimapBuilderWithKeys':
        """public static <K0 extends java.lang.Enum<K0>> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.enumKeys(java.lang.Class<K0>)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.enumKeys(keyClass))

    @staticmethod
    @overload
    def hashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.hashKeys())

    @staticmethod
    @overload
    def linkedHashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys()"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.linkedHashKeys())

    @abstractmethod
    def build(self, ):
        """public abstract <K extends K0,V extends V0> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.MultimapBuilder$SetMultimapBuilder.build()"""
        pass

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def build(self, multimap: 'Multimap') -> 'SetMultimap':
        """public <K extends K0,V extends V0> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.MultimapBuilder$SetMultimapBuilder.build(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'SetMultimap'._wrap(super(_SetMultimapBuilder, self).build(multimap))

    @staticmethod
    @overload
    def treeKeys(comparator: 'Comparator') -> 'MultimapBuilderWithKeys':
        """public static <K0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.treeKeys(java.util.Comparator<K0>)"""
        return MultimapBuilderWithKeys._wrap(_MultimapBuilder.treeKeys(comparator))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool._wrap(super(_object, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int._wrap(super(object, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedSet
import java.util.function.Predicate as Predicate
import java.lang.Object as _Object
_Object = _Object
from builtins import type
import com.google.common.collect.ImmutableSet as _ImmutableSet_Builder
_Builder = _ImmutableSet_Builder.Builder
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet_Builder
_Builder = _ImmutableSortedSet_Builder.Builder
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.lang.Boolean as _boolean
import com.google.common.collect.ImmutableSet as _ImmutableSet
_ImmutableSet = _ImmutableSet
from builtins import bool
from builtins import str
import java.util.SortedSet as _SortedSet
_SortedSet = _SortedSet
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.function.IntFunction as IntFunction
import java.lang.Object as _object
import java.lang.Iterable as Iterable
import java.util.Spliterator as _Spliterator
_Spliterator = _Spliterator
import java.util.SortedSet as SortedSet
from builtins import object
import java.lang.Comparable as Comparable
import java.util.stream.Collector as Collector
import java.lang.String as _String
_String = _String
import java.util.Iterator as Iterator
import java.util.stream.Collector as _Collector
_Collector = _Collector
import java.util.NavigableSet as _NavigableSet
_NavigableSet = _NavigableSet
import com.google.common.collect.ImmutableCollection as _ImmutableCollection
_ImmutableCollection = _ImmutableCollection
from typing import List
import java.util.Comparator as Comparator
import java.util.AbstractCollection as _AbstractCollection
_AbstractCollection = _AbstractCollection
import java.util.Collection as _Collection
_Collection = _Collection
import java.lang.Integer as _int
import java.util.Comparator as _Comparator
_Comparator = _Comparator
import java.lang.Iterable as _Iterable
_Iterable = _Iterable
import com.google.common.collect.ImmutableSortedSet as _ImmutableSortedSet
_ImmutableSortedSet = _ImmutableSortedSet
import java.util.stream.Stream as _Stream
_Stream = _Stream
import java.util.stream.Stream as Stream
import java.lang.Long as _long
from builtins import int
import java.lang.Class as _Class
_Class = _Class
 
class ImmutableSortedSet():
    """com.google.common.collect.ImmutableSortedSet"""
 
    @staticmethod
    def _wrap(java_value: _ImmutableSortedSet) -> 'ImmutableSortedSet':
        return ImmutableSortedSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: _ImmutableSortedSet):
        """
        Dynamic initializer for ImmutableSortedSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        print("Getting attribute %s" % name)
        if name == "_ImmutableSortedSet__wrapper":
            return object.__getattr__(self, name)
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: Any):
        print("Setting attribute %s to %s" % (name, value))
        if name == "_ImmutableSortedSet__wrapper":
            return object.__setattr__(self, name, value)
        setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def naturalOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.naturalOrder()"""
        return Builder._wrap(_ImmutableSortedSet.naturalOrder())

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object._wrap(super(NavigableSet, self).removeLast())

    @staticmethod
    @overload
    def of() -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of()"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of())

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(_SortedSet, self).addLast(arg0)

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object._wrap(super(NavigableSet, self).removeFirst())

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.first()"""
        return object._wrap(super(ImmutableSortedSet, self).first())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterable') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.lang.Iterable<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(comparator, elements))

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool._wrap(super(_ImmutableCollection, self).remove(object))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object]._wrap(super(_ImmutableCollection, self).toArray(other))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.subSet(E,E)"""
        return 'ImmutableSortedSet'._wrap(super(_ImmutableSortedSet, self).subSet(fromElement, toElement))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0))

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.floor(E)"""
        return object._wrap(super(_ImmutableSortedSet, self).floor(e))

    @abstractmethod
    def contains(self, object: object):
        """public abstract boolean com.google.common.collect.ImmutableCollection.contains(java.lang.Object)"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableSet.equals(java.lang.Object)"""
        return bool._wrap(super(_ImmutableSet, self).equals(object))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object]._wrap(super(ImmutableCollection, self).toArray())

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.lower(E)"""
        return object._wrap(super(_ImmutableSortedSet, self).lower(e))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool._wrap(super(_AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(_SortedSet, self).addFirst(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object._wrap(super(SortedSet, self).getLast())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4))

    @overload
    def tailSet(self, fromElement: object) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.tailSet(E)"""
        return 'ImmutableSortedSet'._wrap(super(_ImmutableSortedSet, self).tailSet(fromElement))

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.orderedBy(java.util.Comparator<E>)"""
        return Builder._wrap(_ImmutableSortedSet.orderedBy(comparator))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builder()"""
        return Builder._wrap(_ImmutableSet.builder())

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(element))

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.higher(E)"""
        return object._wrap(super(_ImmutableSortedSet, self).higher(e))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable', e6: 'Comparable', *remaining: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, remaining))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def toImmutableSortedSet(comparator: 'Comparator') -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSortedSet<E>> com.google.common.collect.ImmutableSortedSet.toImmutableSortedSet(java.util.Comparator<? super E>)"""
        return Collector._wrap(_ImmutableSortedSet.toImmutableSortedSet(comparator))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSortedSet':
        """public static <Z> com.google.common.collect.ImmutableSortedSet<Z> com.google.common.collect.ImmutableSortedSet.copyOf(Z[])"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4, e5))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object]._wrap(super(_Collection, self).toArray(arg0))

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).retainAll(elementsToKeep))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4, e5))

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(E[])"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @staticmethod
    @overload
    def reverseOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.reverseOrder()"""
        return Builder._wrap(_ImmutableSortedSet.reverseOrder())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4, e5, e6, others))

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.tailSet(E,boolean)"""
        return 'ImmutableSortedSet'._wrap(super(_ImmutableSortedSet, self).tailSet(fromElement, _boolean.valueOf(inclusive)))

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.subSet(E,boolean,E,boolean)"""
        return 'ImmutableSortedSet'._wrap(super(_ImmutableSortedSet, self).subSet(fromElement, _boolean.valueOf(fromInclusive), toElement, _boolean.valueOf(toInclusive)))

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool._wrap(super(_ImmutableCollection, self).add(e))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Collection') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.util.Collection<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(comparator, elements))

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSortedSet.iterator()"""
        pass

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(element))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'._wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def pollLast(self) -> object:
        """public final E com.google.common.collect.ImmutableSortedSet.pollLast()"""
        return object._wrap(super(ImmutableSortedSet, self).pollLast())

    @overload
    def headSet(self, toElement: object) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.headSet(E)"""
        return 'ImmutableSortedSet'._wrap(super(_ImmutableSortedSet, self).headSet(toElement))

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.ceiling(E)"""
        return object._wrap(super(_ImmutableSortedSet, self).ceiling(e))

    @abstractmethod
    def descendingIterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSortedSet.descendingIterator()"""
        pass

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'._wrap(super(NavigableSet, self).reversed())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ImmutableSortedSet.comparator()"""
        return 'Comparator'._wrap(super(ImmutableSortedSet, self).comparator())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @staticmethod
    @overload
    def toImmutableSet() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSet<E>> com.google.common.collect.ImmutableSortedSet.toImmutableSet()"""
        return Collector._wrap(_ImmutableSortedSet.toImmutableSet())

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableSet.hashCode()"""
        return int._wrap(super(ImmutableSet, self).hashCode())

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterator') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.util.Iterator<? extends E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(comparator, elements))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool._wrap(super(_ImmutableCollection, self).addAll(newElements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E)"""
        return ImmutableSet._wrap(_ImmutableSet.of(e1, e2, e3, e4))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str._wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableSortedSet.spliterator()"""
        return 'Spliterator'._wrap(super(ImmutableSortedSet, self).spliterator())

    @override
    @overload
    def descendingSet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.descendingSet()"""
        return 'ImmutableSortedSet'._wrap(super(ImmutableSortedSet, self).descendingSet())

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.headSet(E,boolean)"""
        return 'ImmutableSortedSet'._wrap(super(_ImmutableSortedSet, self).headSet(toElement, _boolean.valueOf(inclusive)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(_object, self).wait(_long.valueOf(arg0), _int.valueOf(arg1))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object._wrap(super(SortedSet, self).getFirst())

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2))

    @staticmethod
    @overload
    def copyOfSorted(sortedSet: 'SortedSet') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOfSorted(java.util.SortedSet<E>)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOfSorted(sortedSet))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool._wrap(super(_ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *remaining: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, remaining))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.builder()"""
        return Builder._wrap(_ImmutableSortedSet.builder())

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableSortedSet.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'._wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def copyOf(elements: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(E[])"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def of() -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of()"""
        return ImmutableSet._wrap(_ImmutableSet.of())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'._wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of(element: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E)"""
        return ImmutableSortedSet._wrap(_ImmutableSortedSet.of(element))

    @override
    @overload
    def pollFirst(self) -> object:
        """public final E com.google.common.collect.ImmutableSortedSet.pollFirst()"""
        return object._wrap(super(ImmutableSortedSet, self).pollFirst())

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builderWithExpectedSize(int)"""
        return Builder._wrap(_ImmutableSet.builderWithExpectedSize(_int.valueOf(expectedSize)))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(_Iterable, self).forEach(arg0)

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSet._wrap(_ImmutableSet.copyOf(elements))

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.last()"""
        return object._wrap(super(ImmutableSortedSet, self).last())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool._wrap(super(AbstractCollection, self).isEmpty())