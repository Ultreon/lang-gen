from __future__ import annotations
from overload import overload


 
import com.google.common.collect.MapDifference as __MapDifference
__MapDifference = __MapDifference
from abc import abstractmethod, ABC
 
class MapDifference(ABC):
    """com.google.common.collect.MapDifference"""
 
    @staticmethod
    def __wrap(java_value: __MapDifference) -> 'MapDifference':
        return MapDifference(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __MapDifference):
        """
        Dynamic initializer for MapDifference.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def entriesDiffering(self, ):
        """public abstract java.util.Map<K, com.google.common.collect.MapDifference$ValueDifference<V>> com.google.common.collect.MapDifference.entriesDiffering()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.MapDifference.hashCode()"""
        pass

    @abstractmethod
    def entriesOnlyOnLeft(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesOnlyOnLeft()"""
        pass

    @abstractmethod
    def areEqual(self, ):
        """public abstract boolean com.google.common.collect.MapDifference.areEqual()"""
        pass

    @abstractmethod
    def entriesInCommon(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesInCommon()"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.MapDifference.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def entriesOnlyOnRight(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesOnlyOnRight()"""
        pass

 
 
 
# CLASS: com.google.common.collect.MapDifference
import com.google.common.collect.MapDifference as __MapDifference
__MapDifference = __MapDifference
from abc import abstractmethod, ABC
 
class MapDifference(ABC):
    """com.google.common.collect.MapDifference"""
 
    @staticmethod
    def __wrap(java_value: __MapDifference) -> 'MapDifference':
        return MapDifference(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __MapDifference):
        """
        Dynamic initializer for MapDifference.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def entriesDiffering(self, ):
        """public abstract java.util.Map<K, com.google.common.collect.MapDifference$ValueDifference<V>> com.google.common.collect.MapDifference.entriesDiffering()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.MapDifference.hashCode()"""
        pass

    @abstractmethod
    def entriesOnlyOnLeft(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesOnlyOnLeft()"""
        pass

    @abstractmethod
    def areEqual(self, ):
        """public abstract boolean com.google.common.collect.MapDifference.areEqual()"""
        pass

    @abstractmethod
    def entriesInCommon(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesInCommon()"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.MapDifference.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def entriesOnlyOnRight(self, ):
        """public abstract java.util.Map<K, V> com.google.common.collect.MapDifference.entriesOnlyOnRight()"""
        pass

 
 
 
# CLASS: com.google.common.collect.MapDifference 
 
 
# CLASS: com.google.common.collect.ImmutableBiMap$Builder
import com.google.common.collect.ImmutableBiMap as __ImmutableBiMap
__ImmutableBiMap = __ImmutableBiMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ImmutableBiMap as __ImmutableBiMap_Builder
__Builder = __ImmutableBiMap_Builder.Builder
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableBiMap.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableBiMap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).put(entry))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableBiMap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def putAll(self, map: 'Map') -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.putAll(java.util.Map<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(map))

    @override
    @overload
    def buildKeepingLast(self) -> 'ImmutableBiMap':
        """public com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap$Builder.buildKeepingLast()"""
        return 'ImmutableBiMap'.__wrap(super(Builder, self).buildKeepingLast())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def buildOrThrow(self) -> 'ImmutableBiMap':
        """public com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap$Builder.buildOrThrow()"""
        return 'ImmutableBiMap'.__wrap(super(Builder, self).buildOrThrow())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.put(K,V)"""
        return 'Builder'.__wrap(super(__Builder, self).put(key, value))

    @override
    @overload
    def build(self) -> 'ImmutableBiMap':
        """public com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap$Builder.build()"""
        return 'ImmutableBiMap'.__wrap(super(Builder, self).build())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(entries))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def orderEntriesByValue(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap$Builder.orderEntriesByValue(java.util.Comparator<? super V>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderEntriesByValue(valueComparator))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedSet
import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet
__ImmutableSortedSet = __ImmutableSortedSet
import java.util.function.Predicate as Predicate
import java.lang.Boolean as __boolean
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.ImmutableSet as __ImmutableSet_Builder
__Builder = __ImmutableSet_Builder.Builder
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import java.util.SortedSet as SortedSet
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet_Builder
__Builder = __ImmutableSortedSet_Builder.Builder
from builtins import object
import java.lang.Comparable as Comparable
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
from typing import List
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ImmutableSortedSet(ABC):
    """com.google.common.collect.ImmutableSortedSet"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableSortedSet) -> 'ImmutableSortedSet':
        return ImmutableSortedSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableSortedSet):
        """
        Dynamic initializer for ImmutableSortedSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSortedSet':
        """public static <Z> com.google.common.collect.ImmutableSortedSet<Z> com.google.common.collect.ImmutableSortedSet.copyOf(Z[])"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4))

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.lower(E)"""
        return object.__wrap(super(__ImmutableSortedSet, self).lower(e))

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.subSet(E,boolean,E,boolean)"""
        return 'ImmutableSortedSet'.__wrap(super(__ImmutableSortedSet, self).subSet(fromElement, __boolean.valueOf(fromInclusive), toElement, __boolean.valueOf(toInclusive)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *remaining: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, remaining))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable', e6: 'Comparable', *remaining: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, remaining))

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.last()"""
        return object.__wrap(super(ImmutableSortedSet, self).last())

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Collection') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.util.Collection<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(comparator, elements))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableSet, self).equals(object))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @abstractmethod
    def contains(self, object: object):
        """public abstract boolean com.google.common.collect.ImmutableCollection.contains(java.lang.Object)"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool.__wrap(super(__ImmutableCollection, self).add(e))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(__SortedSet, self).addLast(arg0)

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'.__wrap(super(NavigableSet, self).reversed())

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object].__wrap(super(__ImmutableCollection, self).toArray(other))

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableCollection, self).remove(object))

    @staticmethod
    @overload
    def naturalOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.naturalOrder()"""
        return Builder.__wrap(__ImmutableSortedSet.naturalOrder())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object.__wrap(super(SortedSet, self).getFirst())

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object.__wrap(super(NavigableSet, self).removeFirst())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.builder()"""
        return Builder.__wrap(__ImmutableSortedSet.builder())

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.subSet(E,E)"""
        return 'ImmutableSortedSet'.__wrap(super(__ImmutableSortedSet, self).subSet(fromElement, toElement))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(__SortedSet, self).addFirst(arg0)

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableSet.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeIf(filter))

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.higher(E)"""
        return object.__wrap(super(__ImmutableSortedSet, self).higher(e))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @overload
    def headSet(self, toElement: object) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.headSet(E)"""
        return 'ImmutableSortedSet'.__wrap(super(__ImmutableSortedSet, self).headSet(toElement))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ImmutableSortedSet.comparator()"""
        return 'Comparator'.__wrap(super(ImmutableSortedSet, self).comparator())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableSet.hashCode()"""
        return int.__wrap(super(ImmutableSet, self).hashCode())

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterable') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.lang.Iterable<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(comparator, elements))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builder()"""
        return Builder.__wrap(__ImmutableSet.builder())

    @staticmethod
    @overload
    def of(element: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(element))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def reverseOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.reverseOrder()"""
        return Builder.__wrap(__ImmutableSortedSet.reverseOrder())

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableSortedSet.spliterator()"""
        return 'Spliterator'.__wrap(super(ImmutableSortedSet, self).spliterator())

    @override
    @overload
    def pollFirst(self) -> object:
        """public final E com.google.common.collect.ImmutableSortedSet.pollFirst()"""
        return object.__wrap(super(ImmutableSortedSet, self).pollFirst())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def toImmutableSortedSet(comparator: 'Comparator') -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSortedSet<E>> com.google.common.collect.ImmutableSortedSet.toImmutableSortedSet(java.util.Comparator<? super E>)"""
        return Collector.__wrap(__ImmutableSortedSet.toImmutableSortedSet(comparator))

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(E[])"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @overload
    def tailSet(self, fromElement: object) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.tailSet(E)"""
        return 'ImmutableSortedSet'.__wrap(super(__ImmutableSortedSet, self).tailSet(fromElement))

    @staticmethod
    @overload
    def copyOfSorted(sortedSet: 'SortedSet') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOfSorted(java.util.SortedSet<E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOfSorted(sortedSet))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3))

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSortedSet.iterator()"""
        pass

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def of() -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of()"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of())

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(element))

    @override
    @overload
    def pollLast(self) -> object:
        """public final E com.google.common.collect.ImmutableSortedSet.pollLast()"""
        return object.__wrap(super(ImmutableSortedSet, self).pollLast())

    @abstractmethod
    def descendingIterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSortedSet.descendingIterator()"""
        pass

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3))

    @staticmethod
    @overload
    def copyOf(elements: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(E[])"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.floor(E)"""
        return object.__wrap(super(__ImmutableSortedSet, self).floor(e))

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.tailSet(E,boolean)"""
        return 'ImmutableSortedSet'.__wrap(super(__ImmutableSortedSet, self).tailSet(fromElement, __boolean.valueOf(inclusive)))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object.__wrap(super(SortedSet, self).getLast())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object].__wrap(super(ImmutableCollection, self).toArray())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4, e5))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterator') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.util.Iterator<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(comparator, elements))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).addAll(newElements))

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.ceiling(E)"""
        return object.__wrap(super(__ImmutableSortedSet, self).ceiling(e))

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.orderedBy(java.util.Comparator<E>)"""
        return Builder.__wrap(__ImmutableSortedSet.orderedBy(comparator))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(element))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableSortedSet.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object.__wrap(super(NavigableSet, self).removeLast())

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.headSet(E,boolean)"""
        return 'ImmutableSortedSet'.__wrap(super(__ImmutableSortedSet, self).headSet(toElement, __boolean.valueOf(inclusive)))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4, e5, e6, others))

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.first()"""
        return object.__wrap(super(ImmutableSortedSet, self).first())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2))

    @override
    @overload
    def descendingSet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.descendingSet()"""
        return 'ImmutableSortedSet'.__wrap(super(ImmutableSortedSet, self).descendingSet())

    @staticmethod
    @overload
    def toImmutableSet() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSet<E>> com.google.common.collect.ImmutableSortedSet.toImmutableSet()"""
        return Collector.__wrap(__ImmutableSortedSet.toImmutableSet())

    @staticmethod
    @overload
    def of() -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of()"""
        return ImmutableSet.__wrap(__ImmutableSet.of())

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4, e5))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4)) 
 
 
# CLASS: com.google.common.collect.ImmutableList$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Iterator as Iterator
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import com.google.common.collect.ImmutableList as __ImmutableList_Builder
__Builder = __ImmutableList_Builder.Builder
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableList.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList$Builder.add(E)"""
        return 'Builder'.__wrap(super(__Builder, self).add(element))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList$Builder.add(E...)"""
        return 'Builder'.__wrap(super(__Builder, self).add(elements))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableList$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableList$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def build(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList$Builder.build()"""
        return 'ImmutableList'.__wrap(super(Builder, self).build())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ImmutableMultiset$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset
__ImmutableMultiset = __ImmutableMultiset
import java.util.Iterator as Iterator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset_Builder
__Builder = __ImmutableMultiset_Builder.Builder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableMultiset.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @overload
    def setCount(self, element: object, count: int) -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.setCount(E,int)"""
        return 'Builder'.__wrap(super(__Builder, self).setCount(element, __int.valueOf(count)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableMultiset$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.add(E)"""
        return 'Builder'.__wrap(super(__Builder, self).add(element))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableMultiset$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def addCopies(self, element: object, occurrences: int) -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.addCopies(E,int)"""
        return 'Builder'.__wrap(super(__Builder, self).addCopies(element, __int.valueOf(occurrences)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.add(E...)"""
        return 'Builder'.__wrap(super(__Builder, self).add(elements))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @override
    @overload
    def build(self) -> 'ImmutableMultiset':
        """public com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset$Builder.build()"""
        return 'ImmutableMultiset'.__wrap(super(Builder, self).build())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMap$StandardKeySet
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.Sets as __Sets_ImprovedAbstractSet
__ImprovedAbstractSet = __Sets_ImprovedAbstractSet.ImprovedAbstractSet
from builtins import bool
import java.util.AbstractSet as __AbstractSet
__AbstractSet = __AbstractSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.SortedSet as SortedSet
import com.google.common.collect.Maps as __Maps_KeySet
__KeySet = __Maps_KeySet.KeySet
from builtins import object
import com.google.common.collect.ForwardingSortedMap as __ForwardingSortedMap_StandardKeySet
__StandardKeySet = __ForwardingSortedMap_StandardKeySet.StandardKeySet
import java.util.Iterator as Iterator
import com.google.common.collect.Maps as __Maps_SortedKeySet
__SortedKeySet = __Maps_SortedKeySet.SortedKeySet
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
 
class StandardKeySet():
    """com.google.common.collect.ForwardingSortedMap.StandardKeySet"""
 
    @staticmethod
    def __wrap(java_value: __StandardKeySet) -> 'StandardKeySet':
        return StandardKeySet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardKeySet):
        """
        Dynamic initializer for StandardKeySet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$SortedKeySet.tailSet(K)"""
        return 'SortedSet'.__wrap(super(__SortedKeySet, self).tailSet(fromElement))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$KeySet.clear()"""
        super(KeySet, self).clear()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.google.common.collect.Maps$KeySet.iterator()"""
        return 'Iterator'.__wrap(super(KeySet, self).iterator())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'.__wrap(super(SortedSet, self).spliterator())

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.remove(java.lang.Object)"""
        return bool.__wrap(super(__KeySet, self).remove(o))

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.contains(java.lang.Object)"""
        return bool.__wrap(super(__KeySet, self).contains(o))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def reversed(self) -> 'SortedSet':
        """public default java.util.SortedSet<E> java.util.SortedSet.reversed()"""
        return 'SortedSet'.__wrap(super(SortedSet, self).reversed())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.Maps$SortedKeySet.comparator()"""
        return 'Comparator'.__wrap(super(SortedKeySet, self).comparator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool.__wrap(super(__AbstractCollection, self).add(arg0))

    @overload
    def __init__(self, this$0: 'ForwardingSortedMap'):
        """public com.google.common.collect.ForwardingSortedMap$StandardKeySet(com.google.common.collect.ForwardingSortedMap)"""
        val = __StandardKeySet(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.SortedSet.removeLast()"""
        return object.__wrap(super(SortedSet, self).removeLast())

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(__SortedSet, self).addLast(arg0)

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$SortedKeySet.headSet(K)"""
        return 'SortedSet'.__wrap(super(__SortedKeySet, self).headSet(toElement))

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object.__wrap(super(SortedSet, self).getLast())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object.__wrap(super(SortedSet, self).getFirst())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def first(self) -> object:
        """public K com.google.common.collect.Maps$SortedKeySet.first()"""
        return object.__wrap(super(SortedKeySet, self).first())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.isEmpty()"""
        return bool.__wrap(super(KeySet, self).isEmpty())

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(__SortedSet, self).addFirst(arg0)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$SortedKeySet.subSet(K,K)"""
        return 'SortedSet'.__wrap(super(__SortedKeySet, self).subSet(fromElement, toElement))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$KeySet.size()"""
        return int.__wrap(super(KeySet, self).size())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public void com.google.common.collect.Maps$KeySet.forEach(java.util.function.Consumer<? super K>)"""
        super(__KeySet, self).forEach(action)

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.SortedSet.removeFirst()"""
        return object.__wrap(super(SortedSet, self).removeFirst())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def last(self) -> object:
        """public K com.google.common.collect.Maps$SortedKeySet.last()"""
        return object.__wrap(super(SortedKeySet, self).last())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractSet, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int.__wrap(super(AbstractSet, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableListMultimap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableListMultimap as __ImmutableListMultimap_Builder
__Builder = __ImmutableListMultimap_Builder.Builder
import java.lang.String as __String
__String = __String
import com.google.common.collect.ImmutableListMultimap as __ImmutableListMultimap
__ImmutableListMultimap = __ImmutableListMultimap
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableListMultimap.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableListMultimap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(entries))

    @override
    @overload
    def build(self) -> 'ImmutableListMultimap':
        """public com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap$Builder.build()"""
        return 'ImmutableListMultimap'.__wrap(super(Builder, self).build())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def putAll(self, key: object, *values: object) -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.putAll(K,V...)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(key, values))

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.put(K,V)"""
        return 'Builder'.__wrap(super(__Builder, self).put(key, value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def orderKeysBy(self, keyComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.orderKeysBy(java.util.Comparator<? super K>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderKeysBy(keyComparator))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableListMultimap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def putAll(self, key: object, values: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.putAll(K,java.lang.Iterable<? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(key, values))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def orderValuesBy(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.orderValuesBy(java.util.Comparator<? super V>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderValuesBy(valueComparator))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def putAll(self, multimap: 'Multimap') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(multimap))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).put(entry)) 
 
 
# CLASS: com.google.common.collect.ImmutableRangeMap$Builder
from builtins import str
import com.google.common.collect.ImmutableRangeMap as __ImmutableRangeMap_Builder
__Builder = __ImmutableRangeMap_Builder.Builder
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableRangeMap as __ImmutableRangeMap
__ImmutableRangeMap = __ImmutableRangeMap
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableRangeMap.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def build(self) -> 'ImmutableRangeMap':
        """public com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap$Builder.build()"""
        return 'ImmutableRangeMap'.__wrap(super(Builder, self).build())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableRangeMap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def putAll(self, rangeMap: 'RangeMap') -> 'Builder':
        """public com.google.common.collect.ImmutableRangeMap$Builder<K, V> com.google.common.collect.ImmutableRangeMap$Builder.putAll(com.google.common.collect.RangeMap<K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(rangeMap))

    @overload
    def put(self, range: 'Range', value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableRangeMap$Builder<K, V> com.google.common.collect.ImmutableRangeMap$Builder.put(com.google.common.collect.Range<K>,V)"""
        return 'Builder'.__wrap(super(__Builder, self).put(range, value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableRangeMap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ImmutableCollection
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
from builtins import object
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ImmutableCollection(ABC):
    """com.google.common.collect.ImmutableCollection"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableCollection) -> 'ImmutableCollection':
        return ImmutableCollection(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableCollection):
        """
        Dynamic initializer for ImmutableCollection.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @overload
    def asList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableCollection.asList()"""
        return 'ImmutableList'.__wrap(super(ImmutableCollection, self).asList())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def contains(self, object: object):
        """public abstract boolean com.google.common.collect.ImmutableCollection.contains(java.lang.Object)"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool.__wrap(super(__ImmutableCollection, self).add(e))

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object].__wrap(super(__ImmutableCollection, self).toArray(other))

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableCollection.iterator()"""
        pass

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableCollection, self).remove(object))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object].__wrap(super(ImmutableCollection, self).toArray())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).addAll(newElements))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeAll(oldElements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableCollection.spliterator()"""
        return 'Spliterator'.__wrap(super(ImmutableCollection, self).spliterator()) 
 
 
# CLASS: com.google.common.collect.Streams$IntFunctionWithIndex
from abc import abstractmethod, ABC
import com.google.common.collect.Streams as __Streams_IntFunctionWithIndex
__IntFunctionWithIndex = __Streams_IntFunctionWithIndex.IntFunctionWithIndex
 
class IntFunctionWithIndex(ABC):
    """com.google.common.collect.Streams.IntFunctionWithIndex"""
 
    @staticmethod
    def __wrap(java_value: __IntFunctionWithIndex) -> 'IntFunctionWithIndex':
        return IntFunctionWithIndex(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __IntFunctionWithIndex):
        """
        Dynamic initializer for IntFunctionWithIndex.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, from: int, index: int):
        """public abstract R com.google.common.collect.Streams$IntFunctionWithIndex.apply(int,long)"""
        pass 
 
 
# CLASS: com.google.common.collect.Table$Cell
import com.google.common.collect.Table as __Table_Cell
__Cell = __Table_Cell.Cell
from abc import abstractmethod, ABC
 
class Cell(ABC):
    """com.google.common.collect.Table.Cell"""
 
    @staticmethod
    def __wrap(java_value: __Cell) -> 'Cell':
        return Cell(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Cell):
        """
        Dynamic initializer for Cell.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def getColumnKey(self, ):
        """public abstract C com.google.common.collect.Table$Cell.getColumnKey()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Table$Cell.hashCode()"""
        pass

    @abstractmethod
    def getRowKey(self, ):
        """public abstract R com.google.common.collect.Table$Cell.getRowKey()"""
        pass

    @abstractmethod
    def getValue(self, ):
        """public abstract V com.google.common.collect.Table$Cell.getValue()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.Table$Cell.equals(java.lang.Object)"""
        pass 
 
 
# CLASS: com.google.common.collect.TreeTraverser
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
from abc import abstractmethod, ABC
import java.lang.Long as __long
import com.google.common.collect.FluentIterable as __FluentIterable
__FluentIterable = __FluentIterable
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.TreeTraverser as __TreeTraverser
__TreeTraverser = __TreeTraverser
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class TreeTraverser(ABC):
    """com.google.common.collect.TreeTraverser"""
 
    @staticmethod
    def __wrap(java_value: __TreeTraverser) -> 'TreeTraverser':
        return TreeTraverser(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __TreeTraverser):
        """
        Dynamic initializer for TreeTraverser.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def using(nodeToChildrenFunction: 'Function') -> 'TreeTraverser':
        """public static <T> com.google.common.collect.TreeTraverser<T> com.google.common.collect.TreeTraverser.using(com.google.common.base.Function<T, ? extends java.lang.Iterable<T>>)"""
        return TreeTraverser.__wrap(__TreeTraverser.using(nodeToChildrenFunction))

    @overload
    def preOrderTraversal(self, root: object) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<T> com.google.common.collect.TreeTraverser.preOrderTraversal(T)"""
        return 'FluentIterable'.__wrap(super(__TreeTraverser, self).preOrderTraversal(root))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def postOrderTraversal(self, root: object) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<T> com.google.common.collect.TreeTraverser.postOrderTraversal(T)"""
        return 'FluentIterable'.__wrap(super(__TreeTraverser, self).postOrderTraversal(root))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def __init__(self, ):
        """public com.google.common.collect.TreeTraverser()"""
        val = __TreeTraverser()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def breadthFirstTraversal(self, root: object) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<T> com.google.common.collect.TreeTraverser.breadthFirstTraversal(T)"""
        return 'FluentIterable'.__wrap(super(__TreeTraverser, self).breadthFirstTraversal(root))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.google.common.collect.TreeTraverser()"""
        val = __TreeTraverser()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @abstractmethod
    def children(self, root: object):
        """public abstract java.lang.Iterable<T> com.google.common.collect.TreeTraverser.children(T)"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMultiset
import com.google.common.collect.Multiset as __Multiset_Entry
__Entry = __Multiset_Entry.Entry
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import com.google.common.collect.SortedMultiset as __SortedMultiset
__SortedMultiset = __SortedMultiset
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.function.Consumer as Consumer
import com.google.common.collect.ForwardingSortedMultiset as __ForwardingSortedMultiset
__ForwardingSortedMultiset = __ForwardingSortedMultiset
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
import com.google.common.collect.ForwardingMultiset as __ForwardingMultiset
__ForwardingMultiset = __ForwardingMultiset
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ForwardingSortedMultiset(ABC):
    """com.google.common.collect.ForwardingSortedMultiset"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingSortedMultiset) -> 'ForwardingSortedMultiset':
        return ForwardingSortedMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingSortedMultiset):
        """
        Dynamic initializer for ForwardingSortedMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.add(E,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).add(element, __int.valueOf(occurrences)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def subMultiset(self, lowerBound: object, lowerBoundType: 'BoundType', upperBound: object, upperBoundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.ForwardingSortedMultiset.subMultiset(E,com.google.common.collect.BoundType,E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'.__wrap(super(__ForwardingSortedMultiset, self).subMultiset(lowerBound, lowerBoundType, upperBound, upperBoundType))

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__Multiset, self).forEachEntry(action)

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultiset, self).equals(object))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.setCount(E,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).setCount(element, __int.valueOf(count)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ForwardingMultiset.entrySet()"""
        return 'Set'.__wrap(super(ForwardingMultiset, self).entrySet())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def headMultiset(self, upperBound: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.ForwardingSortedMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'.__wrap(super(__ForwardingSortedMultiset, self).headMultiset(upperBound, boundType))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @overload
    def tailMultiset(self, lowerBound: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.ForwardingSortedMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'.__wrap(super(__ForwardingSortedMultiset, self).tailMultiset(lowerBound, boundType))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def elementSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingSortedMultiset.elementSet()"""
        return 'NavigableSet'.__wrap(super(ForwardingSortedMultiset, self).elementSet())

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.setCount(E,int,int)"""
        return bool.__wrap(super(__ForwardingMultiset, self).setCount(element, __int.valueOf(oldCount), __int.valueOf(newCount)))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def firstEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ForwardingSortedMultiset.firstEntry()"""
        return 'Entry'.__wrap(super(ForwardingSortedMultiset, self).firstEntry())

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ForwardingSortedMultiset.pollFirstEntry()"""
        return 'Entry'.__wrap(super(ForwardingSortedMultiset, self).pollFirstEntry())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @override
    @overload
    def pollLastEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ForwardingSortedMultiset.pollLastEntry()"""
        return 'Entry'.__wrap(super(ForwardingSortedMultiset, self).pollLastEntry())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def descendingMultiset(self) -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.ForwardingSortedMultiset.descendingMultiset()"""
        return 'SortedMultiset'.__wrap(super(ForwardingSortedMultiset, self).descendingMultiset())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.remove(java.lang.Object,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).remove(element, __int.valueOf(occurrences)))

    @override
    @overload
    def lastEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ForwardingSortedMultiset.lastEntry()"""
        return 'Entry'.__wrap(super(ForwardingSortedMultiset, self).lastEntry())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ForwardingSortedMultiset.comparator()"""
        return 'Comparator'.__wrap(super(ForwardingSortedMultiset, self).comparator())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingMultiset.count(java.lang.Object)"""
        return int.__wrap(super(__ForwardingMultiset, self).count(element))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultiset.hashCode()"""
        return int.__wrap(super(ForwardingMultiset, self).hashCode())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.Sets
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.Collection as Collection
import java.util.TreeSet as TreeSet
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.lang.Class as __Class
__Class = __Class
import java.util.EnumSet as __EnumSet
__EnumSet = __EnumSet
import com.google.common.collect.Sets as __Sets_SetView
__SetView = __Sets_SetView.SetView
import java.util.concurrent.CopyOnWriteArraySet as __CopyOnWriteArraySet
__CopyOnWriteArraySet = __CopyOnWriteArraySet
import java.util.TreeSet as __TreeSet
__TreeSet = __TreeSet
from builtins import bool
import com.google.common.collect.Sets as __Sets
__Sets = __Sets
from builtins import str
import java.util.NavigableSet as NavigableSet
from pyquantum_helper import override
import java.util.HashSet as HashSet
import java.lang.Object as __object
import java.util.Set as __Set
__Set = __Set
import java.util.HashSet as __HashSet
__HashSet = __HashSet
import java.lang.Iterable as Iterable
import java.util.concurrent.CopyOnWriteArraySet as CopyOnWriteArraySet
import java.util.SortedSet as SortedSet
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
from builtins import object
import java.util.stream.Collector as Collector
import java.util.LinkedHashSet as LinkedHashSet
import java.util.Iterator as Iterator
import java.lang.Enum as Enum
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.lang.Long as __long
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.util.EnumSet as EnumSet
import java.lang.Object as __Object
__Object = __Object
import java.util.LinkedHashSet as __LinkedHashSet
__LinkedHashSet = __LinkedHashSet
import java.lang.Integer as __int
import java.util.Map as Map
import java.util.List as List
from builtins import int
 
class Sets():
    """com.google.common.collect.Sets"""
 
    @staticmethod
    def __wrap(java_value: __Sets) -> 'Sets':
        return Sets(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Sets):
        """
        Dynamic initializer for Sets.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def complementOf(collection: 'Collection') -> 'EnumSet':
        """public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> com.google.common.collect.Sets.complementOf(java.util.Collection<E>)"""
        return EnumSet.__wrap(__Sets.complementOf(collection))

    @staticmethod
    @overload
    def toImmutableEnumSet() -> 'Collector':
        """public static <E extends java.lang.Enum<E>> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSet<E>> com.google.common.collect.Sets.toImmutableEnumSet()"""
        return Collector.__wrap(__Sets.toImmutableEnumSet())

    @staticmethod
    @overload
    def newTreeSet(comparator: 'Comparator') -> 'TreeSet':
        """public static <E> java.util.TreeSet<E> com.google.common.collect.Sets.newTreeSet(java.util.Comparator<? super E>)"""
        return TreeSet.__wrap(__Sets.newTreeSet(comparator))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def newTreeSet() -> 'TreeSet':
        """public static <E extends java.lang.Comparable> java.util.TreeSet<E> com.google.common.collect.Sets.newTreeSet()"""
        return TreeSet.__wrap(__Sets.newTreeSet())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def difference(set1: 'Set', set2: 'Set') -> 'SetView':
        """public static <E> com.google.common.collect.Sets$SetView<E> com.google.common.collect.Sets.difference(java.util.Set<E>,java.util.Set<?>)"""
        return SetView.__wrap(__Sets.difference(set1, set2))

    @staticmethod
    @overload
    def union(set1: 'Set', set2: 'Set') -> 'SetView':
        """public static <E> com.google.common.collect.Sets$SetView<E> com.google.common.collect.Sets.union(java.util.Set<? extends E>,java.util.Set<? extends E>)"""
        return SetView.__wrap(__Sets.union(set1, set2))

    @staticmethod
    @overload
    def newLinkedHashSet() -> 'LinkedHashSet':
        """public static <E> java.util.LinkedHashSet<E> com.google.common.collect.Sets.newLinkedHashSet()"""
        return LinkedHashSet.__wrap(__Sets.newLinkedHashSet())

    @staticmethod
    @overload
    def newConcurrentHashSet(elements: 'Iterable') -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.newConcurrentHashSet(java.lang.Iterable<? extends E>)"""
        return Set.__wrap(__Sets.newConcurrentHashSet(elements))

    @staticmethod
    @overload
    def combinations(set: 'Set', size: int) -> 'Set':
        """public static <E> java.util.Set<java.util.Set<E>> com.google.common.collect.Sets.combinations(java.util.Set<E>,int)"""
        return Set.__wrap(__Sets.combinations(set, __int.valueOf(size)))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def newCopyOnWriteArraySet() -> 'CopyOnWriteArraySet':
        """public static <E> java.util.concurrent.CopyOnWriteArraySet<E> com.google.common.collect.Sets.newCopyOnWriteArraySet()"""
        return CopyOnWriteArraySet.__wrap(__Sets.newCopyOnWriteArraySet())

    @staticmethod
    @overload
    def newHashSet(elements: 'Iterator') -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSet(java.util.Iterator<? extends E>)"""
        return HashSet.__wrap(__Sets.newHashSet(elements))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def newTreeSet(elements: 'Iterable') -> 'TreeSet':
        """public static <E extends java.lang.Comparable> java.util.TreeSet<E> com.google.common.collect.Sets.newTreeSet(java.lang.Iterable<? extends E>)"""
        return TreeSet.__wrap(__Sets.newTreeSet(elements))

    @staticmethod
    @overload
    def synchronizedNavigableSet(navigableSet: 'NavigableSet') -> 'NavigableSet':
        """public static <E> java.util.NavigableSet<E> com.google.common.collect.Sets.synchronizedNavigableSet(java.util.NavigableSet<E>)"""
        return NavigableSet.__wrap(__Sets.synchronizedNavigableSet(navigableSet))

    @staticmethod
    @overload
    def newHashSet(*elements: object) -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSet(E...)"""
        return HashSet.__wrap(__Sets.newHashSet(elements))

    @staticmethod
    @overload
    def filter(unfiltered: 'SortedSet', predicate: 'Predicate') -> 'SortedSet':
        """public static <E> java.util.SortedSet<E> com.google.common.collect.Sets.filter(java.util.SortedSet<E>,com.google.common.base.Predicate<? super E>)"""
        return SortedSet.__wrap(__Sets.filter(unfiltered, predicate))

    @staticmethod
    @overload
    def complementOf(collection: 'Collection', type: 'Class') -> 'EnumSet':
        """public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> com.google.common.collect.Sets.complementOf(java.util.Collection<E>,java.lang.Class<E>)"""
        return EnumSet.__wrap(__Sets.complementOf(collection, type))

    @staticmethod
    @overload
    def newHashSetWithExpectedSize(expectedSize: int) -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSetWithExpectedSize(int)"""
        return HashSet.__wrap(__Sets.newHashSetWithExpectedSize(__int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def intersection(set1: 'Set', set2: 'Set') -> 'SetView':
        """public static <E> com.google.common.collect.Sets$SetView<E> com.google.common.collect.Sets.intersection(java.util.Set<E>,java.util.Set<?>)"""
        return SetView.__wrap(__Sets.intersection(set1, set2))

    @staticmethod
    @overload
    def newConcurrentHashSet() -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.newConcurrentHashSet()"""
        return Set.__wrap(__Sets.newConcurrentHashSet())

    @staticmethod
    @overload
    def symmetricDifference(set1: 'Set', set2: 'Set') -> 'SetView':
        """public static <E> com.google.common.collect.Sets$SetView<E> com.google.common.collect.Sets.symmetricDifference(java.util.Set<? extends E>,java.util.Set<? extends E>)"""
        return SetView.__wrap(__Sets.symmetricDifference(set1, set2))

    @staticmethod
    @overload
    def newIdentityHashSet() -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.newIdentityHashSet()"""
        return Set.__wrap(__Sets.newIdentityHashSet())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def newSetFromMap(map: 'Map') -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.newSetFromMap(java.util.Map<E, java.lang.Boolean>)"""
        return Set.__wrap(__Sets.newSetFromMap(map))

    @staticmethod
    @overload
    def cartesianProduct(sets: 'List') -> 'Set':
        """public static <B> java.util.Set<java.util.List<B>> com.google.common.collect.Sets.cartesianProduct(java.util.List<? extends java.util.Set<? extends B>>)"""
        return Set.__wrap(__Sets.cartesianProduct(sets))

    @staticmethod
    @overload
    def newCopyOnWriteArraySet(elements: 'Iterable') -> 'CopyOnWriteArraySet':
        """public static <E> java.util.concurrent.CopyOnWriteArraySet<E> com.google.common.collect.Sets.newCopyOnWriteArraySet(java.lang.Iterable<? extends E>)"""
        return CopyOnWriteArraySet.__wrap(__Sets.newCopyOnWriteArraySet(elements))

    @staticmethod
    @overload
    def newEnumSet(iterable: 'Iterable', elementType: 'Class') -> 'EnumSet':
        """public static <E extends java.lang.Enum<E>> java.util.EnumSet<E> com.google.common.collect.Sets.newEnumSet(java.lang.Iterable<E>,java.lang.Class<E>)"""
        return EnumSet.__wrap(__Sets.newEnumSet(iterable, elementType))

    @staticmethod
    @overload
    def newHashSet() -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSet()"""
        return HashSet.__wrap(__Sets.newHashSet())

    @staticmethod
    @overload
    def immutableEnumSet(elements: 'Iterable') -> 'ImmutableSet':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.ImmutableSet<E> com.google.common.collect.Sets.immutableEnumSet(java.lang.Iterable<E>)"""
        return ImmutableSet.__wrap(__Sets.immutableEnumSet(elements))

    @staticmethod
    @overload
    def powerSet(set: 'Set') -> 'Set':
        """public static <E> java.util.Set<java.util.Set<E>> com.google.common.collect.Sets.powerSet(java.util.Set<E>)"""
        return Set.__wrap(__Sets.powerSet(set))

    @staticmethod
    @overload
    def immutableEnumSet(anElement: 'Enum', *otherElements: 'Enum') -> 'ImmutableSet':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.ImmutableSet<E> com.google.common.collect.Sets.immutableEnumSet(E,E...)"""
        return ImmutableSet.__wrap(__Sets.immutableEnumSet(anElement, otherElements))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def subSet(set: 'NavigableSet', range: 'Range') -> 'NavigableSet':
        """public static <K extends java.lang.Comparable<? super K>> java.util.NavigableSet<K> com.google.common.collect.Sets.subSet(java.util.NavigableSet<K>,com.google.common.collect.Range<K>)"""
        return NavigableSet.__wrap(__Sets.subSet(set, range))

    @staticmethod
    @overload
    def newLinkedHashSet(elements: 'Iterable') -> 'LinkedHashSet':
        """public static <E> java.util.LinkedHashSet<E> com.google.common.collect.Sets.newLinkedHashSet(java.lang.Iterable<? extends E>)"""
        return LinkedHashSet.__wrap(__Sets.newLinkedHashSet(elements))

    @staticmethod
    @overload
    def filter(unfiltered: 'Set', predicate: 'Predicate') -> 'Set':
        """public static <E> java.util.Set<E> com.google.common.collect.Sets.filter(java.util.Set<E>,com.google.common.base.Predicate<? super E>)"""
        return Set.__wrap(__Sets.filter(unfiltered, predicate))

    @staticmethod
    @overload
    def cartesianProduct(*sets: 'Set') -> 'Set':
        """public static <B> java.util.Set<java.util.List<B>> com.google.common.collect.Sets.cartesianProduct(java.util.Set<? extends B>...)"""
        return Set.__wrap(__Sets.cartesianProduct(sets))

    @staticmethod
    @overload
    def filter(unfiltered: 'NavigableSet', predicate: 'Predicate') -> 'NavigableSet':
        """public static <E> java.util.NavigableSet<E> com.google.common.collect.Sets.filter(java.util.NavigableSet<E>,com.google.common.base.Predicate<? super E>)"""
        return NavigableSet.__wrap(__Sets.filter(unfiltered, predicate))

    @staticmethod
    @overload
    def unmodifiableNavigableSet(set: 'NavigableSet') -> 'NavigableSet':
        """public static <E> java.util.NavigableSet<E> com.google.common.collect.Sets.unmodifiableNavigableSet(java.util.NavigableSet<E>)"""
        return NavigableSet.__wrap(__Sets.unmodifiableNavigableSet(set))

    @staticmethod
    @overload
    def newHashSet(elements: 'Iterable') -> 'HashSet':
        """public static <E> java.util.HashSet<E> com.google.common.collect.Sets.newHashSet(java.lang.Iterable<? extends E>)"""
        return HashSet.__wrap(__Sets.newHashSet(elements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def newLinkedHashSetWithExpectedSize(expectedSize: int) -> 'LinkedHashSet':
        """public static <E> java.util.LinkedHashSet<E> com.google.common.collect.Sets.newLinkedHashSetWithExpectedSize(int)"""
        return LinkedHashSet.__wrap(__Sets.newLinkedHashSetWithExpectedSize(__int.valueOf(expectedSize))) 
 
 
# CLASS: com.google.common.collect.HashMultimap
import java.lang.Long as __long
from pyquantum_helper import override
import java.lang.Class as __Class
__Class = __Class
from builtins import type
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.HashMultimap as __HashMultimap
__HashMultimap = __HashMultimap
import java.lang.Integer as __int
 
class HashMultimap():
    """com.google.common.collect.HashMultimap"""
 
    @staticmethod
    def __wrap(java_value: __HashMultimap) -> 'HashMultimap':
        return HashMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __HashMultimap):
        """
        Dynamic initializer for HashMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'HashMultimap':
        """public static <K,V> com.google.common.collect.HashMultimap<K, V> com.google.common.collect.HashMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return HashMultimap.__wrap(__HashMultimap.create(multimap))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def create() -> 'HashMultimap':
        """public static <K,V> com.google.common.collect.HashMultimap<K, V> com.google.common.collect.HashMultimap.create()"""
        return HashMultimap.__wrap(__HashMultimap.create())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create(expectedKeys: int, expectedValuesPerKey: int) -> 'HashMultimap':
        """public static <K,V> com.google.common.collect.HashMultimap<K, V> com.google.common.collect.HashMultimap.create(int,int)"""
        return HashMultimap.__wrap(__HashMultimap.create(__int.valueOf(expectedKeys), __int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0)) 
 
 
# CLASS: com.google.common.collect.ForwardingCollection
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ForwardingCollection(ABC):
    """com.google.common.collect.ForwardingCollection"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingCollection) -> 'ForwardingCollection':
        return ForwardingCollection(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingCollection):
        """
        Dynamic initializer for ForwardingCollection.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'.__wrap(super(Collection, self).spliterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.ForwardingDeque
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Deque as __Deque
__Deque = __Deque
import java.util.Collection as Collection
import com.google.common.collect.ForwardingDeque as __ForwardingDeque
__ForwardingDeque = __ForwardingDeque
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingQueue as __ForwardingQueue
__ForwardingQueue = __ForwardingQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.Deque as Deque
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ForwardingDeque(ABC):
    """com.google.common.collect.ForwardingDeque"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingDeque) -> 'ForwardingDeque':
        return ForwardingDeque(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingDeque):
        """
        Dynamic initializer for ForwardingDeque.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pollFirst()"""
        return object.__wrap(super(ForwardingDeque, self).pollFirst())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def remove(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.remove()"""
        return object.__wrap(super(ForwardingQueue, self).remove())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def addFirst(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.addFirst(E)"""
        super(__ForwardingDeque, self).addFirst(e)

    @overload
    def offer(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingQueue.offer(E)"""
        return bool.__wrap(super(__ForwardingQueue, self).offer(o))

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingDeque.descendingIterator()"""
        return 'Iterator'.__wrap(super(ForwardingDeque, self).descendingIterator())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @overload
    def offerLast(self, e: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.offerLast(E)"""
        return bool.__wrap(super(__ForwardingDeque, self).offerLast(e))

    @override
    @overload
    def push(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.push(E)"""
        super(__ForwardingDeque, self).push(e)

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pollLast()"""
        return object.__wrap(super(ForwardingDeque, self).pollLast())

    @override
    @overload
    def peekFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.peekFirst()"""
        return object.__wrap(super(ForwardingDeque, self).peekFirst())

    @overload
    def removeLastOccurrence(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.removeLastOccurrence(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingDeque, self).removeLastOccurrence(o))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def reversed(self) -> 'Deque':
        """public default java.util.Deque<E> java.util.Deque.reversed()"""
        return 'Deque'.__wrap(super(Deque, self).reversed())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def pop(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pop()"""
        return object.__wrap(super(ForwardingDeque, self).pop())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.poll()"""
        return object.__wrap(super(ForwardingQueue, self).poll())

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.peek()"""
        return object.__wrap(super(ForwardingQueue, self).peek())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def peekLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.peekLast()"""
        return object.__wrap(super(ForwardingDeque, self).peekLast())

    @overload
    def offerFirst(self, e: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.offerFirst(E)"""
        return bool.__wrap(super(__ForwardingDeque, self).offerFirst(e))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'.__wrap(super(Collection, self).spliterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def element(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.element()"""
        return object.__wrap(super(ForwardingQueue, self).element())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def getLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.getLast()"""
        return object.__wrap(super(ForwardingDeque, self).getLast())

    @override
    @overload
    def removeLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.removeLast()"""
        return object.__wrap(super(ForwardingDeque, self).removeLast())

    @override
    @overload
    def getFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.getFirst()"""
        return object.__wrap(super(ForwardingDeque, self).getFirst())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def removeFirstOccurrence(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.removeFirstOccurrence(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingDeque, self).removeFirstOccurrence(o))

    @override
    @overload
    def addLast(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.addLast(E)"""
        super(__ForwardingDeque, self).addLast(e)

    @override
    @overload
    def removeFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.removeFirst()"""
        return object.__wrap(super(ForwardingDeque, self).removeFirst())

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.Streams$DoubleFunctionWithIndex
from abc import abstractmethod, ABC
import com.google.common.collect.Streams as __Streams_DoubleFunctionWithIndex
__DoubleFunctionWithIndex = __Streams_DoubleFunctionWithIndex.DoubleFunctionWithIndex
 
class DoubleFunctionWithIndex(ABC):
    """com.google.common.collect.Streams.DoubleFunctionWithIndex"""
 
    @staticmethod
    def __wrap(java_value: __DoubleFunctionWithIndex) -> 'DoubleFunctionWithIndex':
        return DoubleFunctionWithIndex(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __DoubleFunctionWithIndex):
        """
        Dynamic initializer for DoubleFunctionWithIndex.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, from: float, index: int):
        """public abstract R com.google.common.collect.Streams$DoubleFunctionWithIndex.apply(double,long)"""
        pass 
 
 
# CLASS: com.google.common.collect.ClassToInstanceMap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Map as __Map
__Map = __Map
from abc import abstractmethod, ABC
from builtins import object
import java.util.function.BiFunction as BiFunction
import com.google.common.collect.ClassToInstanceMap as __ClassToInstanceMap
__ClassToInstanceMap = __ClassToInstanceMap
import java.util.function.BiConsumer as BiConsumer
import java.lang.Object as __Object
__Object = __Object
import java.util.function.Function as Function
from builtins import bool
import java.util.Map as Map
 
class ClassToInstanceMap(ABC):
    """com.google.common.collect.ClassToInstanceMap"""
 
    @staticmethod
    def __wrap(java_value: __ClassToInstanceMap) -> 'ClassToInstanceMap':
        return ClassToInstanceMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ClassToInstanceMap):
        """
        Dynamic initializer for ClassToInstanceMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean java.util.Map.isEmpty()"""
        pass

    @abstractmethod
    def putAll(self, arg0: 'Map'):
        """public abstract void java.util.Map.putAll(java.util.Map<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def put(self, arg0: object, arg1: object):
        """public abstract V java.util.Map.put(K,V)"""
        pass

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @abstractmethod
    def clear(self, ):
        """public abstract void java.util.Map.clear()"""
        pass

    @abstractmethod
    def get(self, arg0: object):
        """public abstract V java.util.Map.get(java.lang.Object)"""
        pass

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @abstractmethod
    def containsValue(self, arg0: object):
        """public abstract boolean java.util.Map.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def remove(self, arg0: object):
        """public abstract V java.util.Map.remove(java.lang.Object)"""
        pass

    @abstractmethod
    def putInstance(self, type: 'Class', value: object):
        """public abstract <T extends B> T com.google.common.collect.ClassToInstanceMap.putInstance(java.lang.Class<T>,T)"""
        pass

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @abstractmethod
    def getInstance(self, type: 'Class'):
        """public abstract <T extends B> T com.google.common.collect.ClassToInstanceMap.getInstance(java.lang.Class<T>)"""
        pass

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @abstractmethod
    def containsKey(self, arg0: object):
        """public abstract boolean java.util.Map.containsKey(java.lang.Object)"""
        pass

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> java.util.Map.keySet()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int java.util.Map.hashCode()"""
        pass

    @abstractmethod
    def entrySet(self, ):
        """public abstract java.util.Set<java.util.Map$Entry<K, V>> java.util.Map.entrySet()"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.Map.size()"""
        pass

    @abstractmethod
    def equals(self, arg0: object):
        """public abstract boolean java.util.Map.equals(java.lang.Object)"""
        pass

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__Map, self).replaceAll(arg0)

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> java.util.Map.values()"""
        pass 
 
 
# CLASS: com.google.common.collect.Interners
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.base.Function as __Function
__Function = __Function
import com.google.common.collect.Interner as __Interner
__Interner = __Interner
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.Interners as __Interners
__Interners = __Interners
import com.google.common.collect.Interners as __Interners_InternerBuilder
__InternerBuilder = __Interners_InternerBuilder.InternerBuilder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Interners():
    """com.google.common.collect.Interners"""
 
    @staticmethod
    def __wrap(java_value: __Interners) -> 'Interners':
        return Interners(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Interners):
        """
        Dynamic initializer for Interners.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def newWeakInterner() -> 'Interner':
        """public static <E> com.google.common.collect.Interner<E> com.google.common.collect.Interners.newWeakInterner()"""
        return Interner.__wrap(__Interners.newWeakInterner())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def asFunction(interner: 'Interner') -> 'base.Function':
        """public static <E> com.google.common.base.Function<E, E> com.google.common.collect.Interners.asFunction(com.google.common.collect.Interner<E>)"""
        return base.Function.__wrap(__Interners.asFunction(interner))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def newBuilder() -> 'InternerBuilder':
        """public static com.google.common.collect.Interners$InternerBuilder com.google.common.collect.Interners.newBuilder()"""
        return InternerBuilder.__wrap(__Interners.newBuilder())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def newStrongInterner() -> 'Interner':
        """public static <E> com.google.common.collect.Interner<E> com.google.common.collect.Interners.newStrongInterner()"""
        return Interner.__wrap(__Interners.newStrongInterner())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ImmutableRangeSet$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableRangeSet as __ImmutableRangeSet_Builder
__Builder = __ImmutableRangeSet_Builder.Builder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ImmutableRangeSet as __ImmutableRangeSet
__ImmutableRangeSet = __ImmutableRangeSet
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableRangeSet.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableRangeSet$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def build(self) -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet$Builder.build()"""
        return 'ImmutableRangeSet'.__wrap(super(Builder, self).build())

    @overload
    def addAll(self, ranges: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableRangeSet$Builder<C> com.google.common.collect.ImmutableRangeSet$Builder.addAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(ranges))

    @overload
    def addAll(self, ranges: 'RangeSet') -> 'Builder':
        """public com.google.common.collect.ImmutableRangeSet$Builder<C> com.google.common.collect.ImmutableRangeSet$Builder.addAll(com.google.common.collect.RangeSet<C>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(ranges))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def add(self, range: 'Range') -> 'Builder':
        """public com.google.common.collect.ImmutableRangeSet$Builder<C> com.google.common.collect.ImmutableRangeSet$Builder.add(com.google.common.collect.Range<C>)"""
        return 'Builder'.__wrap(super(__Builder, self).add(range))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableRangeSet$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ImmutableClassToInstanceMap
from builtins import type
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
import java.util.Collection as Collection
import com.google.common.collect.ImmutableClassToInstanceMap as __ImmutableClassToInstanceMap_Builder
__Builder = __ImmutableClassToInstanceMap_Builder.Builder
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Set as __Set
__Set = __Set
import com.google.common.collect.ImmutableClassToInstanceMap as __ImmutableClassToInstanceMap
__ImmutableClassToInstanceMap = __ImmutableClassToInstanceMap
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import int
 
class ImmutableClassToInstanceMap():
    """com.google.common.collect.ImmutableClassToInstanceMap"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableClassToInstanceMap) -> 'ImmutableClassToInstanceMap':
        return ImmutableClassToInstanceMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableClassToInstanceMap):
        """
        Dynamic initializer for ImmutableClassToInstanceMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @overload
    def getInstance(self, type: 'Class') -> object:
        """public <T extends B> T com.google.common.collect.ImmutableClassToInstanceMap.getInstance(java.lang.Class<T>)"""
        return object.__wrap(super(__ImmutableClassToInstanceMap, self).getInstance(type))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def of(type: 'Class', value: object) -> 'ImmutableClassToInstanceMap':
        """public static <B,T extends B> com.google.common.collect.ImmutableClassToInstanceMap<B> com.google.common.collect.ImmutableClassToInstanceMap.of(java.lang.Class<T>,T)"""
        return ImmutableClassToInstanceMap.__wrap(__ImmutableClassToInstanceMap.of(type, value))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).entrySet())

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @staticmethod
    @overload
    def of() -> 'ImmutableClassToInstanceMap':
        """public static <B> com.google.common.collect.ImmutableClassToInstanceMap<B> com.google.common.collect.ImmutableClassToInstanceMap.of()"""
        return ImmutableClassToInstanceMap.__wrap(__ImmutableClassToInstanceMap.of())

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object.__wrap(super(__ForwardingMap, self).put(key, value))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def putInstance(self, type: 'Class', value: object) -> object:
        """public <T extends B> T com.google.common.collect.ImmutableClassToInstanceMap.putInstance(java.lang.Class<T>,T)"""
        return object.__wrap(super(__ImmutableClassToInstanceMap, self).putInstance(type, value))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ForwardingMap, self).putAll(map)

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <B> com.google.common.collect.ImmutableClassToInstanceMap$Builder<B> com.google.common.collect.ImmutableClassToInstanceMap.builder()"""
        return Builder.__wrap(__ImmutableClassToInstanceMap.builder())

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'.__wrap(super(ForwardingMap, self).values())

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).keySet())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__Map, self).replaceAll(arg0)

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsValue(value))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableClassToInstanceMap':
        """public static <B,S extends B> com.google.common.collect.ImmutableClassToInstanceMap<B> com.google.common.collect.ImmutableClassToInstanceMap.copyOf(java.util.Map<? extends java.lang.Class<? extends S>, ? extends S>)"""
        return ImmutableClassToInstanceMap.__wrap(__ImmutableClassToInstanceMap.copyOf(map)) 
 
 
# CLASS: com.google.common.collect.ImmutableMap
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.Map as __Map
__Map = __Map
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableSetMultimap as __ImmutableSetMultimap
__ImmutableSetMultimap = __ImmutableSetMultimap
import java.util.Map.Entry as Entry
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BinaryOperator as BinaryOperator
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
from builtins import object
import java.util.stream.Collector as Collector
import java.util.function.BiFunction as BiFunction
import com.google.common.collect.ImmutableMap as __ImmutableMap_Builder
__Builder = __ImmutableMap_Builder.Builder
import java.lang.Long as __long
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.lang.Object as __Object
__Object = __Object
import java.util.function.Function as Function
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import int
 
class ImmutableMap(ABC):
    """com.google.common.collect.ImmutableMap"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableMap) -> 'ImmutableMap':
        return ImmutableMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableMap):
        """
        Dynamic initializer for ImmutableMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def merge(self, key: object, value: object, function: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).merge(key, value, function))

    @overload
    def remove(self, o: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ImmutableMap, self).remove(o))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMap.hashCode()"""
        return int.__wrap(super(ImmutableMap, self).hashCode())

    @overload
    def compute(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).compute(key, remappingFunction))

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector.__wrap(__ImmutableMap.toImmutableMap(keyFunction, valueFunction, mergeFunction))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builder()"""
        return Builder.__wrap(__ImmutableMap.builder())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def replace(self, key: object, oldValue: object, newValue: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.replace(K,V,V)"""
        return bool.__wrap(super(__ImmutableMap, self).replace(key, oldValue, newValue))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableMap.__wrap(__ImmutableMap.copyOf(map))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).equals(object))

    @overload
    def putIfAbsent(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.putIfAbsent(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).putIfAbsent(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMap.values()"""
        return 'ImmutableCollection'.__wrap(super(ImmutableMap, self).values())

    @overload
    def replace(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.replace(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).replace(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).containsKey(key))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.isEmpty()"""
        return bool.__wrap(super(ImmutableMap, self).isEmpty())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMap.clear()"""
        super(ImmutableMap, self).clear()

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public final void com.google.common.collect.ImmutableMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__ImmutableMap, self).replaceAll(function)

    @overload
    def getOrDefault(self, key: object, defaultValue: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__ImmutableMap, self).getOrDefault(key, defaultValue))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).remove(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def of() -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of()"""
        return ImmutableMap.__wrap(__ImmutableMap.of())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2))

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableMap.__wrap(__ImmutableMap.ofEntries(entries))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.Map.size()"""
        pass

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMap.__wrap(__ImmutableMap.copyOf(entries))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).containsValue(value))

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableMap.entrySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMap, self).entrySet())

    @overload
    def computeIfPresent(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).computeIfPresent(key, remappingFunction))

    @overload
    def asMultimap(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableMap.asMultimap()"""
        return 'ImmutableSetMultimap'.__wrap(super(ImmutableMap, self).asMultimap())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @abstractmethod
    def get(self, key: object):
        """public abstract V com.google.common.collect.ImmutableMap.get(java.lang.Object)"""
        pass

    @overload
    def put(self, k: object, v: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.put(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).put(k, v))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMap.toString()"""
        return str.__wrap(super(ImmutableMap, self).toString())

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public final void com.google.common.collect.ImmutableMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ImmutableMap, self).putAll(map)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableMap.toImmutableMap(keyFunction, valueFunction))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableMap.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMap.keySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMap, self).keySet())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @overload
    def computeIfAbsent(self, key: object, mappingFunction: 'Function') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).computeIfAbsent(key, mappingFunction)) 
 
 
# CLASS: com.google.common.collect.Comparators
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.lang.Iterable as Iterable
from builtins import object
import java.lang.Comparable as Comparable
import java.util.stream.Collector as Collector
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import java.lang.Comparable as __Comparable
__Comparable = __Comparable
import com.google.common.collect.Comparators as __Comparators
__Comparators = __Comparators
from builtins import int
 
class Comparators():
    """com.google.common.collect.Comparators"""
 
    @staticmethod
    def __wrap(java_value: __Comparators) -> 'Comparators':
        return Comparators(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Comparators):
        """
        Dynamic initializer for Comparators.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def max(a: object, b: object, comparator: 'Comparator') -> object:
        """public static <T> T com.google.common.collect.Comparators.max(T,T,java.util.Comparator<? super T>)"""
        return object.__wrap(__Comparators.max(a, b, comparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def min(a: object, b: object, comparator: 'Comparator') -> object:
        """public static <T> T com.google.common.collect.Comparators.min(T,T,java.util.Comparator<? super T>)"""
        return object.__wrap(__Comparators.min(a, b, comparator))

    @staticmethod
    @overload
    def emptiesLast(valueComparator: 'Comparator') -> 'Comparator':
        """public static <T> java.util.Comparator<java.util.Optional<T>> com.google.common.collect.Comparators.emptiesLast(java.util.Comparator<? super T>)"""
        return Comparator.__wrap(__Comparators.emptiesLast(valueComparator))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def min(a: 'Comparable', b: 'Comparable') -> 'Comparable':
        """public static <T extends java.lang.Comparable<? super T>> T com.google.common.collect.Comparators.min(T,T)"""
        return Comparable.__wrap(__Comparators.min(a, b))

    @staticmethod
    @overload
    def isInOrder(iterable: 'Iterable', comparator: 'Comparator') -> bool:
        """public static <T> boolean com.google.common.collect.Comparators.isInOrder(java.lang.Iterable<? extends T>,java.util.Comparator<T>)"""
        return bool.__wrap(__Comparators.isInOrder(iterable, comparator))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def max(a: 'Comparable', b: 'Comparable') -> 'Comparable':
        """public static <T extends java.lang.Comparable<? super T>> T com.google.common.collect.Comparators.max(T,T)"""
        return Comparable.__wrap(__Comparators.max(a, b))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def greatest(k: int, comparator: 'Comparator') -> 'Collector':
        """public static <T> java.util.stream.Collector<T, ?, java.util.List<T>> com.google.common.collect.Comparators.greatest(int,java.util.Comparator<? super T>)"""
        return Collector.__wrap(__Comparators.greatest(__int.valueOf(k), comparator))

    @staticmethod
    @overload
    def isInStrictOrder(iterable: 'Iterable', comparator: 'Comparator') -> bool:
        """public static <T> boolean com.google.common.collect.Comparators.isInStrictOrder(java.lang.Iterable<? extends T>,java.util.Comparator<T>)"""
        return bool.__wrap(__Comparators.isInStrictOrder(iterable, comparator))

    @staticmethod
    @overload
    def emptiesFirst(valueComparator: 'Comparator') -> 'Comparator':
        """public static <T> java.util.Comparator<java.util.Optional<T>> com.google.common.collect.Comparators.emptiesFirst(java.util.Comparator<? super T>)"""
        return Comparator.__wrap(__Comparators.emptiesFirst(valueComparator))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def least(k: int, comparator: 'Comparator') -> 'Collector':
        """public static <T> java.util.stream.Collector<T, ?, java.util.List<T>> com.google.common.collect.Comparators.least(int,java.util.Comparator<? super T>)"""
        return Collector.__wrap(__Comparators.least(__int.valueOf(k), comparator))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def lexicographical(comparator: 'Comparator') -> 'Comparator':
        """public static <T,S extends T> java.util.Comparator<java.lang.Iterable<S>> com.google.common.collect.Comparators.lexicographical(java.util.Comparator<T>)"""
        return Comparator.__wrap(__Comparators.lexicographical(comparator)) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedMap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import com.google.common.collect.ImmutableSortedMap as __ImmutableSortedMap_Builder
__Builder = __ImmutableSortedMap_Builder.Builder
from builtins import type
import com.google.common.collect.ImmutableSortedMap as __ImmutableSortedMap
__ImmutableSortedMap = __ImmutableSortedMap
import java.lang.Iterable as Iterable
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableSortedMap.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def build(self) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap$Builder.build()"""
        return 'ImmutableSortedMap'.__wrap(super(Builder, self).build())

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.put(K,V)"""
        return 'Builder'.__wrap(super(__Builder, self).put(key, value))

    @overload
    def putAll(self, map: 'Map') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.putAll(java.util.Map<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(map))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def orderEntriesByValue(self, valueComparator: 'Comparator') -> 'Builder':
        """public final com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.orderEntriesByValue(java.util.Comparator<? super V>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderEntriesByValue(valueComparator))

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).put(entry))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(entries))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def buildOrThrow(self) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap$Builder.buildOrThrow()"""
        return 'ImmutableSortedMap'.__wrap(super(Builder, self).buildOrThrow())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def buildKeepingLast(self) -> 'ImmutableSortedMap':
        """public final com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap$Builder.buildKeepingLast()"""
        return 'ImmutableSortedMap'.__wrap(super(Builder, self).buildKeepingLast())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def __init__(self, comparator: 'Comparator'):
        """public com.google.common.collect.ImmutableSortedMap$Builder(java.util.Comparator<? super K>)"""
        val = __Builder(comparator)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.Range
from builtins import str
import java.util.function.Predicate as Predicate
from pyquantum_helper import override
import java.lang.Object as __object
import com.google.common.collect.BoundType as __BoundType
__BoundType = __BoundType
from builtins import type
import java.lang.Iterable as Iterable
import java.util.function.Predicate as __Predicate
__Predicate = __Predicate
import java.lang.Comparable as Comparable
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.Range as __Range
__Range = __Range
import java.lang.Integer as __int
import com.google.common.base.Predicate as __Predicate
__Predicate = __Predicate
from builtins import bool
import java.lang.Comparable as __Comparable
__Comparable = __Comparable
from builtins import int
 
class Range():
    """com.google.common.collect.Range"""
 
    @staticmethod
    def __wrap(java_value: __Range) -> 'Range':
        return Range(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Range):
        """
        Dynamic initializer for Range.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def isConnected(self, other: 'Range') -> bool:
        """public boolean com.google.common.collect.Range.isConnected(com.google.common.collect.Range<C>)"""
        return bool.__wrap(super(__Range, self).isConnected(other))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def upperBoundType(self) -> 'BoundType':
        """public com.google.common.collect.BoundType com.google.common.collect.Range.upperBoundType()"""
        return 'BoundType'.__wrap(super(Range, self).upperBoundType())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.Range.equals(java.lang.Object)"""
        return bool.__wrap(super(__Range, self).equals(object))

    @staticmethod
    @overload
    def open(lower: 'Comparable', upper: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.open(C,C)"""
        return Range.__wrap(__Range.open(lower, upper))

    @staticmethod
    @overload
    def downTo(endpoint: 'Comparable', boundType: 'BoundType') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.downTo(C,com.google.common.collect.BoundType)"""
        return Range.__wrap(__Range.downTo(endpoint, boundType))

    @overload
    def upperEndpoint(self) -> 'Comparable':
        """public C com.google.common.collect.Range.upperEndpoint()"""
        return 'Comparable'.__wrap(super(Range, self).upperEndpoint())

    @overload
    def hasLowerBound(self) -> bool:
        """public boolean com.google.common.collect.Range.hasLowerBound()"""
        return bool.__wrap(super(Range, self).hasLowerBound())

    @staticmethod
    @overload
    def singleton(value: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.singleton(C)"""
        return Range.__wrap(__Range.singleton(value))

    @staticmethod
    @overload
    def openClosed(lower: 'Comparable', upper: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.openClosed(C,C)"""
        return Range.__wrap(__Range.openClosed(lower, upper))

    @staticmethod
    @overload
    def lessThan(endpoint: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.lessThan(C)"""
        return Range.__wrap(__Range.lessThan(endpoint))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def span(self, other: 'Range') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.Range.span(com.google.common.collect.Range<C>)"""
        return 'Range'.__wrap(super(__Range, self).span(other))

    @staticmethod
    @overload
    def closedOpen(lower: 'Comparable', upper: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.closedOpen(C,C)"""
        return Range.__wrap(__Range.closedOpen(lower, upper))

    @staticmethod
    @overload
    def all() -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.all()"""
        return Range.__wrap(__Range.all())

    @overload
    def encloses(self, other: 'Range') -> bool:
        """public boolean com.google.common.collect.Range.encloses(com.google.common.collect.Range<C>)"""
        return bool.__wrap(super(__Range, self).encloses(other))

    @overload
    def or(self, arg0: 'Predicate') -> 'Predicate':
        """public default java.util.function.Predicate<T> java.util.function.Predicate.or(java.util.function.Predicate<? super T>)"""
        return 'Predicate'.__wrap(super(__Predicate, self).or(arg0))

    @staticmethod
    @overload
    def greaterThan(endpoint: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.greaterThan(C)"""
        return Range.__wrap(__Range.greaterThan(endpoint))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def and(self, arg0: 'Predicate') -> 'Predicate':
        """public default java.util.function.Predicate<T> java.util.function.Predicate.and(java.util.function.Predicate<? super T>)"""
        return 'Predicate'.__wrap(super(__Predicate, self).and(arg0))

    @overload
    def gap(self, otherRange: 'Range') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.Range.gap(com.google.common.collect.Range<C>)"""
        return 'Range'.__wrap(super(__Range, self).gap(otherRange))

    @staticmethod
    @overload
    def atMost(endpoint: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.atMost(C)"""
        return Range.__wrap(__Range.atMost(endpoint))

    @overload
    def lowerEndpoint(self) -> 'Comparable':
        """public C com.google.common.collect.Range.lowerEndpoint()"""
        return 'Comparable'.__wrap(super(Range, self).lowerEndpoint())

    @overload
    def contains(self, value: 'Comparable') -> bool:
        """public boolean com.google.common.collect.Range.contains(C)"""
        return bool.__wrap(super(__Range, self).contains(value))

    @staticmethod
    @overload
    def closed(lower: 'Comparable', upper: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.closed(C,C)"""
        return Range.__wrap(__Range.closed(lower, upper))

    @overload
    def intersection(self, connectedRange: 'Range') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.Range.intersection(com.google.common.collect.Range<C>)"""
        return 'Range'.__wrap(super(__Range, self).intersection(connectedRange))

    @overload
    def apply(self, input: 'Comparable') -> bool:
        """public boolean com.google.common.collect.Range.apply(C)"""
        return bool.__wrap(super(__Range, self).apply(input))

    @overload
    def hasUpperBound(self) -> bool:
        """public boolean com.google.common.collect.Range.hasUpperBound()"""
        return bool.__wrap(super(Range, self).hasUpperBound())

    @staticmethod
    @overload
    def atLeast(endpoint: 'Comparable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.atLeast(C)"""
        return Range.__wrap(__Range.atLeast(endpoint))

    @staticmethod
    @overload
    def upTo(endpoint: 'Comparable', boundType: 'BoundType') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.upTo(C,com.google.common.collect.BoundType)"""
        return Range.__wrap(__Range.upTo(endpoint, boundType))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.Range.hashCode()"""
        return int.__wrap(super(Range, self).hashCode())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.Range.toString()"""
        return str.__wrap(super(Range, self).toString())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def containsAll(self, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.Range.containsAll(java.lang.Iterable<? extends C>)"""
        return bool.__wrap(super(__Range, self).containsAll(values))

    @override
    @overload
    def negate(self) -> 'Predicate':
        """public default java.util.function.Predicate<T> java.util.function.Predicate.negate()"""
        return 'Predicate'.__wrap(super(Predicate, self).negate())

    @staticmethod
    @overload
    def encloseAll(values: 'Iterable') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.encloseAll(java.lang.Iterable<C>)"""
        return Range.__wrap(__Range.encloseAll(values))

    @overload
    def test(self, input: object) -> bool:
        """public default boolean com.google.common.base.Predicate.test(T)"""
        return bool.__wrap(super(__base.Predicate, self).test(input))

    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Range.isEmpty()"""
        return bool.__wrap(super(Range, self).isEmpty())

    @overload
    def canonical(self, domain: 'DiscreteDomain') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.Range.canonical(com.google.common.collect.DiscreteDomain<C>)"""
        return 'Range'.__wrap(super(__Range, self).canonical(domain))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def range(lower: 'Comparable', lowerType: 'BoundType', upper: 'Comparable', upperType: 'BoundType') -> 'Range':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.Range<C> com.google.common.collect.Range.range(C,com.google.common.collect.BoundType,C,com.google.common.collect.BoundType)"""
        return Range.__wrap(__Range.range(lower, lowerType, upper, upperType))

    @overload
    def lowerBoundType(self) -> 'BoundType':
        """public com.google.common.collect.BoundType com.google.common.collect.Range.lowerBoundType()"""
        return 'BoundType'.__wrap(super(Range, self).lowerBoundType()) 
 
 
# CLASS: com.google.common.collect.Lists
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

import java.util.concurrent.CopyOnWriteArrayList as CopyOnWriteArrayList
from builtins import type
import java.util.LinkedList as __LinkedList
__LinkedList = __LinkedList
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.util.ArrayList as ArrayList
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __string
import java.util.ArrayList as __ArrayList
__ArrayList = __ArrayList
from builtins import bool
import java.util.concurrent.CopyOnWriteArrayList as __CopyOnWriteArrayList
__CopyOnWriteArrayList = __CopyOnWriteArrayList
from builtins import str
import java.lang.CharSequence as CharSequence
from pyquantum_helper import override
import java.lang.Object as __object
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Iterator as Iterator
import java.util.List as __List
__List = __List
import java.lang.Long as __long
import java.util.LinkedList as LinkedList
import java.lang.String as __String
__String = __String
import com.google.common.collect.Lists as __Lists
__Lists = __Lists
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.List as List
from builtins import int
 
class Lists():
    """com.google.common.collect.Lists"""
 
    @staticmethod
    def __wrap(java_value: __Lists) -> 'Lists':
        return Lists(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Lists):
        """
        Dynamic initializer for Lists.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def reverse(list: 'List') -> 'List':
        """public static <T> java.util.List<T> com.google.common.collect.Lists.reverse(java.util.List<T>)"""
        return List.__wrap(__Lists.reverse(list))

    @staticmethod
    @overload
    def asList(first: object, second: object, rest: 'Object') -> 'List':
        """public static <E> java.util.List<E> com.google.common.collect.Lists.asList(E,E,E[])"""
        return List.__wrap(__Lists.asList(first, second, rest))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def charactersOf(string: str) -> 'ImmutableList':
        """public static com.google.common.collect.ImmutableList<java.lang.Character> com.google.common.collect.Lists.charactersOf(java.lang.String)"""
        return ImmutableList.__wrap(__Lists.charactersOf(string))

    @staticmethod
    @overload
    def cartesianProduct(lists: 'List') -> 'List':
        """public static <B> java.util.List<java.util.List<B>> com.google.common.collect.Lists.cartesianProduct(java.util.List<? extends java.util.List<? extends B>>)"""
        return List.__wrap(__Lists.cartesianProduct(lists))

    @staticmethod
    @overload
    def newArrayList() -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayList()"""
        return ArrayList.__wrap(__Lists.newArrayList())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def newArrayListWithExpectedSize(estimatedSize: int) -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayListWithExpectedSize(int)"""
        return ArrayList.__wrap(__Lists.newArrayListWithExpectedSize(__int.valueOf(estimatedSize)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def newArrayList(elements: 'Iterable') -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayList(java.lang.Iterable<? extends E>)"""
        return ArrayList.__wrap(__Lists.newArrayList(elements))

    @staticmethod
    @overload
    def charactersOf(sequence: 'CharSequence') -> 'List':
        """public static java.util.List<java.lang.Character> com.google.common.collect.Lists.charactersOf(java.lang.CharSequence)"""
        return List.__wrap(__Lists.charactersOf(sequence))

    @staticmethod
    @overload
    def partition(list: 'List', size: int) -> 'List':
        """public static <T> java.util.List<java.util.List<T>> com.google.common.collect.Lists.partition(java.util.List<T>,int)"""
        return List.__wrap(__Lists.partition(list, __int.valueOf(size)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def newLinkedList() -> 'LinkedList':
        """public static <E> java.util.LinkedList<E> com.google.common.collect.Lists.newLinkedList()"""
        return LinkedList.__wrap(__Lists.newLinkedList())

    @staticmethod
    @overload
    def newLinkedList(elements: 'Iterable') -> 'LinkedList':
        """public static <E> java.util.LinkedList<E> com.google.common.collect.Lists.newLinkedList(java.lang.Iterable<? extends E>)"""
        return LinkedList.__wrap(__Lists.newLinkedList(elements))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def newArrayList(elements: 'Iterator') -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayList(java.util.Iterator<? extends E>)"""
        return ArrayList.__wrap(__Lists.newArrayList(elements))

    @staticmethod
    @overload
    def newCopyOnWriteArrayList() -> 'CopyOnWriteArrayList':
        """public static <E> java.util.concurrent.CopyOnWriteArrayList<E> com.google.common.collect.Lists.newCopyOnWriteArrayList()"""
        return CopyOnWriteArrayList.__wrap(__Lists.newCopyOnWriteArrayList())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def cartesianProduct(*lists: 'List') -> 'List':
        """public static <B> java.util.List<java.util.List<B>> com.google.common.collect.Lists.cartesianProduct(java.util.List<? extends B>...)"""
        return List.__wrap(__Lists.cartesianProduct(lists))

    @staticmethod
    @overload
    def newCopyOnWriteArrayList(elements: 'Iterable') -> 'CopyOnWriteArrayList':
        """public static <E> java.util.concurrent.CopyOnWriteArrayList<E> com.google.common.collect.Lists.newCopyOnWriteArrayList(java.lang.Iterable<? extends E>)"""
        return CopyOnWriteArrayList.__wrap(__Lists.newCopyOnWriteArrayList(elements))

    @staticmethod
    @overload
    def asList(first: object, rest: 'Object') -> 'List':
        """public static <E> java.util.List<E> com.google.common.collect.Lists.asList(E,E[])"""
        return List.__wrap(__Lists.asList(first, rest))

    @staticmethod
    @overload
    def transform(fromList: 'List', function: 'Function') -> 'List':
        """public static <F,T> java.util.List<T> com.google.common.collect.Lists.transform(java.util.List<F>,com.google.common.base.Function<? super F, ? extends T>)"""
        return List.__wrap(__Lists.transform(fromList, function))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def newArrayListWithCapacity(initialArraySize: int) -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayListWithCapacity(int)"""
        return ArrayList.__wrap(__Lists.newArrayListWithCapacity(__int.valueOf(initialArraySize)))

    @staticmethod
    @overload
    def newArrayList(*elements: object) -> 'ArrayList':
        """public static <E> java.util.ArrayList<E> com.google.common.collect.Lists.newArrayList(E...)"""
        return ArrayList.__wrap(__Lists.newArrayList(elements)) 
 
 
# CLASS: com.google.common.collect.Sets$SetView
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.Sets as __Sets_SetView
__SetView = __Sets_SetView.SetView
from builtins import bool
import java.util.AbstractSet as __AbstractSet
__AbstractSet = __AbstractSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
from builtins import object
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Set as Set
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class SetView(ABC):
    """com.google.common.collect.Sets.SetView"""
 
    @staticmethod
    def __wrap(java_value: __SetView) -> 'SetView':
        return SetView(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __SetView):
        """
        Dynamic initializer for SetView.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__SetView, self).removeIf(filter))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__SetView, self).retainAll(elementsToKeep))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__SetView, self).addAll(newElements))

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.Sets$SetView.iterator()"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__SetView, self).removeAll(oldElements))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.add(E)"""
        return bool.__wrap(super(__SetView, self).add(e))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'.__wrap(super(Set, self).spliterator())

    @overload
    def copyInto(self, set: 'Set') -> 'Set':
        """public <S extends java.util.Set<E>> S com.google.common.collect.Sets$SetView.copyInto(S)"""
        return 'Set'.__wrap(super(__SetView, self).copyInto(set))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def immutableCopy(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<E> com.google.common.collect.Sets$SetView.immutableCopy()"""
        return 'ImmutableSet'.__wrap(super(SetView, self).immutableCopy())

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.Sets$SetView.remove(java.lang.Object)"""
        return bool.__wrap(super(__SetView, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractSet, self).equals(arg0))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.Sets$SetView.clear()"""
        super(SetView, self).clear()

    @overload
    def contains(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__AbstractCollection, self).contains(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int.__wrap(super(AbstractSet, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.BiMap
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.BiConsumer as BiConsumer
import java.util.Map as __Map
__Map = __Map
import java.lang.Object as __Object
__Object = __Object
from abc import abstractmethod, ABC
from builtins import object
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import bool
import java.util.function.BiFunction as BiFunction
import com.google.common.collect.BiMap as __BiMap
__BiMap = __BiMap
 
class BiMap(ABC):
    """com.google.common.collect.BiMap"""
 
    @staticmethod
    def __wrap(java_value: __BiMap) -> 'BiMap':
        return BiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __BiMap):
        """
        Dynamic initializer for BiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean java.util.Map.isEmpty()"""
        pass

    @abstractmethod
    def putAll(self, map: 'Map'):
        """public abstract void com.google.common.collect.BiMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        pass

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @abstractmethod
    def clear(self, ):
        """public abstract void java.util.Map.clear()"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract V com.google.common.collect.BiMap.put(K,V)"""
        pass

    @abstractmethod
    def get(self, arg0: object):
        """public abstract V java.util.Map.get(java.lang.Object)"""
        pass

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Set<V> com.google.common.collect.BiMap.values()"""
        pass

    @abstractmethod
    def containsValue(self, arg0: object):
        """public abstract boolean java.util.Map.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def remove(self, arg0: object):
        """public abstract V java.util.Map.remove(java.lang.Object)"""
        pass

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @abstractmethod
    def inverse(self, ):
        """public abstract com.google.common.collect.BiMap<V, K> com.google.common.collect.BiMap.inverse()"""
        pass

    @abstractmethod
    def containsKey(self, arg0: object):
        """public abstract boolean java.util.Map.containsKey(java.lang.Object)"""
        pass

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> java.util.Map.keySet()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int java.util.Map.hashCode()"""
        pass

    @abstractmethod
    def entrySet(self, ):
        """public abstract java.util.Set<java.util.Map$Entry<K, V>> java.util.Map.entrySet()"""
        pass

    @abstractmethod
    def forcePut(self, key: object, value: object):
        """public abstract V com.google.common.collect.BiMap.forcePut(K,V)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.Map.size()"""
        pass

    @abstractmethod
    def equals(self, arg0: object):
        """public abstract boolean java.util.Map.equals(java.lang.Object)"""
        pass

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__Map, self).replaceAll(arg0) 
 
 
# CLASS: com.google.common.collect.EnumMultiset
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import com.google.common.collect.AbstractMultiset as __AbstractMultiset
__AbstractMultiset = __AbstractMultiset
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Enum as Enum
import java.lang.Long as __long
import com.google.common.collect.EnumMultiset as __EnumMultiset
__EnumMultiset = __EnumMultiset
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class EnumMultiset():
    """com.google.common.collect.EnumMultiset"""
 
    @staticmethod
    def __wrap(java_value: __EnumMultiset) -> 'EnumMultiset':
        return EnumMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __EnumMultiset):
        """
        Dynamic initializer for EnumMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'EnumMultiset':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.EnumMultiset<E> com.google.common.collect.EnumMultiset.create(java.lang.Iterable<E>)"""
        return EnumMultiset.__wrap(__EnumMultiset.create(elements))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).retainAll(elementsToRetain))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def setCount(self, element: 'Enum', count: int) -> int:
        """public int com.google.common.collect.EnumMultiset.setCount(E,int)"""
        return int.__wrap(super(__EnumMultiset, self).setCount(element, __int.valueOf(count)))

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).equals(object))

    @staticmethod
    @overload
    def create(elements: 'Iterable', type: 'Class') -> 'EnumMultiset':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.EnumMultiset<E> com.google.common.collect.EnumMultiset.create(java.lang.Iterable<E>,java.lang.Class<E>)"""
        return EnumMultiset.__wrap(__EnumMultiset.create(elements, type))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.EnumMultiset.remove(java.lang.Object,int)"""
        return int.__wrap(super(__EnumMultiset, self).remove(element, __int.valueOf(occurrences)))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool.__wrap(super(__AbstractMultiset, self).add(element))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.EnumMultiset.clear()"""
        super(EnumMultiset, self).clear()

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).remove(element))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.EnumMultiset.size()"""
        return int.__wrap(super(EnumMultiset, self).size())

    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str.__wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def add(self, element: 'Enum', occurrences: int) -> int:
        """public int com.google.common.collect.EnumMultiset.add(E,int)"""
        return int.__wrap(super(__EnumMultiset, self).add(element, __int.valueOf(occurrences)))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.EnumMultiset.iterator()"""
        return 'Iterator'.__wrap(super(EnumMultiset, self).iterator())

    @staticmethod
    @overload
    def create(type: 'Class') -> 'EnumMultiset':
        """public static <E extends java.lang.Enum<E>> com.google.common.collect.EnumMultiset<E> com.google.common.collect.EnumMultiset.create(java.lang.Class<E>)"""
        return EnumMultiset.__wrap(__EnumMultiset.create(type))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public void com.google.common.collect.EnumMultiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__EnumMultiset, self).forEachEntry(action)

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int.__wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.EnumMultiset.count(java.lang.Object)"""
        return int.__wrap(super(__EnumMultiset, self).count(element)) 
 
 
# CLASS: com.google.common.collect.Interner
from abc import abstractmethod, ABC
import com.google.common.collect.Interner as __Interner
__Interner = __Interner
 
class Interner(ABC):
    """com.google.common.collect.Interner"""
 
    @staticmethod
    def __wrap(java_value: __Interner) -> 'Interner':
        return Interner(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Interner):
        """
        Dynamic initializer for Interner.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def intern(self, sample: object):
        """public abstract E com.google.common.collect.Interner.intern(E)"""
        pass 
 
 
# CLASS: com.google.common.collect.SortedMultiset
import java.util.function.Predicate as Predicate
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import com.google.common.collect.SortedMultiset as __SortedMultiset
__SortedMultiset = __SortedMultiset
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
from builtins import object
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.function.Consumer as Consumer
from typing import List
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
from builtins import bool
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class SortedMultiset(ABC):
    """com.google.common.collect.SortedMultiset"""
 
    @staticmethod
    def __wrap(java_value: __SortedMultiset) -> 'SortedMultiset':
        return SortedMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __SortedMultiset):
        """
        Dynamic initializer for SortedMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def lastEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.lastEntry()"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean java.util.Collection.isEmpty()"""
        pass

    @abstractmethod
    def setCount(self, element: object, oldCount: int, newCount: int):
        """public abstract boolean com.google.common.collect.Multiset.setCount(E,int,int)"""
        pass

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__Multiset, self).forEachEntry(action)

    @abstractmethod
    def subMultiset(self, lowerBound: object, lowerBoundType: 'BoundType', upperBound: object, upperBoundType: 'BoundType'):
        """public abstract com.google.common.collect.SortedMultiset<E> com.google.common.collect.SortedMultiset.subMultiset(E,com.google.common.collect.BoundType,E,com.google.common.collect.BoundType)"""
        pass

    @abstractmethod
    def removeAll(self, c: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.removeAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.Multiset.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def contains(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.contains(java.lang.Object)"""
        pass

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def add(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.add(E)"""
        pass

    @abstractmethod
    def firstEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.firstEntry()"""
        pass

    @abstractmethod
    def containsAll(self, elements: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.containsAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def count(self, element: object):
        """public abstract int com.google.common.collect.Multiset.count(java.lang.Object)"""
        pass

    @abstractmethod
    def toArray(self, arg0: 'Object'):
        """public abstract <T> T[] java.util.Collection.toArray(T[])"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multiset.hashCode()"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void java.util.Collection.clear()"""
        pass

    @abstractmethod
    def iterator(self, ):
        """public abstract java.util.Iterator<E> com.google.common.collect.SortedMultiset.iterator()"""
        pass

    @abstractmethod
    def descendingMultiset(self, ):
        """public abstract com.google.common.collect.SortedMultiset<E> com.google.common.collect.SortedMultiset.descendingMultiset()"""
        pass

    @abstractmethod
    def setCount(self, element: object, count: int):
        """public abstract int com.google.common.collect.Multiset.setCount(E,int)"""
        pass

    @abstractmethod
    def comparator(self, ):
        """public abstract java.util.Comparator<? super E> com.google.common.collect.SortedMultiset.comparator()"""
        pass

    @abstractmethod
    def elementSet(self, ):
        """public abstract java.util.NavigableSet<E> com.google.common.collect.SortedMultiset.elementSet()"""
        pass

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @abstractmethod
    def pollFirstEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.pollFirstEntry()"""
        pass

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @abstractmethod
    def addAll(self, arg0: 'Collection'):
        """public abstract boolean java.util.Collection.addAll(java.util.Collection<? extends E>)"""
        pass

    @abstractmethod
    def retainAll(self, c: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.retainAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def remove(self, element: object, occurrences: int):
        """public abstract int com.google.common.collect.Multiset.remove(java.lang.Object,int)"""
        pass

    @abstractmethod
    def toArray(self, ):
        """public abstract java.lang.Object[] java.util.Collection.toArray()"""
        pass

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @abstractmethod
    def tailMultiset(self, lowerBound: object, boundType: 'BoundType'):
        """public abstract com.google.common.collect.SortedMultiset<E> com.google.common.collect.SortedMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        pass

    @abstractmethod
    def entrySet(self, ):
        """public abstract java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.SortedMultiset.entrySet()"""
        pass

    @abstractmethod
    def remove(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.remove(java.lang.Object)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multiset.size()"""
        pass

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.Multiset.toString()"""
        pass

    @abstractmethod
    def pollLastEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.pollLastEntry()"""
        pass

    @abstractmethod
    def add(self, element: object, occurrences: int):
        """public abstract int com.google.common.collect.Multiset.add(E,int)"""
        pass

    @abstractmethod
    def headMultiset(self, upperBound: object, boundType: 'BoundType'):
        """public abstract com.google.common.collect.SortedMultiset<E> com.google.common.collect.SortedMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        pass 
 
 
# CLASS: com.google.common.collect.ImmutableMultimap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import com.google.common.collect.ImmutableMultimap as __ImmutableMultimap_Builder
__Builder = __ImmutableMultimap_Builder.Builder
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset
__ImmutableMultiset = __ImmutableMultiset
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.ImmutableMultimap as __ImmutableMultimap
__ImmutableMultimap = __ImmutableMultimap
from builtins import int
 
class ImmutableMultimap(ABC):
    """com.google.common.collect.ImmutableMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableMultimap) -> 'ImmutableMultimap':
        return ImmutableMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableMultimap):
        """
        Dynamic initializer for ImmutableMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap.builder()"""
        return Builder.__wrap(__ImmutableMultimap.builder())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.copyOf(multimap))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool.__wrap(super(__ImmutableMultimap, self).putAll(key, values))

    @abstractmethod
    def get(self, key: object):
        """public abstract com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.get(K)"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @abstractmethod
    def inverse(self, ):
        """public abstract com.google.common.collect.ImmutableMultimap<V, K> com.google.common.collect.ImmutableMultimap.inverse()"""
        pass

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.ImmutableMultimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__ImmutableMultimap, self).forEach(action)

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMultimap.keySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMultimap, self).keySet())

    @override
    @overload
    def entries(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableMultimap.entries()"""
        return 'ImmutableCollection'.__wrap(super(ImmutableMultimap, self).entries())

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'ImmutableCollection'.__wrap(super(__ImmutableMultimap, self).replaceValues(key, values))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).remove(key, value))

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.values()"""
        return 'ImmutableCollection'.__wrap(super(ImmutableMultimap, self).values())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).containsKey(key))

    @staticmethod
    @overload
    def of() -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of()"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of())

    @overload
    def removeAll(self, key: object) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.removeAll(java.lang.Object)"""
        return 'ImmutableCollection'.__wrap(super(__ImmutableMultimap, self).removeAll(key))

    @override
    @overload
    def keys(self) -> 'ImmutableMultiset':
        """public com.google.common.collect.ImmutableMultiset<K> com.google.common.collect.ImmutableMultimap.keys()"""
        return 'ImmutableMultiset'.__wrap(super(ImmutableMultimap, self).keys())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.put(K,V)"""
        return bool.__wrap(super(__ImmutableMultimap, self).put(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def asMap(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, java.util.Collection<V>> com.google.common.collect.ImmutableMultimap.asMap()"""
        return 'ImmutableMap'.__wrap(super(ImmutableMultimap, self).asMap())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ImmutableMultimap.size()"""
        return int.__wrap(super(ImmutableMultimap, self).size())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMultimap.clear()"""
        super(ImmutableMultimap, self).clear()

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).containsValue(value))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.copyOf(entries))

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool.__wrap(super(__ImmutableMultimap, self).putAll(multimap)) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedMultiset$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Iterator as Iterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ImmutableSortedMultiset as __ImmutableSortedMultiset_Builder
__Builder = __ImmutableSortedMultiset_Builder.Builder
import java.lang.Integer as __int
import com.google.common.collect.ImmutableSortedMultiset as __ImmutableSortedMultiset
__ImmutableSortedMultiset = __ImmutableSortedMultiset
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableSortedMultiset.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.add(E...)"""
        return 'Builder'.__wrap(super(__Builder, self).add(elements))

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @override
    @overload
    def build(self) -> 'ImmutableSortedMultiset':
        """public com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset$Builder.build()"""
        return 'ImmutableSortedMultiset'.__wrap(super(Builder, self).build())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def __init__(self, comparator: 'Comparator'):
        """public com.google.common.collect.ImmutableSortedMultiset$Builder(java.util.Comparator<? super E>)"""
        val = __Builder(comparator)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def setCount(self, element: object, count: int) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.setCount(E,int)"""
        return 'Builder'.__wrap(super(__Builder, self).setCount(element, __int.valueOf(count)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.add(E)"""
        return 'Builder'.__wrap(super(__Builder, self).add(element))

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def addCopies(self, element: object, occurrences: int) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset$Builder.addCopies(E,int)"""
        return 'Builder'.__wrap(super(__Builder, self).addCopies(element, __int.valueOf(occurrences)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ArrayListMultimap
import java.lang.Long as __long
from pyquantum_helper import override
import java.lang.Class as __Class
__Class = __Class
from builtins import type
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ArrayListMultimap as __ArrayListMultimap
__ArrayListMultimap = __ArrayListMultimap
import java.lang.Integer as __int
 
class ArrayListMultimap():
    """com.google.common.collect.ArrayListMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ArrayListMultimap) -> 'ArrayListMultimap':
        return ArrayListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ArrayListMultimap):
        """
        Dynamic initializer for ArrayListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'ArrayListMultimap':
        """public static <K,V> com.google.common.collect.ArrayListMultimap<K, V> com.google.common.collect.ArrayListMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ArrayListMultimap.__wrap(__ArrayListMultimap.create(multimap))

    @staticmethod
    @overload
    def create() -> 'ArrayListMultimap':
        """public static <K,V> com.google.common.collect.ArrayListMultimap<K, V> com.google.common.collect.ArrayListMultimap.create()"""
        return ArrayListMultimap.__wrap(__ArrayListMultimap.create())

    @overload
    def trimToSize(self):
        """public void com.google.common.collect.ArrayListMultimap.trimToSize()"""
        super(ArrayListMultimap, self).trimToSize()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create(expectedKeys: int, expectedValuesPerKey: int) -> 'ArrayListMultimap':
        """public static <K,V> com.google.common.collect.ArrayListMultimap<K, V> com.google.common.collect.ArrayListMultimap.create(int,int)"""
        return ArrayListMultimap.__wrap(__ArrayListMultimap.create(__int.valueOf(expectedKeys), __int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0)) 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap
import com.google.common.collect.Maps as __Maps_DescendingMap
__DescendingMap = __Maps_DescendingMap.DescendingMap
import java.util.NavigableMap as __NavigableMap
__NavigableMap = __NavigableMap
import java.lang.Boolean as __boolean
from builtins import type
import java.util.Map as __Map_Entry
__Entry = __Map_Entry.Entry
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
import java.util.Collection as Collection
import java.util.NavigableMap as NavigableMap
import java.util.SequencedCollection as SequencedCollection
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Map.Entry as Entry
import java.lang.Class as __Class
__Class = __Class
import java.util.SortedMap as SortedMap
import java.util.SequencedCollection as __SequencedCollection
__SequencedCollection = __SequencedCollection
import java.util.SequencedSet as SequencedSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.SortedMap as __SortedMap
__SortedMap = __SortedMap
import java.util.Set as __Set
__Set = __Set
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.SequencedMap as __SequencedMap
__SequencedMap = __SequencedMap
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.lang.Long as __long
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.SequencedSet as __SequencedSet
__SequencedSet = __SequencedSet
import com.google.common.collect.ForwardingNavigableMap as __ForwardingNavigableMap_StandardDescendingMap
__StandardDescendingMap = __ForwardingNavigableMap_StandardDescendingMap.StandardDescendingMap
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import int
 
class StandardDescendingMap():
    """com.google.common.collect.ForwardingNavigableMap.StandardDescendingMap"""
 
    @staticmethod
    def __wrap(java_value: __StandardDescendingMap) -> 'StandardDescendingMap':
        return StandardDescendingMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardDescendingMap):
        """
        Dynamic initializer for StandardDescendingMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.Maps$DescendingMap.keySet()"""
        return 'Set'.__wrap(super(DescendingMap, self).keySet())

    @overload
    def subMap(self, fromKey: object, fromInclusive: bool, toKey: object, toInclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.Maps$DescendingMap.subMap(K,boolean,K,boolean)"""
        return 'NavigableMap'.__wrap(super(__DescendingMap, self).subMap(fromKey, __boolean.valueOf(fromInclusive), toKey, __boolean.valueOf(toInclusive)))

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.Maps$DescendingMap.entrySet()"""
        return 'Set'.__wrap(super(DescendingMap, self).entrySet())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def ceilingKey(self, key: object) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.ceilingKey(K)"""
        return object.__wrap(super(__DescendingMap, self).ceilingKey(key))

    @override
    @overload
    def sequencedEntrySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<java.util.Map$Entry<K, V>> java.util.SequencedMap.sequencedEntrySet()"""
        return 'SequencedSet'.__wrap(super(SequencedMap, self).sequencedEntrySet())

    @overload
    def __init__(self, this$0: 'ForwardingNavigableMap'):
        """public com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap(com.google.common.collect.ForwardingNavigableMap)"""
        val = __StandardDescendingMap(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def putFirst(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putFirst(K,V)"""
        return object.__wrap(super(__SortedMap, self).putFirst(arg0, arg1))

    @overload
    def floorEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.floorEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__DescendingMap, self).floorEntry(key))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.Maps$DescendingMap.toString()"""
        return str.__wrap(super(DescendingMap, self).toString())

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object.__wrap(super(__ForwardingMap, self).put(key, value))

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public void com.google.common.collect.ForwardingNavigableMap$StandardDescendingMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__StandardDescendingMap, self).replaceAll(function)

    @override
    @overload
    def lastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.lastEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(DescendingMap, self).lastEntry())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @overload
    def higherEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.higherEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__DescendingMap, self).higherEntry(key))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.Maps$DescendingMap.comparator()"""
        return 'Comparator'.__wrap(super(DescendingMap, self).comparator())

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @override
    @overload
    def lastKey(self) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.lastKey()"""
        return object.__wrap(super(DescendingMap, self).lastKey())

    @override
    @overload
    def sequencedValues(self) -> 'SequencedCollection':
        """public default java.util.SequencedCollection<V> java.util.SequencedMap.sequencedValues()"""
        return 'SequencedCollection'.__wrap(super(SequencedMap, self).sequencedValues())

    @override
    @overload
    def descendingKeySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$DescendingMap.descendingKeySet()"""
        return 'NavigableSet'.__wrap(super(DescendingMap, self).descendingKeySet())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @override
    @overload
    def descendingMap(self) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.Maps$DescendingMap.descendingMap()"""
        return 'NavigableMap'.__wrap(super(DescendingMap, self).descendingMap())

    @override
    @overload
    def firstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.firstEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(DescendingMap, self).firstEntry())

    @override
    @overload
    def firstKey(self) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.firstKey()"""
        return object.__wrap(super(DescendingMap, self).firstKey())

    @overload
    def headMap(self, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.Maps$DescendingMap.headMap(K)"""
        return 'SortedMap'.__wrap(super(__DescendingMap, self).headMap(toKey))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @override
    @overload
    def reversed(self) -> 'NavigableMap':
        """public default java.util.NavigableMap<K, V> java.util.NavigableMap.reversed()"""
        return 'NavigableMap'.__wrap(super(NavigableMap, self).reversed())

    @overload
    def lowerKey(self, key: object) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.lowerKey(K)"""
        return object.__wrap(super(__DescendingMap, self).lowerKey(key))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @overload
    def tailMap(self, fromKey: object, inclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.Maps$DescendingMap.tailMap(K,boolean)"""
        return 'NavigableMap'.__wrap(super(__DescendingMap, self).tailMap(fromKey, __boolean.valueOf(inclusive)))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key))

    @overload
    def putLast(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putLast(K,V)"""
        return object.__wrap(super(__SortedMap, self).putLast(arg0, arg1))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def subMap(self, fromKey: object, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.Maps$DescendingMap.subMap(K,K)"""
        return 'SortedMap'.__wrap(super(__DescendingMap, self).subMap(fromKey, toKey))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).remove(key))

    @overload
    def floorKey(self, key: object) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.floorKey(K)"""
        return object.__wrap(super(__DescendingMap, self).floorKey(key))

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.pollFirstEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(DescendingMap, self).pollFirstEntry())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @override
    @overload
    def navigableKeySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$DescendingMap.navigableKeySet()"""
        return 'NavigableSet'.__wrap(super(DescendingMap, self).navigableKeySet())

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @override
    @overload
    def sequencedKeySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<K> java.util.SequencedMap.sequencedKeySet()"""
        return 'SequencedSet'.__wrap(super(SequencedMap, self).sequencedKeySet())

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ForwardingMap, self).putAll(map)

    @overload
    def ceilingEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.ceilingEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__DescendingMap, self).ceilingEntry(key))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.Maps$DescendingMap.values()"""
        return 'Collection'.__wrap(super(DescendingMap, self).values())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def pollLastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.pollLastEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(DescendingMap, self).pollLastEntry())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def lowerEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.Maps$DescendingMap.lowerEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__DescendingMap, self).lowerEntry(key))

    @overload
    def higherKey(self, key: object) -> object:
        """public K com.google.common.collect.Maps$DescendingMap.higherKey(K)"""
        return object.__wrap(super(__DescendingMap, self).higherKey(key))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @overload
    def headMap(self, toKey: object, inclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.Maps$DescendingMap.headMap(K,boolean)"""
        return 'NavigableMap'.__wrap(super(__DescendingMap, self).headMap(toKey, __boolean.valueOf(inclusive)))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsValue(value))

    @overload
    def tailMap(self, fromKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.Maps$DescendingMap.tailMap(K)"""
        return 'SortedMap'.__wrap(super(__DescendingMap, self).tailMap(fromKey)) 
 
 
# CLASS: com.google.common.collect.TreeMultimap
import java.util.NavigableMap as __NavigableMap
__NavigableMap = __NavigableMap
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
from builtins import type
import java.util.NavigableMap as NavigableMap
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.TreeMultimap as __TreeMultimap
__TreeMultimap = __TreeMultimap
import java.lang.Integer as __int
 
class TreeMultimap():
    """com.google.common.collect.TreeMultimap"""
 
    @staticmethod
    def __wrap(java_value: __TreeMultimap) -> 'TreeMultimap':
        return TreeMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __TreeMultimap):
        """
        Dynamic initializer for TreeMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def asMap(self) -> 'NavigableMap':
        """public java.util.NavigableMap<K, java.util.Collection<V>> com.google.common.collect.TreeMultimap.asMap()"""
        return 'NavigableMap'.__wrap(super(TreeMultimap, self).asMap())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def keySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.TreeMultimap.keySet()"""
        return 'NavigableSet'.__wrap(super(TreeMultimap, self).keySet())

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'TreeMultimap':
        """public static <K extends java.lang.Comparable,V extends java.lang.Comparable> com.google.common.collect.TreeMultimap<K, V> com.google.common.collect.TreeMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return TreeMultimap.__wrap(__TreeMultimap.create(multimap))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def valueComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super V> com.google.common.collect.TreeMultimap.valueComparator()"""
        return 'Comparator'.__wrap(super(TreeMultimap, self).valueComparator())

    @overload
    def get(self, key: object) -> 'NavigableSet':
        """public java.util.NavigableSet<V> com.google.common.collect.TreeMultimap.get(K)"""
        return 'NavigableSet'.__wrap(super(__TreeMultimap, self).get(key))

    @staticmethod
    @overload
    def create() -> 'TreeMultimap':
        """public static <K extends java.lang.Comparable,V extends java.lang.Comparable> com.google.common.collect.TreeMultimap<K, V> com.google.common.collect.TreeMultimap.create()"""
        return TreeMultimap.__wrap(__TreeMultimap.create())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def create(keyComparator: 'Comparator', valueComparator: 'Comparator') -> 'TreeMultimap':
        """public static <K,V> com.google.common.collect.TreeMultimap<K, V> com.google.common.collect.TreeMultimap.create(java.util.Comparator<? super K>,java.util.Comparator<? super V>)"""
        return TreeMultimap.__wrap(__TreeMultimap.create(keyComparator, valueComparator))

    @overload
    def keyComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.TreeMultimap.keyComparator()"""
        return 'Comparator'.__wrap(super(TreeMultimap, self).keyComparator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.Multiset
import java.util.function.Predicate as Predicate
from pyquantum_helper import override
import java.util.function.IntFunction as IntFunction
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
from abc import abstractmethod, ABC
from builtins import object
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.function.Consumer as Consumer
from typing import List
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
from builtins import bool
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class Multiset(ABC):
    """com.google.common.collect.Multiset"""
 
    @staticmethod
    def __wrap(java_value: __Multiset) -> 'Multiset':
        return Multiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Multiset):
        """
        Dynamic initializer for Multiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean java.util.Collection.isEmpty()"""
        pass

    @abstractmethod
    def setCount(self, element: object, oldCount: int, newCount: int):
        """public abstract boolean com.google.common.collect.Multiset.setCount(E,int,int)"""
        pass

    @abstractmethod
    def removeAll(self, c: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.removeAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.Multiset.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def contains(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.contains(java.lang.Object)"""
        pass

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def add(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.add(E)"""
        pass

    @abstractmethod
    def containsAll(self, elements: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.containsAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def count(self, element: object):
        """public abstract int com.google.common.collect.Multiset.count(java.lang.Object)"""
        pass

    @abstractmethod
    def elementSet(self, ):
        """public abstract java.util.Set<E> com.google.common.collect.Multiset.elementSet()"""
        pass

    @abstractmethod
    def toArray(self, arg0: 'Object'):
        """public abstract <T> T[] java.util.Collection.toArray(T[])"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multiset.hashCode()"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void java.util.Collection.clear()"""
        pass

    @abstractmethod
    def setCount(self, element: object, count: int):
        """public abstract int com.google.common.collect.Multiset.setCount(E,int)"""
        pass

    @abstractmethod
    def entrySet(self, ):
        """public abstract java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.Multiset.entrySet()"""
        pass

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @abstractmethod
    def iterator(self, ):
        """public abstract java.util.Iterator<E> com.google.common.collect.Multiset.iterator()"""
        pass

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @abstractmethod
    def addAll(self, arg0: 'Collection'):
        """public abstract boolean java.util.Collection.addAll(java.util.Collection<? extends E>)"""
        pass

    @abstractmethod
    def retainAll(self, c: 'Collection'):
        """public abstract boolean com.google.common.collect.Multiset.retainAll(java.util.Collection<?>)"""
        pass

    @abstractmethod
    def remove(self, element: object, occurrences: int):
        """public abstract int com.google.common.collect.Multiset.remove(java.lang.Object,int)"""
        pass

    @abstractmethod
    def toArray(self, ):
        """public abstract java.lang.Object[] java.util.Collection.toArray()"""
        pass

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__Multiset, self).forEachEntry(action)

    @abstractmethod
    def remove(self, element: object):
        """public abstract boolean com.google.common.collect.Multiset.remove(java.lang.Object)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multiset.size()"""
        pass

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.Multiset.toString()"""
        pass

    @abstractmethod
    def add(self, element: object, occurrences: int):
        """public abstract int com.google.common.collect.Multiset.add(E,int)"""
        pass 
 
 
# CLASS: com.google.common.collect.ObjectArrays
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.ObjectArrays as __ObjectArrays
__ObjectArrays = __ObjectArrays
import java.lang.Object as __object
from builtins import type
from builtins import object
from typing import List
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ObjectArrays():
    """com.google.common.collect.ObjectArrays"""
 
    @staticmethod
    def __wrap(java_value: __ObjectArrays) -> 'ObjectArrays':
        return ObjectArrays(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ObjectArrays):
        """
        Dynamic initializer for ObjectArrays.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def concat(element: object, array: 'Object') -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.concat(T,T[])"""
        return List[object].__wrap(__ObjectArrays.concat(element, array))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def concat(array: 'Object', element: object) -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.concat(T[],T)"""
        return List[object].__wrap(__ObjectArrays.concat(array, element))

    @staticmethod
    @overload
    def concat(first: 'Object', second: 'Object', type: 'Class') -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.concat(T[],T[],java.lang.Class<T>)"""
        return List[object].__wrap(__ObjectArrays.concat(first, second, type))

    @staticmethod
    @overload
    def newArray(type: 'Class', length: int) -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.newArray(java.lang.Class<T>,int)"""
        return List[object].__wrap(__ObjectArrays.newArray(type, __int.valueOf(length)))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def newArray(reference: 'Object', length: int) -> List[object]:
        """public static <T> T[] com.google.common.collect.ObjectArrays.newArray(T[],int)"""
        return List[object].__wrap(__ObjectArrays.newArray(reference, __int.valueOf(length)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.Streams
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.Streams as __Streams
__Streams = __Streams
import java.util.stream.IntStream as __IntStream
__IntStream = __IntStream
import java.lang.Class as __Class
__Class = __Class
import java.util.OptionalInt as OptionalInt
import java.util.stream.LongStream as LongStream
import java.util.stream.DoubleStream as DoubleStream
import java.util.OptionalDouble as __OptionalDouble
__OptionalDouble = __OptionalDouble
import java.util.stream.IntStream as IntStream
from builtins import bool
import java.util.OptionalInt as __OptionalInt
__OptionalInt = __OptionalInt
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.stream.DoubleStream as __DoubleStream
__DoubleStream = __DoubleStream
import java.util.OptionalLong as __OptionalLong
__OptionalLong = __OptionalLong
import java.util.Optional as __Optional
__Optional = __Optional
import java.lang.Iterable as Iterable
import java.util.function.BiFunction as BiFunction
import java.util.Iterator as Iterator
import java.util.stream.LongStream as __LongStream
__LongStream = __LongStream
import java.util.OptionalLong as OptionalLong
import java.util.OptionalDouble as OptionalDouble
import java.lang.Long as __long
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.util.Optional as Optional
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
 
class Streams():
    """com.google.common.collect.Streams"""
 
    @staticmethod
    def __wrap(java_value: __Streams) -> 'Streams':
        return Streams(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Streams):
        """
        Dynamic initializer for Streams.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def concat(*streams: 'LongStream') -> 'LongStream':
        """public static java.util.stream.LongStream com.google.common.collect.Streams.concat(java.util.stream.LongStream...)"""
        return LongStream.__wrap(__Streams.concat(streams))

    @staticmethod
    @overload
    def stream(optional: 'Optional') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(com.google.common.base.Optional<T>)"""
        return Stream.__wrap(__Streams.stream(optional))

    @staticmethod
    @overload
    def stream(optional: 'OptionalInt') -> 'IntStream':
        """public static java.util.stream.IntStream com.google.common.collect.Streams.stream(java.util.OptionalInt)"""
        return IntStream.__wrap(__Streams.stream(optional))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def stream(optional: 'OptionalLong') -> 'LongStream':
        """public static java.util.stream.LongStream com.google.common.collect.Streams.stream(java.util.OptionalLong)"""
        return LongStream.__wrap(__Streams.stream(optional))

    @staticmethod
    @overload
    def findLast(stream: 'Stream') -> 'Optional':
        """public static <T> java.util.Optional<T> com.google.common.collect.Streams.findLast(java.util.stream.Stream<T>)"""
        return Optional.__wrap(__Streams.findLast(stream))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def concat(*streams: 'DoubleStream') -> 'DoubleStream':
        """public static java.util.stream.DoubleStream com.google.common.collect.Streams.concat(java.util.stream.DoubleStream...)"""
        return DoubleStream.__wrap(__Streams.concat(streams))

    @staticmethod
    @overload
    def forEachPair(streamA: 'Stream', streamB: 'Stream', consumer: 'BiConsumer'):
        """public static <A,B> void com.google.common.collect.Streams.forEachPair(java.util.stream.Stream<A>,java.util.stream.Stream<B>,java.util.function.BiConsumer<? super A, ? super B>)"""
        __Streams.forEachPair(streamA, streamB, consumer)

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def stream(collection: 'Collection') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(java.util.Collection<T>)"""
        return Stream.__wrap(__Streams.stream(collection))

    @staticmethod
    @overload
    def zip(streamA: 'Stream', streamB: 'Stream', function: 'BiFunction') -> 'Stream':
        """public static <A,B,R> java.util.stream.Stream<R> com.google.common.collect.Streams.zip(java.util.stream.Stream<A>,java.util.stream.Stream<B>,java.util.function.BiFunction<? super A, ? super B, R>)"""
        return Stream.__wrap(__Streams.zip(streamA, streamB, function))

    @staticmethod
    @overload
    def mapWithIndex(stream: 'Stream', function: 'FunctionWithIndex') -> 'Stream':
        """public static <T,R> java.util.stream.Stream<R> com.google.common.collect.Streams.mapWithIndex(java.util.stream.Stream<T>,com.google.common.collect.Streams$FunctionWithIndex<? super T, ? extends R>)"""
        return Stream.__wrap(__Streams.mapWithIndex(stream, function))

    @staticmethod
    @overload
    def concat(*streams: 'Stream') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.concat(java.util.stream.Stream<? extends T>...)"""
        return Stream.__wrap(__Streams.concat(streams))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def stream(optional: 'OptionalDouble') -> 'DoubleStream':
        """public static java.util.stream.DoubleStream com.google.common.collect.Streams.stream(java.util.OptionalDouble)"""
        return DoubleStream.__wrap(__Streams.stream(optional))

    @staticmethod
    @overload
    def stream(iterable: 'Iterable') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(java.lang.Iterable<T>)"""
        return Stream.__wrap(__Streams.stream(iterable))

    @staticmethod
    @overload
    def findLast(stream: 'LongStream') -> 'OptionalLong':
        """public static java.util.OptionalLong com.google.common.collect.Streams.findLast(java.util.stream.LongStream)"""
        return OptionalLong.__wrap(__Streams.findLast(stream))

    @staticmethod
    @overload
    def stream(iterator: 'Iterator') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(java.util.Iterator<T>)"""
        return Stream.__wrap(__Streams.stream(iterator))

    @staticmethod
    @overload
    def findLast(stream: 'IntStream') -> 'OptionalInt':
        """public static java.util.OptionalInt com.google.common.collect.Streams.findLast(java.util.stream.IntStream)"""
        return OptionalInt.__wrap(__Streams.findLast(stream))

    @staticmethod
    @overload
    def mapWithIndex(stream: 'IntStream', function: 'IntFunctionWithIndex') -> 'Stream':
        """public static <R> java.util.stream.Stream<R> com.google.common.collect.Streams.mapWithIndex(java.util.stream.IntStream,com.google.common.collect.Streams$IntFunctionWithIndex<R>)"""
        return Stream.__wrap(__Streams.mapWithIndex(stream, function))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def stream(optional: 'Optional') -> 'Stream':
        """public static <T> java.util.stream.Stream<T> com.google.common.collect.Streams.stream(java.util.Optional<T>)"""
        return Stream.__wrap(__Streams.stream(optional))

    @staticmethod
    @overload
    def findLast(stream: 'DoubleStream') -> 'OptionalDouble':
        """public static java.util.OptionalDouble com.google.common.collect.Streams.findLast(java.util.stream.DoubleStream)"""
        return OptionalDouble.__wrap(__Streams.findLast(stream))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def mapWithIndex(stream: 'DoubleStream', function: 'DoubleFunctionWithIndex') -> 'Stream':
        """public static <R> java.util.stream.Stream<R> com.google.common.collect.Streams.mapWithIndex(java.util.stream.DoubleStream,com.google.common.collect.Streams$DoubleFunctionWithIndex<R>)"""
        return Stream.__wrap(__Streams.mapWithIndex(stream, function))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def concat(*streams: 'IntStream') -> 'IntStream':
        """public static java.util.stream.IntStream com.google.common.collect.Streams.concat(java.util.stream.IntStream...)"""
        return IntStream.__wrap(__Streams.concat(streams))

    @staticmethod
    @overload
    def mapWithIndex(stream: 'LongStream', function: 'LongFunctionWithIndex') -> 'Stream':
        """public static <R> java.util.stream.Stream<R> com.google.common.collect.Streams.mapWithIndex(java.util.stream.LongStream,com.google.common.collect.Streams$LongFunctionWithIndex<R>)"""
        return Stream.__wrap(__Streams.mapWithIndex(stream, function)) 
 
 
# CLASS: com.google.common.collect.HashBasedTable
import java.lang.Long as __long
from pyquantum_helper import override
import java.lang.Class as __Class
__Class = __Class
from builtins import type
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.HashBasedTable as __HashBasedTable
__HashBasedTable = __HashBasedTable
import java.lang.Integer as __int
 
class HashBasedTable():
    """com.google.common.collect.HashBasedTable"""
 
    @staticmethod
    def __wrap(java_value: __HashBasedTable) -> 'HashBasedTable':
        return HashBasedTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __HashBasedTable):
        """
        Dynamic initializer for HashBasedTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def create(table: 'Table') -> 'HashBasedTable':
        """public static <R,C,V> com.google.common.collect.HashBasedTable<R, C, V> com.google.common.collect.HashBasedTable.create(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        return HashBasedTable.__wrap(__HashBasedTable.create(table))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def create(expectedRows: int, expectedCellsPerRow: int) -> 'HashBasedTable':
        """public static <R,C,V> com.google.common.collect.HashBasedTable<R, C, V> com.google.common.collect.HashBasedTable.create(int,int)"""
        return HashBasedTable.__wrap(__HashBasedTable.create(__int.valueOf(expectedRows), __int.valueOf(expectedCellsPerRow)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create() -> 'HashBasedTable':
        """public static <R,C,V> com.google.common.collect.HashBasedTable<R, C, V> com.google.common.collect.HashBasedTable.create()"""
        return HashBasedTable.__wrap(__HashBasedTable.create())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0)) 
 
 
# CLASS: com.google.common.collect.MoreCollectors
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import com.google.common.collect.MoreCollectors as __MoreCollectors
__MoreCollectors = __MoreCollectors
import java.util.stream.Collector as Collector
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class MoreCollectors():
    """com.google.common.collect.MoreCollectors"""
 
    @staticmethod
    def __wrap(java_value: __MoreCollectors) -> 'MoreCollectors':
        return MoreCollectors(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __MoreCollectors):
        """
        Dynamic initializer for MoreCollectors.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def onlyElement() -> 'Collector':
        """public static <T> java.util.stream.Collector<T, ?, T> com.google.common.collect.MoreCollectors.onlyElement()"""
        return Collector.__wrap(__MoreCollectors.onlyElement())

    @staticmethod
    @overload
    def toOptional() -> 'Collector':
        """public static <T> java.util.stream.Collector<T, ?, java.util.Optional<T>> com.google.common.collect.MoreCollectors.toOptional()"""
        return Collector.__wrap(__MoreCollectors.toOptional())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0)) 
 
 
# CLASS: com.google.common.collect.ImmutableSet$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
from builtins import object
import java.util.Iterator as Iterator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import com.google.common.collect.ImmutableSet as __ImmutableSet_Builder
__Builder = __ImmutableSet_Builder.Builder
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableSet.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet$Builder.add(E)"""
        return 'Builder'.__wrap(super(__Builder, self).add(element))

    @override
    @overload
    def build(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet$Builder.build()"""
        return 'ImmutableSet'.__wrap(super(Builder, self).build())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet$Builder.add(E...)"""
        return 'Builder'.__wrap(super(__Builder, self).add(elements))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableSet$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableSet$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ArrayTable
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Map as __Map
__Map = __Map
import java.util.Set as __Set
__Set = __Set
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import java.util.Collection as Collection
from builtins import object
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
from typing import List
import com.google.common.collect.ArrayTable as __ArrayTable
__ArrayTable = __ArrayTable
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Set as Set
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import java.util.Map as Map
from builtins import int
 
class ArrayTable():
    """com.google.common.collect.ArrayTable"""
 
    @staticmethod
    def __wrap(java_value: __ArrayTable) -> 'ArrayTable':
        return ArrayTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ArrayTable):
        """
        Dynamic initializer for ArrayTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def rowKeySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<R> com.google.common.collect.ArrayTable.rowKeySet()"""
        return 'ImmutableSet'.__wrap(super(ArrayTable, self).rowKeySet())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ArrayTable.isEmpty()"""
        return bool.__wrap(super(ArrayTable, self).isEmpty())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def column(self, columnKey: object) -> 'Map':
        """public java.util.Map<R, V> com.google.common.collect.ArrayTable.column(C)"""
        return 'Map'.__wrap(super(__ArrayTable, self).column(columnKey))

    @override
    @overload
    def rowMap(self) -> 'Map':
        """public java.util.Map<R, java.util.Map<C, V>> com.google.common.collect.ArrayTable.rowMap()"""
        return 'Map'.__wrap(super(ArrayTable, self).rowMap())

    @overload
    def eraseAll(self):
        """public void com.google.common.collect.ArrayTable.eraseAll()"""
        super(ArrayTable, self).eraseAll()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def create(table: 'Table') -> 'ArrayTable':
        """public static <R,C,V> com.google.common.collect.ArrayTable<R, C, V> com.google.common.collect.ArrayTable.create(com.google.common.collect.Table<R, C, ? extends V>)"""
        return ArrayTable.__wrap(__ArrayTable.create(table))

    @overload
    def at(self, rowIndex: int, columnIndex: int) -> object:
        """public V com.google.common.collect.ArrayTable.at(int,int)"""
        return object.__wrap(super(__ArrayTable, self).at(__int.valueOf(rowIndex), __int.valueOf(columnIndex)))

    @overload
    def columnKeyList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<C> com.google.common.collect.ArrayTable.columnKeyList()"""
        return 'ImmutableList'.__wrap(super(ArrayTable, self).columnKeyList())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ArrayTable.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ArrayTable, self).containsValue(value))

    @overload
    def row(self, rowKey: object) -> 'Map':
        """public java.util.Map<C, V> com.google.common.collect.ArrayTable.row(R)"""
        return 'Map'.__wrap(super(__ArrayTable, self).row(rowKey))

    @override
    @overload
    def putAll(self, table: 'Table'):
        """public void com.google.common.collect.ArrayTable.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        super(__ArrayTable, self).putAll(table)

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ArrayTable.values()"""
        return 'Collection'.__wrap(super(ArrayTable, self).values())

    @override
    @overload
    def columnKeySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<C> com.google.common.collect.ArrayTable.columnKeySet()"""
        return 'ImmutableSet'.__wrap(super(ArrayTable, self).columnKeySet())

    @override
    @overload
    def columnMap(self) -> 'Map':
        """public java.util.Map<C, java.util.Map<R, V>> com.google.common.collect.ArrayTable.columnMap()"""
        return 'Map'.__wrap(super(ArrayTable, self).columnMap())

    @overload
    def erase(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ArrayTable.erase(java.lang.Object,java.lang.Object)"""
        return object.__wrap(super(__ArrayTable, self).erase(rowKey, columnKey))

    @overload
    def toArray(self, valueClass: 'Class') -> List[List[object]]:
        """public V[][] com.google.common.collect.ArrayTable.toArray(java.lang.Class<V>)"""
        return List[List[object]].__wrap(super(__ArrayTable, self).toArray(valueClass))

    @overload
    def containsColumn(self, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ArrayTable.containsColumn(java.lang.Object)"""
        return bool.__wrap(super(__ArrayTable, self).containsColumn(columnKey))

    @overload
    def set(self, rowIndex: int, columnIndex: int, value: object) -> object:
        """public V com.google.common.collect.ArrayTable.set(int,int,V)"""
        return object.__wrap(super(__ArrayTable, self).set(__int.valueOf(rowIndex), __int.valueOf(columnIndex), value))

    @overload
    def get(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ArrayTable.get(java.lang.Object,java.lang.Object)"""
        return object.__wrap(super(__ArrayTable, self).get(rowKey, columnKey))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ArrayTable.remove(java.lang.Object,java.lang.Object)"""
        return object.__wrap(super(__ArrayTable, self).remove(rowKey, columnKey))

    @overload
    def put(self, rowKey: object, columnKey: object, value: object) -> object:
        """public V com.google.common.collect.ArrayTable.put(R,C,V)"""
        return object.__wrap(super(__ArrayTable, self).put(rowKey, columnKey, value))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ArrayTable.size()"""
        return int.__wrap(super(ArrayTable, self).size())

    @staticmethod
    @overload
    def create(rowKeys: 'Iterable', columnKeys: 'Iterable') -> 'ArrayTable':
        """public static <R,C,V> com.google.common.collect.ArrayTable<R, C, V> com.google.common.collect.ArrayTable.create(java.lang.Iterable<? extends R>,java.lang.Iterable<? extends C>)"""
        return ArrayTable.__wrap(__ArrayTable.create(rowKeys, columnKeys))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def cellSet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.ArrayTable.cellSet()"""
        return 'Set'.__wrap(super(ArrayTable, self).cellSet())

    @overload
    def containsRow(self, rowKey: object) -> bool:
        """public boolean com.google.common.collect.ArrayTable.containsRow(java.lang.Object)"""
        return bool.__wrap(super(__ArrayTable, self).containsRow(rowKey))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ArrayTable.clear()"""
        super(ArrayTable, self).clear()

    @overload
    def contains(self, rowKey: object, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ArrayTable.contains(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ArrayTable, self).contains(rowKey, columnKey))

    @overload
    def rowKeyList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<R> com.google.common.collect.ArrayTable.rowKeyList()"""
        return 'ImmutableList'.__wrap(super(ArrayTable, self).rowKeyList()) 
 
 
# CLASS: com.google.common.collect.ForwardingObject
from builtins import str
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
from pyquantum_helper import override
import java.lang.Class as __Class
__Class = __Class
import java.lang.Object as __object
import java.lang.String as __String
__String = __String
from builtins import type
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ForwardingObject(ABC):
    """com.google.common.collect.ForwardingObject"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingObject) -> 'ForwardingObject':
        return ForwardingObject(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingObject):
        """
        Dynamic initializer for ForwardingObject.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0)) 
 
 
# CLASS: com.google.common.collect.RangeSet
import com.google.common.collect.RangeSet as __RangeSet
__RangeSet = __RangeSet
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
import java.lang.Comparable as Comparable
from builtins import bool
 
class RangeSet(ABC):
    """com.google.common.collect.RangeSet"""
 
    @staticmethod
    def __wrap(java_value: __RangeSet) -> 'RangeSet':
        return RangeSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __RangeSet):
        """
        Dynamic initializer for RangeSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def intersects(self, otherRange: 'Range'):
        """public abstract boolean com.google.common.collect.RangeSet.intersects(com.google.common.collect.Range<C>)"""
        pass

    @abstractmethod
    def rangeContaining(self, value: 'Comparable'):
        """public abstract com.google.common.collect.Range<C> com.google.common.collect.RangeSet.rangeContaining(C)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.RangeSet.hashCode()"""
        pass

    @overload
    def enclosesAll(self, other: 'Iterable') -> bool:
        """public default boolean com.google.common.collect.RangeSet.enclosesAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return bool.__wrap(super(__RangeSet, self).enclosesAll(other))

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.RangeSet.isEmpty()"""
        pass

    @abstractmethod
    def removeAll(self, other: 'RangeSet'):
        """public abstract void com.google.common.collect.RangeSet.removeAll(com.google.common.collect.RangeSet<C>)"""
        pass

    @abstractmethod
    def addAll(self, other: 'RangeSet'):
        """public abstract void com.google.common.collect.RangeSet.addAll(com.google.common.collect.RangeSet<C>)"""
        pass

    @abstractmethod
    def asRanges(self, ):
        """public abstract java.util.Set<com.google.common.collect.Range<C>> com.google.common.collect.RangeSet.asRanges()"""
        pass

    @abstractmethod
    def remove(self, range: 'Range'):
        """public abstract void com.google.common.collect.RangeSet.remove(com.google.common.collect.Range<C>)"""
        pass

    @abstractmethod
    def asDescendingSetOfRanges(self, ):
        """public abstract java.util.Set<com.google.common.collect.Range<C>> com.google.common.collect.RangeSet.asDescendingSetOfRanges()"""
        pass

    @abstractmethod
    def subRangeSet(self, view: 'Range'):
        """public abstract com.google.common.collect.RangeSet<C> com.google.common.collect.RangeSet.subRangeSet(com.google.common.collect.Range<C>)"""
        pass

    @abstractmethod
    def span(self, ):
        """public abstract com.google.common.collect.Range<C> com.google.common.collect.RangeSet.span()"""
        pass

    @overload
    def removeAll(self, ranges: 'Iterable'):
        """public default void com.google.common.collect.RangeSet.removeAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(__RangeSet, self).removeAll(ranges)

    @overload
    def addAll(self, ranges: 'Iterable'):
        """public default void com.google.common.collect.RangeSet.addAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(__RangeSet, self).addAll(ranges)

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.RangeSet.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.RangeSet.toString()"""
        pass

    @abstractmethod
    def contains(self, value: 'Comparable'):
        """public abstract boolean com.google.common.collect.RangeSet.contains(C)"""
        pass

    @abstractmethod
    def enclosesAll(self, other: 'RangeSet'):
        """public abstract boolean com.google.common.collect.RangeSet.enclosesAll(com.google.common.collect.RangeSet<C>)"""
        pass

    @abstractmethod
    def complement(self, ):
        """public abstract com.google.common.collect.RangeSet<C> com.google.common.collect.RangeSet.complement()"""
        pass

    @abstractmethod
    def add(self, range: 'Range'):
        """public abstract void com.google.common.collect.RangeSet.add(com.google.common.collect.Range<C>)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.RangeSet.clear()"""
        pass

    @abstractmethod
    def encloses(self, otherRange: 'Range'):
        """public abstract boolean com.google.common.collect.RangeSet.encloses(com.google.common.collect.Range<C>)"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMultiset$StandardDescendingMultiset
import com.google.common.collect.Multiset as __Multiset_Entry
__Entry = __Multiset_Entry.Entry
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import com.google.common.collect.SortedMultiset as __SortedMultiset
__SortedMultiset = __SortedMultiset
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingSortedMultiset as __ForwardingSortedMultiset_StandardDescendingMultiset
__StandardDescendingMultiset = __ForwardingSortedMultiset_StandardDescendingMultiset.StandardDescendingMultiset
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.lang.Long as __long
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.DescendingMultiset as __DescendingMultiset
__DescendingMultiset = __DescendingMultiset
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
import com.google.common.collect.ForwardingMultiset as __ForwardingMultiset
__ForwardingMultiset = __ForwardingMultiset
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class StandardDescendingMultiset(ABC):
    """com.google.common.collect.ForwardingSortedMultiset.StandardDescendingMultiset"""
 
    @staticmethod
    def __wrap(java_value: __StandardDescendingMultiset) -> 'StandardDescendingMultiset':
        return StandardDescendingMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardDescendingMultiset):
        """
        Dynamic initializer for StandardDescendingMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.add(E,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).add(element, __int.valueOf(occurrences)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__Multiset, self).forEachEntry(action)

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.DescendingMultiset.toString()"""
        return str.__wrap(super(DescendingMultiset, self).toString())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultiset, self).equals(object))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.setCount(E,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).setCount(element, __int.valueOf(count)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def lastEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.DescendingMultiset.lastEntry()"""
        return 'Entry'.__wrap(super(DescendingMultiset, self).lastEntry())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def elementSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.DescendingMultiset.elementSet()"""
        return 'NavigableSet'.__wrap(super(DescendingMultiset, self).elementSet())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.DescendingMultiset.comparator()"""
        return 'Comparator'.__wrap(super(DescendingMultiset, self).comparator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.DescendingMultiset.toArray()"""
        return List[object].__wrap(super(DescendingMultiset, self).toArray())

    @override
    @overload
    def pollLastEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.DescendingMultiset.pollLastEntry()"""
        return 'Entry'.__wrap(super(DescendingMultiset, self).pollLastEntry())

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.setCount(E,int,int)"""
        return bool.__wrap(super(__ForwardingMultiset, self).setCount(element, __int.valueOf(oldCount), __int.valueOf(newCount)))

    @override
    @overload
    def descendingMultiset(self) -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.DescendingMultiset.descendingMultiset()"""
        return 'SortedMultiset'.__wrap(super(DescendingMultiset, self).descendingMultiset())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @overload
    def headMultiset(self, toElement: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.DescendingMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'.__wrap(super(__DescendingMultiset, self).headMultiset(toElement, boundType))

    @overload
    def subMultiset(self, fromElement: object, fromBoundType: 'BoundType', toElement: object, toBoundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.DescendingMultiset.subMultiset(E,com.google.common.collect.BoundType,E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'.__wrap(super(__DescendingMultiset, self).subMultiset(fromElement, fromBoundType, toElement, toBoundType))

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.DescendingMultiset.toArray(T[])"""
        return List[object].__wrap(super(__DescendingMultiset, self).toArray(array))

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.DescendingMultiset.pollFirstEntry()"""
        return 'Entry'.__wrap(super(DescendingMultiset, self).pollFirstEntry())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.DescendingMultiset.entrySet()"""
        return 'Set'.__wrap(super(DescendingMultiset, self).entrySet())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.DescendingMultiset.iterator()"""
        return 'Iterator'.__wrap(super(DescendingMultiset, self).iterator())

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.remove(java.lang.Object,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).remove(element, __int.valueOf(occurrences)))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingMultiset.count(java.lang.Object)"""
        return int.__wrap(super(__ForwardingMultiset, self).count(element))

    @override
    @overload
    def firstEntry(self) -> 'Entry':
        """public com.google.common.collect.Multiset$Entry<E> com.google.common.collect.DescendingMultiset.firstEntry()"""
        return 'Entry'.__wrap(super(DescendingMultiset, self).firstEntry())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultiset.hashCode()"""
        return int.__wrap(super(ForwardingMultiset, self).hashCode())

    @overload
    def __init__(self, this$0: 'ForwardingSortedMultiset'):
        """public com.google.common.collect.ForwardingSortedMultiset$StandardDescendingMultiset(com.google.common.collect.ForwardingSortedMultiset)"""
        val = __StandardDescendingMultiset(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def tailMultiset(self, fromElement: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.DescendingMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'.__wrap(super(__DescendingMultiset, self).tailMultiset(fromElement, boundType))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.ForwardingMultimap
from builtins import str
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.ForwardingMultimap as __ForwardingMultimap
__ForwardingMultimap = __ForwardingMultimap
import java.util.Set as __Set
__Set = __Set
import java.util.Map as __Map
__Map = __Map
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import java.util.Map as Map
from builtins import int
 
class ForwardingMultimap(ABC):
    """com.google.common.collect.ForwardingMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingMultimap) -> 'ForwardingMultimap':
        return ForwardingMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingMultimap):
        """
        Dynamic initializer for ForwardingMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool.__wrap(super(__ForwardingMultimap, self).putAll(multimap))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.hashCode()"""
        return int.__wrap(super(ForwardingMultimap, self).hashCode())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsKey(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsValue(value))

    @overload
    def get(self, key: object) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.get(K)"""
        return 'Collection'.__wrap(super(__ForwardingMultimap, self).get(key))

    @overload
    def containsEntry(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsEntry(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsEntry(key, value))

    @override
    @overload
    def asMap(self) -> 'Map':
        """public java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ForwardingMultimap.asMap()"""
        return 'Map'.__wrap(super(ForwardingMultimap, self).asMap())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMultimap.clear()"""
        super(ForwardingMultimap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).remove(key, value))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'Collection'.__wrap(super(__ForwardingMultimap, self).replaceValues(key, values))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.size()"""
        return int.__wrap(super(ForwardingMultimap, self).size())

    @override
    @overload
    def entries(self) -> 'Collection':
        """public java.util.Collection<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMultimap.entries()"""
        return 'Collection'.__wrap(super(ForwardingMultimap, self).entries())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).equals(object))

    @overload
    def removeAll(self, key: object) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.removeAll(java.lang.Object)"""
        return 'Collection'.__wrap(super(__ForwardingMultimap, self).removeAll(key))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.put(K,V)"""
        return bool.__wrap(super(__ForwardingMultimap, self).put(key, value))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.values()"""
        return 'Collection'.__wrap(super(ForwardingMultimap, self).values())

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMultimap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMultimap, self).keySet())

    @override
    @overload
    def keys(self) -> 'Multiset':
        """public com.google.common.collect.Multiset<K> com.google.common.collect.ForwardingMultimap.keys()"""
        return 'Multiset'.__wrap(super(ForwardingMultimap, self).keys())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool.__wrap(super(__ForwardingMultimap, self).putAll(key, values))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.isEmpty()"""
        return bool.__wrap(super(ForwardingMultimap, self).isEmpty())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.ImmutableMultimap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableMultimap as __ImmutableMultimap_Builder
__Builder = __ImmutableMultimap_Builder.Builder
from builtins import object
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.ImmutableMultimap as __ImmutableMultimap
__ImmutableMultimap = __ImmutableMultimap
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableMultimap.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(entries))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def build(self) -> 'ImmutableMultimap':
        """public com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap$Builder.build()"""
        return 'ImmutableMultimap'.__wrap(super(Builder, self).build())

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableMultimap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).put(entry))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def putAll(self, key: object, *values: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.putAll(K,V...)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(key, values))

    @overload
    def orderValuesBy(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.orderValuesBy(java.util.Comparator<? super V>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderValuesBy(valueComparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def orderKeysBy(self, keyComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.orderKeysBy(java.util.Comparator<? super K>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderKeysBy(keyComparator))

    @overload
    def putAll(self, multimap: 'Multimap') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(multimap))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.put(K,V)"""
        return 'Builder'.__wrap(super(__Builder, self).put(key, value))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def putAll(self, key: object, values: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap$Builder.putAll(K,java.lang.Iterable<? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(key, values))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableMultimap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val 
 
 
# CLASS: com.google.common.collect.UnmodifiableIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
from builtins import type
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.UnmodifiableIterator as __UnmodifiableIterator
__UnmodifiableIterator = __UnmodifiableIterator
from builtins import int
 
class UnmodifiableIterator(ABC):
    """com.google.common.collect.UnmodifiableIterator"""
 
    @staticmethod
    def __wrap(java_value: __UnmodifiableIterator) -> 'UnmodifiableIterator':
        return UnmodifiableIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __UnmodifiableIterator):
        """
        Dynamic initializer for UnmodifiableIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def remove(self):
        """public final void com.google.common.collect.UnmodifiableIterator.remove()"""
        super(UnmodifiableIterator, self).remove()

    @abstractmethod
    def next(self, ):
        """public abstract E java.util.Iterator.next()"""
        pass

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @abstractmethod
    def hasNext(self, ):
        """public abstract boolean java.util.Iterator.hasNext()"""
        pass

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(__Iterator, self).forEachRemaining(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.RowSortedTable
import com.google.common.collect.Table as __Table
__Table = __Table
import com.google.common.collect.RowSortedTable as __RowSortedTable
__RowSortedTable = __RowSortedTable
from abc import abstractmethod, ABC
 
class RowSortedTable(ABC):
    """com.google.common.collect.RowSortedTable"""
 
    @staticmethod
    def __wrap(java_value: __RowSortedTable) -> 'RowSortedTable':
        return RowSortedTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __RowSortedTable):
        """
        Dynamic initializer for RowSortedTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def containsRow(self, rowKey: object):
        """public abstract boolean com.google.common.collect.Table.containsRow(java.lang.Object)"""
        pass

    @abstractmethod
    def put(self, rowKey: object, columnKey: object, value: object):
        """public abstract V com.google.common.collect.Table.put(R,C,V)"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Table.isEmpty()"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Table.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def columnKeySet(self, ):
        """public abstract java.util.Set<C> com.google.common.collect.Table.columnKeySet()"""
        pass

    @abstractmethod
    def containsColumn(self, columnKey: object):
        """public abstract boolean com.google.common.collect.Table.containsColumn(java.lang.Object)"""
        pass

    @abstractmethod
    def rowKeySet(self, ):
        """public abstract java.util.SortedSet<R> com.google.common.collect.RowSortedTable.rowKeySet()"""
        pass

    @abstractmethod
    def columnMap(self, ):
        """public abstract java.util.Map<C, java.util.Map<R, V>> com.google.common.collect.Table.columnMap()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.Table.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Table.hashCode()"""
        pass

    @abstractmethod
    def rowMap(self, ):
        """public abstract java.util.SortedMap<R, java.util.Map<C, V>> com.google.common.collect.RowSortedTable.rowMap()"""
        pass

    @abstractmethod
    def putAll(self, table: 'Table'):
        """public abstract void com.google.common.collect.Table.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        pass

    @abstractmethod
    def column(self, columnKey: object):
        """public abstract java.util.Map<R, V> com.google.common.collect.Table.column(C)"""
        pass

    @abstractmethod
    def row(self, rowKey: object):
        """public abstract java.util.Map<C, V> com.google.common.collect.Table.row(R)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Table.clear()"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Table.size()"""
        pass

    @abstractmethod
    def cellSet(self, ):
        """public abstract java.util.Set<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.Table.cellSet()"""
        pass

    @abstractmethod
    def remove(self, rowKey: object, columnKey: object):
        """public abstract V com.google.common.collect.Table.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Table.values()"""
        pass

    @abstractmethod
    def get(self, rowKey: object, columnKey: object):
        """public abstract V com.google.common.collect.Table.get(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def contains(self, rowKey: object, columnKey: object):
        """public abstract boolean com.google.common.collect.Table.contains(java.lang.Object,java.lang.Object)"""
        pass 
 
 
# CLASS: com.google.common.collect.TreeMultiset
import java.util.function.Predicate as Predicate
from builtins import type
import com.google.common.collect.SortedMultiset as __SortedMultiset
__SortedMultiset = __SortedMultiset
import java.util.stream.Stream as __Stream
__Stream = __Stream
import com.google.common.collect.AbstractMultiset as __AbstractMultiset
__AbstractMultiset = __AbstractMultiset
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import com.google.common.collect.TreeMultiset as __TreeMultiset
__TreeMultiset = __TreeMultiset
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class TreeMultiset():
    """com.google.common.collect.TreeMultiset"""
 
    @staticmethod
    def __wrap(java_value: __TreeMultiset) -> 'TreeMultiset':
        return TreeMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __TreeMultiset):
        """
        Dynamic initializer for TreeMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def headMultiset(self, upperBound: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.TreeMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'.__wrap(super(__TreeMultiset, self).headMultiset(upperBound, boundType))

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public void com.google.common.collect.TreeMultiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__TreeMultiset, self).forEachEntry(action)

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.TreeMultiset.count(java.lang.Object)"""
        return int.__wrap(super(__TreeMultiset, self).count(element))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.TreeMultiset.setCount(E,int)"""
        return int.__wrap(super(__TreeMultiset, self).setCount(element, __int.valueOf(count)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @staticmethod
    @overload
    def create(comparator: 'Comparator') -> 'TreeMultiset':
        """public static <E> com.google.common.collect.TreeMultiset<E> com.google.common.collect.TreeMultiset.create(java.util.Comparator<? super E>)"""
        return TreeMultiset.__wrap(__TreeMultiset.create(comparator))

    @staticmethod
    @overload
    def create() -> 'TreeMultiset':
        """public static <E extends java.lang.Comparable> com.google.common.collect.TreeMultiset<E> com.google.common.collect.TreeMultiset.create()"""
        return TreeMultiset.__wrap(__TreeMultiset.create())

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).retainAll(elementsToRetain))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.TreeMultiset.iterator()"""
        return 'Iterator'.__wrap(super(TreeMultiset, self).iterator())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).equals(object))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.TreeMultiset.remove(java.lang.Object,int)"""
        return int.__wrap(super(__TreeMultiset, self).remove(element, __int.valueOf(occurrences)))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.TreeMultiset.add(E,int)"""
        return int.__wrap(super(__TreeMultiset, self).add(element, __int.valueOf(occurrences)))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool.__wrap(super(__AbstractMultiset, self).add(element))

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).remove(element))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.TreeMultiset.clear()"""
        super(TreeMultiset, self).clear()

    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'TreeMultiset':
        """public static <E extends java.lang.Comparable> com.google.common.collect.TreeMultiset<E> com.google.common.collect.TreeMultiset.create(java.lang.Iterable<? extends E>)"""
        return TreeMultiset.__wrap(__TreeMultiset.create(elements))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str.__wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.TreeMultiset.size()"""
        return int.__wrap(super(TreeMultiset, self).size())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int.__wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.TreeMultiset.setCount(E,int,int)"""
        return bool.__wrap(super(__TreeMultiset, self).setCount(element, __int.valueOf(oldCount), __int.valueOf(newCount)))

    @overload
    def tailMultiset(self, lowerBound: object, boundType: 'BoundType') -> 'SortedMultiset':
        """public com.google.common.collect.SortedMultiset<E> com.google.common.collect.TreeMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        return 'SortedMultiset'.__wrap(super(__TreeMultiset, self).tailMultiset(lowerBound, boundType)) 
 
 
# CLASS: com.google.common.collect.ImmutableSetMultimap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import com.google.common.collect.ImmutableMultimap as __ImmutableMultimap_Builder
__Builder = __ImmutableMultimap_Builder.Builder
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import com.google.common.collect.ImmutableSetMultimap as __ImmutableSetMultimap
__ImmutableSetMultimap = __ImmutableSetMultimap
import java.util.stream.Collector as Collector
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset
__ImmutableMultiset = __ImmutableMultiset
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ImmutableSetMultimap as __ImmutableSetMultimap_Builder
__Builder = __ImmutableSetMultimap_Builder.Builder
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.lang.Object as __Object
__Object = __Object
import java.util.function.Function as Function
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.ImmutableMultimap as __ImmutableMultimap
__ImmutableMultimap = __ImmutableMultimap
from builtins import int
 
class ImmutableSetMultimap():
    """com.google.common.collect.ImmutableSetMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableSetMultimap) -> 'ImmutableSetMultimap':
        return ImmutableSetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableSetMultimap):
        """
        Dynamic initializer for ImmutableSetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap.builder()"""
        return Builder.__wrap(__ImmutableMultimap.builder())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.copyOf(multimap))

    @staticmethod
    @overload
    def of() -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of()"""
        return ImmutableSetMultimap.__wrap(__ImmutableSetMultimap.of())

    @staticmethod
    @overload
    def toImmutableSetMultimap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSetMultimap<K, V>> com.google.common.collect.ImmutableSetMultimap.toImmutableSetMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableSetMultimap.toImmutableSetMultimap(keyFunction, valueFunction))

    @overload
    def removeAll(self, key: object) -> 'ImmutableSet':
        """public final com.google.common.collect.ImmutableSet<V> com.google.common.collect.ImmutableSetMultimap.removeAll(java.lang.Object)"""
        return 'ImmutableSet'.__wrap(super(__ImmutableSetMultimap, self).removeAll(key))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableSetMultimap.__wrap(__ImmutableSetMultimap.copyOf(multimap))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'ImmutableSet':
        """public final com.google.common.collect.ImmutableSet<V> com.google.common.collect.ImmutableSetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'ImmutableSet'.__wrap(super(__ImmutableSetMultimap, self).replaceValues(key, values))

    @override
    @overload
    def entries(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableSetMultimap.entries()"""
        return 'ImmutableSet'.__wrap(super(ImmutableSetMultimap, self).entries())

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool.__wrap(super(__ImmutableMultimap, self).putAll(key, values))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap.builder()"""
        return Builder.__wrap(__ImmutableSetMultimap.builder())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.ImmutableMultimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__ImmutableMultimap, self).forEach(action)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V,K,V)"""
        return ImmutableSetMultimap.__wrap(__ImmutableSetMultimap.of(k1, v1, k2, v2))

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMultimap.keySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMultimap, self).keySet())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V,K,V,K,V)"""
        return ImmutableSetMultimap.__wrap(__ImmutableSetMultimap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSetMultimap.__wrap(__ImmutableSetMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def flatteningToImmutableSetMultimap(keyFunction: 'Function', valuesFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSetMultimap<K, V>> com.google.common.collect.ImmutableSetMultimap.flatteningToImmutableSetMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends V>>)"""
        return Collector.__wrap(__ImmutableSetMultimap.flatteningToImmutableSetMultimap(keyFunction, valuesFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).remove(key, value))

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.values()"""
        return 'ImmutableCollection'.__wrap(super(ImmutableMultimap, self).values())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).containsKey(key))

    @staticmethod
    @overload
    def of() -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of()"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of())

    @override
    @overload
    def keys(self) -> 'ImmutableMultiset':
        """public com.google.common.collect.ImmutableMultiset<K> com.google.common.collect.ImmutableMultimap.keys()"""
        return 'ImmutableMultiset'.__wrap(super(ImmutableMultimap, self).keys())

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableSetMultimap.__wrap(__ImmutableSetMultimap.copyOf(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V)"""
        return ImmutableSetMultimap.__wrap(__ImmutableSetMultimap.of(k1, v1))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.put(K,V)"""
        return bool.__wrap(super(__ImmutableMultimap, self).put(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def asMap(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, java.util.Collection<V>> com.google.common.collect.ImmutableMultimap.asMap()"""
        return 'ImmutableMap'.__wrap(super(ImmutableMultimap, self).asMap())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableSetMultimap':
        """public static <K,V> com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableSetMultimap.__wrap(__ImmutableSetMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ImmutableMultimap.size()"""
        return int.__wrap(super(ImmutableMultimap, self).size())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMultimap.clear()"""
        super(ImmutableMultimap, self).clear()

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).containsValue(value))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.copyOf(entries))

    @override
    @overload
    def inverse(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<V, K> com.google.common.collect.ImmutableSetMultimap.inverse()"""
        return 'ImmutableSetMultimap'.__wrap(super(ImmutableSetMultimap, self).inverse())

    @overload
    def get(self, key: object) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<V> com.google.common.collect.ImmutableSetMultimap.get(K)"""
        return 'ImmutableSet'.__wrap(super(__ImmutableSetMultimap, self).get(key))

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool.__wrap(super(__ImmutableMultimap, self).putAll(multimap)) 
 
 
# CLASS: com.google.common.collect.AbstractSequentialIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
from builtins import type
import com.google.common.collect.AbstractSequentialIterator as __AbstractSequentialIterator
__AbstractSequentialIterator = __AbstractSequentialIterator
from builtins import object
import java.util.function.Consumer as Consumer
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.UnmodifiableIterator as __UnmodifiableIterator
__UnmodifiableIterator = __UnmodifiableIterator
from builtins import int
 
class AbstractSequentialIterator(ABC):
    """com.google.common.collect.AbstractSequentialIterator"""
 
    @staticmethod
    def __wrap(java_value: __AbstractSequentialIterator) -> 'AbstractSequentialIterator':
        return AbstractSequentialIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __AbstractSequentialIterator):
        """
        Dynamic initializer for AbstractSequentialIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def remove(self):
        """public final void com.google.common.collect.UnmodifiableIterator.remove()"""
        super(UnmodifiableIterator, self).remove()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hasNext(self) -> bool:
        """public final boolean com.google.common.collect.AbstractSequentialIterator.hasNext()"""
        return bool.__wrap(super(AbstractSequentialIterator, self).hasNext())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(__Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def next(self) -> object:
        """public final T com.google.common.collect.AbstractSequentialIterator.next()"""
        return object.__wrap(super(AbstractSequentialIterator, self).next())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.HashBiMap
import java.util.AbstractMap as __AbstractMap
__AbstractMap = __AbstractMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Set as __Set
__Set = __Set
import java.util.Map as __Map
__Map = __Map
from builtins import object
import java.util.function.BiFunction as BiFunction
import com.google.common.collect.BiMap as __BiMap
__BiMap = __BiMap
import java.util.Set as Set
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.function.Function as Function
import com.google.common.collect.HashBiMap as __HashBiMap
__HashBiMap = __HashBiMap
from builtins import bool
import java.util.Map as Map
from builtins import int
 
class HashBiMap():
    """com.google.common.collect.HashBiMap"""
 
    @staticmethod
    def __wrap(java_value: __HashBiMap) -> 'HashBiMap':
        return HashBiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __HashBiMap):
        """
        Dynamic initializer for HashBiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.HashBiMap.get(java.lang.Object)"""
        return object.__wrap(super(__HashBiMap, self).get(key))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.HashBiMap.remove(java.lang.Object)"""
        return object.__wrap(super(__HashBiMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractMap.toString()"""
        return str.__wrap(super(AbstractMap, self).toString())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMap, self).equals(arg0))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.HashBiMap.size()"""
        return int.__wrap(super(HashBiMap, self).size())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractMap.hashCode()"""
        return int.__wrap(super(AbstractMap, self).hashCode())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractMap.isEmpty()"""
        return bool.__wrap(super(AbstractMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public void com.google.common.collect.HashBiMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__HashBiMap, self).replaceAll(function)

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.HashBiMap.keySet()"""
        return 'Set'.__wrap(super(HashBiMap, self).keySet())

    @override
    @overload
    def values(self) -> 'Set':
        """public java.util.Set<V> com.google.common.collect.HashBiMap.values()"""
        return 'Set'.__wrap(super(HashBiMap, self).values())

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @staticmethod
    @overload
    def create(expectedSize: int) -> 'HashBiMap':
        """public static <K,V> com.google.common.collect.HashBiMap<K, V> com.google.common.collect.HashBiMap.create(int)"""
        return HashBiMap.__wrap(__HashBiMap.create(__int.valueOf(expectedSize)))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.HashBiMap.clear()"""
        super(HashBiMap, self).clear()

    @overload
    def forcePut(self, key: object, value: object) -> object:
        """public V com.google.common.collect.HashBiMap.forcePut(K,V)"""
        return object.__wrap(super(__HashBiMap, self).forcePut(key, value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def putAll(self, arg0: 'Map'):
        """public void java.util.AbstractMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__AbstractMap, self).putAll(arg0)

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.HashBiMap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__HashBiMap, self).forEach(action)

    @staticmethod
    @overload
    def create() -> 'HashBiMap':
        """public static <K,V> com.google.common.collect.HashBiMap<K, V> com.google.common.collect.HashBiMap.create()"""
        return HashBiMap.__wrap(__HashBiMap.create())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.HashBiMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__HashBiMap, self).containsValue(value))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @staticmethod
    @overload
    def create(map: 'Map') -> 'HashBiMap':
        """public static <K,V> com.google.common.collect.HashBiMap<K, V> com.google.common.collect.HashBiMap.create(java.util.Map<? extends K, ? extends V>)"""
        return HashBiMap.__wrap(__HashBiMap.create(map))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.HashBiMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__HashBiMap, self).containsKey(key))

    @override
    @overload
    def inverse(self) -> 'BiMap':
        """public com.google.common.collect.BiMap<V, K> com.google.common.collect.HashBiMap.inverse()"""
        return 'BiMap'.__wrap(super(HashBiMap, self).inverse())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.HashBiMap.put(K,V)"""
        return object.__wrap(super(__HashBiMap, self).put(key, value))

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2)) 
 
 
# CLASS: com.google.common.collect.ImmutableClassToInstanceMap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.ImmutableClassToInstanceMap as __ImmutableClassToInstanceMap
__ImmutableClassToInstanceMap = __ImmutableClassToInstanceMap
import com.google.common.collect.ImmutableClassToInstanceMap as __ImmutableClassToInstanceMap_Builder
__Builder = __ImmutableClassToInstanceMap_Builder.Builder
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableClassToInstanceMap.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, map: 'Map') -> 'Builder':
        """public <T extends B> com.google.common.collect.ImmutableClassToInstanceMap$Builder<B> com.google.common.collect.ImmutableClassToInstanceMap$Builder.putAll(java.util.Map<? extends java.lang.Class<? extends T>, ? extends T>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(map))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableClassToInstanceMap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableClassToInstanceMap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def build(self) -> 'ImmutableClassToInstanceMap':
        """public com.google.common.collect.ImmutableClassToInstanceMap<B> com.google.common.collect.ImmutableClassToInstanceMap$Builder.build()"""
        return 'ImmutableClassToInstanceMap'.__wrap(super(Builder, self).build())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def put(self, key: 'Class', value: object) -> 'Builder':
        """public <T extends B> com.google.common.collect.ImmutableClassToInstanceMap$Builder<B> com.google.common.collect.ImmutableClassToInstanceMap$Builder.put(java.lang.Class<T>,T)"""
        return 'Builder'.__wrap(super(__Builder, self).put(key, value))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.SortedSetMultimap
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from pyquantum_helper import override
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.SortedSetMultimap as __SortedSetMultimap
__SortedSetMultimap = __SortedSetMultimap
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
import com.google.common.collect.SetMultimap as __SetMultimap
__SetMultimap = __SetMultimap
 
class SortedSetMultimap(ABC):
    """com.google.common.collect.SortedSetMultimap"""
 
    @staticmethod
    def __wrap(java_value: __SortedSetMultimap) -> 'SortedSetMultimap':
        return SortedSetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __SortedSetMultimap):
        """
        Dynamic initializer for SortedSetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def removeAll(self, key: object):
        """public abstract java.util.SortedSet<V> com.google.common.collect.SortedSetMultimap.removeAll(java.lang.Object)"""
        pass

    @abstractmethod
    def keys(self, ):
        """public abstract com.google.common.collect.Multiset<K> com.google.common.collect.Multimap.keys()"""
        pass

    @abstractmethod
    def asMap(self, ):
        """public abstract java.util.Map<K, java.util.Collection<V>> com.google.common.collect.SortedSetMultimap.asMap()"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Multimap.isEmpty()"""
        pass

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> com.google.common.collect.Multimap.keySet()"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.put(K,V)"""
        pass

    @abstractmethod
    def containsEntry(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def replaceValues(self, key: object, values: 'Iterable'):
        """public abstract java.util.SortedSet<V> com.google.common.collect.SortedSetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def valueComparator(self, ):
        """public abstract java.util.Comparator<? super V> com.google.common.collect.SortedSetMultimap.valueComparator()"""
        pass

    @abstractmethod
    def remove(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def containsKey(self, key: object):
        """public abstract boolean com.google.common.collect.Multimap.containsKey(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.values()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multimap.hashCode()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.SetMultimap.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def putAll(self, key: object, values: 'Iterable'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def entries(self, ):
        """public abstract java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.SetMultimap.entries()"""
        pass

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @abstractmethod
    def get(self, key: object):
        """public abstract java.util.SortedSet<V> com.google.common.collect.SortedSetMultimap.get(K)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Multimap.clear()"""
        pass

    @abstractmethod
    def putAll(self, multimap: 'Multimap'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multimap.size()"""
        pass 
 
 
# CLASS: com.google.common.collect.ImmutableMultiset
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset
__ImmutableMultiset = __ImmutableMultiset
from abc import abstractmethod, ABC
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import java.util.function.ToIntFunction as ToIntFunction
from builtins import bool
import com.google.common.collect.UnmodifiableIterator as __UnmodifiableIterator
__UnmodifiableIterator = __UnmodifiableIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
from builtins import object
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset_Builder
__Builder = __ImmutableMultiset_Builder.Builder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
import java.util.function.Function as Function
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ImmutableMultiset(ABC):
    """com.google.common.collect.ImmutableMultiset"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableMultiset) -> 'ImmutableMultiset':
        return ImmutableMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableMultiset):
        """
        Dynamic initializer for ImmutableMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def of() -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of()"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset.builder()"""
        return Builder.__wrap(__ImmutableMultiset.builder())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E,E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2, e3, e4, e5))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.add(E,int)"""
        return int.__wrap(super(__ImmutableMultiset, self).add(element, __int.valueOf(occurrences)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def count(self, element: object):
        """public abstract int com.google.common.collect.Multiset.count(java.lang.Object)"""
        pass

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ImmutableMultiset.entrySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMultiset, self).entrySet())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool.__wrap(super(__ImmutableCollection, self).add(e))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object].__wrap(super(__ImmutableCollection, self).toArray(other))

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableCollection, self).remove(object))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.copyOf(elements))

    @override
    @overload
    def iterator(self) -> 'UnmodifiableIterator':
        """public com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableMultiset.iterator()"""
        return 'UnmodifiableIterator'.__wrap(super(ImmutableMultiset, self).iterator())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E,E,E,E...)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2, e3, e4, e5, e6, others))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeIf(filter))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultiset, self).equals(object))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.setCount(E,int)"""
        return int.__wrap(super(__ImmutableMultiset, self).setCount(element, __int.valueOf(count)))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMultiset.hashCode()"""
        return int.__wrap(super(ImmutableMultiset, self).hashCode())

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeAll(oldElements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2, e3))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.remove(java.lang.Object,int)"""
        return int.__wrap(super(__ImmutableMultiset, self).remove(element, __int.valueOf(occurrences)))

    @staticmethod
    @overload
    def toImmutableMultiset(elementFunction: 'Function', countFunction: 'ToIntFunction') -> 'Collector':
        """public static <T,E> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMultiset<E>> com.google.common.collect.ImmutableMultiset.toImmutableMultiset(java.util.function.Function<? super T, ? extends E>,java.util.function.ToIntFunction<? super T>)"""
        return Collector.__wrap(__ImmutableMultiset.toImmutableMultiset(elementFunction, countFunction))

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__Multiset, self).forEachEntry(action)

    @staticmethod
    @overload
    def toImmutableMultiset() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableMultiset<E>> com.google.common.collect.ImmutableMultiset.toImmutableMultiset()"""
        return Collector.__wrap(__ImmutableMultiset.toImmutableMultiset())

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(E[])"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.copyOf(elements))

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object].__wrap(super(ImmutableCollection, self).toArray())

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultiset.setCount(E,int,int)"""
        return bool.__wrap(super(__ImmutableMultiset, self).setCount(element, __int.valueOf(oldCount), __int.valueOf(newCount)))

    @abstractmethod
    def elementSet(self, ):
        """public abstract com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableMultiset.elementSet()"""
        pass

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultiset.contains(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultiset, self).contains(object))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).addAll(newElements))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMultiset.toString()"""
        return str.__wrap(super(ImmutableMultiset, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(element))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def asList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableMultiset.asList()"""
        return 'ImmutableList'.__wrap(super(ImmutableMultiset, self).asList())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableCollection.spliterator()"""
        return 'Spliterator'.__wrap(super(ImmutableCollection, self).spliterator()) 
 
 
# CLASS: com.google.common.collect.ForwardingMap$StandardValues
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingMap as __ForwardingMap_StandardValues
__StandardValues = __ForwardingMap_StandardValues.StandardValues
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import com.google.common.collect.Maps as __Maps_Values
__Values = __Maps_Values.Values
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
 
class StandardValues():
    """com.google.common.collect.ForwardingMap.StandardValues"""
 
    @staticmethod
    def __wrap(java_value: __StandardValues) -> 'StandardValues':
        return StandardValues(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardValues):
        """
        Dynamic initializer for StandardValues.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$Values.remove(java.lang.Object)"""
        return bool.__wrap(super(__Values, self).remove(o))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public void com.google.common.collect.Maps$Values.forEach(java.util.function.Consumer<? super V>)"""
        super(__Values, self).forEach(action)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$Values.isEmpty()"""
        return bool.__wrap(super(Values, self).isEmpty())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool.__wrap(super(__AbstractCollection, self).add(arg0))

    @overload
    def __init__(self, this$0: 'ForwardingMap'):
        """public com.google.common.collect.ForwardingMap$StandardValues(com.google.common.collect.ForwardingMap)"""
        val = __StandardValues(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$Values.contains(java.lang.Object)"""
        return bool.__wrap(super(__Values, self).contains(o))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'.__wrap(super(Collection, self).spliterator())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<V> com.google.common.collect.Maps$Values.iterator()"""
        return 'Iterator'.__wrap(super(Values, self).iterator())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$Values.size()"""
        return int.__wrap(super(Values, self).size())

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Maps$Values.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__Values, self).removeAll(c))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$Values.clear()"""
        super(Values, self).clear()

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Maps$Values.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__Values, self).retainAll(c)) 
 
 
# CLASS: com.google.common.collect.ForwardingMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Set as __Set
__Set = __Set
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
import java.util.Collection as Collection
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.function.Function as Function
from builtins import bool
import java.util.Map as Map
from builtins import int
 
class ForwardingMap(ABC):
    """com.google.common.collect.ForwardingMap"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingMap) -> 'ForwardingMap':
        return ForwardingMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingMap):
        """
        Dynamic initializer for ForwardingMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).entrySet())

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object.__wrap(super(__ForwardingMap, self).put(key, value))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ForwardingMap, self).putAll(map)

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'.__wrap(super(ForwardingMap, self).values())

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).keySet())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__Map, self).replaceAll(arg0)

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsValue(value)) 
 
 
# CLASS: com.google.common.collect.ImmutableSet
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.ImmutableSet as __ImmutableSet_Builder
__Builder = __ImmutableSet_Builder.Builder
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
from builtins import object
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ImmutableSet(ABC):
    """com.google.common.collect.ImmutableSet"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableSet) -> 'ImmutableSet':
        return ImmutableSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableSet):
        """
        Dynamic initializer for ImmutableSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(E[])"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @staticmethod
    @overload
    def toImmutableSet() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSet<E>> com.google.common.collect.ImmutableSet.toImmutableSet()"""
        return Collector.__wrap(__ImmutableSet.toImmutableSet())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableSet, self).equals(object))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @abstractmethod
    def contains(self, object: object):
        """public abstract boolean com.google.common.collect.ImmutableCollection.contains(java.lang.Object)"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool.__wrap(super(__ImmutableCollection, self).add(e))

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3))

    @override
    @overload
    def asList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableCollection.asList()"""
        return 'ImmutableList'.__wrap(super(ImmutableCollection, self).asList())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object].__wrap(super(__ImmutableCollection, self).toArray(other))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableCollection, self).remove(object))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object].__wrap(super(ImmutableCollection, self).toArray())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).addAll(newElements))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4, e5))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableSet.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(element))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeIf(filter))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4, e5, e6, others))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableSet.hashCode()"""
        return int.__wrap(super(ImmutableSet, self).hashCode())

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builder()"""
        return Builder.__wrap(__ImmutableSet.builder())

    @staticmethod
    @overload
    def of() -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of()"""
        return ImmutableSet.__wrap(__ImmutableSet.of())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSet.iterator()"""
        pass

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableCollection.spliterator()"""
        return 'Spliterator'.__wrap(super(ImmutableCollection, self).spliterator()) 
 
 
# CLASS: com.google.common.collect.Ordering
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

from builtins import type
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.lang.Class as __Class
__Class = __Class
import java.util.function.ToIntFunction as ToIntFunction
import java.util.function.ToLongFunction as ToLongFunction
import java.util.function.ToDoubleFunction as ToDoubleFunction
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Iterator as Iterator
import java.util.Comparator as Comparator
import java.util.List as __List
__List = __List
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.Ordering as __Ordering
__Ordering = __Ordering
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.List as List
from builtins import int
 
class Ordering(ABC):
    """com.google.common.collect.Ordering"""
 
    @staticmethod
    def __wrap(java_value: __Ordering) -> 'Ordering':
        return Ordering(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Ordering):
        """
        Dynamic initializer for Ordering.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def sortedCopy(self, elements: 'Iterable') -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.sortedCopy(java.lang.Iterable<E>)"""
        return 'List'.__wrap(super(__Ordering, self).sortedCopy(elements))

    @staticmethod
    @overload
    def from(comparator: 'Comparator') -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.from(java.util.Comparator<T>)"""
        return Ordering.__wrap(__Ordering.from(comparator))

    @overload
    def leastOf(self, iterable: 'Iterable', k: int) -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.leastOf(java.lang.Iterable<E>,int)"""
        return 'List'.__wrap(super(__Ordering, self).leastOf(iterable, __int.valueOf(k)))

    @overload
    def greatestOf(self, iterable: 'Iterable', k: int) -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.greatestOf(java.lang.Iterable<E>,int)"""
        return 'List'.__wrap(super(__Ordering, self).greatestOf(iterable, __int.valueOf(k)))

    @staticmethod
    @overload
    def explicit(valuesInOrder: 'List') -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.explicit(java.util.List<T>)"""
        return Ordering.__wrap(__Ordering.explicit(valuesInOrder))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def immutableSortedCopy(self, elements: 'Iterable') -> 'ImmutableList':
        """public <E extends T> com.google.common.collect.ImmutableList<E> com.google.common.collect.Ordering.immutableSortedCopy(java.lang.Iterable<E>)"""
        return 'ImmutableList'.__wrap(super(__Ordering, self).immutableSortedCopy(elements))

    @overload
    def leastOf(self, iterator: 'Iterator', k: int) -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.leastOf(java.util.Iterator<E>,int)"""
        return 'List'.__wrap(super(__Ordering, self).leastOf(iterator, __int.valueOf(k)))

    @overload
    def nullsFirst(self) -> 'Ordering':
        """public <S extends T> com.google.common.collect.Ordering<S> com.google.common.collect.Ordering.nullsFirst()"""
        return 'Ordering'.__wrap(super(Ordering, self).nullsFirst())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def isOrdered(self, iterable: 'Iterable') -> bool:
        """public boolean com.google.common.collect.Ordering.isOrdered(java.lang.Iterable<? extends T>)"""
        return bool.__wrap(super(__Ordering, self).isOrdered(iterable))

    @staticmethod
    @overload
    def compound(comparators: 'Iterable') -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.compound(java.lang.Iterable<? extends java.util.Comparator<? super T>>)"""
        return Ordering.__wrap(__Ordering.compound(comparators))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def arbitrary() -> 'Ordering':
        """public static com.google.common.collect.Ordering<java.lang.Object> com.google.common.collect.Ordering.arbitrary()"""
        return Ordering.__wrap(__Ordering.arbitrary())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def thenComparing(self, arg0: 'Comparator') -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.thenComparing(java.util.Comparator<? super T>)"""
        return 'Comparator'.__wrap(super(__Comparator, self).thenComparing(arg0))

    @overload
    def greatestOf(self, iterator: 'Iterator', k: int) -> 'List':
        """public <E extends T> java.util.List<E> com.google.common.collect.Ordering.greatestOf(java.util.Iterator<E>,int)"""
        return 'List'.__wrap(super(__Ordering, self).greatestOf(iterator, __int.valueOf(k)))

    @overload
    def max(self, a: object, b: object, c: object, *rest: object) -> object:
        """public <E extends T> E com.google.common.collect.Ordering.max(E,E,E,E...)"""
        return object.__wrap(super(__Ordering, self).max(a, b, c, rest))

    @overload
    def thenComparing(self, arg0: 'Function') -> 'Comparator':
        """public default <U extends java.lang.Comparable<? super U>> java.util.Comparator<T> java.util.Comparator.thenComparing(java.util.function.Function<? super T, ? extends U>)"""
        return 'Comparator'.__wrap(super(__Comparator, self).thenComparing(arg0))

    @overload
    def min(self, iterable: 'Iterable') -> object:
        """public <E extends T> E com.google.common.collect.Ordering.min(java.lang.Iterable<E>)"""
        return object.__wrap(super(__Ordering, self).min(iterable))

    @overload
    def nullsLast(self) -> 'Ordering':
        """public <S extends T> com.google.common.collect.Ordering<S> com.google.common.collect.Ordering.nullsLast()"""
        return 'Ordering'.__wrap(super(Ordering, self).nullsLast())

    @overload
    def isStrictlyOrdered(self, iterable: 'Iterable') -> bool:
        """public boolean com.google.common.collect.Ordering.isStrictlyOrdered(java.lang.Iterable<? extends T>)"""
        return bool.__wrap(super(__Ordering, self).isStrictlyOrdered(iterable))

    @overload
    def min(self, a: object, b: object, c: object, *rest: object) -> object:
        """public <E extends T> E com.google.common.collect.Ordering.min(E,E,E,E...)"""
        return object.__wrap(super(__Ordering, self).min(a, b, c, rest))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def max(self, a: object, b: object) -> object:
        """public <E extends T> E com.google.common.collect.Ordering.max(E,E)"""
        return object.__wrap(super(__Ordering, self).max(a, b))

    @overload
    def max(self, iterable: 'Iterable') -> object:
        """public <E extends T> E com.google.common.collect.Ordering.max(java.lang.Iterable<E>)"""
        return object.__wrap(super(__Ordering, self).max(iterable))

    @overload
    def thenComparingLong(self, arg0: 'ToLongFunction') -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.thenComparingLong(java.util.function.ToLongFunction<? super T>)"""
        return 'Comparator'.__wrap(super(__Comparator, self).thenComparingLong(arg0))

    @overload
    def thenComparing(self, arg0: 'Function', arg1: 'Comparator') -> 'Comparator':
        """public default <U> java.util.Comparator<T> java.util.Comparator.thenComparing(java.util.function.Function<? super T, ? extends U>,java.util.Comparator<? super U>)"""
        return 'Comparator'.__wrap(super(__Comparator, self).thenComparing(arg0, arg1))

    @overload
    def thenComparingDouble(self, arg0: 'ToDoubleFunction') -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.thenComparingDouble(java.util.function.ToDoubleFunction<? super T>)"""
        return 'Comparator'.__wrap(super(__Comparator, self).thenComparingDouble(arg0))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @abstractmethod
    def compare(self, left: object, right: object):
        """public abstract int com.google.common.collect.Ordering.compare(T,T)"""
        pass

    @overload
    def max(self, iterator: 'Iterator') -> object:
        """public <E extends T> E com.google.common.collect.Ordering.max(java.util.Iterator<E>)"""
        return object.__wrap(super(__Ordering, self).max(iterator))

    @staticmethod
    @overload
    def explicit(leastValue: object, *remainingValuesInOrder: object) -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.explicit(T,T...)"""
        return Ordering.__wrap(__Ordering.explicit(leastValue, remainingValuesInOrder))

    @overload
    def compound(self, secondaryComparator: 'Comparator') -> 'Ordering':
        """public <U extends T> com.google.common.collect.Ordering<U> com.google.common.collect.Ordering.compound(java.util.Comparator<? super U>)"""
        return 'Ordering'.__wrap(super(__Ordering, self).compound(secondaryComparator))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def reverse(self) -> 'Ordering':
        """public <S extends T> com.google.common.collect.Ordering<S> com.google.common.collect.Ordering.reverse()"""
        return 'Ordering'.__wrap(super(Ordering, self).reverse())

    @staticmethod
    @overload
    def from(ordering: 'Ordering') -> 'Ordering':
        """public static <T> com.google.common.collect.Ordering<T> com.google.common.collect.Ordering.from(com.google.common.collect.Ordering<T>)"""
        return Ordering.__wrap(__Ordering.from(ordering))

    @overload
    def lexicographical(self) -> 'Ordering':
        """public <S extends T> com.google.common.collect.Ordering<java.lang.Iterable<S>> com.google.common.collect.Ordering.lexicographical()"""
        return 'Ordering'.__wrap(super(Ordering, self).lexicographical())

    @overload
    def min(self, a: object, b: object) -> object:
        """public <E extends T> E com.google.common.collect.Ordering.min(E,E)"""
        return object.__wrap(super(__Ordering, self).min(a, b))

    @overload
    def binarySearch(self, sortedList: 'List', key: object) -> int:
        """public int com.google.common.collect.Ordering.binarySearch(java.util.List<? extends T>,T)"""
        return int.__wrap(super(__Ordering, self).binarySearch(sortedList, key))

    @staticmethod
    @overload
    def usingToString() -> 'Ordering':
        """public static com.google.common.collect.Ordering<java.lang.Object> com.google.common.collect.Ordering.usingToString()"""
        return Ordering.__wrap(__Ordering.usingToString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def reversed(self) -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.reversed()"""
        return 'Comparator'.__wrap(super(Comparator, self).reversed())

    @overload
    def min(self, iterator: 'Iterator') -> object:
        """public <E extends T> E com.google.common.collect.Ordering.min(java.util.Iterator<E>)"""
        return object.__wrap(super(__Ordering, self).min(iterator))

    @overload
    def onResultOf(self, function: 'Function') -> 'Ordering':
        """public <F> com.google.common.collect.Ordering<F> com.google.common.collect.Ordering.onResultOf(com.google.common.base.Function<F, ? extends T>)"""
        return 'Ordering'.__wrap(super(__Ordering, self).onResultOf(function))

    @overload
    def thenComparingInt(self, arg0: 'ToIntFunction') -> 'Comparator':
        """public default java.util.Comparator<T> java.util.Comparator.thenComparingInt(java.util.function.ToIntFunction<? super T>)"""
        return 'Comparator'.__wrap(super(__Comparator, self).thenComparingInt(arg0))

    @staticmethod
    @overload
    def natural() -> 'Ordering':
        """public static <C extends java.lang.Comparable> com.google.common.collect.Ordering<C> com.google.common.collect.Ordering.natural()"""
        return Ordering.__wrap(__Ordering.natural())

    @staticmethod
    @overload
    def allEqual() -> 'Ordering':
        """public static com.google.common.collect.Ordering<java.lang.Object> com.google.common.collect.Ordering.allEqual()"""
        return Ordering.__wrap(__Ordering.allEqual()) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder$SetMultimapBuilder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_SetMultimapBuilder
__SetMultimapBuilder = __MultimapBuilder_SetMultimapBuilder.SetMultimapBuilder
from abc import abstractmethod, ABC
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_MultimapBuilderWithKeys
__MultimapBuilderWithKeys = __MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.MultimapBuilder as __MultimapBuilder
__MultimapBuilder = __MultimapBuilder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.SetMultimap as __SetMultimap
__SetMultimap = __SetMultimap
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class SetMultimapBuilder(ABC):
    """com.google.common.collect.MultimapBuilder.SetMultimapBuilder"""
 
    @staticmethod
    def __wrap(java_value: __SetMultimapBuilder) -> 'SetMultimapBuilder':
        return SetMultimapBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __SetMultimapBuilder):
        """
        Dynamic initializer for SetMultimapBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def hashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys(int)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.hashKeys(__int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def hashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.hashKeys())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def treeKeys(comparator: 'Comparator') -> 'MultimapBuilderWithKeys':
        """public static <K0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.treeKeys(java.util.Comparator<K0>)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.treeKeys(comparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @abstractmethod
    def build(self, ):
        """public abstract <K extends K0,V extends V0> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.MultimapBuilder$SetMultimapBuilder.build()"""
        pass

    @staticmethod
    @overload
    def treeKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Comparable> com.google.common.collect.MultimapBuilder.treeKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.treeKeys())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def linkedHashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.linkedHashKeys())

    @staticmethod
    @overload
    def enumKeys(keyClass: 'Class') -> 'MultimapBuilderWithKeys':
        """public static <K0 extends java.lang.Enum<K0>> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.enumKeys(java.lang.Class<K0>)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.enumKeys(keyClass))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def build(self, multimap: 'Multimap') -> 'SetMultimap':
        """public <K extends K0,V extends V0> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.MultimapBuilder$SetMultimapBuilder.build(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'SetMultimap'.__wrap(super(__SetMultimapBuilder, self).build(multimap))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def linkedHashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys(int)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.linkedHashKeys(__int.valueOf(expectedKeys)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.Maps$EntryTransformer
import com.google.common.collect.Maps as __Maps_EntryTransformer
__EntryTransformer = __Maps_EntryTransformer.EntryTransformer
from abc import abstractmethod, ABC
 
class EntryTransformer(ABC):
    """com.google.common.collect.Maps.EntryTransformer"""
 
    @staticmethod
    def __wrap(java_value: __EntryTransformer) -> 'EntryTransformer':
        return EntryTransformer(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __EntryTransformer):
        """
        Dynamic initializer for EntryTransformer.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def transformEntry(self, key: object, value: object):
        """public abstract V2 com.google.common.collect.Maps$EntryTransformer.transformEntry(K,V1)"""
        pass 
 
 
# CLASS: com.google.common.collect.ImmutableRangeSet
import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet
__ImmutableSortedSet = __ImmutableSortedSet
from builtins import str
from pyquantum_helper import override
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import com.google.common.collect.AbstractRangeSet as __AbstractRangeSet
__AbstractRangeSet = __AbstractRangeSet
import java.lang.Comparable as Comparable
import java.util.stream.Collector as Collector
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableRangeSet as __ImmutableRangeSet_Builder
__Builder = __ImmutableRangeSet_Builder.Builder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.RangeSet as __RangeSet
__RangeSet = __RangeSet
import com.google.common.collect.Range as __Range
__Range = __Range
import com.google.common.collect.ImmutableRangeSet as __ImmutableRangeSet
__ImmutableRangeSet = __ImmutableRangeSet
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ImmutableRangeSet():
    """com.google.common.collect.ImmutableRangeSet"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableRangeSet) -> 'ImmutableRangeSet':
        return ImmutableRangeSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableRangeSet):
        """
        Dynamic initializer for ImmutableRangeSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def add(self, range: 'Range'):
        """public void com.google.common.collect.ImmutableRangeSet.add(com.google.common.collect.Range<C>)"""
        super(__ImmutableRangeSet, self).add(range)

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def subRangeSet(self, range: 'Range') -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.subRangeSet(com.google.common.collect.Range<C>)"""
        return 'ImmutableRangeSet'.__wrap(super(__ImmutableRangeSet, self).subRangeSet(range))

    @overload
    def union(self, other: 'RangeSet') -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.union(com.google.common.collect.RangeSet<C>)"""
        return 'ImmutableRangeSet'.__wrap(super(__ImmutableRangeSet, self).union(other))

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractRangeSet.toString()"""
        return str.__wrap(super(AbstractRangeSet, self).toString())

    @staticmethod
    @overload
    def of(range: 'Range') -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.of(com.google.common.collect.Range<C>)"""
        return ImmutableRangeSet.__wrap(__ImmutableRangeSet.of(range))

    @overload
    def enclosesAll(self, other: 'Iterable') -> bool:
        """public default boolean com.google.common.collect.RangeSet.enclosesAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return bool.__wrap(super(__RangeSet, self).enclosesAll(other))

    @staticmethod
    @overload
    def unionOf(ranges: 'Iterable') -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.unionOf(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return ImmutableRangeSet.__wrap(__ImmutableRangeSet.unionOf(ranges))

    @staticmethod
    @overload
    def copyOf(rangeSet: 'RangeSet') -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.copyOf(com.google.common.collect.RangeSet<C>)"""
        return ImmutableRangeSet.__wrap(__ImmutableRangeSet.copyOf(rangeSet))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def addAll(self, other: 'RangeSet'):
        """public void com.google.common.collect.ImmutableRangeSet.addAll(com.google.common.collect.RangeSet<C>)"""
        super(__ImmutableRangeSet, self).addAll(other)

    @override
    @overload
    def span(self) -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.ImmutableRangeSet.span()"""
        return 'Range'.__wrap(super(ImmutableRangeSet, self).span())

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractRangeSet.hashCode()"""
        return int.__wrap(super(AbstractRangeSet, self).hashCode())

    @override
    @overload
    def removeAll(self, other: 'Iterable'):
        """public void com.google.common.collect.ImmutableRangeSet.removeAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(__ImmutableRangeSet, self).removeAll(other)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def encloses(self, otherRange: 'Range') -> bool:
        """public boolean com.google.common.collect.ImmutableRangeSet.encloses(com.google.common.collect.Range<C>)"""
        return bool.__wrap(super(__ImmutableRangeSet, self).encloses(otherRange))

    @overload
    def intersection(self, other: 'RangeSet') -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.intersection(com.google.common.collect.RangeSet<C>)"""
        return 'ImmutableRangeSet'.__wrap(super(__ImmutableRangeSet, self).intersection(other))

    @override
    @overload
    def asRanges(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Range<C>> com.google.common.collect.ImmutableRangeSet.asRanges()"""
        return 'ImmutableSet'.__wrap(super(ImmutableRangeSet, self).asRanges())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.ImmutableRangeSet$Builder<C> com.google.common.collect.ImmutableRangeSet.builder()"""
        return Builder.__wrap(__ImmutableRangeSet.builder())

    @overload
    def asSet(self, domain: 'DiscreteDomain') -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<C> com.google.common.collect.ImmutableRangeSet.asSet(com.google.common.collect.DiscreteDomain<C>)"""
        return 'ImmutableSortedSet'.__wrap(super(__ImmutableRangeSet, self).asSet(domain))

    @staticmethod
    @overload
    def of() -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.of()"""
        return ImmutableRangeSet.__wrap(__ImmutableRangeSet.of())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ImmutableRangeSet.isEmpty()"""
        return bool.__wrap(super(ImmutableRangeSet, self).isEmpty())

    @override
    @overload
    def asDescendingSetOfRanges(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Range<C>> com.google.common.collect.ImmutableRangeSet.asDescendingSetOfRanges()"""
        return 'ImmutableSet'.__wrap(super(ImmutableRangeSet, self).asDescendingSetOfRanges())

    @overload
    def difference(self, other: 'RangeSet') -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.difference(com.google.common.collect.RangeSet<C>)"""
        return 'ImmutableRangeSet'.__wrap(super(__ImmutableRangeSet, self).difference(other))

    @overload
    def rangeContaining(self, value: 'Comparable') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.ImmutableRangeSet.rangeContaining(C)"""
        return 'Range'.__wrap(super(__ImmutableRangeSet, self).rangeContaining(value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def intersects(self, otherRange: 'Range') -> bool:
        """public boolean com.google.common.collect.ImmutableRangeSet.intersects(com.google.common.collect.Range<C>)"""
        return bool.__wrap(super(__ImmutableRangeSet, self).intersects(otherRange))

    @override
    @overload
    def addAll(self, other: 'Iterable'):
        """public void com.google.common.collect.ImmutableRangeSet.addAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(__ImmutableRangeSet, self).addAll(other)

    @override
    @overload
    def removeAll(self, other: 'RangeSet'):
        """public void com.google.common.collect.ImmutableRangeSet.removeAll(com.google.common.collect.RangeSet<C>)"""
        super(__ImmutableRangeSet, self).removeAll(other)

    @staticmethod
    @overload
    def copyOf(ranges: 'Iterable') -> 'ImmutableRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.copyOf(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return ImmutableRangeSet.__wrap(__ImmutableRangeSet.copyOf(ranges))

    @staticmethod
    @overload
    def toImmutableRangeSet() -> 'Collector':
        """public static <E extends java.lang.Comparable<? super E>> java.util.stream.Collector<com.google.common.collect.Range<E>, ?, com.google.common.collect.ImmutableRangeSet<E>> com.google.common.collect.ImmutableRangeSet.toImmutableRangeSet()"""
        return Collector.__wrap(__ImmutableRangeSet.toImmutableRangeSet())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def remove(self, range: 'Range'):
        """public void com.google.common.collect.ImmutableRangeSet.remove(com.google.common.collect.Range<C>)"""
        super(__ImmutableRangeSet, self).remove(range)

    @override
    @overload
    def complement(self) -> 'ImmutableRangeSet':
        """public com.google.common.collect.ImmutableRangeSet<C> com.google.common.collect.ImmutableRangeSet.complement()"""
        return 'ImmutableRangeSet'.__wrap(super(ImmutableRangeSet, self).complement()) 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableMap
import com.google.common.collect.ForwardingNavigableMap as __ForwardingNavigableMap
__ForwardingNavigableMap = __ForwardingNavigableMap
import java.util.NavigableMap as __NavigableMap
__NavigableMap = __NavigableMap
import java.lang.Boolean as __boolean
from builtins import type
import java.util.Map as __Map_Entry
__Entry = __Map_Entry.Entry
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
import java.util.Collection as Collection
import java.util.NavigableMap as NavigableMap
import java.util.SequencedCollection as SequencedCollection
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Map.Entry as Entry
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
import java.util.SortedMap as SortedMap
import java.util.SequencedCollection as __SequencedCollection
__SequencedCollection = __SequencedCollection
import java.util.SequencedSet as SequencedSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.SortedMap as __SortedMap
__SortedMap = __SortedMap
import com.google.common.collect.ForwardingSortedMap as __ForwardingSortedMap
__ForwardingSortedMap = __ForwardingSortedMap
import java.util.Set as __Set
__Set = __Set
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.SequencedMap as __SequencedMap
__SequencedMap = __SequencedMap
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.SequencedSet as __SequencedSet
__SequencedSet = __SequencedSet
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import int
 
class ForwardingNavigableMap(ABC):
    """com.google.common.collect.ForwardingNavigableMap"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingNavigableMap) -> 'ForwardingNavigableMap':
        return ForwardingNavigableMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingNavigableMap):
        """
        Dynamic initializer for ForwardingNavigableMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def floorKey(self, key: object) -> object:
        """public K com.google.common.collect.ForwardingNavigableMap.floorKey(K)"""
        return object.__wrap(super(__ForwardingNavigableMap, self).floorKey(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def sequencedEntrySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<java.util.Map$Entry<K, V>> java.util.SequencedMap.sequencedEntrySet()"""
        return 'SequencedSet'.__wrap(super(SequencedMap, self).sequencedEntrySet())

    @overload
    def putFirst(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putFirst(K,V)"""
        return object.__wrap(super(__SortedMap, self).putFirst(arg0, arg1))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).entrySet())

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object.__wrap(super(__ForwardingMap, self).put(key, value))

    @overload
    def higherEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.higherEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ForwardingNavigableMap, self).higherEntry(key))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def lastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.lastEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(ForwardingNavigableMap, self).lastEntry())

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @overload
    def headMap(self, toKey: object, inclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.ForwardingNavigableMap.headMap(K,boolean)"""
        return 'NavigableMap'.__wrap(super(__ForwardingNavigableMap, self).headMap(toKey, __boolean.valueOf(inclusive)))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @override
    @overload
    def sequencedValues(self) -> 'SequencedCollection':
        """public default java.util.SequencedCollection<V> java.util.SequencedMap.sequencedValues()"""
        return 'SequencedCollection'.__wrap(super(SequencedMap, self).sequencedValues())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @overload
    def floorEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.floorEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ForwardingNavigableMap, self).floorEntry(key))

    @overload
    def tailMap(self, fromKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.tailMap(K)"""
        return 'SortedMap'.__wrap(super(__ForwardingSortedMap, self).tailMap(fromKey))

    @overload
    def lowerKey(self, key: object) -> object:
        """public K com.google.common.collect.ForwardingNavigableMap.lowerKey(K)"""
        return object.__wrap(super(__ForwardingNavigableMap, self).lowerKey(key))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'.__wrap(super(ForwardingMap, self).values())

    @override
    @overload
    def reversed(self) -> 'NavigableMap':
        """public default java.util.NavigableMap<K, V> java.util.NavigableMap.reversed()"""
        return 'NavigableMap'.__wrap(super(NavigableMap, self).reversed())

    @overload
    def higherKey(self, key: object) -> object:
        """public K com.google.common.collect.ForwardingNavigableMap.higherKey(K)"""
        return object.__wrap(super(__ForwardingNavigableMap, self).higherKey(key))

    @overload
    def headMap(self, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.headMap(K)"""
        return 'SortedMap'.__wrap(super(__ForwardingSortedMap, self).headMap(toKey))

    @override
    @overload
    def navigableKeySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.ForwardingNavigableMap.navigableKeySet()"""
        return 'NavigableSet'.__wrap(super(ForwardingNavigableMap, self).navigableKeySet())

    @overload
    def tailMap(self, fromKey: object, inclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.ForwardingNavigableMap.tailMap(K,boolean)"""
        return 'NavigableMap'.__wrap(super(__ForwardingNavigableMap, self).tailMap(fromKey, __boolean.valueOf(inclusive)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__Map, self).replaceAll(arg0)

    @overload
    def putLast(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putLast(K,V)"""
        return object.__wrap(super(__SortedMap, self).putLast(arg0, arg1))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def ceilingEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.ceilingEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ForwardingNavigableMap, self).ceilingEntry(key))

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.ForwardingSortedMap.comparator()"""
        return 'Comparator'.__wrap(super(ForwardingSortedMap, self).comparator())

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).remove(key))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def descendingKeySet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.ForwardingNavigableMap.descendingKeySet()"""
        return 'NavigableSet'.__wrap(super(ForwardingNavigableMap, self).descendingKeySet())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @overload
    def ceilingKey(self, key: object) -> object:
        """public K com.google.common.collect.ForwardingNavigableMap.ceilingKey(K)"""
        return object.__wrap(super(__ForwardingNavigableMap, self).ceilingKey(key))

    @override
    @overload
    def lastKey(self) -> object:
        """public K com.google.common.collect.ForwardingSortedMap.lastKey()"""
        return object.__wrap(super(ForwardingSortedMap, self).lastKey())

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @override
    @overload
    def descendingMap(self) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.ForwardingNavigableMap.descendingMap()"""
        return 'NavigableMap'.__wrap(super(ForwardingNavigableMap, self).descendingMap())

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @override
    @overload
    def sequencedKeySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<K> java.util.SequencedMap.sequencedKeySet()"""
        return 'SequencedSet'.__wrap(super(SequencedMap, self).sequencedKeySet())

    @overload
    def lowerEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.lowerEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ForwardingNavigableMap, self).lowerEntry(key))

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ForwardingMap, self).putAll(map)

    @override
    @overload
    def firstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.firstEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(ForwardingNavigableMap, self).firstEntry())

    @overload
    def subMap(self, fromKey: object, fromInclusive: bool, toKey: object, toInclusive: bool) -> 'NavigableMap':
        """public java.util.NavigableMap<K, V> com.google.common.collect.ForwardingNavigableMap.subMap(K,boolean,K,boolean)"""
        return 'NavigableMap'.__wrap(super(__ForwardingNavigableMap, self).subMap(fromKey, __boolean.valueOf(fromInclusive), toKey, __boolean.valueOf(toInclusive)))

    @override
    @overload
    def firstKey(self) -> object:
        """public K com.google.common.collect.ForwardingSortedMap.firstKey()"""
        return object.__wrap(super(ForwardingSortedMap, self).firstKey())

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def pollLastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.pollLastEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(ForwardingNavigableMap, self).pollLastEntry())

    @overload
    def subMap(self, fromKey: object, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.subMap(K,K)"""
        return 'SortedMap'.__wrap(super(__ForwardingSortedMap, self).subMap(fromKey, toKey))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).keySet())

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsValue(value))

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ForwardingNavigableMap.pollFirstEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(ForwardingNavigableMap, self).pollFirstEntry()) 
 
 
# CLASS: com.google.common.collect.HashMultiset
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import com.google.common.collect.AbstractMultiset as __AbstractMultiset
__AbstractMultiset = __AbstractMultiset
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.HashMultiset as __HashMultiset
__HashMultiset = __HashMultiset
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
from builtins import object
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
 
class HashMultiset():
    """com.google.common.collect.HashMultiset"""
 
    @staticmethod
    def __wrap(java_value: __HashMultiset) -> 'HashMultiset':
        return HashMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __HashMultiset):
        """
        Dynamic initializer for HashMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'HashMultiset':
        """public static <E> com.google.common.collect.HashMultiset<E> com.google.common.collect.HashMultiset.create(java.lang.Iterable<? extends E>)"""
        return HashMultiset.__wrap(__HashMultiset.create(elements))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @staticmethod
    @overload
    def create() -> 'HashMultiset':
        """public static <E> com.google.common.collect.HashMultiset<E> com.google.common.collect.HashMultiset.create()"""
        return HashMultiset.__wrap(__HashMultiset.create())

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).retainAll(elementsToRetain))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).equals(object))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool.__wrap(super(__AbstractMultiset, self).add(element))

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).remove(element))

    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def create(distinctElements: int) -> 'HashMultiset':
        """public static <E> com.google.common.collect.HashMultiset<E> com.google.common.collect.HashMultiset.create(int)"""
        return HashMultiset.__wrap(__HashMultiset.create(__int.valueOf(distinctElements)))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str.__wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int.__wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.ForwardingIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
from builtins import type
from builtins import object
import java.util.function.Consumer as Consumer
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ForwardingIterator as __ForwardingIterator
__ForwardingIterator = __ForwardingIterator
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ForwardingIterator(ABC):
    """com.google.common.collect.ForwardingIterator"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingIterator) -> 'ForwardingIterator':
        return ForwardingIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingIterator):
        """
        Dynamic initializer for ForwardingIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.google.common.collect.ForwardingIterator.hasNext()"""
        return bool.__wrap(super(ForwardingIterator, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def next(self) -> object:
        """public T com.google.common.collect.ForwardingIterator.next()"""
        return object.__wrap(super(ForwardingIterator, self).next())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(__Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def remove(self):
        """public void com.google.common.collect.ForwardingIterator.remove()"""
        super(ForwardingIterator, self).remove()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ForwardingQueue
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingQueue as __ForwardingQueue
__ForwardingQueue = __ForwardingQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ForwardingQueue(ABC):
    """com.google.common.collect.ForwardingQueue"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingQueue) -> 'ForwardingQueue':
        return ForwardingQueue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingQueue):
        """
        Dynamic initializer for ForwardingQueue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.poll()"""
        return object.__wrap(super(ForwardingQueue, self).poll())

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.peek()"""
        return object.__wrap(super(ForwardingQueue, self).peek())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def remove(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.remove()"""
        return object.__wrap(super(ForwardingQueue, self).remove())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def offer(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingQueue.offer(E)"""
        return bool.__wrap(super(__ForwardingQueue, self).offer(o))

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'.__wrap(super(Collection, self).spliterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @override
    @overload
    def element(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.element()"""
        return object.__wrap(super(ForwardingQueue, self).element())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedMultiset
import com.google.common.collect.Multiset as __Multiset_Entry
__Entry = __Multiset_Entry.Entry
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import com.google.common.collect.SortedMultiset as __SortedMultiset
__SortedMultiset = __SortedMultiset
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset
__ImmutableMultiset = __ImmutableMultiset
from abc import abstractmethod, ABC
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import java.util.function.ToIntFunction as ToIntFunction
import com.google.common.collect.ImmutableSortedMultiset as __ImmutableSortedMultiset
__ImmutableSortedMultiset = __ImmutableSortedMultiset
from builtins import bool
import com.google.common.collect.UnmodifiableIterator as __UnmodifiableIterator
__UnmodifiableIterator = __UnmodifiableIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import java.lang.Comparable as Comparable
from builtins import object
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset_Builder
__Builder = __ImmutableMultiset_Builder.Builder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import com.google.common.collect.ImmutableSortedMultiset as __ImmutableSortedMultiset_Builder
__Builder = __ImmutableSortedMultiset_Builder.Builder
import java.util.function.Function as Function
import java.lang.Integer as __int
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ImmutableSortedMultiset(ABC):
    """com.google.common.collect.ImmutableSortedMultiset"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableSortedMultiset) -> 'ImmutableSortedMultiset':
        return ImmutableSortedMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableSortedMultiset):
        """
        Dynamic initializer for ImmutableSortedMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copyOfSorted(sortedMultiset: 'SortedMultiset') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOfSorted(com.google.common.collect.SortedMultiset<E>)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.copyOfSorted(sortedMultiset))

    @abstractmethod
    def lastEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.lastEntry()"""
        pass

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterable') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(java.util.Comparator<? super E>,java.lang.Iterable<? extends E>)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.copyOf(comparator, elements))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(element))

    @staticmethod
    @overload
    def of() -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of()"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableMultiset$Builder<E> com.google.common.collect.ImmutableMultiset.builder()"""
        return Builder.__wrap(__ImmutableMultiset.builder())

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry':
        """public final com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ImmutableSortedMultiset.pollFirstEntry()"""
        return 'Entry'.__wrap(super(ImmutableSortedMultiset, self).pollFirstEntry())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E,E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2, e3, e4, e5))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.add(E,int)"""
        return int.__wrap(super(__ImmutableMultiset, self).add(element, __int.valueOf(occurrences)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *remaining: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2, e3, e4, e5, e6, remaining))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @abstractmethod
    def count(self, element: object):
        """public abstract int com.google.common.collect.Multiset.count(java.lang.Object)"""
        pass

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2, e3))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E,E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ImmutableMultiset.entrySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMultiset, self).entrySet())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSortedMultiset':
        """public static <Z> com.google.common.collect.ImmutableSortedMultiset<Z> com.google.common.collect.ImmutableSortedMultiset.copyOf(Z[])"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.copyOf(elements))

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool.__wrap(super(__ImmutableCollection, self).add(e))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset.builder()"""
        return Builder.__wrap(__ImmutableSortedMultiset.builder())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object].__wrap(super(__ImmutableCollection, self).toArray(other))

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableCollection, self).remove(object))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset.orderedBy(java.util.Comparator<E>)"""
        return Builder.__wrap(__ImmutableSortedMultiset.orderedBy(comparator))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.copyOf(elements))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.copyOf(elements))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable', e6: 'Comparable', *remaining: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2, e3, e4, e5, e6, remaining))

    @override
    @overload
    def iterator(self) -> 'UnmodifiableIterator':
        """public com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableMultiset.iterator()"""
        return 'UnmodifiableIterator'.__wrap(super(ImmutableMultiset, self).iterator())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E,E,E,E,E...)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2, e3, e4, e5, e6, others))

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeIf(filter))

    @overload
    def subMultiset(self, lowerBound: object, lowerBoundType: 'BoundType', upperBound: object, upperBoundType: 'BoundType') -> 'ImmutableSortedMultiset':
        """public com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.subMultiset(E,com.google.common.collect.BoundType,E,com.google.common.collect.BoundType)"""
        return 'ImmutableSortedMultiset'.__wrap(super(__ImmutableSortedMultiset, self).subMultiset(lowerBound, lowerBoundType, upperBound, upperBoundType))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @override
    @overload
    def pollLastEntry(self) -> 'Entry':
        """public final com.google.common.collect.Multiset$Entry<E> com.google.common.collect.ImmutableSortedMultiset.pollLastEntry()"""
        return 'Entry'.__wrap(super(ImmutableSortedMultiset, self).pollLastEntry())

    @abstractmethod
    def elementSet(self, ):
        """public abstract com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedMultiset.elementSet()"""
        pass

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultiset, self).equals(object))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.setCount(E,int)"""
        return int.__wrap(super(__ImmutableMultiset, self).setCount(element, __int.valueOf(count)))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMultiset.hashCode()"""
        return int.__wrap(super(ImmutableMultiset, self).hashCode())

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterator') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(java.util.Comparator<? super E>,java.util.Iterator<? extends E>)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.copyOf(comparator, elements))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def toImmutableMultiset() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableMultiset<E>> com.google.common.collect.ImmutableSortedMultiset.toImmutableMultiset()"""
        return Collector.__wrap(__ImmutableSortedMultiset.toImmutableMultiset())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E,E,E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(e1, e2, e3))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def reverseOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset.reverseOrder()"""
        return Builder.__wrap(__ImmutableSortedMultiset.reverseOrder())

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public final int com.google.common.collect.ImmutableMultiset.remove(java.lang.Object,int)"""
        return int.__wrap(super(__ImmutableMultiset, self).remove(element, __int.valueOf(occurrences)))

    @abstractmethod
    def tailMultiset(self, lowerBound: object, boundType: 'BoundType'):
        """public abstract com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.tailMultiset(E,com.google.common.collect.BoundType)"""
        pass

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__Multiset, self).forEachEntry(action)

    @staticmethod
    @overload
    def of(element: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(element))

    @staticmethod
    @overload
    def toImmutableMultiset(elementFunction: 'Function', countFunction: 'ToIntFunction') -> 'Collector':
        """public static <T,E> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMultiset<E>> com.google.common.collect.ImmutableSortedMultiset.toImmutableMultiset(java.util.function.Function<? super T, ? extends E>,java.util.function.ToIntFunction<? super T>)"""
        return Collector.__wrap(__ImmutableSortedMultiset.toImmutableMultiset(elementFunction, countFunction))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.copyOf(elements))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2, e3))

    @abstractmethod
    def firstEntry(self, ):
        """public abstract com.google.common.collect.Multiset$Entry<E> com.google.common.collect.SortedMultiset.firstEntry()"""
        pass

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(E[])"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.copyOf(elements))

    @override
    @overload
    def descendingMultiset(self) -> 'ImmutableSortedMultiset':
        """public com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.descendingMultiset()"""
        return 'ImmutableSortedMultiset'.__wrap(super(ImmutableSortedMultiset, self).descendingMultiset())

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.copyOf(elements))

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public final java.util.Comparator<? super E> com.google.common.collect.ImmutableSortedMultiset.comparator()"""
        return 'Comparator'.__wrap(super(ImmutableSortedMultiset, self).comparator())

    @staticmethod
    @overload
    def copyOf(elements: 'Comparable') -> 'ImmutableSortedMultiset':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.copyOf(E[])"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.copyOf(elements))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object].__wrap(super(ImmutableCollection, self).toArray())

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultiset.setCount(E,int,int)"""
        return bool.__wrap(super(__ImmutableMultiset, self).setCount(element, __int.valueOf(oldCount), __int.valueOf(newCount)))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultiset.contains(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultiset, self).contains(object))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).addAll(newElements))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @staticmethod
    @overload
    def toImmutableSortedMultiset(comparator: 'Comparator') -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSortedMultiset<E>> com.google.common.collect.ImmutableSortedMultiset.toImmutableSortedMultiset(java.util.Comparator<? super E>)"""
        return Collector.__wrap(__ImmutableSortedMultiset.toImmutableSortedMultiset(comparator))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMultiset.toString()"""
        return str.__wrap(super(ImmutableMultiset, self).toString())

    @staticmethod
    @overload
    def toImmutableSortedMultiset(comparator: 'Comparator', elementFunction: 'Function', countFunction: 'ToIntFunction') -> 'Collector':
        """public static <T,E> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSortedMultiset<E>> com.google.common.collect.ImmutableSortedMultiset.toImmutableSortedMultiset(java.util.Comparator<? super E>,java.util.function.Function<? super T, ? extends E>,java.util.function.ToIntFunction<? super T>)"""
        return Collector.__wrap(__ImmutableSortedMultiset.toImmutableSortedMultiset(comparator, elementFunction, countFunction))

    @staticmethod
    @overload
    def naturalOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedMultiset$Builder<E> com.google.common.collect.ImmutableSortedMultiset.naturalOrder()"""
        return Builder.__wrap(__ImmutableSortedMultiset.naturalOrder())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2, e3, e4))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @abstractmethod
    def headMultiset(self, upperBound: object, boundType: 'BoundType'):
        """public abstract com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.headMultiset(E,com.google.common.collect.BoundType)"""
        pass

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.ImmutableMultiset.of(E)"""
        return ImmutableMultiset.__wrap(__ImmutableMultiset.of(element))

    @staticmethod
    @overload
    def of() -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of()"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of())

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSortedMultiset':
        """public static <E> com.google.common.collect.ImmutableSortedMultiset<E> com.google.common.collect.ImmutableSortedMultiset.of(E,E,E,E,E)"""
        return ImmutableSortedMultiset.__wrap(__ImmutableSortedMultiset.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def asList(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableMultiset.asList()"""
        return 'ImmutableList'.__wrap(super(ImmutableMultiset, self).asList())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableCollection.spliterator()"""
        return 'Spliterator'.__wrap(super(ImmutableCollection, self).spliterator()) 
 
 
# CLASS: com.google.common.collect.ForwardingSet
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingSet as __ForwardingSet
__ForwardingSet = __ForwardingSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ForwardingSet(ABC):
    """com.google.common.collect.ForwardingSet"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingSet) -> 'ForwardingSet':
        return ForwardingSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingSet):
        """
        Dynamic initializer for ForwardingSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int.__wrap(super(ForwardingSet, self).hashCode())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingSet, self).equals(object))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'.__wrap(super(Set, self).spliterator())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.Maps
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

import com.google.common.base.Converter as __Converter
__Converter = __Converter
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.concurrent.ConcurrentMap as ConcurrentMap
import com.google.common.collect.SortedMapDifference as __SortedMapDifference
__SortedMapDifference = __SortedMapDifference
import java.util.TreeMap as __TreeMap
__TreeMap = __TreeMap
import java.util.Map.Entry as Entry
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BinaryOperator as BinaryOperator
import java.util.SortedMap as SortedMap
from builtins import bool
import java.util.IdentityHashMap as __IdentityHashMap
__IdentityHashMap = __IdentityHashMap
import java.util.NavigableSet as NavigableSet
import java.util.SortedMap as __SortedMap
__SortedMap = __SortedMap
import java.util.SortedSet as SortedSet
import java.util.stream.Collector as Collector
import java.util.IdentityHashMap as IdentityHashMap
import java.util.Comparator as Comparator
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.Properties as Properties
import java.util.EnumMap as EnumMap
import java.util.concurrent.ConcurrentMap as __ConcurrentMap
__ConcurrentMap = __ConcurrentMap
from builtins import int
import java.util.NavigableMap as __NavigableMap
__NavigableMap = __NavigableMap
import java.util.HashMap as __HashMap
__HashMap = __HashMap
import java.util.EnumMap as __EnumMap
__EnumMap = __EnumMap
import java.util.LinkedHashMap as __LinkedHashMap
__LinkedHashMap = __LinkedHashMap
from builtins import type
import java.util.Map as __Map_Entry
__Entry = __Map_Entry.Entry
import java.util.Map as __Map
__Map = __Map
import java.util.NavigableMap as NavigableMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import com.google.common.collect.Maps as __Maps
__Maps = __Maps
import java.util.LinkedHashMap as LinkedHashMap
import java.lang.Iterable as Iterable
import java.util.HashMap as HashMap
import java.util.Iterator as Iterator
import com.google.common.collect.BiMap as __BiMap
__BiMap = __BiMap
import java.util.TreeMap as TreeMap
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import com.google.common.collect.MapDifference as __MapDifference
__MapDifference = __MapDifference
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.Map as Map
 
class Maps():
    """com.google.common.collect.Maps"""
 
    @staticmethod
    def __wrap(java_value: __Maps) -> 'Maps':
        return Maps(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Maps):
        """
        Dynamic initializer for Maps.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def newHashMapWithExpectedSize(expectedSize: int) -> 'HashMap':
        """public static <K,V> java.util.HashMap<K, V> com.google.common.collect.Maps.newHashMapWithExpectedSize(int)"""
        return HashMap.__wrap(__Maps.newHashMapWithExpectedSize(__int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'Map', valuePredicate: 'Predicate') -> 'Map':
        """public static <K,V> java.util.Map<K, V> com.google.common.collect.Maps.filterValues(java.util.Map<K, V>,com.google.common.base.Predicate<? super V>)"""
        return Map.__wrap(__Maps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def immutableEntry(key: object, value: object) -> 'Entry.Map$Entry':
        """public static <K,V> java.util.Map$Entry<K, V> com.google.common.collect.Maps.immutableEntry(K,V)"""
        return Entry.Map$Entry.__wrap(__Maps.immutableEntry(key, value))

    @staticmethod
    @overload
    def transformValues(fromMap: 'Map', function: 'Function') -> 'Map':
        """public static <K,V1,V2> java.util.Map<K, V2> com.google.common.collect.Maps.transformValues(java.util.Map<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return Map.__wrap(__Maps.transformValues(fromMap, function))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'Map', entryPredicate: 'Predicate') -> 'Map':
        """public static <K,V> java.util.Map<K, V> com.google.common.collect.Maps.filterEntries(java.util.Map<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return Map.__wrap(__Maps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def immutableEnumMap(map: 'Map') -> 'ImmutableMap':
        """public static <K extends java.lang.Enum<K>,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.immutableEnumMap(java.util.Map<K, ? extends V>)"""
        return ImmutableMap.__wrap(__Maps.immutableEnumMap(map))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'SortedMap', entryPredicate: 'Predicate') -> 'SortedMap':
        """public static <K,V> java.util.SortedMap<K, V> com.google.common.collect.Maps.filterEntries(java.util.SortedMap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return SortedMap.__wrap(__Maps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def newEnumMap(map: 'Map') -> 'EnumMap':
        """public static <K extends java.lang.Enum<K>,V> java.util.EnumMap<K, V> com.google.common.collect.Maps.newEnumMap(java.util.Map<K, ? extends V>)"""
        return EnumMap.__wrap(__Maps.newEnumMap(map))

    @staticmethod
    @overload
    def difference(left: 'Map', right: 'Map') -> 'MapDifference':
        """public static <K,V> com.google.common.collect.MapDifference<K, V> com.google.common.collect.Maps.difference(java.util.Map<? extends K, ? extends V>,java.util.Map<? extends K, ? extends V>)"""
        return MapDifference.__wrap(__Maps.difference(left, right))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def newLinkedHashMapWithExpectedSize(expectedSize: int) -> 'LinkedHashMap':
        """public static <K,V> java.util.LinkedHashMap<K, V> com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize(int)"""
        return LinkedHashMap.__wrap(__Maps.newLinkedHashMapWithExpectedSize(__int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def unmodifiableNavigableMap(map: 'NavigableMap') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.unmodifiableNavigableMap(java.util.NavigableMap<K, ? extends V>)"""
        return NavigableMap.__wrap(__Maps.unmodifiableNavigableMap(map))

    @staticmethod
    @overload
    def newHashMap() -> 'HashMap':
        """public static <K,V> java.util.HashMap<K, V> com.google.common.collect.Maps.newHashMap()"""
        return HashMap.__wrap(__Maps.newHashMap())

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'BiMap', entryPredicate: 'Predicate') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.filterEntries(com.google.common.collect.BiMap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return BiMap.__wrap(__Maps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def fromProperties(properties: 'Properties') -> 'ImmutableMap':
        """public static com.google.common.collect.ImmutableMap<java.lang.String, java.lang.String> com.google.common.collect.Maps.fromProperties(java.util.Properties)"""
        return ImmutableMap.__wrap(__Maps.fromProperties(properties))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'BiMap', valuePredicate: 'Predicate') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.filterValues(com.google.common.collect.BiMap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return BiMap.__wrap(__Maps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def newLinkedHashMap(map: 'Map') -> 'LinkedHashMap':
        """public static <K,V> java.util.LinkedHashMap<K, V> com.google.common.collect.Maps.newLinkedHashMap(java.util.Map<? extends K, ? extends V>)"""
        return LinkedHashMap.__wrap(__Maps.newLinkedHashMap(map))

    @staticmethod
    @overload
    def newLinkedHashMap() -> 'LinkedHashMap':
        """public static <K,V> java.util.LinkedHashMap<K, V> com.google.common.collect.Maps.newLinkedHashMap()"""
        return LinkedHashMap.__wrap(__Maps.newLinkedHashMap())

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'Map', keyPredicate: 'Predicate') -> 'Map':
        """public static <K,V> java.util.Map<K, V> com.google.common.collect.Maps.filterKeys(java.util.Map<K, V>,com.google.common.base.Predicate<? super K>)"""
        return Map.__wrap(__Maps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def unmodifiableBiMap(bimap: 'BiMap') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.unmodifiableBiMap(com.google.common.collect.BiMap<? extends K, ? extends V>)"""
        return BiMap.__wrap(__Maps.unmodifiableBiMap(bimap))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'SortedMap', transformer: 'EntryTransformer') -> 'SortedMap':
        """public static <K,V1,V2> java.util.SortedMap<K, V2> com.google.common.collect.Maps.transformEntries(java.util.SortedMap<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return SortedMap.__wrap(__Maps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def asMap(set: 'SortedSet', function: 'Function') -> 'SortedMap':
        """public static <K,V> java.util.SortedMap<K, V> com.google.common.collect.Maps.asMap(java.util.SortedSet<K>,com.google.common.base.Function<? super K, V>)"""
        return SortedMap.__wrap(__Maps.asMap(set, function))

    @staticmethod
    @overload
    def uniqueIndex(values: 'Iterator', keyFunction: 'Function') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.uniqueIndex(java.util.Iterator<V>,com.google.common.base.Function<? super V, K>)"""
        return ImmutableMap.__wrap(__Maps.uniqueIndex(values, keyFunction))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'NavigableMap', keyPredicate: 'Predicate') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.filterKeys(java.util.NavigableMap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return NavigableMap.__wrap(__Maps.filterKeys(unfiltered, keyPredicate))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def asConverter(bimap: 'BiMap') -> 'base.Converter':
        """public static <A,B> com.google.common.base.Converter<A, B> com.google.common.collect.Maps.asConverter(com.google.common.collect.BiMap<A, B>)"""
        return base.Converter.__wrap(__Maps.asConverter(bimap))

    @staticmethod
    @overload
    def newHashMap(map: 'Map') -> 'HashMap':
        """public static <K,V> java.util.HashMap<K, V> com.google.common.collect.Maps.newHashMap(java.util.Map<? extends K, ? extends V>)"""
        return HashMap.__wrap(__Maps.newHashMap(map))

    @staticmethod
    @overload
    def newTreeMap(comparator: 'Comparator') -> 'TreeMap':
        """public static <C,K extends C,V> java.util.TreeMap<K, V> com.google.common.collect.Maps.newTreeMap(java.util.Comparator<C>)"""
        return TreeMap.__wrap(__Maps.newTreeMap(comparator))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'Map', transformer: 'EntryTransformer') -> 'Map':
        """public static <K,V1,V2> java.util.Map<K, V2> com.google.common.collect.Maps.transformEntries(java.util.Map<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return Map.__wrap(__Maps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def toMap(keys: 'Iterable', valueFunction: 'Function') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.toMap(java.lang.Iterable<K>,com.google.common.base.Function<? super K, V>)"""
        return ImmutableMap.__wrap(__Maps.toMap(keys, valueFunction))

    @staticmethod
    @overload
    def difference(left: 'SortedMap', right: 'Map') -> 'SortedMapDifference':
        """public static <K,V> com.google.common.collect.SortedMapDifference<K, V> com.google.common.collect.Maps.difference(java.util.SortedMap<K, ? extends V>,java.util.Map<? extends K, ? extends V>)"""
        return SortedMapDifference.__wrap(__Maps.difference(left, right))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'NavigableMap', entryPredicate: 'Predicate') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.filterEntries(java.util.NavigableMap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return NavigableMap.__wrap(__Maps.filterEntries(unfiltered, entryPredicate))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def toImmutableEnumMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K extends java.lang.Enum<K>,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.Maps.toImmutableEnumMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__Maps.toImmutableEnumMap(keyFunction, valueFunction))

    @staticmethod
    @overload
    def subMap(map: 'NavigableMap', range: 'Range') -> 'NavigableMap':
        """public static <K extends java.lang.Comparable<? super K>,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.subMap(java.util.NavigableMap<K, V>,com.google.common.collect.Range<K>)"""
        return NavigableMap.__wrap(__Maps.subMap(map, range))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'NavigableMap', valuePredicate: 'Predicate') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.filterValues(java.util.NavigableMap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return NavigableMap.__wrap(__Maps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def newTreeMap(map: 'SortedMap') -> 'TreeMap':
        """public static <K,V> java.util.TreeMap<K, V> com.google.common.collect.Maps.newTreeMap(java.util.SortedMap<K, ? extends V>)"""
        return TreeMap.__wrap(__Maps.newTreeMap(map))

    @staticmethod
    @overload
    def asMap(set: 'NavigableSet', function: 'Function') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.asMap(java.util.NavigableSet<K>,com.google.common.base.Function<? super K, V>)"""
        return NavigableMap.__wrap(__Maps.asMap(set, function))

    @staticmethod
    @overload
    def newTreeMap() -> 'TreeMap':
        """public static <K extends java.lang.Comparable,V> java.util.TreeMap<K, V> com.google.common.collect.Maps.newTreeMap()"""
        return TreeMap.__wrap(__Maps.newTreeMap())

    @staticmethod
    @overload
    def synchronizedNavigableMap(navigableMap: 'NavigableMap') -> 'NavigableMap':
        """public static <K,V> java.util.NavigableMap<K, V> com.google.common.collect.Maps.synchronizedNavigableMap(java.util.NavigableMap<K, V>)"""
        return NavigableMap.__wrap(__Maps.synchronizedNavigableMap(navigableMap))

    @staticmethod
    @overload
    def toMap(keys: 'Iterator', valueFunction: 'Function') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.toMap(java.util.Iterator<K>,com.google.common.base.Function<? super K, V>)"""
        return ImmutableMap.__wrap(__Maps.toMap(keys, valueFunction))

    @staticmethod
    @overload
    def newConcurrentMap() -> 'ConcurrentMap':
        """public static <K,V> java.util.concurrent.ConcurrentMap<K, V> com.google.common.collect.Maps.newConcurrentMap()"""
        return ConcurrentMap.__wrap(__Maps.newConcurrentMap())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def asMap(set: 'Set', function: 'Function') -> 'Map':
        """public static <K,V> java.util.Map<K, V> com.google.common.collect.Maps.asMap(java.util.Set<K>,com.google.common.base.Function<? super K, V>)"""
        return Map.__wrap(__Maps.asMap(set, function))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'NavigableMap', transformer: 'EntryTransformer') -> 'NavigableMap':
        """public static <K,V1,V2> java.util.NavigableMap<K, V2> com.google.common.collect.Maps.transformEntries(java.util.NavigableMap<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return NavigableMap.__wrap(__Maps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def transformValues(fromMap: 'NavigableMap', function: 'Function') -> 'NavigableMap':
        """public static <K,V1,V2> java.util.NavigableMap<K, V2> com.google.common.collect.Maps.transformValues(java.util.NavigableMap<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return NavigableMap.__wrap(__Maps.transformValues(fromMap, function))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'SortedMap', valuePredicate: 'Predicate') -> 'SortedMap':
        """public static <K,V> java.util.SortedMap<K, V> com.google.common.collect.Maps.filterValues(java.util.SortedMap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return SortedMap.__wrap(__Maps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'BiMap', keyPredicate: 'Predicate') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.filterKeys(com.google.common.collect.BiMap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return BiMap.__wrap(__Maps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def synchronizedBiMap(bimap: 'BiMap') -> 'BiMap':
        """public static <K,V> com.google.common.collect.BiMap<K, V> com.google.common.collect.Maps.synchronizedBiMap(com.google.common.collect.BiMap<K, V>)"""
        return BiMap.__wrap(__Maps.synchronizedBiMap(bimap))

    @staticmethod
    @overload
    def uniqueIndex(values: 'Iterable', keyFunction: 'Function') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.Maps.uniqueIndex(java.lang.Iterable<V>,com.google.common.base.Function<? super V, K>)"""
        return ImmutableMap.__wrap(__Maps.uniqueIndex(values, keyFunction))

    @staticmethod
    @overload
    def newEnumMap(type: 'Class') -> 'EnumMap':
        """public static <K extends java.lang.Enum<K>,V> java.util.EnumMap<K, V> com.google.common.collect.Maps.newEnumMap(java.lang.Class<K>)"""
        return EnumMap.__wrap(__Maps.newEnumMap(type))

    @staticmethod
    @overload
    def transformValues(fromMap: 'SortedMap', function: 'Function') -> 'SortedMap':
        """public static <K,V1,V2> java.util.SortedMap<K, V2> com.google.common.collect.Maps.transformValues(java.util.SortedMap<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return SortedMap.__wrap(__Maps.transformValues(fromMap, function))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def difference(left: 'Map', right: 'Map', valueEquivalence: 'Equivalence') -> 'MapDifference':
        """public static <K,V> com.google.common.collect.MapDifference<K, V> com.google.common.collect.Maps.difference(java.util.Map<? extends K, ? extends V>,java.util.Map<? extends K, ? extends V>,com.google.common.base.Equivalence<? super V>)"""
        return MapDifference.__wrap(__Maps.difference(left, right, valueEquivalence))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def newIdentityHashMap() -> 'IdentityHashMap':
        """public static <K,V> java.util.IdentityHashMap<K, V> com.google.common.collect.Maps.newIdentityHashMap()"""
        return IdentityHashMap.__wrap(__Maps.newIdentityHashMap())

    @staticmethod
    @overload
    def toImmutableEnumMap(keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K extends java.lang.Enum<K>,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.Maps.toImmutableEnumMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector.__wrap(__Maps.toImmutableEnumMap(keyFunction, valueFunction, mergeFunction))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'SortedMap', keyPredicate: 'Predicate') -> 'SortedMap':
        """public static <K,V> java.util.SortedMap<K, V> com.google.common.collect.Maps.filterKeys(java.util.SortedMap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return SortedMap.__wrap(__Maps.filterKeys(unfiltered, keyPredicate)) 
 
 
# CLASS: com.google.common.collect.ForwardingConcurrentMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Set as __Set
__Set = __Set
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
import java.util.Collection as Collection
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.function.Function as Function
from builtins import bool
import java.util.Map as Map
import java.util.concurrent.ConcurrentMap as __ConcurrentMap
__ConcurrentMap = __ConcurrentMap
import com.google.common.collect.ForwardingConcurrentMap as __ForwardingConcurrentMap
__ForwardingConcurrentMap = __ForwardingConcurrentMap
from builtins import int
 
class ForwardingConcurrentMap(ABC):
    """com.google.common.collect.ForwardingConcurrentMap"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingConcurrentMap) -> 'ForwardingConcurrentMap':
        return ForwardingConcurrentMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingConcurrentMap):
        """
        Dynamic initializer for ForwardingConcurrentMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def replace(self, key: object, oldValue: object, newValue: object) -> bool:
        """public boolean com.google.common.collect.ForwardingConcurrentMap.replace(K,V,V)"""
        return bool.__wrap(super(__ForwardingConcurrentMap, self).replace(key, oldValue, newValue))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.concurrent.ConcurrentMap.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__ConcurrentMap, self).compute(arg0, arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).entrySet())

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.concurrent.ConcurrentMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__ConcurrentMap, self).replaceAll(arg0)

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object.__wrap(super(__ForwardingMap, self).put(key, value))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.concurrent.ConcurrentMap.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__ConcurrentMap, self).getOrDefault(arg0, arg1))

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ForwardingMap, self).putAll(map)

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingConcurrentMap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingConcurrentMap, self).remove(key, value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.concurrent.ConcurrentMap.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__ConcurrentMap, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.concurrent.ConcurrentMap.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__ConcurrentMap, self).merge(arg0, arg1, arg2))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'.__wrap(super(ForwardingMap, self).values())

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.concurrent.ConcurrentMap.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__ConcurrentMap, self).computeIfPresent(arg0, arg1))

    @overload
    def putIfAbsent(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingConcurrentMap.putIfAbsent(K,V)"""
        return object.__wrap(super(__ForwardingConcurrentMap, self).putIfAbsent(key, value))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).keySet())

    @overload
    def replace(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingConcurrentMap.replace(K,V)"""
        return object.__wrap(super(__ForwardingConcurrentMap, self).replace(key, value))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsValue(value))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.concurrent.ConcurrentMap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__ConcurrentMap, self).forEach(arg0) 
 
 
# CLASS: com.google.common.collect.Streams$LongFunctionWithIndex
import com.google.common.collect.Streams as __Streams_LongFunctionWithIndex
__LongFunctionWithIndex = __Streams_LongFunctionWithIndex.LongFunctionWithIndex
from abc import abstractmethod, ABC
 
class LongFunctionWithIndex(ABC):
    """com.google.common.collect.Streams.LongFunctionWithIndex"""
 
    @staticmethod
    def __wrap(java_value: __LongFunctionWithIndex) -> 'LongFunctionWithIndex':
        return LongFunctionWithIndex(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __LongFunctionWithIndex):
        """
        Dynamic initializer for LongFunctionWithIndex.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, from: int, index: int):
        """public abstract R com.google.common.collect.Streams$LongFunctionWithIndex.apply(long,long)"""
        pass 
 
 
# CLASS: com.google.common.collect.Table
import com.google.common.collect.Table as __Table
__Table = __Table
from abc import abstractmethod, ABC
 
class Table(ABC):
    """com.google.common.collect.Table"""
 
    @staticmethod
    def __wrap(java_value: __Table) -> 'Table':
        return Table(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Table):
        """
        Dynamic initializer for Table.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def containsRow(self, rowKey: object):
        """public abstract boolean com.google.common.collect.Table.containsRow(java.lang.Object)"""
        pass

    @abstractmethod
    def put(self, rowKey: object, columnKey: object, value: object):
        """public abstract V com.google.common.collect.Table.put(R,C,V)"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Table.isEmpty()"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Table.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def columnKeySet(self, ):
        """public abstract java.util.Set<C> com.google.common.collect.Table.columnKeySet()"""
        pass

    @abstractmethod
    def containsColumn(self, columnKey: object):
        """public abstract boolean com.google.common.collect.Table.containsColumn(java.lang.Object)"""
        pass

    @abstractmethod
    def columnMap(self, ):
        """public abstract java.util.Map<C, java.util.Map<R, V>> com.google.common.collect.Table.columnMap()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.Table.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Table.hashCode()"""
        pass

    @abstractmethod
    def rowMap(self, ):
        """public abstract java.util.Map<R, java.util.Map<C, V>> com.google.common.collect.Table.rowMap()"""
        pass

    @abstractmethod
    def putAll(self, table: 'Table'):
        """public abstract void com.google.common.collect.Table.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        pass

    @abstractmethod
    def column(self, columnKey: object):
        """public abstract java.util.Map<R, V> com.google.common.collect.Table.column(C)"""
        pass

    @abstractmethod
    def row(self, rowKey: object):
        """public abstract java.util.Map<C, V> com.google.common.collect.Table.row(R)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Table.clear()"""
        pass

    @abstractmethod
    def rowKeySet(self, ):
        """public abstract java.util.Set<R> com.google.common.collect.Table.rowKeySet()"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Table.size()"""
        pass

    @abstractmethod
    def cellSet(self, ):
        """public abstract java.util.Set<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.Table.cellSet()"""
        pass

    @abstractmethod
    def remove(self, rowKey: object, columnKey: object):
        """public abstract V com.google.common.collect.Table.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Table.values()"""
        pass

    @abstractmethod
    def get(self, rowKey: object, columnKey: object):
        """public abstract V com.google.common.collect.Table.get(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def contains(self, rowKey: object, columnKey: object):
        """public abstract boolean com.google.common.collect.Table.contains(java.lang.Object,java.lang.Object)"""
        pass 
 
 
# CLASS: com.google.common.collect.ImmutableCollection$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
from builtins import object
import java.util.Iterator as Iterator
import com.google.common.collect.ImmutableCollection as __ImmutableCollection_Builder
__Builder = __ImmutableCollection_Builder.Builder
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder(ABC):
    """com.google.common.collect.ImmutableCollection.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableCollection$Builder<E> com.google.common.collect.ImmutableCollection$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableCollection$Builder<E> com.google.common.collect.ImmutableCollection$Builder.add(E...)"""
        return 'Builder'.__wrap(super(__Builder, self).add(elements))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def build(self, ):
        """public abstract com.google.common.collect.ImmutableCollection<E> com.google.common.collect.ImmutableCollection$Builder.build()"""
        pass

    @abstractmethod
    def add(self, element: object):
        """public abstract com.google.common.collect.ImmutableCollection$Builder<E> com.google.common.collect.ImmutableCollection$Builder.add(E)"""
        pass

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableCollection$Builder<E> com.google.common.collect.ImmutableCollection$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements)) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder$ListMultimapBuilder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_ListMultimapBuilder
__ListMultimapBuilder = __MultimapBuilder_ListMultimapBuilder.ListMultimapBuilder
from abc import abstractmethod, ABC
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_MultimapBuilderWithKeys
__MultimapBuilderWithKeys = __MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.MultimapBuilder as __MultimapBuilder
__MultimapBuilder = __MultimapBuilder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.ListMultimap as __ListMultimap
__ListMultimap = __ListMultimap
from builtins import int
 
class ListMultimapBuilder(ABC):
    """com.google.common.collect.MultimapBuilder.ListMultimapBuilder"""
 
    @staticmethod
    def __wrap(java_value: __ListMultimapBuilder) -> 'ListMultimapBuilder':
        return ListMultimapBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ListMultimapBuilder):
        """
        Dynamic initializer for ListMultimapBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @abstractmethod
    def build(self, ):
        """public abstract <K extends K0,V extends V0> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.MultimapBuilder$ListMultimapBuilder.build()"""
        pass

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def hashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys(int)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.hashKeys(__int.valueOf(expectedKeys)))

    @overload
    def build(self, multimap: 'Multimap') -> 'ListMultimap':
        """public <K extends K0,V extends V0> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.MultimapBuilder$ListMultimapBuilder.build(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'ListMultimap'.__wrap(super(__ListMultimapBuilder, self).build(multimap))

    @staticmethod
    @overload
    def hashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.hashKeys())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def treeKeys(comparator: 'Comparator') -> 'MultimapBuilderWithKeys':
        """public static <K0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.treeKeys(java.util.Comparator<K0>)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.treeKeys(comparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def treeKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Comparable> com.google.common.collect.MultimapBuilder.treeKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.treeKeys())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def linkedHashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.linkedHashKeys())

    @staticmethod
    @overload
    def enumKeys(keyClass: 'Class') -> 'MultimapBuilderWithKeys':
        """public static <K0 extends java.lang.Enum<K0>> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.enumKeys(java.lang.Class<K0>)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.enumKeys(keyClass))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def linkedHashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys(int)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.linkedHashKeys(__int.valueOf(expectedKeys)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.MutableClassToInstanceMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Set as __Set
__Set = __Set
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
import java.util.Collection as Collection
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.Set as Set
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import com.google.common.collect.MutableClassToInstanceMap as __MutableClassToInstanceMap
__MutableClassToInstanceMap = __MutableClassToInstanceMap
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import bool
from builtins import int
 
class MutableClassToInstanceMap():
    """com.google.common.collect.MutableClassToInstanceMap"""
 
    @staticmethod
    def __wrap(java_value: __MutableClassToInstanceMap) -> 'MutableClassToInstanceMap':
        return MutableClassToInstanceMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __MutableClassToInstanceMap):
        """
        Dynamic initializer for MutableClassToInstanceMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).remove(key))

    @staticmethod
    @overload
    def create(backingMap: 'Map') -> 'MutableClassToInstanceMap':
        """public static <B> com.google.common.collect.MutableClassToInstanceMap<B> com.google.common.collect.MutableClassToInstanceMap.create(java.util.Map<java.lang.Class<? extends B>, B>)"""
        return MutableClassToInstanceMap.__wrap(__MutableClassToInstanceMap.create(backingMap))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def create() -> 'MutableClassToInstanceMap':
        """public static <B> com.google.common.collect.MutableClassToInstanceMap<B> com.google.common.collect.MutableClassToInstanceMap.create()"""
        return MutableClassToInstanceMap.__wrap(__MutableClassToInstanceMap.create())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @overload
    def putInstance(self, type: 'Class', value: object) -> object:
        """public <T extends B> T com.google.common.collect.MutableClassToInstanceMap.putInstance(java.lang.Class<T>,T)"""
        return object.__wrap(super(__MutableClassToInstanceMap, self).putInstance(type, value))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @overload
    def getInstance(self, type: 'Class') -> object:
        """public <T extends B> T com.google.common.collect.MutableClassToInstanceMap.getInstance(java.lang.Class<T>)"""
        return object.__wrap(super(__MutableClassToInstanceMap, self).getInstance(type))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def put(self, key: 'Class', value: object) -> object:
        """public B com.google.common.collect.MutableClassToInstanceMap.put(java.lang.Class<? extends B>,B)"""
        return object.__wrap(super(__MutableClassToInstanceMap, self).put(key, value))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<java.lang.Class<? extends B>, B>> com.google.common.collect.MutableClassToInstanceMap.entrySet()"""
        return 'Set'.__wrap(super(MutableClassToInstanceMap, self).entrySet())

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.MutableClassToInstanceMap.putAll(java.util.Map<? extends java.lang.Class<? extends B>, ? extends B>)"""
        super(__MutableClassToInstanceMap, self).putAll(map)

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'.__wrap(super(ForwardingMap, self).values())

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).keySet())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__Map, self).replaceAll(arg0)

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsValue(value)) 
 
 
# CLASS: com.google.common.collect.MapMaker
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.concurrent.ConcurrentMap as ConcurrentMap
import java.lang.Long as __long
import com.google.common.collect.MapMaker as __MapMaker
__MapMaker = __MapMaker
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import java.util.concurrent.ConcurrentMap as __ConcurrentMap
__ConcurrentMap = __ConcurrentMap
from builtins import int
 
class MapMaker():
    """com.google.common.collect.MapMaker"""
 
    @staticmethod
    def __wrap(java_value: __MapMaker) -> 'MapMaker':
        return MapMaker(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __MapMaker):
        """
        Dynamic initializer for MapMaker.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def weakValues(self) -> 'MapMaker':
        """public com.google.common.collect.MapMaker com.google.common.collect.MapMaker.weakValues()"""
        return 'MapMaker'.__wrap(super(MapMaker, self).weakValues())

    @overload
    def concurrencyLevel(self, concurrencyLevel: int) -> 'MapMaker':
        """public com.google.common.collect.MapMaker com.google.common.collect.MapMaker.concurrencyLevel(int)"""
        return 'MapMaker'.__wrap(super(__MapMaker, self).concurrencyLevel(__int.valueOf(concurrencyLevel)))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.MapMaker()"""
        val = __MapMaker()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def weakKeys(self) -> 'MapMaker':
        """public com.google.common.collect.MapMaker com.google.common.collect.MapMaker.weakKeys()"""
        return 'MapMaker'.__wrap(super(MapMaker, self).weakKeys())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def makeMap(self) -> 'ConcurrentMap':
        """public <K,V> java.util.concurrent.ConcurrentMap<K, V> com.google.common.collect.MapMaker.makeMap()"""
        return 'ConcurrentMap'.__wrap(super(MapMaker, self).makeMap())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.MapMaker.toString()"""
        return str.__wrap(super(MapMaker, self).toString())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def __init__(self):
        """public com.google.common.collect.MapMaker()"""
        val = __MapMaker()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def initialCapacity(self, initialCapacity: int) -> 'MapMaker':
        """public com.google.common.collect.MapMaker com.google.common.collect.MapMaker.initialCapacity(int)"""
        return 'MapMaker'.__wrap(super(__MapMaker, self).initialCapacity(__int.valueOf(initialCapacity)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ImmutableListMultimap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableMultimap as __ImmutableMultimap_Builder
__Builder = __ImmutableMultimap_Builder.Builder
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import java.util.stream.Collector as Collector
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset
__ImmutableMultiset = __ImmutableMultiset
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableListMultimap as __ImmutableListMultimap_Builder
__Builder = __ImmutableListMultimap_Builder.Builder
import java.util.function.BiConsumer as BiConsumer
import com.google.common.collect.ImmutableListMultimap as __ImmutableListMultimap
__ImmutableListMultimap = __ImmutableListMultimap
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.lang.Object as __Object
__Object = __Object
import java.util.function.Function as Function
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.ImmutableMultimap as __ImmutableMultimap
__ImmutableMultimap = __ImmutableMultimap
from builtins import int
 
class ImmutableListMultimap():
    """com.google.common.collect.ImmutableListMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableListMultimap) -> 'ImmutableListMultimap':
        return ImmutableListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableListMultimap):
        """
        Dynamic initializer for ImmutableListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMultimap$Builder<K, V> com.google.common.collect.ImmutableMultimap.builder()"""
        return Builder.__wrap(__ImmutableMultimap.builder())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.copyOf(multimap))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableListMultimap.__wrap(__ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @overload
    def get(self, key: object) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<V> com.google.common.collect.ImmutableListMultimap.get(K)"""
        return 'ImmutableList'.__wrap(super(__ImmutableListMultimap, self).get(key))

    @staticmethod
    @overload
    def flatteningToImmutableListMultimap(keyFunction: 'Function', valuesFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableListMultimap<K, V>> com.google.common.collect.ImmutableListMultimap.flatteningToImmutableListMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends V>>)"""
        return Collector.__wrap(__ImmutableListMultimap.flatteningToImmutableListMultimap(keyFunction, valuesFunction))

    @staticmethod
    @overload
    def copyOf(multimap: 'Multimap') -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.copyOf(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return ImmutableListMultimap.__wrap(__ImmutableListMultimap.copyOf(multimap))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableListMultimap.__wrap(__ImmutableListMultimap.copyOf(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool.__wrap(super(__ImmutableMultimap, self).putAll(key, values))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def toImmutableListMultimap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableListMultimap<K, V>> com.google.common.collect.ImmutableListMultimap.toImmutableListMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableListMultimap.toImmutableListMultimap(keyFunction, valueFunction))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<V> com.google.common.collect.ImmutableListMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'ImmutableList'.__wrap(super(__ImmutableListMultimap, self).replaceValues(key, values))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.ImmutableMultimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__ImmutableMultimap, self).forEach(action)

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap$Builder<K, V> com.google.common.collect.ImmutableListMultimap.builder()"""
        return Builder.__wrap(__ImmutableListMultimap.builder())

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMultimap.keySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMultimap, self).keySet())

    @override
    @overload
    def entries(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableMultimap.entries()"""
        return 'ImmutableCollection'.__wrap(super(ImmutableMultimap, self).entries())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V,K,V)"""
        return ImmutableListMultimap.__wrap(__ImmutableListMultimap.of(k1, v1, k2, v2))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2))

    @override
    @overload
    def inverse(self) -> 'ImmutableListMultimap':
        """public com.google.common.collect.ImmutableListMultimap<V, K> com.google.common.collect.ImmutableListMultimap.inverse()"""
        return 'ImmutableListMultimap'.__wrap(super(ImmutableListMultimap, self).inverse())

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).remove(key, value))

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableMultimap.values()"""
        return 'ImmutableCollection'.__wrap(super(ImmutableMultimap, self).values())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V,K,V,K,V)"""
        return ImmutableListMultimap.__wrap(__ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).containsKey(key))

    @overload
    def removeAll(self, key: object) -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<V> com.google.common.collect.ImmutableListMultimap.removeAll(java.lang.Object)"""
        return 'ImmutableList'.__wrap(super(__ImmutableListMultimap, self).removeAll(key))

    @staticmethod
    @overload
    def of() -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of()"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of())

    @override
    @overload
    def keys(self) -> 'ImmutableMultiset':
        """public com.google.common.collect.ImmutableMultiset<K> com.google.common.collect.ImmutableMultimap.keys()"""
        return 'ImmutableMultiset'.__wrap(super(ImmutableMultimap, self).keys())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableListMultimap.__wrap(__ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.put(K,V)"""
        return bool.__wrap(super(__ImmutableMultimap, self).put(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.of(K,V)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.of(k1, v1))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of(K,V)"""
        return ImmutableListMultimap.__wrap(__ImmutableListMultimap.of(k1, v1))

    @override
    @overload
    def asMap(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, java.util.Collection<V>> com.google.common.collect.ImmutableMultimap.asMap()"""
        return 'ImmutableMap'.__wrap(super(ImmutableMultimap, self).asMap())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ImmutableMultimap.size()"""
        return int.__wrap(super(ImmutableMultimap, self).size())

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMultimap.clear()"""
        super(ImmutableMultimap, self).clear()

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMultimap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMultimap, self).containsValue(value))

    @staticmethod
    @overload
    def of() -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.ImmutableListMultimap.of()"""
        return ImmutableListMultimap.__wrap(__ImmutableListMultimap.of())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMultimap':
        """public static <K,V> com.google.common.collect.ImmutableMultimap<K, V> com.google.common.collect.ImmutableMultimap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMultimap.__wrap(__ImmutableMultimap.copyOf(entries))

    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public final boolean com.google.common.collect.ImmutableMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool.__wrap(super(__ImmutableMultimap, self).putAll(multimap)) 
 
 
# CLASS: com.google.common.collect.Multisets
from pyquantum_helper import import_once as __import_once__
import com.google.common.collect.Multisets as __Multisets
__Multisets = __Multisets
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

import com.google.common.collect.Multiset as __Multiset_Entry
__Entry = __Multiset_Entry.Entry
import java.util.function.Supplier as Supplier
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import com.google.common.collect.SortedMultiset as __SortedMultiset
__SortedMultiset = __SortedMultiset
import java.lang.Iterable as Iterable
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.stream.Collector as Collector
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset
__ImmutableMultiset = __ImmutableMultiset
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.util.function.ToIntFunction as ToIntFunction
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.function.Function as Function
from builtins import bool
from builtins import int
 
class Multisets():
    """com.google.common.collect.Multisets"""
 
    @staticmethod
    def __wrap(java_value: __Multisets) -> 'Multisets':
        return Multisets(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Multisets):
        """
        Dynamic initializer for Multisets.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def unmodifiableMultiset(multiset: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.unmodifiableMultiset(com.google.common.collect.Multiset<? extends E>)"""
        return Multiset.__wrap(__Multisets.unmodifiableMultiset(multiset))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def removeOccurrences(multisetToModify: 'Multiset', occurrencesToRemove: 'Iterable') -> bool:
        """public static boolean com.google.common.collect.Multisets.removeOccurrences(com.google.common.collect.Multiset<?>,java.lang.Iterable<?>)"""
        return bool.__wrap(__Multisets.removeOccurrences(multisetToModify, occurrencesToRemove))

    @staticmethod
    @overload
    def filter(unfiltered: 'Multiset', predicate: 'Predicate') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.filter(com.google.common.collect.Multiset<E>,com.google.common.base.Predicate<? super E>)"""
        return Multiset.__wrap(__Multisets.filter(unfiltered, predicate))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def union(multiset1: 'Multiset', multiset2: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.union(com.google.common.collect.Multiset<? extends E>,com.google.common.collect.Multiset<? extends E>)"""
        return Multiset.__wrap(__Multisets.union(multiset1, multiset2))

    @staticmethod
    @overload
    def retainOccurrences(multisetToModify: 'Multiset', multisetToRetain: 'Multiset') -> bool:
        """public static boolean com.google.common.collect.Multisets.retainOccurrences(com.google.common.collect.Multiset<?>,com.google.common.collect.Multiset<?>)"""
        return bool.__wrap(__Multisets.retainOccurrences(multisetToModify, multisetToRetain))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def difference(multiset1: 'Multiset', multiset2: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.difference(com.google.common.collect.Multiset<E>,com.google.common.collect.Multiset<?>)"""
        return Multiset.__wrap(__Multisets.difference(multiset1, multiset2))

    @staticmethod
    @overload
    def removeOccurrences(multisetToModify: 'Multiset', occurrencesToRemove: 'Multiset') -> bool:
        """public static boolean com.google.common.collect.Multisets.removeOccurrences(com.google.common.collect.Multiset<?>,com.google.common.collect.Multiset<?>)"""
        return bool.__wrap(__Multisets.removeOccurrences(multisetToModify, occurrencesToRemove))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def unmodifiableMultiset(multiset: 'ImmutableMultiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.unmodifiableMultiset(com.google.common.collect.ImmutableMultiset<E>)"""
        return Multiset.__wrap(__Multisets.unmodifiableMultiset(multiset))

    @staticmethod
    @overload
    def immutableEntry(e: object, n: int) -> 'Entry':
        """public static <E> com.google.common.collect.Multiset$Entry<E> com.google.common.collect.Multisets.immutableEntry(E,int)"""
        return Entry.__wrap(__Multisets.immutableEntry(e, __int.valueOf(n)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def copyHighestCountFirst(multiset: 'Multiset') -> 'ImmutableMultiset':
        """public static <E> com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.Multisets.copyHighestCountFirst(com.google.common.collect.Multiset<E>)"""
        return ImmutableMultiset.__wrap(__Multisets.copyHighestCountFirst(multiset))

    @staticmethod
    @overload
    def unmodifiableSortedMultiset(sortedMultiset: 'SortedMultiset') -> 'SortedMultiset':
        """public static <E> com.google.common.collect.SortedMultiset<E> com.google.common.collect.Multisets.unmodifiableSortedMultiset(com.google.common.collect.SortedMultiset<E>)"""
        return SortedMultiset.__wrap(__Multisets.unmodifiableSortedMultiset(sortedMultiset))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def intersection(multiset1: 'Multiset', multiset2: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.intersection(com.google.common.collect.Multiset<E>,com.google.common.collect.Multiset<?>)"""
        return Multiset.__wrap(__Multisets.intersection(multiset1, multiset2))

    @staticmethod
    @overload
    def toMultiset(elementFunction: 'Function', countFunction: 'ToIntFunction', multisetSupplier: 'Supplier') -> 'Collector':
        """public static <T,E,M extends com.google.common.collect.Multiset<E>> java.util.stream.Collector<T, ?, M> com.google.common.collect.Multisets.toMultiset(java.util.function.Function<? super T, E>,java.util.function.ToIntFunction<? super T>,java.util.function.Supplier<M>)"""
        return Collector.__wrap(__Multisets.toMultiset(elementFunction, countFunction, multisetSupplier))

    @staticmethod
    @overload
    def containsOccurrences(superMultiset: 'Multiset', subMultiset: 'Multiset') -> bool:
        """public static boolean com.google.common.collect.Multisets.containsOccurrences(com.google.common.collect.Multiset<?>,com.google.common.collect.Multiset<?>)"""
        return bool.__wrap(__Multisets.containsOccurrences(superMultiset, subMultiset))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def sum(multiset1: 'Multiset', multiset2: 'Multiset') -> 'Multiset':
        """public static <E> com.google.common.collect.Multiset<E> com.google.common.collect.Multisets.sum(com.google.common.collect.Multiset<? extends E>,com.google.common.collect.Multiset<? extends E>)"""
        return Multiset.__wrap(__Multisets.sum(multiset1, multiset2))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.Collections2
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
import java.util.Comparator as Comparator
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.Collections2 as __Collections2
__Collections2 = __Collections2
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Collections2():
    """com.google.common.collect.Collections2"""
 
    @staticmethod
    def __wrap(java_value: __Collections2) -> 'Collections2':
        return Collections2(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Collections2):
        """
        Dynamic initializer for Collections2.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def permutations(elements: 'Collection') -> 'Collection':
        """public static <E> java.util.Collection<java.util.List<E>> com.google.common.collect.Collections2.permutations(java.util.Collection<E>)"""
        return Collection.__wrap(__Collections2.permutations(elements))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def orderedPermutations(elements: 'Iterable', comparator: 'Comparator') -> 'Collection':
        """public static <E> java.util.Collection<java.util.List<E>> com.google.common.collect.Collections2.orderedPermutations(java.lang.Iterable<E>,java.util.Comparator<? super E>)"""
        return Collection.__wrap(__Collections2.orderedPermutations(elements, comparator))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def orderedPermutations(elements: 'Iterable') -> 'Collection':
        """public static <E extends java.lang.Comparable<? super E>> java.util.Collection<java.util.List<E>> com.google.common.collect.Collections2.orderedPermutations(java.lang.Iterable<E>)"""
        return Collection.__wrap(__Collections2.orderedPermutations(elements))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def filter(unfiltered: 'Collection', predicate: 'Predicate') -> 'Collection':
        """public static <E> java.util.Collection<E> com.google.common.collect.Collections2.filter(java.util.Collection<E>,com.google.common.base.Predicate<? super E>)"""
        return Collection.__wrap(__Collections2.filter(unfiltered, predicate))

    @staticmethod
    @overload
    def transform(fromCollection: 'Collection', function: 'Function') -> 'Collection':
        """public static <F,T> java.util.Collection<T> com.google.common.collect.Collections2.transform(java.util.Collection<F>,com.google.common.base.Function<? super F, T>)"""
        return Collection.__wrap(__Collections2.transform(fromCollection, function))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.Tables
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

import java.util.function.Supplier as Supplier
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import com.google.common.collect.Table as __Table
__Table = __Table
import com.google.common.collect.Table as __Table_Cell
__Cell = __Table_Cell.Cell
import com.google.common.collect.Tables as __Tables
__Tables = __Tables
import java.util.stream.Collector as Collector
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.util.function.BinaryOperator as BinaryOperator
import java.lang.Object as __Object
__Object = __Object
import java.util.function.Function as Function
import com.google.common.collect.RowSortedTable as __RowSortedTable
__RowSortedTable = __RowSortedTable
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import bool
from builtins import int
 
class Tables():
    """com.google.common.collect.Tables"""
 
    @staticmethod
    def __wrap(java_value: __Tables) -> 'Tables':
        return Tables(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Tables):
        """
        Dynamic initializer for Tables.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def unmodifiableTable(table: 'Table') -> 'Table':
        """public static <R,C,V> com.google.common.collect.Table<R, C, V> com.google.common.collect.Tables.unmodifiableTable(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        return Table.__wrap(__Tables.unmodifiableTable(table))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def toTable(rowFunction: 'Function', columnFunction: 'Function', valueFunction: 'Function', tableSupplier: 'Supplier') -> 'Collector':
        """public static <T,R,C,V,I extends com.google.common.collect.Table<R, C, V>> java.util.stream.Collector<T, ?, I> com.google.common.collect.Tables.toTable(java.util.function.Function<? super T, ? extends R>,java.util.function.Function<? super T, ? extends C>,java.util.function.Function<? super T, ? extends V>,java.util.function.Supplier<I>)"""
        return Collector.__wrap(__Tables.toTable(rowFunction, columnFunction, valueFunction, tableSupplier))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def immutableCell(rowKey: object, columnKey: object, value: object) -> 'Cell':
        """public static <R,C,V> com.google.common.collect.Table$Cell<R, C, V> com.google.common.collect.Tables.immutableCell(R,C,V)"""
        return Cell.__wrap(__Tables.immutableCell(rowKey, columnKey, value))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def toTable(rowFunction: 'Function', columnFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator', tableSupplier: 'Supplier') -> 'Collector':
        """public static <T,R,C,V,I extends com.google.common.collect.Table<R, C, V>> java.util.stream.Collector<T, ?, I> com.google.common.collect.Tables.toTable(java.util.function.Function<? super T, ? extends R>,java.util.function.Function<? super T, ? extends C>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>,java.util.function.Supplier<I>)"""
        return Collector.__wrap(__Tables.toTable(rowFunction, columnFunction, valueFunction, mergeFunction, tableSupplier))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def newCustomTable(backingMap: 'Map', factory: 'Supplier') -> 'Table':
        """public static <R,C,V> com.google.common.collect.Table<R, C, V> com.google.common.collect.Tables.newCustomTable(java.util.Map<R, java.util.Map<C, V>>,com.google.common.base.Supplier<? extends java.util.Map<C, V>>)"""
        return Table.__wrap(__Tables.newCustomTable(backingMap, factory))

    @staticmethod
    @overload
    def synchronizedTable(table: 'Table') -> 'Table':
        """public static <R,C,V> com.google.common.collect.Table<R, C, V> com.google.common.collect.Tables.synchronizedTable(com.google.common.collect.Table<R, C, V>)"""
        return Table.__wrap(__Tables.synchronizedTable(table))

    @staticmethod
    @overload
    def transformValues(fromTable: 'Table', function: 'Function') -> 'Table':
        """public static <R,C,V1,V2> com.google.common.collect.Table<R, C, V2> com.google.common.collect.Tables.transformValues(com.google.common.collect.Table<R, C, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return Table.__wrap(__Tables.transformValues(fromTable, function))

    @staticmethod
    @overload
    def unmodifiableRowSortedTable(table: 'RowSortedTable') -> 'RowSortedTable':
        """public static <R,C,V> com.google.common.collect.RowSortedTable<R, C, V> com.google.common.collect.Tables.unmodifiableRowSortedTable(com.google.common.collect.RowSortedTable<R, ? extends C, ? extends V>)"""
        return RowSortedTable.__wrap(__Tables.unmodifiableRowSortedTable(table))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def transpose(table: 'Table') -> 'Table':
        """public static <R,C,V> com.google.common.collect.Table<C, R, V> com.google.common.collect.Tables.transpose(com.google.common.collect.Table<R, C, V>)"""
        return Table.__wrap(__Tables.transpose(table))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.TreeRangeSet
from builtins import str
from pyquantum_helper import override
from builtins import type
import java.util.Set as __Set
__Set = __Set
import java.lang.Iterable as Iterable
import com.google.common.collect.AbstractRangeSet as __AbstractRangeSet
__AbstractRangeSet = __AbstractRangeSet
import java.lang.Comparable as Comparable
import java.util.Set as Set
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.RangeSet as __RangeSet
__RangeSet = __RangeSet
import com.google.common.collect.Range as __Range
__Range = __Range
import com.google.common.collect.TreeRangeSet as __TreeRangeSet
__TreeRangeSet = __TreeRangeSet
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class TreeRangeSet():
    """com.google.common.collect.TreeRangeSet"""
 
    @staticmethod
    def __wrap(java_value: __TreeRangeSet) -> 'TreeRangeSet':
        return TreeRangeSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __TreeRangeSet):
        """
        Dynamic initializer for TreeRangeSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def subRangeSet(self, view: 'Range') -> 'RangeSet':
        """public com.google.common.collect.RangeSet<C> com.google.common.collect.TreeRangeSet.subRangeSet(com.google.common.collect.Range<C>)"""
        return 'RangeSet'.__wrap(super(__TreeRangeSet, self).subRangeSet(view))

    @overload
    def intersects(self, range: 'Range') -> bool:
        """public boolean com.google.common.collect.TreeRangeSet.intersects(com.google.common.collect.Range<C>)"""
        return bool.__wrap(super(__TreeRangeSet, self).intersects(range))

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractRangeSet.toString()"""
        return str.__wrap(super(AbstractRangeSet, self).toString())

    @overload
    def enclosesAll(self, other: 'Iterable') -> bool:
        """public default boolean com.google.common.collect.RangeSet.enclosesAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return bool.__wrap(super(__RangeSet, self).enclosesAll(other))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def encloses(self, range: 'Range') -> bool:
        """public boolean com.google.common.collect.TreeRangeSet.encloses(com.google.common.collect.Range<C>)"""
        return bool.__wrap(super(__TreeRangeSet, self).encloses(range))

    @staticmethod
    @overload
    def create(ranges: 'Iterable') -> 'TreeRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.TreeRangeSet<C> com.google.common.collect.TreeRangeSet.create(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        return TreeRangeSet.__wrap(__TreeRangeSet.create(ranges))

    @override
    @overload
    def span(self) -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.TreeRangeSet.span()"""
        return 'Range'.__wrap(super(TreeRangeSet, self).span())

    @staticmethod
    @overload
    def create(rangeSet: 'RangeSet') -> 'TreeRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.TreeRangeSet<C> com.google.common.collect.TreeRangeSet.create(com.google.common.collect.RangeSet<C>)"""
        return TreeRangeSet.__wrap(__TreeRangeSet.create(rangeSet))

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractRangeSet.hashCode()"""
        return int.__wrap(super(AbstractRangeSet, self).hashCode())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def create() -> 'TreeRangeSet':
        """public static <C extends java.lang.Comparable<?>> com.google.common.collect.TreeRangeSet<C> com.google.common.collect.TreeRangeSet.create()"""
        return TreeRangeSet.__wrap(__TreeRangeSet.create())

    @override
    @overload
    def complement(self) -> 'RangeSet':
        """public com.google.common.collect.RangeSet<C> com.google.common.collect.TreeRangeSet.complement()"""
        return 'RangeSet'.__wrap(super(TreeRangeSet, self).complement())

    @override
    @overload
    def add(self, rangeToAdd: 'Range'):
        """public void com.google.common.collect.TreeRangeSet.add(com.google.common.collect.Range<C>)"""
        super(__TreeRangeSet, self).add(rangeToAdd)

    @override
    @overload
    def removeAll(self, ranges: 'Iterable'):
        """public default void com.google.common.collect.RangeSet.removeAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(__RangeSet, self).removeAll(ranges)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def rangeContaining(self, value: 'Comparable') -> 'Range':
        """public com.google.common.collect.Range<C> com.google.common.collect.TreeRangeSet.rangeContaining(C)"""
        return 'Range'.__wrap(super(__TreeRangeSet, self).rangeContaining(value))

    @override
    @overload
    def asDescendingSetOfRanges(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Range<C>> com.google.common.collect.TreeRangeSet.asDescendingSetOfRanges()"""
        return 'Set'.__wrap(super(TreeRangeSet, self).asDescendingSetOfRanges())

    @override
    @overload
    def addAll(self, ranges: 'Iterable'):
        """public default void com.google.common.collect.RangeSet.addAll(java.lang.Iterable<com.google.common.collect.Range<C>>)"""
        super(__RangeSet, self).addAll(ranges)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def remove(self, rangeToRemove: 'Range'):
        """public void com.google.common.collect.TreeRangeSet.remove(com.google.common.collect.Range<C>)"""
        super(__TreeRangeSet, self).remove(rangeToRemove)

    @override
    @overload
    def asRanges(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Range<C>> com.google.common.collect.TreeRangeSet.asRanges()"""
        return 'Set'.__wrap(super(TreeRangeSet, self).asRanges()) 
 
 
# CLASS: com.google.common.collect.TreeRangeMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.TreeRangeMap as __TreeRangeMap
__TreeRangeMap = __TreeRangeMap
import java.util.Map as __Map_Entry
__Entry = __Map_Entry.Entry
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.RangeMap as __RangeMap
__RangeMap = __RangeMap
import java.lang.Comparable as Comparable
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.Map.Entry as Entry
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.Range as __Range
__Range = __Range
import java.lang.Integer as __int
from builtins import bool
import java.util.Map as Map
from builtins import int
 
class TreeRangeMap():
    """com.google.common.collect.TreeRangeMap"""
 
    @staticmethod
    def __wrap(java_value: __TreeRangeMap) -> 'TreeRangeMap':
        return TreeRangeMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __TreeRangeMap):
        """
        Dynamic initializer for TreeRangeMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def asMapOfRanges(self) -> 'Map':
        """public java.util.Map<com.google.common.collect.Range<K>, V> com.google.common.collect.TreeRangeMap.asMapOfRanges()"""
        return 'Map'.__wrap(super(TreeRangeMap, self).asMapOfRanges())

    @override
    @overload
    def put(self, range: 'Range', value: object):
        """public void com.google.common.collect.TreeRangeMap.put(com.google.common.collect.Range<K>,V)"""
        super(__TreeRangeMap, self).put(range, value)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.TreeRangeMap.toString()"""
        return str.__wrap(super(TreeRangeMap, self).toString())

    @override
    @overload
    def merge(self, range: 'Range', value: object, remappingFunction: 'BiFunction'):
        """public void com.google.common.collect.TreeRangeMap.merge(com.google.common.collect.Range<K>,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        super(__TreeRangeMap, self).merge(range, value, remappingFunction)

    @overload
    def subRangeMap(self, subRange: 'Range') -> 'RangeMap':
        """public com.google.common.collect.RangeMap<K, V> com.google.common.collect.TreeRangeMap.subRangeMap(com.google.common.collect.Range<K>)"""
        return 'RangeMap'.__wrap(super(__TreeRangeMap, self).subRangeMap(subRange))

    @override
    @overload
    def asDescendingMapOfRanges(self) -> 'Map':
        """public java.util.Map<com.google.common.collect.Range<K>, V> com.google.common.collect.TreeRangeMap.asDescendingMapOfRanges()"""
        return 'Map'.__wrap(super(TreeRangeMap, self).asDescendingMapOfRanges())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def get(self, key: 'Comparable') -> object:
        """public V com.google.common.collect.TreeRangeMap.get(K)"""
        return object.__wrap(super(__TreeRangeMap, self).get(key))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, o: object) -> bool:
        """public boolean com.google.common.collect.TreeRangeMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__TreeRangeMap, self).equals(o))

    @overload
    def getEntry(self, key: 'Comparable') -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<com.google.common.collect.Range<K>, V> com.google.common.collect.TreeRangeMap.getEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__TreeRangeMap, self).getEntry(key))

    @override
    @overload
    def putCoalescing(self, range: 'Range', value: object):
        """public void com.google.common.collect.TreeRangeMap.putCoalescing(com.google.common.collect.Range<K>,V)"""
        super(__TreeRangeMap, self).putCoalescing(range, value)

    @override
    @overload
    def remove(self, rangeToRemove: 'Range'):
        """public void com.google.common.collect.TreeRangeMap.remove(com.google.common.collect.Range<K>)"""
        super(__TreeRangeMap, self).remove(rangeToRemove)

    @override
    @overload
    def putAll(self, rangeMap: 'RangeMap'):
        """public void com.google.common.collect.TreeRangeMap.putAll(com.google.common.collect.RangeMap<K, ? extends V>)"""
        super(__TreeRangeMap, self).putAll(rangeMap)

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.TreeRangeMap.hashCode()"""
        return int.__wrap(super(TreeRangeMap, self).hashCode())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.TreeRangeMap.clear()"""
        super(TreeRangeMap, self).clear()

    @override
    @overload
    def span(self) -> 'Range':
        """public com.google.common.collect.Range<K> com.google.common.collect.TreeRangeMap.span()"""
        return 'Range'.__wrap(super(TreeRangeMap, self).span())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create() -> 'TreeRangeMap':
        """public static <K extends java.lang.Comparable,V> com.google.common.collect.TreeRangeMap<K, V> com.google.common.collect.TreeRangeMap.create()"""
        return TreeRangeMap.__wrap(__TreeRangeMap.create()) 
 
 
# CLASS: com.google.common.collect.ForwardingMultiset$StandardElementSet
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import com.google.common.collect.ForwardingMultiset as __ForwardingMultiset_StandardElementSet
__StandardElementSet = __ForwardingMultiset_StandardElementSet.StandardElementSet
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.Sets as __Sets_ImprovedAbstractSet
__ImprovedAbstractSet = __Sets_ImprovedAbstractSet.ImprovedAbstractSet
import com.google.common.collect.Multisets as __Multisets_ElementSet
__ElementSet = __Multisets_ElementSet.ElementSet
from builtins import bool
import java.util.AbstractSet as __AbstractSet
__AbstractSet = __AbstractSet
from builtins import str
from pyquantum_helper import override
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class StandardElementSet():
    """com.google.common.collect.ForwardingMultiset.StandardElementSet"""
 
    @staticmethod
    def __wrap(java_value: __StandardElementSet) -> 'StandardElementSet':
        return StandardElementSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardElementSet):
        """
        Dynamic initializer for StandardElementSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def __init__(self, this$0: 'ForwardingMultiset'):
        """public com.google.common.collect.ForwardingMultiset$StandardElementSet(com.google.common.collect.ForwardingMultiset)"""
        val = __StandardElementSet(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingMultiset$StandardElementSet.iterator()"""
        return 'Iterator'.__wrap(super(StandardElementSet, self).iterator())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Multisets$ElementSet.size()"""
        return int.__wrap(super(ElementSet, self).size())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool.__wrap(super(__AbstractCollection, self).add(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractCollection, self).addAll(arg0))

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'.__wrap(super(Set, self).spliterator())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.isEmpty()"""
        return bool.__wrap(super(ElementSet, self).isEmpty())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.contains(java.lang.Object)"""
        return bool.__wrap(super(__ElementSet, self).contains(o))

    @overload
    def containsAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ElementSet, self).containsAll(c))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.remove(java.lang.Object)"""
        return bool.__wrap(super(__ElementSet, self).remove(o))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractSet, self).equals(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Multisets$ElementSet.clear()"""
        super(ElementSet, self).clear()

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int.__wrap(super(AbstractSet, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ForwardingMap$StandardEntrySet
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingMap as __ForwardingMap_StandardEntrySet
__StandardEntrySet = __ForwardingMap_StandardEntrySet.StandardEntrySet
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
from builtins import bool
import java.util.AbstractSet as __AbstractSet
__AbstractSet = __AbstractSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
from builtins import object
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import com.google.common.collect.Maps as __Maps_EntrySet
__EntrySet = __Maps_EntrySet.EntrySet
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class StandardEntrySet(ABC):
    """com.google.common.collect.ForwardingMap.StandardEntrySet"""
 
    @staticmethod
    def __wrap(java_value: __StandardEntrySet) -> 'StandardEntrySet':
        return StandardEntrySet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardEntrySet):
        """
        Dynamic initializer for StandardEntrySet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__EntrySet, self).retainAll(c))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.remove(java.lang.Object)"""
        return bool.__wrap(super(__EntrySet, self).remove(o))

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.contains(java.lang.Object)"""
        return bool.__wrap(super(__EntrySet, self).contains(o))

    @abstractmethod
    def iterator(self, ):
        """public abstract java.util.Iterator<E> java.util.AbstractCollection.iterator()"""
        pass

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool.__wrap(super(__AbstractCollection, self).add(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractCollection, self).addAll(arg0))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__EntrySet, self).removeAll(c))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'.__wrap(super(Set, self).spliterator())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$EntrySet.isEmpty()"""
        return bool.__wrap(super(EntrySet, self).isEmpty())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$EntrySet.clear()"""
        super(EntrySet, self).clear()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$EntrySet.size()"""
        return int.__wrap(super(EntrySet, self).size())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractSet, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int.__wrap(super(AbstractSet, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.DiscreteDomain
import com.google.common.collect.DiscreteDomain as __DiscreteDomain
__DiscreteDomain = __DiscreteDomain
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Comparable as Comparable
from abc import abstractmethod, ABC
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import java.lang.Comparable as __Comparable
__Comparable = __Comparable
from builtins import int
 
class DiscreteDomain(ABC):
    """com.google.common.collect.DiscreteDomain"""
 
    @staticmethod
    def __wrap(java_value: __DiscreteDomain) -> 'DiscreteDomain':
        return DiscreteDomain(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __DiscreteDomain):
        """
        Dynamic initializer for DiscreteDomain.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @abstractmethod
    def distance(self, start: 'Comparable', end: 'Comparable'):
        """public abstract long com.google.common.collect.DiscreteDomain.distance(C,C)"""
        pass

    @abstractmethod
    def previous(self, value: 'Comparable'):
        """public abstract C com.google.common.collect.DiscreteDomain.previous(C)"""
        pass

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def bigIntegers() -> 'DiscreteDomain':
        """public static com.google.common.collect.DiscreteDomain<java.math.BigInteger> com.google.common.collect.DiscreteDomain.bigIntegers()"""
        return DiscreteDomain.__wrap(__DiscreteDomain.bigIntegers())

    @overload
    def minValue(self) -> 'Comparable':
        """public C com.google.common.collect.DiscreteDomain.minValue()"""
        return 'Comparable'.__wrap(super(DiscreteDomain, self).minValue())

    @staticmethod
    @overload
    def integers() -> 'DiscreteDomain':
        """public static com.google.common.collect.DiscreteDomain<java.lang.Integer> com.google.common.collect.DiscreteDomain.integers()"""
        return DiscreteDomain.__wrap(__DiscreteDomain.integers())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def longs() -> 'DiscreteDomain':
        """public static com.google.common.collect.DiscreteDomain<java.lang.Long> com.google.common.collect.DiscreteDomain.longs()"""
        return DiscreteDomain.__wrap(__DiscreteDomain.longs())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def maxValue(self) -> 'Comparable':
        """public C com.google.common.collect.DiscreteDomain.maxValue()"""
        return 'Comparable'.__wrap(super(DiscreteDomain, self).maxValue())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def next(self, value: 'Comparable'):
        """public abstract C com.google.common.collect.DiscreteDomain.next(C)"""
        pass

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ForwardingMap$StandardKeySet
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.Sets as __Sets_ImprovedAbstractSet
__ImprovedAbstractSet = __Sets_ImprovedAbstractSet.ImprovedAbstractSet
from builtins import bool
import java.util.AbstractSet as __AbstractSet
__AbstractSet = __AbstractSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
import com.google.common.collect.Maps as __Maps_KeySet
__KeySet = __Maps_KeySet.KeySet
from builtins import object
import com.google.common.collect.ForwardingMap as __ForwardingMap_StandardKeySet
__StandardKeySet = __ForwardingMap_StandardKeySet.StandardKeySet
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
 
class StandardKeySet():
    """com.google.common.collect.ForwardingMap.StandardKeySet"""
 
    @staticmethod
    def __wrap(java_value: __StandardKeySet) -> 'StandardKeySet':
        return StandardKeySet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardKeySet):
        """
        Dynamic initializer for StandardKeySet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$KeySet.clear()"""
        super(KeySet, self).clear()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.google.common.collect.Maps$KeySet.iterator()"""
        return 'Iterator'.__wrap(super(KeySet, self).iterator())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @overload
    def __init__(self, this$0: 'ForwardingMap'):
        """public com.google.common.collect.ForwardingMap$StandardKeySet(com.google.common.collect.ForwardingMap)"""
        val = __StandardKeySet(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.remove(java.lang.Object)"""
        return bool.__wrap(super(__KeySet, self).remove(o))

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.contains(java.lang.Object)"""
        return bool.__wrap(super(__KeySet, self).contains(o))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool.__wrap(super(__AbstractCollection, self).add(arg0))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractCollection, self).addAll(arg0))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Set.spliterator()"""
        return 'Spliterator'.__wrap(super(Set, self).spliterator())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.isEmpty()"""
        return bool.__wrap(super(KeySet, self).isEmpty())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$KeySet.size()"""
        return int.__wrap(super(KeySet, self).size())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public void com.google.common.collect.Maps$KeySet.forEach(java.util.function.Consumer<? super K>)"""
        super(__KeySet, self).forEach(action)

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractSet, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int.__wrap(super(AbstractSet, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.MinMaxPriorityQueue$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.MinMaxPriorityQueue as __MinMaxPriorityQueue
__MinMaxPriorityQueue = __MinMaxPriorityQueue
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import com.google.common.collect.MinMaxPriorityQueue as __MinMaxPriorityQueue_Builder
__Builder = __MinMaxPriorityQueue_Builder.Builder
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.MinMaxPriorityQueue.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def expectedSize(self, expectedSize: int) -> 'Builder':
        """public com.google.common.collect.MinMaxPriorityQueue$Builder<B> com.google.common.collect.MinMaxPriorityQueue$Builder.expectedSize(int)"""
        return 'Builder'.__wrap(super(__Builder, self).expectedSize(__int.valueOf(expectedSize)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def create(self, initialContents: 'Iterable') -> 'MinMaxPriorityQueue':
        """public <T extends B> com.google.common.collect.MinMaxPriorityQueue<T> com.google.common.collect.MinMaxPriorityQueue$Builder.create(java.lang.Iterable<? extends T>)"""
        return 'MinMaxPriorityQueue'.__wrap(super(__Builder, self).create(initialContents))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def maximumSize(self, maximumSize: int) -> 'Builder':
        """public com.google.common.collect.MinMaxPriorityQueue$Builder<B> com.google.common.collect.MinMaxPriorityQueue$Builder.maximumSize(int)"""
        return 'Builder'.__wrap(super(__Builder, self).maximumSize(__int.valueOf(maximumSize)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def create(self) -> 'MinMaxPriorityQueue':
        """public <T extends B> com.google.common.collect.MinMaxPriorityQueue<T> com.google.common.collect.MinMaxPriorityQueue$Builder.create()"""
        return 'MinMaxPriorityQueue'.__wrap(super(Builder, self).create()) 
 
 
# CLASS: com.google.common.collect.ForwardingMapEntry
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import com.google.common.collect.ForwardingMapEntry as __ForwardingMapEntry
__ForwardingMapEntry = __ForwardingMapEntry
from builtins import type
from builtins import object
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ForwardingMapEntry(ABC):
    """com.google.common.collect.ForwardingMapEntry"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingMapEntry) -> 'ForwardingMapEntry':
        return ForwardingMapEntry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingMapEntry):
        """
        Dynamic initializer for ForwardingMapEntry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def getValue(self) -> object:
        """public V com.google.common.collect.ForwardingMapEntry.getValue()"""
        return object.__wrap(super(ForwardingMapEntry, self).getValue())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def getKey(self) -> object:
        """public K com.google.common.collect.ForwardingMapEntry.getKey()"""
        return object.__wrap(super(ForwardingMapEntry, self).getKey())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMapEntry.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMapEntry, self).equals(object))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMapEntry.hashCode()"""
        return int.__wrap(super(ForwardingMapEntry, self).hashCode())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def setValue(self, value: object) -> object:
        """public V com.google.common.collect.ForwardingMapEntry.setValue(V)"""
        return object.__wrap(super(__ForwardingMapEntry, self).setValue(value)) 
 
 
# CLASS: com.google.common.collect.ImmutableTable$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.ImmutableTable as __ImmutableTable_Builder
__Builder = __ImmutableTable_Builder.Builder
import java.util.Comparator as Comparator
import java.lang.Long as __long
import com.google.common.collect.ImmutableTable as __ImmutableTable
__ImmutableTable = __ImmutableTable
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableTable.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def build(self) -> 'ImmutableTable':
        """public com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable$Builder.build()"""
        return 'ImmutableTable'.__wrap(super(Builder, self).build())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def orderColumnsBy(self, columnComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.orderColumnsBy(java.util.Comparator<? super C>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderColumnsBy(columnComparator))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableTable$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableTable$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def put(self, cell: 'Cell') -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.put(com.google.common.collect.Table$Cell<? extends R, ? extends C, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).put(cell))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def buildOrThrow(self) -> 'ImmutableTable':
        """public com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable$Builder.buildOrThrow()"""
        return 'ImmutableTable'.__wrap(super(Builder, self).buildOrThrow())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def orderRowsBy(self, rowComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.orderRowsBy(java.util.Comparator<? super R>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderRowsBy(rowComparator))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def put(self, rowKey: object, columnKey: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.put(R,C,V)"""
        return 'Builder'.__wrap(super(__Builder, self).put(rowKey, columnKey, value))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def putAll(self, table: 'Table') -> 'Builder':
        """public com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable$Builder.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(table)) 
 
 
# CLASS: com.google.common.collect.ConcurrentHashMultiset
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.concurrent.ConcurrentMap as ConcurrentMap
import java.util.stream.Stream as __Stream
__Stream = __Stream
import com.google.common.collect.AbstractMultiset as __AbstractMultiset
__AbstractMultiset = __AbstractMultiset
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.function.Consumer as Consumer
import com.google.common.collect.ConcurrentHashMultiset as __ConcurrentHashMultiset
__ConcurrentHashMultiset = __ConcurrentHashMultiset
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Set as Set
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ConcurrentHashMultiset():
    """com.google.common.collect.ConcurrentHashMultiset"""
 
    @staticmethod
    def __wrap(java_value: __ConcurrentHashMultiset) -> 'ConcurrentHashMultiset':
        return ConcurrentHashMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ConcurrentHashMultiset):
        """
        Dynamic initializer for ConcurrentHashMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__Multiset, self).forEachEntry(action)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def setCount(self, element: object, expectedOldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.ConcurrentHashMultiset.setCount(E,int,int)"""
        return bool.__wrap(super(__ConcurrentHashMultiset, self).setCount(element, __int.valueOf(expectedOldCount), __int.valueOf(newCount)))

    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.add(E,int)"""
        return int.__wrap(super(__ConcurrentHashMultiset, self).add(element, __int.valueOf(occurrences)))

    @overload
    def removeExactly(self, element: object, occurrences: int) -> bool:
        """public boolean com.google.common.collect.ConcurrentHashMultiset.removeExactly(java.lang.Object,int)"""
        return bool.__wrap(super(__ConcurrentHashMultiset, self).removeExactly(element, __int.valueOf(occurrences)))

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ConcurrentHashMultiset.toArray(T[])"""
        return List[object].__wrap(super(__ConcurrentHashMultiset, self).toArray(array))

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).retainAll(elementsToRetain))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ConcurrentHashMultiset.toArray()"""
        return List[object].__wrap(super(ConcurrentHashMultiset, self).toArray())

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.count(java.lang.Object)"""
        return int.__wrap(super(__ConcurrentHashMultiset, self).count(element))

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.setCount(E,int)"""
        return int.__wrap(super(__ConcurrentHashMultiset, self).setCount(element, __int.valueOf(count)))

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).equals(object))

    @staticmethod
    @overload
    def create(countMap: 'ConcurrentMap') -> 'ConcurrentHashMultiset':
        """public static <E> com.google.common.collect.ConcurrentHashMultiset<E> com.google.common.collect.ConcurrentHashMultiset.create(java.util.concurrent.ConcurrentMap<E, java.util.concurrent.atomic.AtomicInteger>)"""
        return ConcurrentHashMultiset.__wrap(__ConcurrentHashMultiset.create(countMap))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool.__wrap(super(__AbstractMultiset, self).add(element))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ConcurrentHashMultiset.iterator()"""
        return 'Iterator'.__wrap(super(ConcurrentHashMultiset, self).iterator())

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.remove(java.lang.Object,int)"""
        return int.__wrap(super(__ConcurrentHashMultiset, self).remove(element, __int.valueOf(occurrences)))

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).remove(element))

    @overload
    def createEntrySet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ConcurrentHashMultiset.createEntrySet()"""
        return 'Set'.__wrap(super(ConcurrentHashMultiset, self).createEntrySet())

    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ConcurrentHashMultiset.clear()"""
        super(ConcurrentHashMultiset, self).clear()

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ConcurrentHashMultiset.size()"""
        return int.__wrap(super(ConcurrentHashMultiset, self).size())

    @staticmethod
    @overload
    def create() -> 'ConcurrentHashMultiset':
        """public static <E> com.google.common.collect.ConcurrentHashMultiset<E> com.google.common.collect.ConcurrentHashMultiset.create()"""
        return ConcurrentHashMultiset.__wrap(__ConcurrentHashMultiset.create())

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str.__wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int.__wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ConcurrentHashMultiset.isEmpty()"""
        return bool.__wrap(super(ConcurrentHashMultiset, self).isEmpty())

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'ConcurrentHashMultiset':
        """public static <E> com.google.common.collect.ConcurrentHashMultiset<E> com.google.common.collect.ConcurrentHashMultiset.create(java.lang.Iterable<? extends E>)"""
        return ConcurrentHashMultiset.__wrap(__ConcurrentHashMultiset.create(elements)) 
 
 
# CLASS: com.google.common.collect.ComparisonChain
import java.lang.Boolean as Boolean
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.ComparisonChain as __ComparisonChain
__ComparisonChain = __ComparisonChain
import java.lang.Object as __object
from builtins import type
from abc import abstractmethod, ABC
import java.lang.Comparable as Comparable
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ComparisonChain(ABC):
    """com.google.common.collect.ComparisonChain"""
 
    @staticmethod
    def __wrap(java_value: __ComparisonChain) -> 'ComparisonChain':
        return ComparisonChain(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ComparisonChain):
        """
        Dynamic initializer for ComparisonChain.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def compareTrueFirst(self, left: bool, right: bool):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compareTrueFirst(boolean,boolean)"""
        pass

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def compare(self, left: 'Boolean', right: 'Boolean') -> 'ComparisonChain':
        """public final com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(java.lang.Boolean,java.lang.Boolean)"""
        return 'ComparisonChain'.__wrap(super(__ComparisonChain, self).compare(left, right))

    @abstractmethod
    def result(self, ):
        """public abstract int com.google.common.collect.ComparisonChain.result()"""
        pass

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @abstractmethod
    def compare(self, left: int, right: int):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(long,long)"""
        pass

    @staticmethod
    @overload
    def start() -> 'ComparisonChain':
        """public static com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.start()"""
        return ComparisonChain.__wrap(__ComparisonChain.start())

    @abstractmethod
    def compareFalseFirst(self, left: bool, right: bool):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compareFalseFirst(boolean,boolean)"""
        pass

    @abstractmethod
    def compare(self, left: int, right: int):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(int,int)"""
        pass

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @abstractmethod
    def compare(self, left: 'Comparable', right: 'Comparable'):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(java.lang.Comparable<?>,java.lang.Comparable<?>)"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @abstractmethod
    def compare(self, left: float, right: float):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(float,float)"""
        pass

    @abstractmethod
    def compare(self, left: object, right: object, comparator: 'Comparator'):
        """public abstract <T> com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(T,T,java.util.Comparator<T>)"""
        pass

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def compare(self, left: float, right: float):
        """public abstract com.google.common.collect.ComparisonChain com.google.common.collect.ComparisonChain.compare(double,double)"""
        pass

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.Interners$InternerBuilder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.Interner as __Interner
__Interner = __Interner
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.Interners as __Interners_InternerBuilder
__InternerBuilder = __Interners_InternerBuilder.InternerBuilder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class InternerBuilder():
    """com.google.common.collect.Interners.InternerBuilder"""
 
    @staticmethod
    def __wrap(java_value: __InternerBuilder) -> 'InternerBuilder':
        return InternerBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __InternerBuilder):
        """
        Dynamic initializer for InternerBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def concurrencyLevel(self, concurrencyLevel: int) -> 'InternerBuilder':
        """public com.google.common.collect.Interners$InternerBuilder com.google.common.collect.Interners$InternerBuilder.concurrencyLevel(int)"""
        return 'InternerBuilder'.__wrap(super(__InternerBuilder, self).concurrencyLevel(__int.valueOf(concurrencyLevel)))

    @overload
    def weak(self) -> 'InternerBuilder':
        """public com.google.common.collect.Interners$InternerBuilder com.google.common.collect.Interners$InternerBuilder.weak()"""
        return 'InternerBuilder'.__wrap(super(InternerBuilder, self).weak())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def strong(self) -> 'InternerBuilder':
        """public com.google.common.collect.Interners$InternerBuilder com.google.common.collect.Interners$InternerBuilder.strong()"""
        return 'InternerBuilder'.__wrap(super(InternerBuilder, self).strong())

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def build(self) -> 'Interner':
        """public <E> com.google.common.collect.Interner<E> com.google.common.collect.Interners$InternerBuilder.build()"""
        return 'Interner'.__wrap(super(InternerBuilder, self).build())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.TreeBasedTable
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.SortedMap as __SortedMap
__SortedMap = __SortedMap
from builtins import type
import java.util.SortedSet as SortedSet
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Comparator as Comparator
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.Object as __Object
__Object = __Object
import java.util.SortedMap as SortedMap
import java.lang.Integer as __int
import com.google.common.collect.TreeBasedTable as __TreeBasedTable
__TreeBasedTable = __TreeBasedTable
 
class TreeBasedTable():
    """com.google.common.collect.TreeBasedTable"""
 
    @staticmethod
    def __wrap(java_value: __TreeBasedTable) -> 'TreeBasedTable':
        return TreeBasedTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __TreeBasedTable):
        """
        Dynamic initializer for TreeBasedTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def rowKeySet(self) -> 'SortedSet':
        """public java.util.SortedSet<R> com.google.common.collect.TreeBasedTable.rowKeySet()"""
        return 'SortedSet'.__wrap(super(TreeBasedTable, self).rowKeySet())

    @overload
    def rowComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super R> com.google.common.collect.TreeBasedTable.rowComparator()"""
        return 'Comparator'.__wrap(super(TreeBasedTable, self).rowComparator())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def create(table: 'TreeBasedTable') -> 'TreeBasedTable':
        """public static <R,C,V> com.google.common.collect.TreeBasedTable<R, C, V> com.google.common.collect.TreeBasedTable.create(com.google.common.collect.TreeBasedTable<R, C, ? extends V>)"""
        return TreeBasedTable.__wrap(__TreeBasedTable.create(table))

    @override
    @overload
    def rowMap(self) -> 'SortedMap':
        """public java.util.SortedMap<R, java.util.Map<C, V>> com.google.common.collect.TreeBasedTable.rowMap()"""
        return 'SortedMap'.__wrap(super(TreeBasedTable, self).rowMap())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def row(self, rowKey: object) -> 'SortedMap':
        """public java.util.SortedMap<C, V> com.google.common.collect.TreeBasedTable.row(R)"""
        return 'SortedMap'.__wrap(super(__TreeBasedTable, self).row(rowKey))

    @staticmethod
    @overload
    def create() -> 'TreeBasedTable':
        """public static <R extends java.lang.Comparable,C extends java.lang.Comparable,V> com.google.common.collect.TreeBasedTable<R, C, V> com.google.common.collect.TreeBasedTable.create()"""
        return TreeBasedTable.__wrap(__TreeBasedTable.create())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def create(rowComparator: 'Comparator', columnComparator: 'Comparator') -> 'TreeBasedTable':
        """public static <R,C,V> com.google.common.collect.TreeBasedTable<R, C, V> com.google.common.collect.TreeBasedTable.create(java.util.Comparator<? super R>,java.util.Comparator<? super C>)"""
        return TreeBasedTable.__wrap(__TreeBasedTable.create(rowComparator, columnComparator))

    @overload
    def columnComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super C> com.google.common.collect.TreeBasedTable.columnComparator()"""
        return 'Comparator'.__wrap(super(TreeBasedTable, self).columnComparator()) 
 
 
# CLASS: com.google.common.collect.ListMultimap
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from pyquantum_helper import override
import java.util.function.BiConsumer as BiConsumer
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
import com.google.common.collect.ListMultimap as __ListMultimap
__ListMultimap = __ListMultimap
 
class ListMultimap(ABC):
    """com.google.common.collect.ListMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ListMultimap) -> 'ListMultimap':
        return ListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ListMultimap):
        """
        Dynamic initializer for ListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def keys(self, ):
        """public abstract com.google.common.collect.Multiset<K> com.google.common.collect.Multimap.keys()"""
        pass

    @abstractmethod
    def removeAll(self, key: object):
        """public abstract java.util.List<V> com.google.common.collect.ListMultimap.removeAll(java.lang.Object)"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Multimap.isEmpty()"""
        pass

    @abstractmethod
    def asMap(self, ):
        """public abstract java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ListMultimap.asMap()"""
        pass

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> com.google.common.collect.Multimap.keySet()"""
        pass

    @abstractmethod
    def get(self, key: object):
        """public abstract java.util.List<V> com.google.common.collect.ListMultimap.get(K)"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.put(K,V)"""
        pass

    @abstractmethod
    def entries(self, ):
        """public abstract java.util.Collection<java.util.Map$Entry<K, V>> com.google.common.collect.Multimap.entries()"""
        pass

    @abstractmethod
    def containsEntry(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def replaceValues(self, key: object, values: 'Iterable'):
        """public abstract java.util.List<V> com.google.common.collect.ListMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def remove(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def containsKey(self, key: object):
        """public abstract boolean com.google.common.collect.Multimap.containsKey(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.values()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multimap.hashCode()"""
        pass

    @abstractmethod
    def putAll(self, key: object, values: 'Iterable'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.ListMultimap.equals(java.lang.Object)"""
        pass

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Multimap.clear()"""
        pass

    @abstractmethod
    def putAll(self, multimap: 'Multimap'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multimap.size()"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingMultiset
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.Set as __Set
__Set = __Set
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import com.google.common.collect.ForwardingMultiset as __ForwardingMultiset
__ForwardingMultiset = __ForwardingMultiset
import java.lang.Integer as __int
from builtins import int
import java.util.function.ObjIntConsumer as ObjIntConsumer
 
class ForwardingMultiset(ABC):
    """com.google.common.collect.ForwardingMultiset"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingMultiset) -> 'ForwardingMultiset':
        return ForwardingMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingMultiset):
        """
        Dynamic initializer for ForwardingMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def add(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.add(E,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).add(element, __int.valueOf(occurrences)))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def elementSet(self) -> 'Set':
        """public java.util.Set<E> com.google.common.collect.ForwardingMultiset.elementSet()"""
        return 'Set'.__wrap(super(ForwardingMultiset, self).elementSet())

    @override
    @overload
    def forEachEntry(self, action: 'ObjIntConsumer'):
        """public default void com.google.common.collect.Multiset.forEachEntry(java.util.function.ObjIntConsumer<? super E>)"""
        super(__Multiset, self).forEachEntry(action)

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultiset, self).equals(object))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @overload
    def setCount(self, element: object, count: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.setCount(E,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).setCount(element, __int.valueOf(count)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Multiset$Entry<E>> com.google.common.collect.ForwardingMultiset.entrySet()"""
        return 'Set'.__wrap(super(ForwardingMultiset, self).entrySet())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def setCount(self, element: object, oldCount: int, newCount: int) -> bool:
        """public boolean com.google.common.collect.ForwardingMultiset.setCount(E,int,int)"""
        return bool.__wrap(super(__ForwardingMultiset, self).setCount(element, __int.valueOf(oldCount), __int.valueOf(newCount)))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def remove(self, element: object, occurrences: int) -> int:
        """public int com.google.common.collect.ForwardingMultiset.remove(java.lang.Object,int)"""
        return int.__wrap(super(__ForwardingMultiset, self).remove(element, __int.valueOf(occurrences)))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def count(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingMultiset.count(java.lang.Object)"""
        return int.__wrap(super(__ForwardingMultiset, self).count(element))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultiset.hashCode()"""
        return int.__wrap(super(ForwardingMultiset, self).hashCode())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_SetMultimapBuilder
__SetMultimapBuilder = __MultimapBuilder_SetMultimapBuilder.SetMultimapBuilder
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_SortedSetMultimapBuilder
__SortedSetMultimapBuilder = __MultimapBuilder_SortedSetMultimapBuilder.SortedSetMultimapBuilder
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_ListMultimapBuilder
__ListMultimapBuilder = __MultimapBuilder_ListMultimapBuilder.ListMultimapBuilder
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_MultimapBuilderWithKeys
__MultimapBuilderWithKeys = __MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class MultimapBuilderWithKeys(ABC):
    """com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys"""
 
    @staticmethod
    def __wrap(java_value: __MultimapBuilderWithKeys) -> 'MultimapBuilderWithKeys':
        return MultimapBuilderWithKeys(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __MultimapBuilderWithKeys):
        """
        Dynamic initializer for MultimapBuilderWithKeys.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def linkedHashSetValues(self, expectedValuesPerKey: int) -> 'SetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.linkedHashSetValues(int)"""
        return 'SetMultimapBuilder'.__wrap(super(__MultimapBuilderWithKeys, self).linkedHashSetValues(__int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def linkedListValues(self) -> 'ListMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$ListMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.linkedListValues()"""
        return 'ListMultimapBuilder'.__wrap(super(MultimapBuilderWithKeys, self).linkedListValues())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def treeSetValues(self, comparator: 'Comparator') -> 'SortedSetMultimapBuilder':
        """public <V0> com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder<K0, V0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.treeSetValues(java.util.Comparator<V0>)"""
        return 'SortedSetMultimapBuilder'.__wrap(super(__MultimapBuilderWithKeys, self).treeSetValues(comparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def hashSetValues(self, expectedValuesPerKey: int) -> 'SetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.hashSetValues(int)"""
        return 'SetMultimapBuilder'.__wrap(super(__MultimapBuilderWithKeys, self).hashSetValues(__int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def hashSetValues(self) -> 'SetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.hashSetValues()"""
        return 'SetMultimapBuilder'.__wrap(super(MultimapBuilderWithKeys, self).hashSetValues())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def arrayListValues(self, expectedValuesPerKey: int) -> 'ListMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$ListMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.arrayListValues(int)"""
        return 'ListMultimapBuilder'.__wrap(super(__MultimapBuilderWithKeys, self).arrayListValues(__int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def linkedHashSetValues(self) -> 'SetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.linkedHashSetValues()"""
        return 'SetMultimapBuilder'.__wrap(super(MultimapBuilderWithKeys, self).linkedHashSetValues())

    @overload
    def arrayListValues(self) -> 'ListMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$ListMultimapBuilder<K0, java.lang.Object> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.arrayListValues()"""
        return 'ListMultimapBuilder'.__wrap(super(MultimapBuilderWithKeys, self).arrayListValues())

    @overload
    def enumSetValues(self, valueClass: 'Class') -> 'SetMultimapBuilder':
        """public <V0 extends java.lang.Enum<V0>> com.google.common.collect.MultimapBuilder$SetMultimapBuilder<K0, V0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.enumSetValues(java.lang.Class<V0>)"""
        return 'SetMultimapBuilder'.__wrap(super(__MultimapBuilderWithKeys, self).enumSetValues(valueClass))

    @overload
    def treeSetValues(self) -> 'SortedSetMultimapBuilder':
        """public com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder<K0, java.lang.Comparable> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys.treeSetValues()"""
        return 'SortedSetMultimapBuilder'.__wrap(super(MultimapBuilderWithKeys, self).treeSetValues())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder
from builtins import str
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
from abc import abstractmethod, ABC
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_MultimapBuilderWithKeys
__MultimapBuilderWithKeys = __MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.MultimapBuilder as __MultimapBuilder
__MultimapBuilder = __MultimapBuilder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class MultimapBuilder(ABC):
    """com.google.common.collect.MultimapBuilder"""
 
    @staticmethod
    def __wrap(java_value: __MultimapBuilder) -> 'MultimapBuilder':
        return MultimapBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __MultimapBuilder):
        """
        Dynamic initializer for MultimapBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def build(self, multimap: 'Multimap') -> 'Multimap':
        """public <K extends K0,V extends V0> com.google.common.collect.Multimap<K, V> com.google.common.collect.MultimapBuilder.build(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'Multimap'.__wrap(super(__MultimapBuilder, self).build(multimap))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def hashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys(int)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.hashKeys(__int.valueOf(expectedKeys)))

    @abstractmethod
    def build(self, ):
        """public abstract <K extends K0,V extends V0> com.google.common.collect.Multimap<K, V> com.google.common.collect.MultimapBuilder.build()"""
        pass

    @staticmethod
    @overload
    def hashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.hashKeys())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def treeKeys(comparator: 'Comparator') -> 'MultimapBuilderWithKeys':
        """public static <K0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.treeKeys(java.util.Comparator<K0>)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.treeKeys(comparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def treeKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Comparable> com.google.common.collect.MultimapBuilder.treeKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.treeKeys())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def linkedHashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.linkedHashKeys())

    @staticmethod
    @overload
    def enumKeys(keyClass: 'Class') -> 'MultimapBuilderWithKeys':
        """public static <K0 extends java.lang.Enum<K0>> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.enumKeys(java.lang.Class<K0>)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.enumKeys(keyClass))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def linkedHashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys(int)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.linkedHashKeys(__int.valueOf(expectedKeys)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ForwardingTable
from builtins import str
import com.google.common.collect.ForwardingTable as __ForwardingTable
__ForwardingTable = __ForwardingTable
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Map as __Map
__Map = __Map
import java.util.Set as __Set
__Set = __Set
import java.util.Collection as Collection
from builtins import object
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import java.util.Map as Map
from builtins import int
 
class ForwardingTable(ABC):
    """com.google.common.collect.ForwardingTable"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingTable) -> 'ForwardingTable':
        return ForwardingTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingTable):
        """
        Dynamic initializer for ForwardingTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingTable.size()"""
        return int.__wrap(super(ForwardingTable, self).size())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def containsColumn(self, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.containsColumn(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingTable, self).containsColumn(columnKey))

    @override
    @overload
    def rowKeySet(self) -> 'Set':
        """public java.util.Set<R> com.google.common.collect.ForwardingTable.rowKeySet()"""
        return 'Set'.__wrap(super(ForwardingTable, self).rowKeySet())

    @overload
    def remove(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ForwardingTable.remove(java.lang.Object,java.lang.Object)"""
        return object.__wrap(super(__ForwardingTable, self).remove(rowKey, columnKey))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def contains(self, rowKey: object, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.contains(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingTable, self).contains(rowKey, columnKey))

    @overload
    def equals(self, obj: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingTable, self).equals(obj))

    @overload
    def get(self, rowKey: object, columnKey: object) -> object:
        """public V com.google.common.collect.ForwardingTable.get(java.lang.Object,java.lang.Object)"""
        return object.__wrap(super(__ForwardingTable, self).get(rowKey, columnKey))

    @overload
    def containsRow(self, rowKey: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.containsRow(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingTable, self).containsRow(rowKey))

    @override
    @overload
    def columnKeySet(self) -> 'Set':
        """public java.util.Set<C> com.google.common.collect.ForwardingTable.columnKeySet()"""
        return 'Set'.__wrap(super(ForwardingTable, self).columnKeySet())

    @override
    @overload
    def rowMap(self) -> 'Map':
        """public java.util.Map<R, java.util.Map<C, V>> com.google.common.collect.ForwardingTable.rowMap()"""
        return 'Map'.__wrap(super(ForwardingTable, self).rowMap())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.isEmpty()"""
        return bool.__wrap(super(ForwardingTable, self).isEmpty())

    @overload
    def column(self, columnKey: object) -> 'Map':
        """public java.util.Map<R, V> com.google.common.collect.ForwardingTable.column(C)"""
        return 'Map'.__wrap(super(__ForwardingTable, self).column(columnKey))

    @override
    @overload
    def putAll(self, table: 'Table'):
        """public void com.google.common.collect.ForwardingTable.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        super(__ForwardingTable, self).putAll(table)

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingTable.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingTable, self).containsValue(value))

    @override
    @overload
    def cellSet(self) -> 'Set':
        """public java.util.Set<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.ForwardingTable.cellSet()"""
        return 'Set'.__wrap(super(ForwardingTable, self).cellSet())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingTable.hashCode()"""
        return int.__wrap(super(ForwardingTable, self).hashCode())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def columnMap(self) -> 'Map':
        """public java.util.Map<C, java.util.Map<R, V>> com.google.common.collect.ForwardingTable.columnMap()"""
        return 'Map'.__wrap(super(ForwardingTable, self).columnMap())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def row(self, rowKey: object) -> 'Map':
        """public java.util.Map<C, V> com.google.common.collect.ForwardingTable.row(R)"""
        return 'Map'.__wrap(super(__ForwardingTable, self).row(rowKey))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingTable.values()"""
        return 'Collection'.__wrap(super(ForwardingTable, self).values())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingTable.clear()"""
        super(ForwardingTable, self).clear()

    @overload
    def put(self, rowKey: object, columnKey: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingTable.put(R,C,V)"""
        return object.__wrap(super(__ForwardingTable, self).put(rowKey, columnKey, value))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.MapDifference$ValueDifference
import com.google.common.collect.MapDifference as __MapDifference_ValueDifference
__ValueDifference = __MapDifference_ValueDifference.ValueDifference
from abc import abstractmethod, ABC
 
class ValueDifference(ABC):
    """com.google.common.collect.MapDifference.ValueDifference"""
 
    @staticmethod
    def __wrap(java_value: __ValueDifference) -> 'ValueDifference':
        return ValueDifference(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ValueDifference):
        """
        Dynamic initializer for ValueDifference.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def equals(self, other: object):
        """public abstract boolean com.google.common.collect.MapDifference$ValueDifference.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.MapDifference$ValueDifference.hashCode()"""
        pass

    @abstractmethod
    def leftValue(self, ):
        """public abstract V com.google.common.collect.MapDifference$ValueDifference.leftValue()"""
        pass

    @abstractmethod
    def rightValue(self, ):
        """public abstract V com.google.common.collect.MapDifference$ValueDifference.rightValue()"""
        pass 
 
 
# CLASS: com.google.common.collect.ImmutableBiMap
import com.google.common.collect.ImmutableBiMap as __ImmutableBiMap
__ImmutableBiMap = __ImmutableBiMap
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.Map as __Map
__Map = __Map
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableSetMultimap as __ImmutableSetMultimap
__ImmutableSetMultimap = __ImmutableSetMultimap
import java.util.Map.Entry as Entry
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BinaryOperator as BinaryOperator
import com.google.common.collect.ImmutableBiMap as __ImmutableBiMap_Builder
__Builder = __ImmutableBiMap_Builder.Builder
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import java.util.stream.Collector as Collector
from builtins import object
import com.google.common.collect.ImmutableMap as __ImmutableMap_Builder
__Builder = __ImmutableMap_Builder.Builder
import java.util.function.BiFunction as BiFunction
import java.lang.Long as __long
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.lang.Object as __Object
__Object = __Object
import java.util.function.Function as Function
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import int
 
class ImmutableBiMap(ABC):
    """com.google.common.collect.ImmutableBiMap"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableBiMap) -> 'ImmutableBiMap':
        return ImmutableBiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableBiMap):
        """
        Dynamic initializer for ImmutableBiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def toImmutableBiMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableBiMap<K, V>> com.google.common.collect.ImmutableBiMap.toImmutableBiMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableBiMap.toImmutableBiMap(keyFunction, valueFunction))

    @overload
    def merge(self, key: object, value: object, function: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).merge(key, value, function))

    @overload
    def remove(self, o: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ImmutableMap, self).remove(o))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMap.hashCode()"""
        return int.__wrap(super(ImmutableMap, self).hashCode())

    @overload
    def compute(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).compute(key, remappingFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.copyOf(map))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builder()"""
        return Builder.__wrap(__ImmutableMap.builder())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def replace(self, key: object, oldValue: object, newValue: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.replace(K,V,V)"""
        return bool.__wrap(super(__ImmutableMap, self).replace(key, oldValue, newValue))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableMap.__wrap(__ImmutableMap.copyOf(map))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1))

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.ofEntries(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap.builder()"""
        return Builder.__wrap(__ImmutableBiMap.builder())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).equals(object))

    @overload
    def putIfAbsent(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.putIfAbsent(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).putIfAbsent(key, value))

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableBiMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableBiMap.toImmutableMap(keyFunction, valueFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.copyOf(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @overload
    def replace(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.replace(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).replace(key, value))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).containsKey(key))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.isEmpty()"""
        return bool.__wrap(super(ImmutableMap, self).isEmpty())

    @overload
    def forcePut(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableBiMap.forcePut(K,V)"""
        return object.__wrap(super(__ImmutableBiMap, self).forcePut(key, value))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMap.clear()"""
        super(ImmutableMap, self).clear()

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public final void com.google.common.collect.ImmutableMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__ImmutableMap, self).replaceAll(function)

    @staticmethod
    @overload
    def of() -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of()"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of())

    @overload
    def getOrDefault(self, key: object, defaultValue: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__ImmutableMap, self).getOrDefault(key, defaultValue))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).remove(key, value))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def of() -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of()"""
        return ImmutableMap.__wrap(__ImmutableMap.of())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2))

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableMap.__wrap(__ImmutableMap.ofEntries(entries))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.Map.size()"""
        pass

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMap.__wrap(__ImmutableMap.copyOf(entries))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).containsValue(value))

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableMap.entrySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMap, self).entrySet())

    @abstractmethod
    def inverse(self, ):
        """public abstract com.google.common.collect.ImmutableBiMap<V, K> com.google.common.collect.ImmutableBiMap.inverse()"""
        pass

    @overload
    def computeIfPresent(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).computeIfPresent(key, remappingFunction))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableBiMap$Builder<K, V> com.google.common.collect.ImmutableBiMap.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableBiMap.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @override
    @overload
    def values(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<V> com.google.common.collect.ImmutableBiMap.values()"""
        return 'ImmutableSet'.__wrap(super(ImmutableBiMap, self).values())

    @abstractmethod
    def get(self, key: object):
        """public abstract V com.google.common.collect.ImmutableMap.get(java.lang.Object)"""
        pass

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableBiMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector.__wrap(__ImmutableBiMap.toImmutableMap(keyFunction, valueFunction, mergeFunction))

    @overload
    def put(self, k: object, v: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.put(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).put(k, v))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMap.toString()"""
        return str.__wrap(super(ImmutableMap, self).toString())

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public final void com.google.common.collect.ImmutableMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ImmutableMap, self).putAll(map)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableMap.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def keySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<K> com.google.common.collect.ImmutableMap.keySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableMap, self).keySet())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableBiMap':
        """public static <K,V> com.google.common.collect.ImmutableBiMap<K, V> com.google.common.collect.ImmutableBiMap.of(K,V,K,V,K,V)"""
        return ImmutableBiMap.__wrap(__ImmutableBiMap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @override
    @overload
    def asMultimap(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableMap.asMultimap()"""
        return 'ImmutableSetMultimap'.__wrap(super(ImmutableMap, self).asMultimap())

    @overload
    def computeIfAbsent(self, key: object, mappingFunction: 'Function') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).computeIfAbsent(key, mappingFunction)) 
 
 
# CLASS: com.google.common.collect.AbstractIterator
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.AbstractIterator as __AbstractIterator
__AbstractIterator = __AbstractIterator
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
from builtins import type
from builtins import object
import java.util.function.Consumer as Consumer
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.UnmodifiableIterator as __UnmodifiableIterator
__UnmodifiableIterator = __UnmodifiableIterator
from builtins import int
 
class AbstractIterator(ABC):
    """com.google.common.collect.AbstractIterator"""
 
    @staticmethod
    def __wrap(java_value: __AbstractIterator) -> 'AbstractIterator':
        return AbstractIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __AbstractIterator):
        """
        Dynamic initializer for AbstractIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def hasNext(self) -> bool:
        """public final boolean com.google.common.collect.AbstractIterator.hasNext()"""
        return bool.__wrap(super(AbstractIterator, self).hasNext())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def remove(self):
        """public final void com.google.common.collect.UnmodifiableIterator.remove()"""
        super(UnmodifiableIterator, self).remove()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def next(self) -> object:
        """public final T com.google.common.collect.AbstractIterator.next()"""
        return object.__wrap(super(AbstractIterator, self).next())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(__Iterator, self).forEachRemaining(arg0)

    @overload
    def peek(self) -> object:
        """public final T com.google.common.collect.AbstractIterator.peek()"""
        return object.__wrap(super(AbstractIterator, self).peek())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ImmutableRangeMap
from builtins import str
import com.google.common.collect.ImmutableRangeMap as __ImmutableRangeMap_Builder
__Builder = __ImmutableRangeMap_Builder.Builder
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Map as __Map_Entry
__Entry = __Map_Entry.Entry
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.lang.Comparable as Comparable
from builtins import object
import java.util.stream.Collector as Collector
import java.util.function.BiFunction as BiFunction
import java.util.Map.Entry as Entry
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableRangeMap as __ImmutableRangeMap
__ImmutableRangeMap = __ImmutableRangeMap
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import com.google.common.collect.Range as __Range
__Range = __Range
import java.util.function.Function as Function
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ImmutableRangeMap():
    """com.google.common.collect.ImmutableRangeMap"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableRangeMap) -> 'ImmutableRangeMap':
        return ImmutableRangeMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableRangeMap):
        """
        Dynamic initializer for ImmutableRangeMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def of() -> 'ImmutableRangeMap':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap.of()"""
        return ImmutableRangeMap.__wrap(__ImmutableRangeMap.of())

    @override
    @overload
    def asMapOfRanges(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<com.google.common.collect.Range<K>, V> com.google.common.collect.ImmutableRangeMap.asMapOfRanges()"""
        return 'ImmutableMap'.__wrap(super(ImmutableRangeMap, self).asMapOfRanges())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableRangeMap.toString()"""
        return str.__wrap(super(ImmutableRangeMap, self).toString())

    @overload
    def equals(self, o: object) -> bool:
        """public boolean com.google.common.collect.ImmutableRangeMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableRangeMap, self).equals(o))

    @staticmethod
    @overload
    def of(range: 'Range', value: object) -> 'ImmutableRangeMap':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap.of(com.google.common.collect.Range<K>,V)"""
        return ImmutableRangeMap.__wrap(__ImmutableRangeMap.of(range, value))

    @override
    @overload
    def put(self, range: 'Range', value: object):
        """public final void com.google.common.collect.ImmutableRangeMap.put(com.google.common.collect.Range<K>,V)"""
        super(__ImmutableRangeMap, self).put(range, value)

    @override
    @overload
    def remove(self, range: 'Range'):
        """public final void com.google.common.collect.ImmutableRangeMap.remove(com.google.common.collect.Range<K>)"""
        super(__ImmutableRangeMap, self).remove(range)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def asDescendingMapOfRanges(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<com.google.common.collect.Range<K>, V> com.google.common.collect.ImmutableRangeMap.asDescendingMapOfRanges()"""
        return 'ImmutableMap'.__wrap(super(ImmutableRangeMap, self).asDescendingMapOfRanges())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableRangeMap$Builder<K, V> com.google.common.collect.ImmutableRangeMap.builder()"""
        return Builder.__wrap(__ImmutableRangeMap.builder())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def toImmutableRangeMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K extends java.lang.Comparable<? super K>,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableRangeMap<K, V>> com.google.common.collect.ImmutableRangeMap.toImmutableRangeMap(java.util.function.Function<? super T, com.google.common.collect.Range<K>>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableRangeMap.toImmutableRangeMap(keyFunction, valueFunction))

    @override
    @overload
    def putAll(self, rangeMap: 'RangeMap'):
        """public final void com.google.common.collect.ImmutableRangeMap.putAll(com.google.common.collect.RangeMap<K, ? extends V>)"""
        super(__ImmutableRangeMap, self).putAll(rangeMap)

    @override
    @overload
    def putCoalescing(self, range: 'Range', value: object):
        """public final void com.google.common.collect.ImmutableRangeMap.putCoalescing(com.google.common.collect.Range<K>,V)"""
        super(__ImmutableRangeMap, self).putCoalescing(range, value)

    @override
    @overload
    def span(self) -> 'Range':
        """public com.google.common.collect.Range<K> com.google.common.collect.ImmutableRangeMap.span()"""
        return 'Range'.__wrap(super(ImmutableRangeMap, self).span())

    @overload
    def get(self, key: 'Comparable') -> object:
        """public V com.google.common.collect.ImmutableRangeMap.get(K)"""
        return object.__wrap(super(__ImmutableRangeMap, self).get(key))

    @overload
    def getEntry(self, key: 'Comparable') -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<com.google.common.collect.Range<K>, V> com.google.common.collect.ImmutableRangeMap.getEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ImmutableRangeMap, self).getEntry(key))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableRangeMap.clear()"""
        super(ImmutableRangeMap, self).clear()

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableRangeMap.hashCode()"""
        return int.__wrap(super(ImmutableRangeMap, self).hashCode())

    @staticmethod
    @overload
    def copyOf(rangeMap: 'RangeMap') -> 'ImmutableRangeMap':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap.copyOf(com.google.common.collect.RangeMap<K, ? extends V>)"""
        return ImmutableRangeMap.__wrap(__ImmutableRangeMap.copyOf(rangeMap))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def subRangeMap(self, range: 'Range') -> 'ImmutableRangeMap':
        """public com.google.common.collect.ImmutableRangeMap<K, V> com.google.common.collect.ImmutableRangeMap.subRangeMap(com.google.common.collect.Range<K>)"""
        return 'ImmutableRangeMap'.__wrap(super(__ImmutableRangeMap, self).subRangeMap(range))

    @override
    @overload
    def merge(self, range: 'Range', value: object, remappingFunction: 'BiFunction'):
        """public final void com.google.common.collect.ImmutableRangeMap.merge(com.google.common.collect.Range<K>,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        super(__ImmutableRangeMap, self).merge(range, value, remappingFunction) 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableSet$StandardDescendingSet
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
import java.lang.Boolean as __boolean
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import com.google.common.collect.ForwardingNavigableSet as __ForwardingNavigableSet_StandardDescendingSet
__StandardDescendingSet = __ForwardingNavigableSet_StandardDescendingSet.StandardDescendingSet
import java.util.Collection as Collection
import com.google.common.collect.Sets as __Sets_DescendingSet
__DescendingSet = __Sets_DescendingSet.DescendingSet
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingSet as __ForwardingSet
__ForwardingSet = __ForwardingSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.SortedSet as SortedSet
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class StandardDescendingSet():
    """com.google.common.collect.ForwardingNavigableSet.StandardDescendingSet"""
 
    @staticmethod
    def __wrap(java_value: __StandardDescendingSet) -> 'StandardDescendingSet':
        return StandardDescendingSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardDescendingSet):
        """
        Dynamic initializer for StandardDescendingSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.Sets$DescendingSet.toArray()"""
        return List[object].__wrap(super(DescendingSet, self).toArray())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.Sets$DescendingSet.toString()"""
        return str.__wrap(super(DescendingSet, self).toString())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int.__wrap(super(ForwardingSet, self).hashCode())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.Sets$DescendingSet.descendingIterator()"""
        return 'Iterator'.__wrap(super(DescendingSet, self).descendingIterator())

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(__SortedSet, self).addLast(arg0)

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'.__wrap(super(NavigableSet, self).reversed())

    @overload
    def __init__(self, this$0: 'ForwardingNavigableSet'):
        """public com.google.common.collect.ForwardingNavigableSet$StandardDescendingSet(com.google.common.collect.ForwardingNavigableSet)"""
        val = __StandardDescendingSet(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.floor(E)"""
        return object.__wrap(super(__DescendingSet, self).floor(e))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object.__wrap(super(SortedSet, self).getFirst())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object.__wrap(super(NavigableSet, self).removeFirst())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.Sets$DescendingSet.iterator()"""
        return 'Iterator'.__wrap(super(DescendingSet, self).iterator())

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(__SortedSet, self).addFirst(arg0)

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.higher(E)"""
        return object.__wrap(super(__DescendingSet, self).higher(e))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.first()"""
        return object.__wrap(super(DescendingSet, self).first())

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.ceiling(E)"""
        return object.__wrap(super(__DescendingSet, self).ceiling(e))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.Sets$DescendingSet.toArray(T[])"""
        return List[object].__wrap(super(__DescendingSet, self).toArray(array))

    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.pollFirst()"""
        return object.__wrap(super(DescendingSet, self).pollFirst())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.Sets$DescendingSet.tailSet(E)"""
        return 'SortedSet'.__wrap(super(__DescendingSet, self).tailSet(fromElement))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'.__wrap(super(SortedSet, self).spliterator())

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.last()"""
        return object.__wrap(super(DescendingSet, self).last())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object.__wrap(super(SortedSet, self).getLast())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.Sets$DescendingSet.comparator()"""
        return 'Comparator'.__wrap(super(DescendingSet, self).comparator())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingSet, self).equals(object))

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.Sets$DescendingSet.headSet(E,boolean)"""
        return 'NavigableSet'.__wrap(super(__DescendingSet, self).headSet(toElement, __boolean.valueOf(inclusive)))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.Sets$DescendingSet.subSet(E,boolean,E,boolean)"""
        return 'NavigableSet'.__wrap(super(__DescendingSet, self).subSet(fromElement, __boolean.valueOf(fromInclusive), toElement, __boolean.valueOf(toInclusive)))

    @override
    @overload
    def descendingSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.Sets$DescendingSet.descendingSet()"""
        return 'NavigableSet'.__wrap(super(DescendingSet, self).descendingSet())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.lower(E)"""
        return object.__wrap(super(__DescendingSet, self).lower(e))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object.__wrap(super(NavigableSet, self).removeLast())

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.Sets$DescendingSet.pollLast()"""
        return object.__wrap(super(DescendingSet, self).pollLast())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.Sets$DescendingSet.subSet(E,E)"""
        return 'SortedSet'.__wrap(super(__DescendingSet, self).subSet(fromElement, toElement))

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.Sets$DescendingSet.headSet(E)"""
        return 'SortedSet'.__wrap(super(__DescendingSet, self).headSet(toElement))

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.Sets$DescendingSet.tailSet(E,boolean)"""
        return 'NavigableSet'.__wrap(super(__DescendingSet, self).tailSet(fromElement, __boolean.valueOf(inclusive)))

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.ForwardingList
import java.util.ListIterator as __ListIterator
__ListIterator = __ListIterator
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingList as __ForwardingList
__ForwardingList = __ForwardingList
from builtins import bool
from builtins import str
import java.util.function.UnaryOperator as UnaryOperator
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.util.List as __List
__List = __List
import java.lang.Long as __long
import java.util.ListIterator as ListIterator
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.util.List as List
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ForwardingList(ABC):
    """com.google.common.collect.ForwardingList"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingList) -> 'ForwardingList':
        return ForwardingList(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingList):
        """
        Dynamic initializer for ForwardingList.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @overload
    def remove(self, index: int) -> object:
        """public E com.google.common.collect.ForwardingList.remove(int)"""
        return object.__wrap(super(__ForwardingList, self).remove(__int.valueOf(index)))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def sort(self, arg0: 'Comparator'):
        """public default void java.util.List.sort(java.util.Comparator<? super E>)"""
        super(__List, self).sort(arg0)

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.List.addFirst(E)"""
        super(__List, self).addFirst(arg0)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def subList(self, fromIndex: int, toIndex: int) -> 'List':
        """public java.util.List<E> com.google.common.collect.ForwardingList.subList(int,int)"""
        return 'List'.__wrap(super(__ForwardingList, self).subList(__int.valueOf(fromIndex), __int.valueOf(toIndex)))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @override
    @overload
    def listIterator(self) -> 'ListIterator':
        """public java.util.ListIterator<E> com.google.common.collect.ForwardingList.listIterator()"""
        return 'ListIterator'.__wrap(super(ForwardingList, self).listIterator())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @overload
    def addAll(self, index: int, elements: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingList.addAll(int,java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingList, self).addAll(__int.valueOf(index), elements))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.List.getFirst()"""
        return object.__wrap(super(List, self).getFirst())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def replaceAll(self, arg0: 'UnaryOperator'):
        """public default void java.util.List.replaceAll(java.util.function.UnaryOperator<E>)"""
        super(__List, self).replaceAll(arg0)

    @overload
    def lastIndexOf(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingList.lastIndexOf(java.lang.Object)"""
        return int.__wrap(super(__ForwardingList, self).lastIndexOf(element))

    @overload
    def listIterator(self, index: int) -> 'ListIterator':
        """public java.util.ListIterator<E> com.google.common.collect.ForwardingList.listIterator(int)"""
        return 'ListIterator'.__wrap(super(__ForwardingList, self).listIterator(__int.valueOf(index)))

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.List.getLast()"""
        return object.__wrap(super(List, self).getLast())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.List.spliterator()"""
        return 'Spliterator'.__wrap(super(List, self).spliterator())

    @overload
    def indexOf(self, element: object) -> int:
        """public int com.google.common.collect.ForwardingList.indexOf(java.lang.Object)"""
        return int.__wrap(super(__ForwardingList, self).indexOf(element))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.List.removeFirst()"""
        return object.__wrap(super(List, self).removeFirst())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.List.removeLast()"""
        return object.__wrap(super(List, self).removeLast())

    @overload
    def get(self, index: int) -> object:
        """public E com.google.common.collect.ForwardingList.get(int)"""
        return object.__wrap(super(__ForwardingList, self).get(__int.valueOf(index)))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.List.addLast(E)"""
        super(__List, self).addLast(arg0)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def add(self, index: int, element: object):
        """public void com.google.common.collect.ForwardingList.add(int,E)"""
        super(__ForwardingList, self).add(__int.valueOf(index), element)

    @overload
    def set(self, index: int, element: object) -> object:
        """public E com.google.common.collect.ForwardingList.set(int,E)"""
        return object.__wrap(super(__ForwardingList, self).set(__int.valueOf(index), element))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingList.hashCode()"""
        return int.__wrap(super(ForwardingList, self).hashCode())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingList.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingList, self).equals(object))

    @override
    @overload
    def reversed(self) -> 'List':
        """public default java.util.List<E> java.util.List.reversed()"""
        return 'List'.__wrap(super(List, self).reversed())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMultiset$StandardElementSet
import com.google.common.collect.ForwardingSortedMultiset as __ForwardingSortedMultiset_StandardElementSet
__StandardElementSet = __ForwardingSortedMultiset_StandardElementSet.StandardElementSet
import java.util.function.Predicate as Predicate
import java.lang.Boolean as __boolean
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.Sets as __Sets_ImprovedAbstractSet
__ImprovedAbstractSet = __Sets_ImprovedAbstractSet.ImprovedAbstractSet
import com.google.common.collect.SortedMultisets as __SortedMultisets_ElementSet
__ElementSet = __SortedMultisets_ElementSet.ElementSet
import com.google.common.collect.Multisets as __Multisets_ElementSet
__ElementSet = __Multisets_ElementSet.ElementSet
import com.google.common.collect.SortedMultisets as __SortedMultisets_NavigableElementSet
__NavigableElementSet = __SortedMultisets_NavigableElementSet.NavigableElementSet
from builtins import bool
import java.util.AbstractSet as __AbstractSet
__AbstractSet = __AbstractSet
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.SortedSet as SortedSet
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class StandardElementSet():
    """com.google.common.collect.ForwardingSortedMultiset.StandardElementSet"""
 
    @staticmethod
    def __wrap(java_value: __StandardElementSet) -> 'StandardElementSet':
        return StandardElementSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardElementSet):
        """
        Dynamic initializer for StandardElementSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.SortedMultisets$ElementSet.last()"""
        return object.__wrap(super(ElementSet, self).last())

    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.pollFirst()"""
        return object.__wrap(super(NavigableElementSet, self).pollFirst())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.SortedMultisets$ElementSet.comparator()"""
        return 'Comparator'.__wrap(super(ElementSet, self).comparator())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool.__wrap(super(__AbstractCollection, self).add(arg0))

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.pollLast()"""
        return object.__wrap(super(NavigableElementSet, self).pollLast())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractCollection, self).addAll(arg0))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(__SortedSet, self).addLast(arg0)

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'.__wrap(super(NavigableSet, self).reversed())

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.SortedMultisets$ElementSet.headSet(E)"""
        return 'SortedSet'.__wrap(super(__ElementSet, self).headSet(toElement))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object.__wrap(super(SortedSet, self).getFirst())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object.__wrap(super(NavigableSet, self).removeFirst())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.contains(java.lang.Object)"""
        return bool.__wrap(super(__ElementSet, self).contains(o))

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.ceiling(E)"""
        return object.__wrap(super(__NavigableElementSet, self).ceiling(e))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(__SortedSet, self).addFirst(arg0)

    @override
    @overload
    def descendingSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.SortedMultisets$NavigableElementSet.descendingSet()"""
        return 'NavigableSet'.__wrap(super(NavigableElementSet, self).descendingSet())

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.SortedMultisets$ElementSet.tailSet(E)"""
        return 'SortedSet'.__wrap(super(__ElementSet, self).tailSet(fromElement))

    @overload
    def containsAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ElementSet, self).containsAll(c))

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.SortedMultisets$NavigableElementSet.subSet(E,boolean,E,boolean)"""
        return 'NavigableSet'.__wrap(super(__NavigableElementSet, self).subSet(fromElement, __boolean.valueOf(fromInclusive), toElement, __boolean.valueOf(toInclusive)))

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.higher(E)"""
        return object.__wrap(super(__NavigableElementSet, self).higher(e))

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.remove(java.lang.Object)"""
        return bool.__wrap(super(__ElementSet, self).remove(o))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.SortedMultisets$NavigableElementSet.descendingIterator()"""
        return 'Iterator'.__wrap(super(NavigableElementSet, self).descendingIterator())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.SortedMultisets$ElementSet.iterator()"""
        return 'Iterator'.__wrap(super(ElementSet, self).iterator())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Multisets$ElementSet.clear()"""
        super(ElementSet, self).clear()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'.__wrap(super(SortedSet, self).spliterator())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Multisets$ElementSet.size()"""
        return int.__wrap(super(ElementSet, self).size())

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.floor(E)"""
        return object.__wrap(super(__NavigableElementSet, self).floor(e))

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.SortedMultisets$ElementSet.first()"""
        return object.__wrap(super(ElementSet, self).first())

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object.__wrap(super(SortedSet, self).getLast())

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.SortedMultisets$ElementSet.subSet(E,E)"""
        return 'SortedSet'.__wrap(super(__ElementSet, self).subSet(fromElement, toElement))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Multisets$ElementSet.isEmpty()"""
        return bool.__wrap(super(ElementSet, self).isEmpty())

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.SortedMultisets$NavigableElementSet.lower(E)"""
        return object.__wrap(super(__NavigableElementSet, self).lower(e))

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.SortedMultisets$NavigableElementSet.tailSet(E,boolean)"""
        return 'NavigableSet'.__wrap(super(__NavigableElementSet, self).tailSet(fromElement, __boolean.valueOf(inclusive)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object.__wrap(super(NavigableSet, self).removeLast())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractSet, self).equals(arg0))

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.SortedMultisets$NavigableElementSet.headSet(E,boolean)"""
        return 'NavigableSet'.__wrap(super(__NavigableElementSet, self).headSet(toElement, __boolean.valueOf(inclusive)))

    @overload
    def __init__(self, this$0: 'ForwardingSortedMultiset'):
        """public com.google.common.collect.ForwardingSortedMultiset$StandardElementSet(com.google.common.collect.ForwardingSortedMultiset)"""
        val = __StandardElementSet(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int.__wrap(super(AbstractSet, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.LinkedListMultimap
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.List as __List
__List = __List
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.LinkedListMultimap as __LinkedListMultimap
__LinkedListMultimap = __LinkedListMultimap
import java.lang.Integer as __int
from builtins import bool
from builtins import int
import java.util.List as List
 
class LinkedListMultimap():
    """com.google.common.collect.LinkedListMultimap"""
 
    @staticmethod
    def __wrap(java_value: __LinkedListMultimap) -> 'LinkedListMultimap':
        return LinkedListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __LinkedListMultimap):
        """
        Dynamic initializer for LinkedListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'LinkedListMultimap':
        """public static <K,V> com.google.common.collect.LinkedListMultimap<K, V> com.google.common.collect.LinkedListMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return LinkedListMultimap.__wrap(__LinkedListMultimap.create(multimap))

    @staticmethod
    @overload
    def create(expectedKeys: int) -> 'LinkedListMultimap':
        """public static <K,V> com.google.common.collect.LinkedListMultimap<K, V> com.google.common.collect.LinkedListMultimap.create(int)"""
        return LinkedListMultimap.__wrap(__LinkedListMultimap.create(__int.valueOf(expectedKeys)))

    @overload
    def removeAll(self, key: object) -> 'List':
        """public java.util.List<V> com.google.common.collect.LinkedListMultimap.removeAll(java.lang.Object)"""
        return 'List'.__wrap(super(__LinkedListMultimap, self).removeAll(key))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.LinkedListMultimap.put(K,V)"""
        return bool.__wrap(super(__LinkedListMultimap, self).put(key, value))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def get(self, key: object) -> 'List':
        """public java.util.List<V> com.google.common.collect.LinkedListMultimap.get(K)"""
        return 'List'.__wrap(super(__LinkedListMultimap, self).get(key))

    @override
    @overload
    def entries(self) -> 'List':
        """public java.util.List<java.util.Map$Entry<K, V>> com.google.common.collect.LinkedListMultimap.entries()"""
        return 'List'.__wrap(super(LinkedListMultimap, self).entries())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.LinkedListMultimap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__LinkedListMultimap, self).containsValue(value))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.LinkedListMultimap.isEmpty()"""
        return bool.__wrap(super(LinkedListMultimap, self).isEmpty())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.LinkedListMultimap.size()"""
        return int.__wrap(super(LinkedListMultimap, self).size())

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @override
    @overload
    def values(self) -> 'List':
        """public java.util.List<V> com.google.common.collect.LinkedListMultimap.values()"""
        return 'List'.__wrap(super(LinkedListMultimap, self).values())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.LinkedListMultimap.clear()"""
        super(LinkedListMultimap, self).clear()

    @staticmethod
    @overload
    def create() -> 'LinkedListMultimap':
        """public static <K,V> com.google.common.collect.LinkedListMultimap<K, V> com.google.common.collect.LinkedListMultimap.create()"""
        return LinkedListMultimap.__wrap(__LinkedListMultimap.create())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.LinkedListMultimap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__LinkedListMultimap, self).containsKey(key))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'List':
        """public java.util.List<V> com.google.common.collect.LinkedListMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'List'.__wrap(super(__LinkedListMultimap, self).replaceValues(key, values)) 
 
 
# CLASS: com.google.common.collect.SetMultimap
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from pyquantum_helper import override
import java.util.function.BiConsumer as BiConsumer
import java.lang.Iterable as Iterable
import com.google.common.collect.SetMultimap as __SetMultimap
__SetMultimap = __SetMultimap
from abc import abstractmethod, ABC
 
class SetMultimap(ABC):
    """com.google.common.collect.SetMultimap"""
 
    @staticmethod
    def __wrap(java_value: __SetMultimap) -> 'SetMultimap':
        return SetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __SetMultimap):
        """
        Dynamic initializer for SetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def keys(self, ):
        """public abstract com.google.common.collect.Multiset<K> com.google.common.collect.Multimap.keys()"""
        pass

    @abstractmethod
    def asMap(self, ):
        """public abstract java.util.Map<K, java.util.Collection<V>> com.google.common.collect.SetMultimap.asMap()"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Multimap.isEmpty()"""
        pass

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> com.google.common.collect.Multimap.keySet()"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.put(K,V)"""
        pass

    @abstractmethod
    def containsEntry(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def remove(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def containsKey(self, key: object):
        """public abstract boolean com.google.common.collect.Multimap.containsKey(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.values()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multimap.hashCode()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.SetMultimap.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def putAll(self, key: object, values: 'Iterable'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def entries(self, ):
        """public abstract java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.SetMultimap.entries()"""
        pass

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Multimap.clear()"""
        pass

    @abstractmethod
    def replaceValues(self, key: object, values: 'Iterable'):
        """public abstract java.util.Set<V> com.google.common.collect.SetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def get(self, key: object):
        """public abstract java.util.Set<V> com.google.common.collect.SetMultimap.get(K)"""
        pass

    @abstractmethod
    def removeAll(self, key: object):
        """public abstract java.util.Set<V> com.google.common.collect.SetMultimap.removeAll(java.lang.Object)"""
        pass

    @abstractmethod
    def putAll(self, multimap: 'Multimap'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multimap.size()"""
        pass 
 
 
# CLASS: com.google.common.collect.Multimap
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
import java.util.function.BiConsumer as BiConsumer
import java.lang.Iterable as Iterable
from abc import abstractmethod, ABC
 
class Multimap(ABC):
    """com.google.common.collect.Multimap"""
 
    @staticmethod
    def __wrap(java_value: __Multimap) -> 'Multimap':
        return Multimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Multimap):
        """
        Dynamic initializer for Multimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def keys(self, ):
        """public abstract com.google.common.collect.Multiset<K> com.google.common.collect.Multimap.keys()"""
        pass

    @abstractmethod
    def equals(self, obj: object):
        """public abstract boolean com.google.common.collect.Multimap.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def replaceValues(self, key: object, values: 'Iterable'):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def isEmpty(self, ):
        """public abstract boolean com.google.common.collect.Multimap.isEmpty()"""
        pass

    @abstractmethod
    def asMap(self, ):
        """public abstract java.util.Map<K, java.util.Collection<V>> com.google.common.collect.Multimap.asMap()"""
        pass

    @abstractmethod
    def removeAll(self, key: object):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.removeAll(java.lang.Object)"""
        pass

    @abstractmethod
    def keySet(self, ):
        """public abstract java.util.Set<K> com.google.common.collect.Multimap.keySet()"""
        pass

    @abstractmethod
    def put(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.put(K,V)"""
        pass

    @abstractmethod
    def entries(self, ):
        """public abstract java.util.Collection<java.util.Map$Entry<K, V>> com.google.common.collect.Multimap.entries()"""
        pass

    @abstractmethod
    def containsEntry(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsEntry(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def remove(self, key: object, value: object):
        """public abstract boolean com.google.common.collect.Multimap.remove(java.lang.Object,java.lang.Object)"""
        pass

    @abstractmethod
    def containsKey(self, key: object):
        """public abstract boolean com.google.common.collect.Multimap.containsKey(java.lang.Object)"""
        pass

    @abstractmethod
    def containsValue(self, value: object):
        """public abstract boolean com.google.common.collect.Multimap.containsValue(java.lang.Object)"""
        pass

    @abstractmethod
    def values(self, ):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.values()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multimap.hashCode()"""
        pass

    @abstractmethod
    def putAll(self, key: object, values: 'Iterable'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(K,java.lang.Iterable<? extends V>)"""
        pass

    @abstractmethod
    def get(self, key: object):
        """public abstract java.util.Collection<V> com.google.common.collect.Multimap.get(K)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.Multimap.clear()"""
        pass

    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @abstractmethod
    def putAll(self, multimap: 'Multimap'):
        """public abstract boolean com.google.common.collect.Multimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        pass

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Multimap.size()"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingListIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
from builtins import type
from builtins import object
import com.google.common.collect.ForwardingListIterator as __ForwardingListIterator
__ForwardingListIterator = __ForwardingListIterator
import java.util.function.Consumer as Consumer
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ForwardingIterator as __ForwardingIterator
__ForwardingIterator = __ForwardingIterator
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ForwardingListIterator(ABC):
    """com.google.common.collect.ForwardingListIterator"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingListIterator) -> 'ForwardingListIterator':
        return ForwardingListIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingListIterator):
        """
        Dynamic initializer for ForwardingListIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def hasNext(self) -> bool:
        """public boolean com.google.common.collect.ForwardingIterator.hasNext()"""
        return bool.__wrap(super(ForwardingIterator, self).hasNext())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def set(self, element: object):
        """public void com.google.common.collect.ForwardingListIterator.set(E)"""
        super(__ForwardingListIterator, self).set(element)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hasPrevious(self) -> bool:
        """public boolean com.google.common.collect.ForwardingListIterator.hasPrevious()"""
        return bool.__wrap(super(ForwardingListIterator, self).hasPrevious())

    @override
    @overload
    def previous(self) -> object:
        """public E com.google.common.collect.ForwardingListIterator.previous()"""
        return object.__wrap(super(ForwardingListIterator, self).previous())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def nextIndex(self) -> int:
        """public int com.google.common.collect.ForwardingListIterator.nextIndex()"""
        return int.__wrap(super(ForwardingListIterator, self).nextIndex())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def next(self) -> object:
        """public T com.google.common.collect.ForwardingIterator.next()"""
        return object.__wrap(super(ForwardingIterator, self).next())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def previousIndex(self) -> int:
        """public int com.google.common.collect.ForwardingListIterator.previousIndex()"""
        return int.__wrap(super(ForwardingListIterator, self).previousIndex())

    @override
    @overload
    def add(self, element: object):
        """public void com.google.common.collect.ForwardingListIterator.add(E)"""
        super(__ForwardingListIterator, self).add(element)

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(__Iterator, self).forEachRemaining(arg0)

    @override
    @overload
    def remove(self):
        """public void com.google.common.collect.ForwardingIterator.remove()"""
        super(ForwardingIterator, self).remove()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ForwardingListMultimap
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from builtins import type
import com.google.common.collect.ForwardingMultimap as __ForwardingMultimap
__ForwardingMultimap = __ForwardingMultimap
import java.util.Map as __Map
__Map = __Map
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Set as __Set
__Set = __Set
import java.lang.Iterable as Iterable
import com.google.common.collect.ForwardingListMultimap as __ForwardingListMultimap
__ForwardingListMultimap = __ForwardingListMultimap
import java.util.List as __List
__List = __List
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.Map as Map
import java.util.List as List
from builtins import int
 
class ForwardingListMultimap(ABC):
    """com.google.common.collect.ForwardingListMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingListMultimap) -> 'ForwardingListMultimap':
        return ForwardingListMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingListMultimap):
        """
        Dynamic initializer for ForwardingListMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool.__wrap(super(__ForwardingMultimap, self).putAll(multimap))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.hashCode()"""
        return int.__wrap(super(ForwardingMultimap, self).hashCode())

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsKey(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsValue(value))

    @overload
    def containsEntry(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsEntry(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsEntry(key, value))

    @override
    @overload
    def asMap(self) -> 'Map':
        """public java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ForwardingMultimap.asMap()"""
        return 'Map'.__wrap(super(ForwardingMultimap, self).asMap())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMultimap.clear()"""
        super(ForwardingMultimap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).remove(key, value))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.size()"""
        return int.__wrap(super(ForwardingMultimap, self).size())

    @override
    @overload
    def entries(self) -> 'Collection':
        """public java.util.Collection<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMultimap.entries()"""
        return 'Collection'.__wrap(super(ForwardingMultimap, self).entries())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).equals(object))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.put(K,V)"""
        return bool.__wrap(super(__ForwardingMultimap, self).put(key, value))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.values()"""
        return 'Collection'.__wrap(super(ForwardingMultimap, self).values())

    @overload
    def get(self, key: object) -> 'List':
        """public java.util.List<V> com.google.common.collect.ForwardingListMultimap.get(K)"""
        return 'List'.__wrap(super(__ForwardingListMultimap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMultimap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMultimap, self).keySet())

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'List':
        """public java.util.List<V> com.google.common.collect.ForwardingListMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'List'.__wrap(super(__ForwardingListMultimap, self).replaceValues(key, values))

    @override
    @overload
    def keys(self) -> 'Multiset':
        """public com.google.common.collect.Multiset<K> com.google.common.collect.ForwardingMultimap.keys()"""
        return 'Multiset'.__wrap(super(ForwardingMultimap, self).keys())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool.__wrap(super(__ForwardingMultimap, self).putAll(key, values))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.isEmpty()"""
        return bool.__wrap(super(ForwardingMultimap, self).isEmpty())

    @overload
    def removeAll(self, key: object) -> 'List':
        """public java.util.List<V> com.google.common.collect.ForwardingListMultimap.removeAll(java.lang.Object)"""
        return 'List'.__wrap(super(__ForwardingListMultimap, self).removeAll(key))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.UnmodifiableListIterator
import java.util.ListIterator as __ListIterator
__ListIterator = __ListIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
from builtins import type
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.UnmodifiableListIterator as __UnmodifiableListIterator
__UnmodifiableListIterator = __UnmodifiableListIterator
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import com.google.common.collect.UnmodifiableIterator as __UnmodifiableIterator
__UnmodifiableIterator = __UnmodifiableIterator
from builtins import int
 
class UnmodifiableListIterator(ABC):
    """com.google.common.collect.UnmodifiableListIterator"""
 
    @staticmethod
    def __wrap(java_value: __UnmodifiableListIterator) -> 'UnmodifiableListIterator':
        return UnmodifiableListIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __UnmodifiableListIterator):
        """
        Dynamic initializer for UnmodifiableListIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @abstractmethod
    def nextIndex(self, ):
        """public abstract int java.util.ListIterator.nextIndex()"""
        pass

    @abstractmethod
    def previousIndex(self, ):
        """public abstract int java.util.ListIterator.previousIndex()"""
        pass

    @abstractmethod
    def previous(self, ):
        """public abstract E java.util.ListIterator.previous()"""
        pass

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @abstractmethod
    def next(self, ):
        """public abstract E java.util.ListIterator.next()"""
        pass

    @override
    @overload
    def set(self, e: object):
        """public final void com.google.common.collect.UnmodifiableListIterator.set(E)"""
        super(__UnmodifiableListIterator, self).set(e)

    @override
    @overload
    def remove(self):
        """public final void com.google.common.collect.UnmodifiableIterator.remove()"""
        super(UnmodifiableIterator, self).remove()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @abstractmethod
    def hasPrevious(self, ):
        """public abstract boolean java.util.ListIterator.hasPrevious()"""
        pass

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @abstractmethod
    def hasNext(self, ):
        """public abstract boolean java.util.ListIterator.hasNext()"""
        pass

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def add(self, e: object):
        """public final void com.google.common.collect.UnmodifiableListIterator.add(E)"""
        super(__UnmodifiableListIterator, self).add(e)

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(__Iterator, self).forEachRemaining(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.PeekingIterator
from pyquantum_helper import override
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import com.google.common.collect.PeekingIterator as __PeekingIterator
__PeekingIterator = __PeekingIterator
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
 
class PeekingIterator(ABC):
    """com.google.common.collect.PeekingIterator"""
 
    @staticmethod
    def __wrap(java_value: __PeekingIterator) -> 'PeekingIterator':
        return PeekingIterator(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __PeekingIterator):
        """
        Dynamic initializer for PeekingIterator.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def next(self, ):
        """public abstract E com.google.common.collect.PeekingIterator.next()"""
        pass

    @override
    @overload
    def forEachRemaining(self, arg0: 'Consumer'):
        """public default void java.util.Iterator.forEachRemaining(java.util.function.Consumer<? super E>)"""
        super(__Iterator, self).forEachRemaining(arg0)

    @abstractmethod
    def peek(self, ):
        """public abstract E com.google.common.collect.PeekingIterator.peek()"""
        pass

    @abstractmethod
    def remove(self, ):
        """public abstract void com.google.common.collect.PeekingIterator.remove()"""
        pass

    @abstractmethod
    def hasNext(self, ):
        """public abstract boolean java.util.Iterator.hasNext()"""
        pass 
 
 
# CLASS: com.google.common.collect.Multimaps
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

import java.util.function.Supplier as Supplier
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.Map as __Map
__Map = __Map
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableListMultimap as __ImmutableListMultimap
__ImmutableListMultimap = __ImmutableListMultimap
import com.google.common.collect.SortedSetMultimap as __SortedSetMultimap
__SortedSetMultimap = __SortedSetMultimap
import com.google.common.collect.SetMultimap as __SetMultimap
__SetMultimap = __SetMultimap
from builtins import bool
import com.google.common.collect.ListMultimap as __ListMultimap
__ListMultimap = __ListMultimap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.lang.Iterable as Iterable
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
import java.lang.Long as __long
import com.google.common.collect.Multimaps as __Multimaps
__Multimaps = __Multimaps
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.function.Function as Function
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import int
 
class Multimaps():
    """com.google.common.collect.Multimaps"""
 
    @staticmethod
    def __wrap(java_value: __Multimaps) -> 'Multimaps':
        return Multimaps(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Multimaps):
        """
        Dynamic initializer for Multimaps.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def synchronizedListMultimap(multimap: 'ListMultimap') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.synchronizedListMultimap(com.google.common.collect.ListMultimap<K, V>)"""
        return ListMultimap.__wrap(__Multimaps.synchronizedListMultimap(multimap))

    @staticmethod
    @overload
    def index(values: 'Iterable', keyFunction: 'Function') -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.Multimaps.index(java.lang.Iterable<V>,com.google.common.base.Function<? super V, K>)"""
        return ImmutableListMultimap.__wrap(__Multimaps.index(values, keyFunction))

    @staticmethod
    @overload
    def synchronizedSetMultimap(multimap: 'SetMultimap') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.synchronizedSetMultimap(com.google.common.collect.SetMultimap<K, V>)"""
        return SetMultimap.__wrap(__Multimaps.synchronizedSetMultimap(multimap))

    @staticmethod
    @overload
    def asMap(multimap: 'SetMultimap') -> 'Map':
        """public static <K,V> java.util.Map<K, java.util.Set<V>> com.google.common.collect.Multimaps.asMap(com.google.common.collect.SetMultimap<K, V>)"""
        return Map.__wrap(__Multimaps.asMap(multimap))

    @staticmethod
    @overload
    def newListMultimap(map: 'Map', factory: 'Supplier') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.newListMultimap(java.util.Map<K, java.util.Collection<V>>,com.google.common.base.Supplier<? extends java.util.List<V>>)"""
        return ListMultimap.__wrap(__Multimaps.newListMultimap(map, factory))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def toMultimap(keyFunction: 'Function', valueFunction: 'Function', multimapSupplier: 'Supplier') -> 'Collector':
        """public static <T,K,V,M extends com.google.common.collect.Multimap<K, V>> java.util.stream.Collector<T, ?, M> com.google.common.collect.Multimaps.toMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.Supplier<M>)"""
        return Collector.__wrap(__Multimaps.toMultimap(keyFunction, valueFunction, multimapSupplier))

    @staticmethod
    @overload
    def transformValues(fromMultimap: 'Multimap', function: 'Function') -> 'Multimap':
        """public static <K,V1,V2> com.google.common.collect.Multimap<K, V2> com.google.common.collect.Multimaps.transformValues(com.google.common.collect.Multimap<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return Multimap.__wrap(__Multimaps.transformValues(fromMultimap, function))

    @staticmethod
    @overload
    def synchronizedSortedSetMultimap(multimap: 'SortedSetMultimap') -> 'SortedSetMultimap':
        """public static <K,V> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.Multimaps.synchronizedSortedSetMultimap(com.google.common.collect.SortedSetMultimap<K, V>)"""
        return SortedSetMultimap.__wrap(__Multimaps.synchronizedSortedSetMultimap(multimap))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'Multimap', transformer: 'EntryTransformer') -> 'Multimap':
        """public static <K,V1,V2> com.google.common.collect.Multimap<K, V2> com.google.common.collect.Multimaps.transformEntries(com.google.common.collect.Multimap<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return Multimap.__wrap(__Multimaps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def flatteningToMultimap(keyFunction: 'Function', valueFunction: 'Function', multimapSupplier: 'Supplier') -> 'Collector':
        """public static <T,K,V,M extends com.google.common.collect.Multimap<K, V>> java.util.stream.Collector<T, ?, M> com.google.common.collect.Multimaps.flatteningToMultimap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends java.util.stream.Stream<? extends V>>,java.util.function.Supplier<M>)"""
        return Collector.__wrap(__Multimaps.flatteningToMultimap(keyFunction, valueFunction, multimapSupplier))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'Multimap', entryPredicate: 'Predicate') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.filterEntries(com.google.common.collect.Multimap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return Multimap.__wrap(__Multimaps.filterEntries(unfiltered, entryPredicate))

    @staticmethod
    @overload
    def synchronizedMultimap(multimap: 'Multimap') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.synchronizedMultimap(com.google.common.collect.Multimap<K, V>)"""
        return Multimap.__wrap(__Multimaps.synchronizedMultimap(multimap))

    @staticmethod
    @overload
    def asMap(multimap: 'ListMultimap') -> 'Map':
        """public static <K,V> java.util.Map<K, java.util.List<V>> com.google.common.collect.Multimaps.asMap(com.google.common.collect.ListMultimap<K, V>)"""
        return Map.__wrap(__Multimaps.asMap(multimap))

    @staticmethod
    @overload
    def transformValues(fromMultimap: 'ListMultimap', function: 'Function') -> 'ListMultimap':
        """public static <K,V1,V2> com.google.common.collect.ListMultimap<K, V2> com.google.common.collect.Multimaps.transformValues(com.google.common.collect.ListMultimap<K, V1>,com.google.common.base.Function<? super V1, V2>)"""
        return ListMultimap.__wrap(__Multimaps.transformValues(fromMultimap, function))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def newSetMultimap(map: 'Map', factory: 'Supplier') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.newSetMultimap(java.util.Map<K, java.util.Collection<V>>,com.google.common.base.Supplier<? extends java.util.Set<V>>)"""
        return SetMultimap.__wrap(__Multimaps.newSetMultimap(map, factory))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def forMap(map: 'Map') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.forMap(java.util.Map<K, V>)"""
        return SetMultimap.__wrap(__Multimaps.forMap(map))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'ListMultimap', keyPredicate: 'Predicate') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.filterKeys(com.google.common.collect.ListMultimap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return ListMultimap.__wrap(__Multimaps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def unmodifiableSetMultimap(delegate: 'SetMultimap') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableSetMultimap(com.google.common.collect.SetMultimap<K, V>)"""
        return SetMultimap.__wrap(__Multimaps.unmodifiableSetMultimap(delegate))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'SetMultimap', keyPredicate: 'Predicate') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.filterKeys(com.google.common.collect.SetMultimap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return SetMultimap.__wrap(__Multimaps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def transformEntries(fromMap: 'ListMultimap', transformer: 'EntryTransformer') -> 'ListMultimap':
        """public static <K,V1,V2> com.google.common.collect.ListMultimap<K, V2> com.google.common.collect.Multimaps.transformEntries(com.google.common.collect.ListMultimap<K, V1>,com.google.common.collect.Maps$EntryTransformer<? super K, ? super V1, V2>)"""
        return ListMultimap.__wrap(__Multimaps.transformEntries(fromMap, transformer))

    @staticmethod
    @overload
    def newMultimap(map: 'Map', factory: 'Supplier') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.newMultimap(java.util.Map<K, java.util.Collection<V>>,com.google.common.base.Supplier<? extends java.util.Collection<V>>)"""
        return Multimap.__wrap(__Multimaps.newMultimap(map, factory))

    @staticmethod
    @overload
    def unmodifiableMultimap(delegate: 'ImmutableMultimap') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.unmodifiableMultimap(com.google.common.collect.ImmutableMultimap<K, V>)"""
        return Multimap.__wrap(__Multimaps.unmodifiableMultimap(delegate))

    @staticmethod
    @overload
    def unmodifiableListMultimap(delegate: 'ListMultimap') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableListMultimap(com.google.common.collect.ListMultimap<K, V>)"""
        return ListMultimap.__wrap(__Multimaps.unmodifiableListMultimap(delegate))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def newSortedSetMultimap(map: 'Map', factory: 'Supplier') -> 'SortedSetMultimap':
        """public static <K,V> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.Multimaps.newSortedSetMultimap(java.util.Map<K, java.util.Collection<V>>,com.google.common.base.Supplier<? extends java.util.SortedSet<V>>)"""
        return SortedSetMultimap.__wrap(__Multimaps.newSortedSetMultimap(map, factory))

    @staticmethod
    @overload
    def filterKeys(unfiltered: 'Multimap', keyPredicate: 'Predicate') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.filterKeys(com.google.common.collect.Multimap<K, V>,com.google.common.base.Predicate<? super K>)"""
        return Multimap.__wrap(__Multimaps.filterKeys(unfiltered, keyPredicate))

    @staticmethod
    @overload
    def invertFrom(source: 'Multimap', dest: 'Multimap') -> 'Multimap':
        """public static <K,V,M extends com.google.common.collect.Multimap<K, V>> M com.google.common.collect.Multimaps.invertFrom(com.google.common.collect.Multimap<? extends V, ? extends K>,M)"""
        return Multimap.__wrap(__Multimaps.invertFrom(source, dest))

    @staticmethod
    @overload
    def unmodifiableListMultimap(delegate: 'ImmutableListMultimap') -> 'ListMultimap':
        """public static <K,V> com.google.common.collect.ListMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableListMultimap(com.google.common.collect.ImmutableListMultimap<K, V>)"""
        return ListMultimap.__wrap(__Multimaps.unmodifiableListMultimap(delegate))

    @staticmethod
    @overload
    def filterEntries(unfiltered: 'SetMultimap', entryPredicate: 'Predicate') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.filterEntries(com.google.common.collect.SetMultimap<K, V>,com.google.common.base.Predicate<? super java.util.Map$Entry<K, V>>)"""
        return SetMultimap.__wrap(__Multimaps.filterEntries(unfiltered, entryPredicate))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def unmodifiableSetMultimap(delegate: 'ImmutableSetMultimap') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableSetMultimap(com.google.common.collect.ImmutableSetMultimap<K, V>)"""
        return SetMultimap.__wrap(__Multimaps.unmodifiableSetMultimap(delegate))

    @staticmethod
    @overload
    def asMap(multimap: 'Multimap') -> 'Map':
        """public static <K,V> java.util.Map<K, java.util.Collection<V>> com.google.common.collect.Multimaps.asMap(com.google.common.collect.Multimap<K, V>)"""
        return Map.__wrap(__Multimaps.asMap(multimap))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'Multimap', valuePredicate: 'Predicate') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.filterValues(com.google.common.collect.Multimap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return Multimap.__wrap(__Multimaps.filterValues(unfiltered, valuePredicate))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def unmodifiableMultimap(delegate: 'Multimap') -> 'Multimap':
        """public static <K,V> com.google.common.collect.Multimap<K, V> com.google.common.collect.Multimaps.unmodifiableMultimap(com.google.common.collect.Multimap<K, V>)"""
        return Multimap.__wrap(__Multimaps.unmodifiableMultimap(delegate))

    @staticmethod
    @overload
    def filterValues(unfiltered: 'SetMultimap', valuePredicate: 'Predicate') -> 'SetMultimap':
        """public static <K,V> com.google.common.collect.SetMultimap<K, V> com.google.common.collect.Multimaps.filterValues(com.google.common.collect.SetMultimap<K, V>,com.google.common.base.Predicate<? super V>)"""
        return SetMultimap.__wrap(__Multimaps.filterValues(unfiltered, valuePredicate))

    @staticmethod
    @overload
    def unmodifiableSortedSetMultimap(delegate: 'SortedSetMultimap') -> 'SortedSetMultimap':
        """public static <K,V> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.Multimaps.unmodifiableSortedSetMultimap(com.google.common.collect.SortedSetMultimap<K, V>)"""
        return SortedSetMultimap.__wrap(__Multimaps.unmodifiableSortedSetMultimap(delegate))

    @staticmethod
    @overload
    def asMap(multimap: 'SortedSetMultimap') -> 'Map':
        """public static <K,V> java.util.Map<K, java.util.SortedSet<V>> com.google.common.collect.Multimaps.asMap(com.google.common.collect.SortedSetMultimap<K, V>)"""
        return Map.__wrap(__Multimaps.asMap(multimap))

    @staticmethod
    @overload
    def index(values: 'Iterator', keyFunction: 'Function') -> 'ImmutableListMultimap':
        """public static <K,V> com.google.common.collect.ImmutableListMultimap<K, V> com.google.common.collect.Multimaps.index(java.util.Iterator<V>,com.google.common.base.Function<? super V, K>)"""
        return ImmutableListMultimap.__wrap(__Multimaps.index(values, keyFunction))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.ImmutableSortedSet$Builder
import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet
__ImmutableSortedSet = __ImmutableSortedSet
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet_Builder
__Builder = __ImmutableSortedSet_Builder.Builder
from builtins import object
import java.util.Iterator as Iterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableSortedSet.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def add(self, *elements: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet$Builder.add(E...)"""
        return 'Builder'.__wrap(super(__Builder, self).add(elements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def build(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet$Builder.build()"""
        return 'ImmutableSortedSet'.__wrap(super(Builder, self).build())

    @overload
    def addAll(self, elements: 'Iterator') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet$Builder.addAll(java.util.Iterator<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def __init__(self, comparator: 'Comparator'):
        """public com.google.common.collect.ImmutableSortedSet$Builder(java.util.Comparator<? super E>)"""
        val = __Builder(comparator)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def add(self, element: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet$Builder.add(E)"""
        return 'Builder'.__wrap(super(__Builder, self).add(element))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def addAll(self, elements: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet$Builder.addAll(java.lang.Iterable<? extends E>)"""
        return 'Builder'.__wrap(super(__Builder, self).addAll(elements))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.FluentIterable
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet
__ImmutableSortedSet = __ImmutableSortedSet
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.ImmutableMultiset as __ImmutableMultiset
__ImmutableMultiset = __ImmutableMultiset
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableListMultimap as __ImmutableListMultimap
__ImmutableListMultimap = __ImmutableListMultimap
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
from builtins import object
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import com.google.common.collect.FluentIterable as __FluentIterable
__FluentIterable = __FluentIterable
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
import com.google.common.base.Optional as __Optional
__Optional = __Optional
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class FluentIterable(ABC):
    """com.google.common.collect.FluentIterable"""
 
    @staticmethod
    def __wrap(java_value: __FluentIterable) -> 'FluentIterable':
        return FluentIterable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __FluentIterable):
        """
        Dynamic initializer for FluentIterable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def last(self) -> 'base.Optional':
        """public final com.google.common.base.Optional<E> com.google.common.collect.FluentIterable.last()"""
        return 'base.Optional'.__wrap(super(FluentIterable, self).last())

    @overload
    def toMultiset(self) -> 'ImmutableMultiset':
        """public final com.google.common.collect.ImmutableMultiset<E> com.google.common.collect.FluentIterable.toMultiset()"""
        return 'ImmutableMultiset'.__wrap(super(FluentIterable, self).toMultiset())

    @overload
    def contains(self, target: object) -> bool:
        """public final boolean com.google.common.collect.FluentIterable.contains(java.lang.Object)"""
        return bool.__wrap(super(__FluentIterable, self).contains(target))

    @overload
    def toMap(self, valueFunction: 'Function') -> 'ImmutableMap':
        """public final <V> com.google.common.collect.ImmutableMap<E, V> com.google.common.collect.FluentIterable.toMap(com.google.common.base.Function<? super E, V>)"""
        return 'ImmutableMap'.__wrap(super(__FluentIterable, self).toMap(valueFunction))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def anyMatch(self, predicate: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.FluentIterable.anyMatch(com.google.common.base.Predicate<? super E>)"""
        return bool.__wrap(super(__FluentIterable, self).anyMatch(predicate))

    @staticmethod
    @overload
    def from(iterable: 'FluentIterable') -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.from(com.google.common.collect.FluentIterable<E>)"""
        return FluentIterable.__wrap(__FluentIterable.from(iterable))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def size(self) -> int:
        """public final int com.google.common.collect.FluentIterable.size()"""
        return int.__wrap(super(FluentIterable, self).size())

    @overload
    def cycle(self) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.cycle()"""
        return 'FluentIterable'.__wrap(super(FluentIterable, self).cycle())

    @overload
    def uniqueIndex(self, keyFunction: 'Function') -> 'ImmutableMap':
        """public final <K> com.google.common.collect.ImmutableMap<K, E> com.google.common.collect.FluentIterable.uniqueIndex(com.google.common.base.Function<? super E, K>)"""
        return 'ImmutableMap'.__wrap(super(__FluentIterable, self).uniqueIndex(keyFunction))

    @overload
    def copyInto(self, collection: 'Collection') -> 'Collection':
        """public final <C extends java.util.Collection<? super E>> C com.google.common.collect.FluentIterable.copyInto(C)"""
        return 'Collection'.__wrap(super(__FluentIterable, self).copyInto(collection))

    @abstractmethod
    def iterator(self, ):
        """public abstract java.util.Iterator<T> java.lang.Iterable.iterator()"""
        pass

    @overload
    def index(self, keyFunction: 'Function') -> 'ImmutableListMultimap':
        """public final <K> com.google.common.collect.ImmutableListMultimap<K, E> com.google.common.collect.FluentIterable.index(com.google.common.base.Function<? super E, K>)"""
        return 'ImmutableListMultimap'.__wrap(super(__FluentIterable, self).index(keyFunction))

    @overload
    def filter(self, type: 'Class') -> 'FluentIterable':
        """public final <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.filter(java.lang.Class<T>)"""
        return 'FluentIterable'.__wrap(super(__FluentIterable, self).filter(type))

    @staticmethod
    @overload
    def concat(*inputs: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends T>...)"""
        return FluentIterable.__wrap(__FluentIterable.concat(inputs))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def stream(self) -> 'Stream':
        """public final java.util.stream.Stream<E> com.google.common.collect.FluentIterable.stream()"""
        return 'Stream'.__wrap(super(FluentIterable, self).stream())

    @overload
    def skip(self, numberToSkip: int) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.skip(int)"""
        return 'FluentIterable'.__wrap(super(__FluentIterable, self).skip(__int.valueOf(numberToSkip)))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable', c: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return FluentIterable.__wrap(__FluentIterable.concat(a, b, c))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return FluentIterable.__wrap(__FluentIterable.concat(a, b))

    @overload
    def allMatch(self, predicate: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.FluentIterable.allMatch(com.google.common.base.Predicate<? super E>)"""
        return bool.__wrap(super(__FluentIterable, self).allMatch(predicate))

    @staticmethod
    @overload
    def from(iterable: 'Iterable') -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.from(java.lang.Iterable<E>)"""
        return FluentIterable.__wrap(__FluentIterable.from(iterable))

    @overload
    def isEmpty(self) -> bool:
        """public final boolean com.google.common.collect.FluentIterable.isEmpty()"""
        return bool.__wrap(super(FluentIterable, self).isEmpty())

    @overload
    def limit(self, maxSize: int) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.limit(int)"""
        return 'FluentIterable'.__wrap(super(__FluentIterable, self).limit(__int.valueOf(maxSize)))

    @overload
    def toSortedList(self, comparator: 'Comparator') -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<E> com.google.common.collect.FluentIterable.toSortedList(java.util.Comparator<? super E>)"""
        return 'ImmutableList'.__wrap(super(__FluentIterable, self).toSortedList(comparator))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable', c: 'Iterable', d: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return FluentIterable.__wrap(__FluentIterable.concat(a, b, c, d))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<T> java.lang.Iterable.spliterator()"""
        return 'Spliterator'.__wrap(super(Iterable, self).spliterator())

    @overload
    def toArray(self, type: 'Class') -> List[object]:
        """public final E[] com.google.common.collect.FluentIterable.toArray(java.lang.Class<E>)"""
        return List[object].__wrap(super(__FluentIterable, self).toArray(type))

    @overload
    def append(self, *elements: object) -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.append(E...)"""
        return 'FluentIterable'.__wrap(super(__FluentIterable, self).append(elements))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def filter(self, predicate: 'Predicate') -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.filter(com.google.common.base.Predicate<? super E>)"""
        return 'FluentIterable'.__wrap(super(__FluentIterable, self).filter(predicate))

    @overload
    def first(self) -> 'base.Optional':
        """public final com.google.common.base.Optional<E> com.google.common.collect.FluentIterable.first()"""
        return 'base.Optional'.__wrap(super(FluentIterable, self).first())

    @overload
    def join(self, joiner: 'Joiner') -> str:
        """public final java.lang.String com.google.common.collect.FluentIterable.join(com.google.common.base.Joiner)"""
        return str.__wrap(super(__FluentIterable, self).join(joiner))

    @overload
    def firstMatch(self, predicate: 'Predicate') -> 'base.Optional':
        """public final com.google.common.base.Optional<E> com.google.common.collect.FluentIterable.firstMatch(com.google.common.base.Predicate<? super E>)"""
        return 'base.Optional'.__wrap(super(__FluentIterable, self).firstMatch(predicate))

    @staticmethod
    @overload
    def of(element: object, *elements: object) -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.of(E,E...)"""
        return FluentIterable.__wrap(__FluentIterable.of(element, elements))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def toList(self) -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<E> com.google.common.collect.FluentIterable.toList()"""
        return 'ImmutableList'.__wrap(super(FluentIterable, self).toList())

    @overload
    def transformAndConcat(self, function: 'Function') -> 'FluentIterable':
        """public <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.transformAndConcat(com.google.common.base.Function<? super E, ? extends java.lang.Iterable<? extends T>>)"""
        return 'FluentIterable'.__wrap(super(__FluentIterable, self).transformAndConcat(function))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def toSet(self) -> 'ImmutableSet':
        """public final com.google.common.collect.ImmutableSet<E> com.google.common.collect.FluentIterable.toSet()"""
        return 'ImmutableSet'.__wrap(super(FluentIterable, self).toSet())

    @staticmethod
    @overload
    def from(elements: 'Object') -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.from(E[])"""
        return FluentIterable.__wrap(__FluentIterable.from(elements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.FluentIterable.toString()"""
        return str.__wrap(super(FluentIterable, self).toString())

    @overload
    def append(self, other: 'Iterable') -> 'FluentIterable':
        """public final com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.append(java.lang.Iterable<? extends E>)"""
        return 'FluentIterable'.__wrap(super(__FluentIterable, self).append(other))

    @overload
    def transform(self, function: 'Function') -> 'FluentIterable':
        """public final <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.transform(com.google.common.base.Function<? super E, T>)"""
        return 'FluentIterable'.__wrap(super(__FluentIterable, self).transform(function))

    @staticmethod
    @overload
    def concat(inputs: 'Iterable') -> 'FluentIterable':
        """public static <T> com.google.common.collect.FluentIterable<T> com.google.common.collect.FluentIterable.concat(java.lang.Iterable<? extends java.lang.Iterable<? extends T>>)"""
        return FluentIterable.__wrap(__FluentIterable.concat(inputs))

    @overload
    def toSortedSet(self, comparator: 'Comparator') -> 'ImmutableSortedSet':
        """public final com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.FluentIterable.toSortedSet(java.util.Comparator<? super E>)"""
        return 'ImmutableSortedSet'.__wrap(super(__FluentIterable, self).toSortedSet(comparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def get(self, position: int) -> object:
        """public final E com.google.common.collect.FluentIterable.get(int)"""
        return object.__wrap(super(__FluentIterable, self).get(__int.valueOf(position)))

    @staticmethod
    @overload
    def of() -> 'FluentIterable':
        """public static <E> com.google.common.collect.FluentIterable<E> com.google.common.collect.FluentIterable.of()"""
        return FluentIterable.__wrap(__FluentIterable.of()) 
 
 
# CLASS: com.google.common.collect.BoundType
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import com.google.common.collect.BoundType as __BoundType
__BoundType = __BoundType
from builtins import type
import java.util.Optional as __Optional
__Optional = __Optional
from typing import List
import java.lang.Enum as Enum
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __string
import java.lang.String as __String
__String = __String
import java.util.Optional as Optional
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.lang.Enum as __Enum
__Enum = __Enum
from builtins import bool
from builtins import int
 
class BoundType():
    """com.google.common.collect.BoundType"""
 
    @staticmethod
    def __wrap(java_value: __BoundType) -> 'BoundType':
        return BoundType(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __BoundType):
        """
        Dynamic initializer for BoundType.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def valueOf(name: str) -> 'BoundType':
        """public static com.google.common.collect.BoundType com.google.common.collect.BoundType.valueOf(java.lang.String)"""
        return BoundType.__wrap(__BoundType.valueOf(name))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def valueOf(arg0: 'Class', arg1: str) -> 'Enum':
        """public static <T extends java.lang.Enum<T>> T java.lang.Enum.valueOf(java.lang.Class<T>,java.lang.String)"""
        return Enum.__wrap(__Enum.valueOf(arg0, arg1))

    @override
    @overload
    def name(self) -> str:
        """public final java.lang.String java.lang.Enum.name()"""
        return str.__wrap(super(Enum, self).name())

    @override
    @overload
    def hashCode(self) -> int:
        """public final int java.lang.Enum.hashCode()"""
        return int.__wrap(super(Enum, self).hashCode())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def describeConstable(self) -> 'Optional':
        """public final java.util.Optional<java.lang.Enum$EnumDesc<E>> java.lang.Enum.describeConstable()"""
        return 'Optional'.__wrap(super(Enum, self).describeConstable())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def compareTo(self, arg0: 'Enum') -> int:
        """public final int java.lang.Enum.compareTo(E)"""
        return int.__wrap(super(__Enum, self).compareTo(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, arg0: object) -> bool:
        """public final boolean java.lang.Enum.equals(java.lang.Object)"""
        return bool.__wrap(super(__Enum, self).equals(arg0))

    @override
    @overload
    def getDeclaringClass(self) -> 'type.Class':
        """public final java.lang.Class<E> java.lang.Enum.getDeclaringClass()"""
        return 'type.Class'.__wrap(super(Enum, self).getDeclaringClass())

    @override
    @overload
    def ordinal(self) -> int:
        """public final int java.lang.Enum.ordinal()"""
        return int.__wrap(super(Enum, self).ordinal())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Enum.toString()"""
        return str.__wrap(super(Enum, self).toString())

    @staticmethod
    @overload
    def values() -> List['BoundType']:
        """public static com.google.common.collect.BoundType[] com.google.common.collect.BoundType.values()"""
        return List[BoundType].__wrap(__BoundType.values()) 
 
 
# CLASS: com.google.common.collect.ForwardingSortedMap
from builtins import type
import java.util.Map as __Map_Entry
__Entry = __Map_Entry.Entry
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
import java.util.Collection as Collection
import java.util.SequencedCollection as SequencedCollection
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Map.Entry as Entry
import java.lang.Class as __Class
__Class = __Class
import java.util.SortedMap as SortedMap
import java.util.SequencedCollection as __SequencedCollection
__SequencedCollection = __SequencedCollection
import java.util.SequencedSet as SequencedSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.SortedMap as __SortedMap
__SortedMap = __SortedMap
import com.google.common.collect.ForwardingSortedMap as __ForwardingSortedMap
__ForwardingSortedMap = __ForwardingSortedMap
import java.util.Set as __Set
__Set = __Set
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.util.SequencedMap as __SequencedMap
__SequencedMap = __SequencedMap
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.SequencedSet as __SequencedSet
__SequencedSet = __SequencedSet
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import int
 
class ForwardingSortedMap(ABC):
    """com.google.common.collect.ForwardingSortedMap"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingSortedMap) -> 'ForwardingSortedMap':
        return ForwardingSortedMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingSortedMap):
        """
        Dynamic initializer for ForwardingSortedMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry.Map$Entry':
        """public default java.util.Map$Entry<K, V> java.util.SequencedMap.pollFirstEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(SequencedMap, self).pollFirstEntry())

    @override
    @overload
    def lastEntry(self) -> 'Entry.Map$Entry':
        """public default java.util.Map$Entry<K, V> java.util.SequencedMap.lastEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(SequencedMap, self).lastEntry())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.ForwardingSortedMap.comparator()"""
        return 'Comparator'.__wrap(super(ForwardingSortedMap, self).comparator())

    @overload
    def remove(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).remove(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def sequencedEntrySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<java.util.Map$Entry<K, V>> java.util.SequencedMap.sequencedEntrySet()"""
        return 'SequencedSet'.__wrap(super(SequencedMap, self).sequencedEntrySet())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMap.clear()"""
        super(ForwardingMap, self).clear()

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @override
    @overload
    def reversed(self) -> 'SortedMap':
        """public default java.util.SortedMap<K, V> java.util.SortedMap.reversed()"""
        return 'SortedMap'.__wrap(super(SortedMap, self).reversed())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @overload
    def putFirst(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putFirst(K,V)"""
        return object.__wrap(super(__SortedMap, self).putFirst(arg0, arg1))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def entrySet(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingMap.entrySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).entrySet())

    @override
    @overload
    def lastKey(self) -> object:
        """public K com.google.common.collect.ForwardingSortedMap.lastKey()"""
        return object.__wrap(super(ForwardingSortedMap, self).lastKey())

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @override
    @overload
    def firstEntry(self) -> 'Entry.Map$Entry':
        """public default java.util.Map$Entry<K, V> java.util.SequencedMap.firstEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(SequencedMap, self).firstEntry())

    @overload
    def put(self, key: object, value: object) -> object:
        """public V com.google.common.collect.ForwardingMap.put(K,V)"""
        return object.__wrap(super(__ForwardingMap, self).put(key, value))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @override
    @overload
    def sequencedKeySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<K> java.util.SequencedMap.sequencedKeySet()"""
        return 'SequencedSet'.__wrap(super(SequencedMap, self).sequencedKeySet())

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public void com.google.common.collect.ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ForwardingMap, self).putAll(map)

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @override
    @overload
    def firstKey(self) -> object:
        """public K com.google.common.collect.ForwardingSortedMap.firstKey()"""
        return object.__wrap(super(ForwardingSortedMap, self).firstKey())

    @override
    @overload
    def pollLastEntry(self) -> 'Entry.Map$Entry':
        """public default java.util.Map$Entry<K, V> java.util.SequencedMap.pollLastEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(SequencedMap, self).pollLastEntry())

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def sequencedValues(self) -> 'SequencedCollection':
        """public default java.util.SequencedCollection<V> java.util.SequencedMap.sequencedValues()"""
        return 'SequencedCollection'.__wrap(super(SequencedMap, self).sequencedValues())

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @overload
    def tailMap(self, fromKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.tailMap(K)"""
        return 'SortedMap'.__wrap(super(__ForwardingSortedMap, self).tailMap(fromKey))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @overload
    def subMap(self, fromKey: object, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.subMap(K,K)"""
        return 'SortedMap'.__wrap(super(__ForwardingSortedMap, self).subMap(fromKey, toKey))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMap.values()"""
        return 'Collection'.__wrap(super(ForwardingMap, self).values())

    @overload
    def headMap(self, toKey: object) -> 'SortedMap':
        """public java.util.SortedMap<K, V> com.google.common.collect.ForwardingSortedMap.headMap(K)"""
        return 'SortedMap'.__wrap(super(__ForwardingSortedMap, self).headMap(toKey))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMap, self).keySet())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key))

    @override
    @overload
    def replaceAll(self, arg0: 'BiFunction'):
        """public default void java.util.Map.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__Map, self).replaceAll(arg0)

    @overload
    def putLast(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putLast(K,V)"""
        return object.__wrap(super(__SortedMap, self).putLast(arg0, arg1))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsValue(value)) 
 
 
# CLASS: com.google.common.collect.LinkedHashMultimap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Set as __Set
__Set = __Set
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Set as Set
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import com.google.common.collect.LinkedHashMultimap as __LinkedHashMultimap
__LinkedHashMultimap = __LinkedHashMultimap
 
class LinkedHashMultimap():
    """com.google.common.collect.LinkedHashMultimap"""
 
    @staticmethod
    def __wrap(java_value: __LinkedHashMultimap) -> 'LinkedHashMultimap':
        return LinkedHashMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __LinkedHashMultimap):
        """
        Dynamic initializer for LinkedHashMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def entries(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.LinkedHashMultimap.entries()"""
        return 'Set'.__wrap(super(LinkedHashMultimap, self).entries())

    @staticmethod
    @overload
    def create(multimap: 'Multimap') -> 'LinkedHashMultimap':
        """public static <K,V> com.google.common.collect.LinkedHashMultimap<K, V> com.google.common.collect.LinkedHashMultimap.create(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return LinkedHashMultimap.__wrap(__LinkedHashMultimap.create(multimap))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.LinkedHashMultimap.keySet()"""
        return 'Set'.__wrap(super(LinkedHashMultimap, self).keySet())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.LinkedHashMultimap.values()"""
        return 'Collection'.__wrap(super(LinkedHashMultimap, self).values())

    @staticmethod
    @overload
    def create(expectedKeys: int, expectedValuesPerKey: int) -> 'LinkedHashMultimap':
        """public static <K,V> com.google.common.collect.LinkedHashMultimap<K, V> com.google.common.collect.LinkedHashMultimap.create(int,int)"""
        return LinkedHashMultimap.__wrap(__LinkedHashMultimap.create(__int.valueOf(expectedKeys), __int.valueOf(expectedValuesPerKey)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.LinkedHashMultimap.clear()"""
        super(LinkedHashMultimap, self).clear()

    @staticmethod
    @overload
    def create() -> 'LinkedHashMultimap':
        """public static <K,V> com.google.common.collect.LinkedHashMultimap<K, V> com.google.common.collect.LinkedHashMultimap.create()"""
        return LinkedHashMultimap.__wrap(__LinkedHashMultimap.create())

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'Set':
        """public java.util.Set<V> com.google.common.collect.LinkedHashMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'Set'.__wrap(super(__LinkedHashMultimap, self).replaceValues(key, values))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.ForwardingSetMultimap
from builtins import str
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.Set as __Set
__Set = __Set
import com.google.common.collect.ForwardingMultimap as __ForwardingMultimap
__ForwardingMultimap = __ForwardingMultimap
import java.util.Map as __Map
__Map = __Map
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.Set as Set
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Long as __long
import com.google.common.collect.ForwardingSetMultimap as __ForwardingSetMultimap
__ForwardingSetMultimap = __ForwardingSetMultimap
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
import java.util.Map as Map
from builtins import int
 
class ForwardingSetMultimap(ABC):
    """com.google.common.collect.ForwardingSetMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingSetMultimap) -> 'ForwardingSetMultimap':
        return ForwardingSetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingSetMultimap):
        """
        Dynamic initializer for ForwardingSetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool.__wrap(super(__ForwardingMultimap, self).putAll(multimap))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.hashCode()"""
        return int.__wrap(super(ForwardingMultimap, self).hashCode())

    @overload
    def get(self, key: object) -> 'Set':
        """public java.util.Set<V> com.google.common.collect.ForwardingSetMultimap.get(K)"""
        return 'Set'.__wrap(super(__ForwardingSetMultimap, self).get(key))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsKey(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsValue(value))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ForwardingSetMultimap()"""
        val = __ForwardingSetMultimap()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def containsEntry(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsEntry(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsEntry(key, value))

    @override
    @overload
    def asMap(self) -> 'Map':
        """public java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ForwardingMultimap.asMap()"""
        return 'Map'.__wrap(super(ForwardingMultimap, self).asMap())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMultimap.clear()"""
        super(ForwardingMultimap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).remove(key, value))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.size()"""
        return int.__wrap(super(ForwardingMultimap, self).size())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).equals(object))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.put(K,V)"""
        return bool.__wrap(super(__ForwardingMultimap, self).put(key, value))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.values()"""
        return 'Collection'.__wrap(super(ForwardingMultimap, self).values())

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMultimap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMultimap, self).keySet())

    @override
    @overload
    def keys(self) -> 'Multiset':
        """public com.google.common.collect.Multiset<K> com.google.common.collect.ForwardingMultimap.keys()"""
        return 'Multiset'.__wrap(super(ForwardingMultimap, self).keys())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool.__wrap(super(__ForwardingMultimap, self).putAll(key, values))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.isEmpty()"""
        return bool.__wrap(super(ForwardingMultimap, self).isEmpty())

    @override
    @overload
    def entries(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingSetMultimap.entries()"""
        return 'Set'.__wrap(super(ForwardingSetMultimap, self).entries())

    @overload
    def __init__(self):
        """public com.google.common.collect.ForwardingSetMultimap()"""
        val = __ForwardingSetMultimap()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def removeAll(self, key: object) -> 'Set':
        """public java.util.Set<V> com.google.common.collect.ForwardingSetMultimap.removeAll(java.lang.Object)"""
        return 'Set'.__wrap(super(__ForwardingSetMultimap, self).removeAll(key))

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'Set':
        """public java.util.Set<V> com.google.common.collect.ForwardingSetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'Set'.__wrap(super(__ForwardingSetMultimap, self).replaceValues(key, values)) 
 
 
# CLASS: com.google.common.collect.ForwardingSortedSet
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingSet as __ForwardingSet
__ForwardingSet = __ForwardingSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.SortedSet as SortedSet
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import com.google.common.collect.ForwardingSortedSet as __ForwardingSortedSet
__ForwardingSortedSet = __ForwardingSortedSet
import java.util.Comparator as Comparator
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ForwardingSortedSet(ABC):
    """com.google.common.collect.ForwardingSortedSet"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingSortedSet) -> 'ForwardingSortedSet':
        return ForwardingSortedSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingSortedSet):
        """
        Dynamic initializer for ForwardingSortedSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'.__wrap(super(SortedSet, self).spliterator())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def reversed(self) -> 'SortedSet':
        """public default java.util.SortedSet<E> java.util.SortedSet.reversed()"""
        return 'SortedSet'.__wrap(super(SortedSet, self).reversed())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.headSet(E)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSet, self).headSet(toElement))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int.__wrap(super(ForwardingSet, self).hashCode())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ForwardingSortedSet.comparator()"""
        return 'Comparator'.__wrap(super(ForwardingSortedSet, self).comparator())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.SortedSet.removeLast()"""
        return object.__wrap(super(SortedSet, self).removeLast())

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(__SortedSet, self).addLast(arg0)

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object.__wrap(super(SortedSet, self).getLast())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingSet, self).equals(object))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.subSet(E,E)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSet, self).subSet(fromElement, toElement))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object.__wrap(super(SortedSet, self).getFirst())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(__SortedSet, self).addFirst(arg0)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.first()"""
        return object.__wrap(super(ForwardingSortedSet, self).first())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.SortedSet.removeFirst()"""
        return object.__wrap(super(SortedSet, self).removeFirst())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.last()"""
        return object.__wrap(super(ForwardingSortedSet, self).last())

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.tailSet(E)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSet, self).tailSet(fromElement))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.ContiguousSet
import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet
__ImmutableSortedSet = __ImmutableSortedSet
import java.util.function.Predicate as Predicate
import java.lang.Boolean as __boolean
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.ImmutableSet as __ImmutableSet_Builder
__Builder = __ImmutableSet_Builder.Builder
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import java.util.SortedSet as SortedSet
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet_Builder
__Builder = __ImmutableSortedSet_Builder.Builder
import java.lang.Comparable as Comparable
from builtins import object
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
from typing import List
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
import com.google.common.collect.ContiguousSet as __ContiguousSet
__ContiguousSet = __ContiguousSet
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ContiguousSet(ABC):
    """com.google.common.collect.ContiguousSet"""
 
    @staticmethod
    def __wrap(java_value: __ContiguousSet) -> 'ContiguousSet':
        return ContiguousSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ContiguousSet):
        """
        Dynamic initializer for ContiguousSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSortedSet':
        """public static <Z> com.google.common.collect.ImmutableSortedSet<Z> com.google.common.collect.ImmutableSortedSet.copyOf(Z[])"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def closedOpen(lower: int, upper: int) -> 'ContiguousSet':
        """public static com.google.common.collect.ContiguousSet<java.lang.Long> com.google.common.collect.ContiguousSet.closedOpen(long,long)"""
        return ContiguousSet.__wrap(__ContiguousSet.closedOpen(__long.valueOf(lower), __long.valueOf(upper)))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *remaining: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, remaining))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Collection') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.util.Collection<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(comparator, elements))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableSet, self).equals(object))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @abstractmethod
    def contains(self, object: object):
        """public abstract boolean com.google.common.collect.ImmutableCollection.contains(java.lang.Object)"""
        pass

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool.__wrap(super(__ImmutableCollection, self).add(e))

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'.__wrap(super(NavigableSet, self).reversed())

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableCollection, self).remove(object))

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object.__wrap(super(SortedSet, self).getFirst())

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4, e5))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ContiguousSet.builder()"""
        return Builder.__wrap(__ContiguousSet.builder())

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeIf(filter))

    @overload
    def tailSet(self, fromElement: 'Comparable') -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.tailSet(C)"""
        return 'ContiguousSet'.__wrap(super(__ContiguousSet, self).tailSet(fromElement))

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.higher(E)"""
        return object.__wrap(super(__ImmutableSortedSet, self).higher(e))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ImmutableSortedSet.comparator()"""
        return 'Comparator'.__wrap(super(ImmutableSortedSet, self).comparator())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableSet.hashCode()"""
        return int.__wrap(super(ImmutableSet, self).hashCode())

    @abstractmethod
    def range(self, lowerBoundType: 'BoundType', upperBoundType: 'BoundType'):
        """public abstract com.google.common.collect.Range<C> com.google.common.collect.ContiguousSet.range(com.google.common.collect.BoundType,com.google.common.collect.BoundType)"""
        pass

    @overload
    def subSet(self, fromElement: 'Comparable', fromInclusive: bool, toElement: 'Comparable', toInclusive: bool) -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.subSet(C,boolean,C,boolean)"""
        return 'ContiguousSet'.__wrap(super(__ContiguousSet, self).subSet(fromElement, __boolean.valueOf(fromInclusive), toElement, __boolean.valueOf(toInclusive)))

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterable') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.lang.Iterable<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(comparator, elements))

    @staticmethod
    @overload
    def of(element: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(element))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableSortedSet.spliterator()"""
        return 'Spliterator'.__wrap(super(ImmutableSortedSet, self).spliterator())

    @override
    @overload
    def pollFirst(self) -> object:
        """public final E com.google.common.collect.ImmutableSortedSet.pollFirst()"""
        return object.__wrap(super(ImmutableSortedSet, self).pollFirst())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @staticmethod
    @overload
    def closed(lower: int, upper: int) -> 'ContiguousSet':
        """public static com.google.common.collect.ContiguousSet<java.lang.Long> com.google.common.collect.ContiguousSet.closed(long,long)"""
        return ContiguousSet.__wrap(__ContiguousSet.closed(__long.valueOf(lower), __long.valueOf(upper)))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(element))

    @abstractmethod
    def intersection(self, other: 'ContiguousSet'):
        """public abstract com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.intersection(com.google.common.collect.ContiguousSet<C>)"""
        pass

    @abstractmethod
    def descendingIterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSortedSet.descendingIterator()"""
        pass

    @staticmethod
    @overload
    def copyOf(elements: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(E[])"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object].__wrap(super(ImmutableCollection, self).toArray())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4, e5))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).addAll(newElements))

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.ceiling(E)"""
        return object.__wrap(super(__ImmutableSortedSet, self).ceiling(e))

    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(element))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableSortedSet.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.first()"""
        return object.__wrap(super(ImmutableSortedSet, self).first())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ContiguousSet.toString()"""
        return str.__wrap(super(ContiguousSet, self).toString())

    @staticmethod
    @overload
    def of() -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of()"""
        return ImmutableSet.__wrap(__ImmutableSet.of())

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4, e5))

    @staticmethod
    @overload
    def create(range: 'Range', domain: 'DiscreteDomain') -> 'ContiguousSet':
        """public static <C extends java.lang.Comparable> com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.create(com.google.common.collect.Range<C>,com.google.common.collect.DiscreteDomain<C>)"""
        return ContiguousSet.__wrap(__ContiguousSet.create(range, domain))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4))

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.lower(E)"""
        return object.__wrap(super(__ImmutableSortedSet, self).lower(e))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable', e5: 'Comparable', e6: 'Comparable', *remaining: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4, e5, e6, remaining))

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.last()"""
        return object.__wrap(super(ImmutableSortedSet, self).last())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def tailSet(self, fromElement: 'Comparable', inclusive: bool) -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.tailSet(C,boolean)"""
        return 'ContiguousSet'.__wrap(super(__ContiguousSet, self).tailSet(fromElement, __boolean.valueOf(inclusive)))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(__SortedSet, self).addLast(arg0)

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object].__wrap(super(__ImmutableCollection, self).toArray(other))

    @staticmethod
    @overload
    def naturalOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.naturalOrder()"""
        return Builder.__wrap(__ImmutableSortedSet.naturalOrder())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object.__wrap(super(NavigableSet, self).removeFirst())

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(__SortedSet, self).addFirst(arg0)

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableSet.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @abstractmethod
    def range(self, ):
        """public abstract com.google.common.collect.Range<C> com.google.common.collect.ContiguousSet.range()"""
        pass

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(elements))

    @overload
    def headSet(self, toElement: 'Comparable') -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.headSet(C)"""
        return 'ContiguousSet'.__wrap(super(__ContiguousSet, self).headSet(toElement))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSet$Builder<E> com.google.common.collect.ImmutableSet.builder()"""
        return Builder.__wrap(__ImmutableSet.builder())

    @staticmethod
    @overload
    def reverseOrder() -> 'Builder':
        """public static <E extends java.lang.Comparable<?>> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.reverseOrder()"""
        return Builder.__wrap(__ImmutableSortedSet.reverseOrder())

    @staticmethod
    @overload
    def closed(lower: int, upper: int) -> 'ContiguousSet':
        """public static com.google.common.collect.ContiguousSet<java.lang.Integer> com.google.common.collect.ContiguousSet.closed(int,int)"""
        return ContiguousSet.__wrap(__ContiguousSet.closed(__int.valueOf(lower), __int.valueOf(upper)))

    @staticmethod
    @overload
    def toImmutableSortedSet(comparator: 'Comparator') -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSortedSet<E>> com.google.common.collect.ImmutableSortedSet.toImmutableSortedSet(java.util.Comparator<? super E>)"""
        return Collector.__wrap(__ImmutableSortedSet.toImmutableSortedSet(comparator))

    @staticmethod
    @overload
    def closedOpen(lower: int, upper: int) -> 'ContiguousSet':
        """public static com.google.common.collect.ContiguousSet<java.lang.Integer> com.google.common.collect.ContiguousSet.closedOpen(int,int)"""
        return ContiguousSet.__wrap(__ContiguousSet.closedOpen(__int.valueOf(lower), __int.valueOf(upper)))

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(E[])"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @staticmethod
    @overload
    def copyOfSorted(sortedSet: 'SortedSet') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOfSorted(java.util.SortedSet<E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOfSorted(sortedSet))

    @abstractmethod
    def iterator(self, ):
        """public abstract com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableSortedSet.iterator()"""
        pass

    @staticmethod
    @overload
    def of() -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of()"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of())

    @overload
    def headSet(self, toElement: 'Comparable', inclusive: bool) -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.headSet(C,boolean)"""
        return 'ContiguousSet'.__wrap(super(__ContiguousSet, self).headSet(toElement, __boolean.valueOf(inclusive)))

    @override
    @overload
    def pollLast(self) -> object:
        """public final E com.google.common.collect.ImmutableSortedSet.pollLast()"""
        return object.__wrap(super(ImmutableSortedSet, self).pollLast())

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3))

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.ImmutableSortedSet.floor(E)"""
        return object.__wrap(super(__ImmutableSortedSet, self).floor(e))

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object.__wrap(super(SortedSet, self).getLast())

    @staticmethod
    @overload
    def copyOf(comparator: 'Comparator', elements: 'Iterator') -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.copyOf(java.util.Comparator<? super E>,java.util.Iterator<? extends E>)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.copyOf(comparator, elements))

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableSortedSet$Builder<E> com.google.common.collect.ImmutableSortedSet.orderedBy(java.util.Comparator<E>)"""
        return Builder.__wrap(__ImmutableSortedSet.orderedBy(comparator))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableSet.__wrap(__ImmutableSet.copyOf(elements))

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object.__wrap(super(NavigableSet, self).removeLast())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, *others: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E,E,E,E,E,E...)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2, e3, e4, e5, e6, others))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableSet':
        """public static <E> com.google.common.collect.ImmutableSet<E> com.google.common.collect.ImmutableSet.of(E,E)"""
        return ImmutableSet.__wrap(__ImmutableSet.of(e1, e2))

    @override
    @overload
    def descendingSet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.descendingSet()"""
        return 'ImmutableSortedSet'.__wrap(super(ImmutableSortedSet, self).descendingSet())

    @staticmethod
    @overload
    def toImmutableSet() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableSet<E>> com.google.common.collect.ImmutableSortedSet.toImmutableSet()"""
        return Collector.__wrap(__ImmutableSortedSet.toImmutableSet())

    @overload
    def subSet(self, fromElement: 'Comparable', toElement: 'Comparable') -> 'ContiguousSet':
        """public com.google.common.collect.ContiguousSet<C> com.google.common.collect.ContiguousSet.subSet(C,C)"""
        return 'ContiguousSet'.__wrap(super(__ContiguousSet, self).subSet(fromElement, toElement))

    @staticmethod
    @overload
    def of(e1: 'Comparable', e2: 'Comparable', e3: 'Comparable', e4: 'Comparable') -> 'ImmutableSortedSet':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableSortedSet':
        """public static <E> com.google.common.collect.ImmutableSortedSet<E> com.google.common.collect.ImmutableSortedSet.of(E,E,E,E)"""
        return ImmutableSortedSet.__wrap(__ImmutableSortedSet.of(e1, e2, e3, e4)) 
 
 
# CLASS: com.google.common.collect.SortedMapDifference
import com.google.common.collect.MapDifference as __MapDifference
__MapDifference = __MapDifference
from abc import abstractmethod, ABC
import com.google.common.collect.SortedMapDifference as __SortedMapDifference
__SortedMapDifference = __SortedMapDifference
 
class SortedMapDifference(ABC):
    """com.google.common.collect.SortedMapDifference"""
 
    @staticmethod
    def __wrap(java_value: __SortedMapDifference) -> 'SortedMapDifference':
        return SortedMapDifference(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __SortedMapDifference):
        """
        Dynamic initializer for SortedMapDifference.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def entriesOnlyOnLeft(self, ):
        """public abstract java.util.SortedMap<K, V> com.google.common.collect.SortedMapDifference.entriesOnlyOnLeft()"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.MapDifference.hashCode()"""
        pass

    @abstractmethod
    def entriesInCommon(self, ):
        """public abstract java.util.SortedMap<K, V> com.google.common.collect.SortedMapDifference.entriesInCommon()"""
        pass

    @abstractmethod
    def entriesOnlyOnRight(self, ):
        """public abstract java.util.SortedMap<K, V> com.google.common.collect.SortedMapDifference.entriesOnlyOnRight()"""
        pass

    @abstractmethod
    def areEqual(self, ):
        """public abstract boolean com.google.common.collect.MapDifference.areEqual()"""
        pass

    @abstractmethod
    def entriesDiffering(self, ):
        """public abstract java.util.SortedMap<K, com.google.common.collect.MapDifference$ValueDifference<V>> com.google.common.collect.SortedMapDifference.entriesDiffering()"""
        pass

    @abstractmethod
    def equals(self, object: object):
        """public abstract boolean com.google.common.collect.MapDifference.equals(java.lang.Object)"""
        pass 
 
 
# CLASS: com.google.common.collect.ForwardingSortedSetMultimap
import com.google.common.collect.Multimap as __Multimap
__Multimap = __Multimap
from builtins import type
import com.google.common.collect.ForwardingMultimap as __ForwardingMultimap
__ForwardingMultimap = __ForwardingMultimap
import java.util.Map as __Map
__Map = __Map
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Set as __Set
__Set = __Set
import java.lang.Iterable as Iterable
import com.google.common.collect.ForwardingSortedSetMultimap as __ForwardingSortedSetMultimap
__ForwardingSortedSetMultimap = __ForwardingSortedSetMultimap
import java.util.SortedSet as SortedSet
import java.util.Comparator as Comparator
import java.util.Set as Set
import java.lang.Long as __long
import com.google.common.collect.ForwardingSetMultimap as __ForwardingSetMultimap
__ForwardingSetMultimap = __ForwardingSetMultimap
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import int
 
class ForwardingSortedSetMultimap(ABC):
    """com.google.common.collect.ForwardingSortedSetMultimap"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingSortedSetMultimap) -> 'ForwardingSortedSetMultimap':
        return ForwardingSortedSetMultimap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingSortedSetMultimap):
        """
        Dynamic initializer for ForwardingSortedSetMultimap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def putAll(self, multimap: 'Multimap') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return bool.__wrap(super(__ForwardingMultimap, self).putAll(multimap))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def valueComparator(self) -> 'Comparator':
        """public java.util.Comparator<? super V> com.google.common.collect.ForwardingSortedSetMultimap.valueComparator()"""
        return 'Comparator'.__wrap(super(ForwardingSortedSetMultimap, self).valueComparator())

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.hashCode()"""
        return int.__wrap(super(ForwardingMultimap, self).hashCode())

    @overload
    def replaceValues(self, key: object, values: 'Iterable') -> 'SortedSet':
        """public java.util.SortedSet<V> com.google.common.collect.ForwardingSortedSetMultimap.replaceValues(K,java.lang.Iterable<? extends V>)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSetMultimap, self).replaceValues(key, values))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsKey(key))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsValue(value))

    @overload
    def containsEntry(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.containsEntry(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).containsEntry(key, value))

    @override
    @overload
    def asMap(self) -> 'Map':
        """public java.util.Map<K, java.util.Collection<V>> com.google.common.collect.ForwardingMultimap.asMap()"""
        return 'Map'.__wrap(super(ForwardingMultimap, self).asMap())

    @overload
    def removeAll(self, key: object) -> 'SortedSet':
        """public java.util.SortedSet<V> com.google.common.collect.ForwardingSortedSetMultimap.removeAll(java.lang.Object)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSetMultimap, self).removeAll(key))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingMultimap.clear()"""
        super(ForwardingMultimap, self).clear()

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).remove(key, value))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public default void com.google.common.collect.Multimap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Multimap, self).forEach(action)

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMultimap.size()"""
        return int.__wrap(super(ForwardingMultimap, self).size())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMultimap, self).equals(object))

    @overload
    def put(self, key: object, value: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.put(K,V)"""
        return bool.__wrap(super(__ForwardingMultimap, self).put(key, value))

    @override
    @overload
    def values(self) -> 'Collection':
        """public java.util.Collection<V> com.google.common.collect.ForwardingMultimap.values()"""
        return 'Collection'.__wrap(super(ForwardingMultimap, self).values())

    @override
    @overload
    def keySet(self) -> 'Set':
        """public java.util.Set<K> com.google.common.collect.ForwardingMultimap.keySet()"""
        return 'Set'.__wrap(super(ForwardingMultimap, self).keySet())

    @override
    @overload
    def keys(self) -> 'Multiset':
        """public com.google.common.collect.Multiset<K> com.google.common.collect.ForwardingMultimap.keys()"""
        return 'Multiset'.__wrap(super(ForwardingMultimap, self).keys())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.putAll(K,java.lang.Iterable<? extends V>)"""
        return bool.__wrap(super(__ForwardingMultimap, self).putAll(key, values))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMultimap.isEmpty()"""
        return bool.__wrap(super(ForwardingMultimap, self).isEmpty())

    @override
    @overload
    def entries(self) -> 'Set':
        """public java.util.Set<java.util.Map$Entry<K, V>> com.google.common.collect.ForwardingSetMultimap.entries()"""
        return 'Set'.__wrap(super(ForwardingSetMultimap, self).entries())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def get(self, key: object) -> 'SortedSet':
        """public java.util.SortedSet<V> com.google.common.collect.ForwardingSortedSetMultimap.get(K)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSetMultimap, self).get(key)) 
 
 
# CLASS: com.google.common.collect.EnumBiMap
from builtins import str
from pyquantum_helper import override
import com.google.common.collect.EnumBiMap as __EnumBiMap
__EnumBiMap = __EnumBiMap
import java.lang.Object as __object
from builtins import type
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import bool
from builtins import int
 
class EnumBiMap():
    """com.google.common.collect.EnumBiMap"""
 
    @staticmethod
    def __wrap(java_value: __EnumBiMap) -> 'EnumBiMap':
        return EnumBiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __EnumBiMap):
        """
        Dynamic initializer for EnumBiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def valueType(self) -> 'type.Class':
        """public java.lang.Class<V> com.google.common.collect.EnumBiMap.valueType()"""
        return 'type.Class'.__wrap(super(EnumBiMap, self).valueType())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @overload
    def keyType(self) -> 'type.Class':
        """public java.lang.Class<K> com.google.common.collect.EnumBiMap.keyType()"""
        return 'type.Class'.__wrap(super(EnumBiMap, self).keyType())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def create(keyType: 'Class', valueType: 'Class') -> 'EnumBiMap':
        """public static <K extends java.lang.Enum<K>,V extends java.lang.Enum<V>> com.google.common.collect.EnumBiMap<K, V> com.google.common.collect.EnumBiMap.create(java.lang.Class<K>,java.lang.Class<V>)"""
        return EnumBiMap.__wrap(__EnumBiMap.create(keyType, valueType))

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @staticmethod
    @overload
    def create(map: 'Map') -> 'EnumBiMap':
        """public static <K extends java.lang.Enum<K>,V extends java.lang.Enum<V>> com.google.common.collect.EnumBiMap<K, V> com.google.common.collect.EnumBiMap.create(java.util.Map<K, V>)"""
        return EnumBiMap.__wrap(__EnumBiMap.create(map))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key)) 
 
 
# CLASS: com.google.common.collect.ImmutableList
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
from abc import abstractmethod, ABC
import com.google.common.collect.ImmutableList as __ImmutableList
__ImmutableList = __ImmutableList
import java.util.function.Consumer as Consumer
import java.util.Spliterator as Spliterator
import java.util.Collection as __Collection
__Collection = __Collection
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.ImmutableList as __ImmutableList_Builder
__Builder = __ImmutableList_Builder.Builder
from builtins import bool
import com.google.common.collect.UnmodifiableIterator as __UnmodifiableIterator
__UnmodifiableIterator = __UnmodifiableIterator
from builtins import str
import java.util.function.UnaryOperator as UnaryOperator
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
from builtins import object
import java.util.stream.Collector as Collector
import java.util.Iterator as Iterator
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
from typing import List
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.util.List as __List
__List = __List
import com.google.common.collect.UnmodifiableListIterator as __UnmodifiableListIterator
__UnmodifiableListIterator = __UnmodifiableListIterator
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.util.List as List
 
class ImmutableList(ABC):
    """com.google.common.collect.ImmutableList"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableList) -> 'ImmutableList':
        return ImmutableList(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableList):
        """
        Dynamic initializer for ImmutableList.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def of(element: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E)"""
        return ImmutableList.__wrap(__ImmutableList.of(element))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4, e5, e6))

    @override
    @overload
    def iterator(self) -> 'UnmodifiableIterator':
        """public com.google.common.collect.UnmodifiableIterator<E> com.google.common.collect.ImmutableList.iterator()"""
        return 'UnmodifiableIterator'.__wrap(super(ImmutableList, self).iterator())

    @overload
    def addAll(self, index: int, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableList.addAll(int,java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ImmutableList, self).addAll(__int.valueOf(index), newElements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.List.addFirst(E)"""
        super(__List, self).addFirst(arg0)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object, e9: object, e10: object, e11: object, e12: object, *others: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E,E,E,E,E,E...)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, others))

    @override
    @overload
    def sort(self, c: 'Comparator'):
        """public final void com.google.common.collect.ImmutableList.sort(java.util.Comparator<? super E>)"""
        super(__ImmutableList, self).sort(c)

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def reverse(self) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.reverse()"""
        return 'ImmutableList'.__wrap(super(ImmutableList, self).reverse())

    @staticmethod
    @overload
    def copyOf(elements: 'Iterator') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.copyOf(java.util.Iterator<? extends E>)"""
        return ImmutableList.__wrap(__ImmutableList.copyOf(elements))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def add(self, e: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.add(E)"""
        return bool.__wrap(super(__ImmutableCollection, self).add(e))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @overload
    def subList(self, fromIndex: int, toIndex: int) -> 'ImmutableList':
        """public com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.subList(int,int)"""
        return 'ImmutableList'.__wrap(super(__ImmutableList, self).subList(__int.valueOf(fromIndex), __int.valueOf(toIndex)))

    @overload
    def toArray(self, other: 'Object') -> List[object]:
        """public final <T> T[] com.google.common.collect.ImmutableCollection.toArray(T[])"""
        return List[object].__wrap(super(__ImmutableCollection, self).toArray(other))

    @staticmethod
    @overload
    def copyOf(elements: 'Collection') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.copyOf(java.util.Collection<? extends E>)"""
        return ImmutableList.__wrap(__ImmutableList.copyOf(elements))

    @overload
    def remove(self, object: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableCollection, self).remove(object))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object, e9: object, e10: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @staticmethod
    @overload
    def copyOf(elements: 'Object') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.copyOf(E[])"""
        return ImmutableList.__wrap(__ImmutableList.copyOf(elements))

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList.builder()"""
        return Builder.__wrap(__ImmutableList.builder())

    @override
    @overload
    def asList(self) -> 'ImmutableList':
        """public final com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.asList()"""
        return 'ImmutableList'.__wrap(super(ImmutableList, self).asList())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def add(self, index: int, element: object):
        """public final void com.google.common.collect.ImmutableList.add(int,E)"""
        super(__ImmutableList, self).add(__int.valueOf(index), element)

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.List.removeLast()"""
        return object.__wrap(super(List, self).removeLast())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4, e5, e6, e7))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.List.addLast(E)"""
        super(__List, self).addLast(arg0)

    @overload
    def removeIf(self, filter: 'Predicate') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeIf(filter))

    @staticmethod
    @overload
    def copyOf(elements: 'Iterable') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.copyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableList.__wrap(__ImmutableList.copyOf(elements))

    @staticmethod
    @overload
    def toImmutableList() -> 'Collector':
        """public static <E> java.util.stream.Collector<E, ?, com.google.common.collect.ImmutableList<E>> com.google.common.collect.ImmutableList.toImmutableList()"""
        return Collector.__wrap(__ImmutableList.toImmutableList())

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableList.contains(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableList, self).contains(object))

    @abstractmethod
    def size(self, ):
        """public abstract int java.util.AbstractCollection.size()"""
        pass

    @override
    @overload
    def listIterator(self) -> 'UnmodifiableListIterator':
        """public com.google.common.collect.UnmodifiableListIterator<E> com.google.common.collect.ImmutableList.listIterator()"""
        return 'UnmodifiableListIterator'.__wrap(super(ImmutableList, self).listIterator())

    @staticmethod
    @overload
    def sortedCopyOf(comparator: 'Comparator', elements: 'Iterable') -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.sortedCopyOf(java.util.Comparator<? super E>,java.lang.Iterable<? extends E>)"""
        return ImmutableList.__wrap(__ImmutableList.sortedCopyOf(comparator, elements))

    @overload
    def equals(self, obj: object) -> bool:
        """public boolean com.google.common.collect.ImmutableList.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableList, self).equals(obj))

    @overload
    def removeAll(self, oldElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).removeAll(oldElements))

    @staticmethod
    @overload
    def sortedCopyOf(elements: 'Iterable') -> 'ImmutableList':
        """public static <E extends java.lang.Comparable<? super E>> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.sortedCopyOf(java.lang.Iterable<? extends E>)"""
        return ImmutableList.__wrap(__ImmutableList.sortedCopyOf(elements))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def listIterator(self, index: int) -> 'UnmodifiableListIterator':
        """public com.google.common.collect.UnmodifiableListIterator<E> com.google.common.collect.ImmutableList.listIterator(int)"""
        return 'UnmodifiableListIterator'.__wrap(super(__ImmutableList, self).listIterator(__int.valueOf(index)))

    @staticmethod
    @overload
    def of() -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of()"""
        return ImmutableList.__wrap(__ImmutableList.of())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def forEach(self, consumer: 'Consumer'):
        """public void com.google.common.collect.ImmutableList.forEach(java.util.function.Consumer<? super E>)"""
        super(__ImmutableList, self).forEach(consumer)

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object, e9: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8, e9))

    @override
    @overload
    def replaceAll(self, operator: 'UnaryOperator'):
        """public final void com.google.common.collect.ImmutableList.replaceAll(java.util.function.UnaryOperator<E>)"""
        super(__ImmutableList, self).replaceAll(operator)

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.List.getFirst()"""
        return object.__wrap(super(List, self).getFirst())

    @overload
    def retainAll(self, elementsToKeep: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImmutableCollection, self).retainAll(elementsToKeep))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableCollection.clear()"""
        super(ImmutableCollection, self).clear()

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.List.getLast()"""
        return object.__wrap(super(List, self).getLast())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public final java.lang.Object[] com.google.common.collect.ImmutableCollection.toArray()"""
        return List[object].__wrap(super(ImmutableCollection, self).toArray())

    @overload
    def remove(self, index: int) -> object:
        """public final E com.google.common.collect.ImmutableList.remove(int)"""
        return object.__wrap(super(__ImmutableList, self).remove(__int.valueOf(index)))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.List.removeFirst()"""
        return object.__wrap(super(List, self).removeFirst())

    @overload
    def lastIndexOf(self, object: object) -> int:
        """public int com.google.common.collect.ImmutableList.lastIndexOf(java.lang.Object)"""
        return int.__wrap(super(__ImmutableList, self).lastIndexOf(object))

    @abstractmethod
    def get(self, arg0: int):
        """public abstract E java.util.List.get(int)"""
        pass

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public final boolean com.google.common.collect.ImmutableCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ImmutableCollection, self).addAll(newElements))

    @overload
    def set(self, index: int, element: object) -> object:
        """public final E com.google.common.collect.ImmutableList.set(int,E)"""
        return object.__wrap(super(__ImmutableList, self).set(__int.valueOf(index), element))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object, e9: object, e10: object, e11: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E,E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableList.hashCode()"""
        return int.__wrap(super(ImmutableList, self).hashCode())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <E> com.google.common.collect.ImmutableList$Builder<E> com.google.common.collect.ImmutableList.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableList.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def indexOf(self, object: object) -> int:
        """public int com.google.common.collect.ImmutableList.indexOf(java.lang.Object)"""
        return int.__wrap(super(__ImmutableList, self).indexOf(object))

    @staticmethod
    @overload
    def of(e1: object, e2: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2))

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4, e5))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public java.util.Spliterator<E> com.google.common.collect.ImmutableList.spliterator()"""
        return 'Spliterator'.__wrap(super(ImmutableList, self).spliterator())

    @staticmethod
    @overload
    def of(e1: object, e2: object, e3: object, e4: object, e5: object, e6: object, e7: object, e8: object) -> 'ImmutableList':
        """public static <E> com.google.common.collect.ImmutableList<E> com.google.common.collect.ImmutableList.of(E,E,E,E,E,E,E,E)"""
        return ImmutableList.__wrap(__ImmutableList.of(e1, e2, e3, e4, e5, e6, e7, e8))

    @override
    @overload
    def reversed(self) -> 'List':
        """public default java.util.List<E> java.util.List.reversed()"""
        return 'List'.__wrap(super(List, self).reversed()) 
 
 
# CLASS: com.google.common.collect.Multiset$Entry
import com.google.common.collect.Multiset as __Multiset_Entry
__Entry = __Multiset_Entry.Entry
from abc import abstractmethod, ABC
 
class Entry(ABC):
    """com.google.common.collect.Multiset.Entry"""
 
    @staticmethod
    def __wrap(java_value: __Entry) -> 'Entry':
        return Entry(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Entry):
        """
        Dynamic initializer for Entry.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def getElement(self, ):
        """public abstract E com.google.common.collect.Multiset$Entry.getElement()"""
        pass

    @abstractmethod
    def equals(self, o: object):
        """public abstract boolean com.google.common.collect.Multiset$Entry.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.Multiset$Entry.hashCode()"""
        pass

    @abstractmethod
    def getCount(self, ):
        """public abstract int com.google.common.collect.Multiset$Entry.getCount()"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.Multiset$Entry.toString()"""
        pass 
 
 
# CLASS: com.google.common.collect.RangeMap
import com.google.common.collect.RangeMap as __RangeMap
__RangeMap = __RangeMap
from abc import abstractmethod, ABC
import java.lang.Comparable as Comparable
import java.util.function.BiFunction as BiFunction
 
class RangeMap(ABC):
    """com.google.common.collect.RangeMap"""
 
    @staticmethod
    def __wrap(java_value: __RangeMap) -> 'RangeMap':
        return RangeMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __RangeMap):
        """
        Dynamic initializer for RangeMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def asDescendingMapOfRanges(self, ):
        """public abstract java.util.Map<com.google.common.collect.Range<K>, V> com.google.common.collect.RangeMap.asDescendingMapOfRanges()"""
        pass

    @abstractmethod
    def equals(self, o: object):
        """public abstract boolean com.google.common.collect.RangeMap.equals(java.lang.Object)"""
        pass

    @abstractmethod
    def merge(self, range: 'Range', value: object, remappingFunction: 'BiFunction'):
        """public abstract void com.google.common.collect.RangeMap.merge(com.google.common.collect.Range<K>,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        pass

    @abstractmethod
    def remove(self, range: 'Range'):
        """public abstract void com.google.common.collect.RangeMap.remove(com.google.common.collect.Range<K>)"""
        pass

    @abstractmethod
    def asMapOfRanges(self, ):
        """public abstract java.util.Map<com.google.common.collect.Range<K>, V> com.google.common.collect.RangeMap.asMapOfRanges()"""
        pass

    @abstractmethod
    def toString(self, ):
        """public abstract java.lang.String com.google.common.collect.RangeMap.toString()"""
        pass

    @abstractmethod
    def get(self, key: 'Comparable'):
        """public abstract V com.google.common.collect.RangeMap.get(K)"""
        pass

    @abstractmethod
    def putAll(self, rangeMap: 'RangeMap'):
        """public abstract void com.google.common.collect.RangeMap.putAll(com.google.common.collect.RangeMap<K, ? extends V>)"""
        pass

    @abstractmethod
    def subRangeMap(self, range: 'Range'):
        """public abstract com.google.common.collect.RangeMap<K, V> com.google.common.collect.RangeMap.subRangeMap(com.google.common.collect.Range<K>)"""
        pass

    @abstractmethod
    def getEntry(self, key: 'Comparable'):
        """public abstract java.util.Map$Entry<com.google.common.collect.Range<K>, V> com.google.common.collect.RangeMap.getEntry(K)"""
        pass

    @abstractmethod
    def putCoalescing(self, range: 'Range', value: object):
        """public abstract void com.google.common.collect.RangeMap.putCoalescing(com.google.common.collect.Range<K>,V)"""
        pass

    @abstractmethod
    def hashCode(self, ):
        """public abstract int com.google.common.collect.RangeMap.hashCode()"""
        pass

    @abstractmethod
    def span(self, ):
        """public abstract com.google.common.collect.Range<K> com.google.common.collect.RangeMap.span()"""
        pass

    @abstractmethod
    def put(self, range: 'Range', value: object):
        """public abstract void com.google.common.collect.RangeMap.put(com.google.common.collect.Range<K>,V)"""
        pass

    @abstractmethod
    def clear(self, ):
        """public abstract void com.google.common.collect.RangeMap.clear()"""
        pass 
 
 
# CLASS: com.google.common.collect.ComputationException
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Throwable as __Throwable
__Throwable = __Throwable
import java.io.PrintWriter as PrintWriter
import java.lang.StackTraceElement as StackTraceElement
import java.lang.StackTraceElement as __StackTraceElement
__StackTraceElement = __StackTraceElement
from typing import List
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.io.PrintStream as PrintStream
import com.google.common.collect.ComputationException as __ComputationException
__ComputationException = __ComputationException
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Throwable as Throwable
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class ComputationException():
    """com.google.common.collect.ComputationException"""
 
    @staticmethod
    def __wrap(java_value: __ComputationException) -> 'ComputationException':
        return ComputationException(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ComputationException):
        """
        Dynamic initializer for ComputationException.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def printStackTrace(self, arg0: 'PrintStream'):
        """public void java.lang.Throwable.printStackTrace(java.io.PrintStream)"""
        super(__Throwable, self).printStackTrace(arg0)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Throwable.toString()"""
        return str.__wrap(super(Throwable, self).toString())

    @override
    @overload
    def getStackTrace(self) -> List['StackTraceElement']:
        """public java.lang.StackTraceElement[] java.lang.Throwable.getStackTrace()"""
        return List['StackTraceElement'].__wrap(super(Throwable, self).getStackTrace())

    @override
    @overload
    def printStackTrace(self, arg0: 'PrintWriter'):
        """public void java.lang.Throwable.printStackTrace(java.io.PrintWriter)"""
        super(__Throwable, self).printStackTrace(arg0)

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def getMessage(self) -> str:
        """public java.lang.String java.lang.Throwable.getMessage()"""
        return str.__wrap(super(Throwable, self).getMessage())

    @override
    @overload
    def printStackTrace(self):
        """public void java.lang.Throwable.printStackTrace()"""
        super(Throwable, self).printStackTrace()

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getCause(self) -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.getCause()"""
        return 'Throwable'.__wrap(super(Throwable, self).getCause())

    @overload
    def initCause(self, arg0: 'Throwable') -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.initCause(java.lang.Throwable)"""
        return 'Throwable'.__wrap(super(__Throwable, self).initCause(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def addSuppressed(self, arg0: 'Throwable'):
        """public final synchronized void java.lang.Throwable.addSuppressed(java.lang.Throwable)"""
        super(__Throwable, self).addSuppressed(arg0)

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def setStackTrace(self, arg0: 'StackTraceElement'):
        """public void java.lang.Throwable.setStackTrace(java.lang.StackTraceElement[])"""
        super(__Throwable, self).setStackTrace(arg0)

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def getLocalizedMessage(self) -> str:
        """public java.lang.String java.lang.Throwable.getLocalizedMessage()"""
        return str.__wrap(super(Throwable, self).getLocalizedMessage())

    @override
    @overload
    def getSuppressed(self) -> List['Throwable']:
        """public final synchronized java.lang.Throwable[] java.lang.Throwable.getSuppressed()"""
        return List['Throwable'].__wrap(super(Throwable, self).getSuppressed())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def __init__(self, cause: 'Throwable'):
        """public com.google.common.collect.ComputationException(java.lang.Throwable)"""
        val = __ComputationException(cause)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def fillInStackTrace(self) -> 'Throwable':
        """public synchronized java.lang.Throwable java.lang.Throwable.fillInStackTrace()"""
        return 'Throwable'.__wrap(super(Throwable, self).fillInStackTrace()) 
 
 
# CLASS: com.google.common.collect.ImmutableSortedMap
import com.google.common.collect.ImmutableSortedSet as __ImmutableSortedSet
__ImmutableSortedSet = __ImmutableSortedSet
import java.util.NavigableMap as __NavigableMap
__NavigableMap = __NavigableMap
import java.lang.Boolean as __boolean
from builtins import type
import java.util.Map as __Map_Entry
__Entry = __Map_Entry.Entry
import java.util.stream.Collector as __Collector
__Collector = __Collector
import com.google.common.collect.ImmutableSetMultimap as __ImmutableSetMultimap
__ImmutableSetMultimap = __ImmutableSetMultimap
import java.util.NavigableMap as NavigableMap
import java.util.SequencedCollection as SequencedCollection
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Map.Entry as Entry
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BinaryOperator as BinaryOperator
import java.util.SortedMap as SortedMap
import java.util.SequencedCollection as __SequencedCollection
__SequencedCollection = __SequencedCollection
import java.util.SequencedSet as SequencedSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.SortedMap as __SortedMap
__SortedMap = __SortedMap
import com.google.common.collect.ImmutableSortedMap as __ImmutableSortedMap_Builder
__Builder = __ImmutableSortedMap_Builder.Builder
import com.google.common.collect.ImmutableSortedMap as __ImmutableSortedMap
__ImmutableSortedMap = __ImmutableSortedMap
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
from builtins import object
import java.lang.Comparable as Comparable
import java.util.stream.Collector as Collector
import com.google.common.collect.ImmutableMap as __ImmutableMap_Builder
__Builder = __ImmutableMap_Builder.Builder
import java.util.function.BiFunction as BiFunction
import java.util.SequencedMap as __SequencedMap
__SequencedMap = __SequencedMap
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.util.SequencedSet as __SequencedSet
__SequencedSet = __SequencedSet
import java.util.function.Function as Function
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import int
 
class ImmutableSortedMap():
    """com.google.common.collect.ImmutableSortedMap"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableSortedMap) -> 'ImmutableSortedMap':
        return ImmutableSortedMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableSortedMap):
        """
        Dynamic initializer for ImmutableSortedMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def toImmutableSortedMap(comparator: 'Comparator', keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSortedMap<K, V>> com.google.common.collect.ImmutableSortedMap.toImmutableSortedMap(java.util.Comparator<? super K>,java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableSortedMap.toImmutableSortedMap(comparator, keyFunction, valueFunction))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ImmutableMap.hashCode()"""
        return int.__wrap(super(ImmutableMap, self).hashCode())

    @overload
    def compute(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).compute(key, remappingFunction))

    @override
    @overload
    def sequencedEntrySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<java.util.Map$Entry<K, V>> java.util.SequencedMap.sequencedEntrySet()"""
        return 'SequencedSet'.__wrap(super(SequencedMap, self).sequencedEntrySet())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builder()"""
        return Builder.__wrap(__ImmutableMap.builder())

    @staticmethod
    @overload
    def toImmutableSortedMap(comparator: 'Comparator', keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableSortedMap<K, V>> com.google.common.collect.ImmutableSortedMap.toImmutableSortedMap(java.util.Comparator<? super K>,java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector.__wrap(__ImmutableSortedMap.toImmutableSortedMap(comparator, keyFunction, valueFunction, mergeFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).equals(object))

    @override
    @overload
    def descendingKeySet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<K> com.google.common.collect.ImmutableSortedMap.descendingKeySet()"""
        return 'ImmutableSortedSet'.__wrap(super(ImmutableSortedMap, self).descendingKeySet())

    @overload
    def putIfAbsent(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.putIfAbsent(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).putIfAbsent(key, value))

    @overload
    def lowerKey(self, key: object) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.lowerKey(K)"""
        return object.__wrap(super(__ImmutableSortedMap, self).lowerKey(key))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @overload
    def subMap(self, fromKey: object, fromInclusive: bool, toKey: object, toInclusive: bool) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.subMap(K,boolean,K,boolean)"""
        return 'ImmutableSortedMap'.__wrap(super(__ImmutableSortedMap, self).subMap(fromKey, __boolean.valueOf(fromInclusive), toKey, __boolean.valueOf(toInclusive)))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableMap.clear()"""
        super(ImmutableMap, self).clear()

    @override
    @overload
    def replaceAll(self, function: 'BiFunction'):
        """public final void com.google.common.collect.ImmutableMap.replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        super(__ImmutableMap, self).replaceAll(function)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1))

    @override
    @overload
    def pollLastEntry(self) -> 'Entry.Map$Entry':
        """public final java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.pollLastEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(ImmutableSortedMap, self).pollLastEntry())

    @override
    @overload
    def reversed(self) -> 'NavigableMap':
        """public default java.util.NavigableMap<K, V> java.util.NavigableMap.reversed()"""
        return 'NavigableMap'.__wrap(super(NavigableMap, self).reversed())

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).containsValue(value))

    @overload
    def computeIfPresent(self, key: object, remappingFunction: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).computeIfPresent(key, remappingFunction))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @staticmethod
    @overload
    def naturalOrder() -> 'Builder':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.naturalOrder()"""
        return Builder.__wrap(__ImmutableSortedMap.naturalOrder())

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @staticmethod
    @overload
    def copyOfSorted(map: 'SortedMap') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOfSorted(java.util.SortedMap<K, ? extends V>)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.copyOfSorted(map))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4))

    @staticmethod
    @overload
    def copyOf(map: 'Map', comparator: 'Comparator') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOf(java.util.Map<? extends K, ? extends V>,java.util.Comparator<? super K>)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.copyOf(map, comparator))

    @override
    @overload
    def lastEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.lastEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(ImmutableSortedMap, self).lastEntry())

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableSortedMap.values()"""
        return 'ImmutableCollection'.__wrap(super(ImmutableSortedMap, self).values())

    @override
    @overload
    def navigableKeySet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<K> com.google.common.collect.ImmutableSortedMap.navigableKeySet()"""
        return 'ImmutableSortedSet'.__wrap(super(ImmutableSortedMap, self).navigableKeySet())

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableMap.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @override
    @overload
    def sequencedKeySet(self) -> 'SequencedSet':
        """public default java.util.SequencedSet<K> java.util.SequencedMap.sequencedKeySet()"""
        return 'SequencedSet'.__wrap(super(SequencedMap, self).sequencedKeySet())

    @overload
    def subMap(self, fromKey: object, toKey: object) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.subMap(K,K)"""
        return 'ImmutableSortedMap'.__wrap(super(__ImmutableSortedMap, self).subMap(fromKey, toKey))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object, k7: 'Comparable', v7: object, k8: 'Comparable', v8: object, k9: 'Comparable', v9: object, k10: 'Comparable', v10: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @overload
    def tailMap(self, fromKey: object, inclusive: bool) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.tailMap(K,boolean)"""
        return 'ImmutableSortedMap'.__wrap(super(__ImmutableSortedMap, self).tailMap(fromKey, __boolean.valueOf(inclusive)))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def tailMap(self, fromKey: object) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.tailMap(K)"""
        return 'ImmutableSortedMap'.__wrap(super(__ImmutableSortedMap, self).tailMap(fromKey))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.copyOf(entries))

    @staticmethod
    @overload
    def reverseOrder() -> 'Builder':
        """public static <K extends java.lang.Comparable<?>,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.reverseOrder()"""
        return Builder.__wrap(__ImmutableSortedMap.reverseOrder())

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ImmutableSortedMap.get(java.lang.Object)"""
        return object.__wrap(super(__ImmutableSortedMap, self).get(key))

    @override
    @overload
    def entrySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<java.util.Map$Entry<K, V>> com.google.common.collect.ImmutableSortedMap.entrySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableSortedMap, self).entrySet())

    @overload
    def higherEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.higherEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ImmutableSortedMap, self).higherEntry(key))

    @overload
    def lowerEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.lowerEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ImmutableSortedMap, self).lowerEntry(key))

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableSortedMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector.__wrap(__ImmutableSortedMap.toImmutableMap(keyFunction, valueFunction, mergeFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5))

    @override
    @overload
    def asMultimap(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableMap.asMultimap()"""
        return 'ImmutableSetMultimap'.__wrap(super(ImmutableMap, self).asMultimap())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.ImmutableSortedMap.comparator()"""
        return 'Comparator'.__wrap(super(ImmutableSortedMap, self).comparator())

    @override
    @overload
    def keySet(self) -> 'ImmutableSortedSet':
        """public com.google.common.collect.ImmutableSortedSet<K> com.google.common.collect.ImmutableSortedMap.keySet()"""
        return 'ImmutableSortedSet'.__wrap(super(ImmutableSortedMap, self).keySet())

    @overload
    def merge(self, key: object, value: object, function: 'BiFunction') -> object:
        """public final V com.google.common.collect.ImmutableMap.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).merge(key, value, function))

    @overload
    def remove(self, o: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.remove(java.lang.Object)"""
        return object.__wrap(super(__ImmutableMap, self).remove(o))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object, k7: 'Comparable', v7: object, k8: 'Comparable', v8: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @overload
    def putFirst(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putFirst(K,V)"""
        return object.__wrap(super(__SortedMap, self).putFirst(arg0, arg1))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.copyOf(map))

    @override
    @overload
    def forEach(self, action: 'BiConsumer'):
        """public void com.google.common.collect.ImmutableSortedMap.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__ImmutableSortedMap, self).forEach(action)

    @overload
    def replace(self, key: object, oldValue: object, newValue: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.replace(K,V,V)"""
        return bool.__wrap(super(__ImmutableMap, self).replace(key, oldValue, newValue))

    @staticmethod
    @overload
    def copyOf(map: 'Map') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.util.Map<? extends K, ? extends V>)"""
        return ImmutableMap.__wrap(__ImmutableMap.copyOf(map))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2))

    @overload
    def floorEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.floorEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ImmutableSortedMap, self).floorEntry(key))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object, k10: object, v10: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10))

    @override
    @overload
    def pollFirstEntry(self) -> 'Entry.Map$Entry':
        """public final java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.pollFirstEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(ImmutableSortedMap, self).pollFirstEntry())

    @overload
    def replace(self, key: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.replace(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).replace(key, value))

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.orderedBy(java.util.Comparator<K>)"""
        return Builder.__wrap(__ImmutableSortedMap.orderedBy(comparator))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).containsKey(key))

    @override
    @overload
    def sequencedValues(self) -> 'SequencedCollection':
        """public default java.util.SequencedCollection<V> java.util.SequencedMap.sequencedValues()"""
        return 'SequencedCollection'.__wrap(super(SequencedMap, self).sequencedValues())

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.ofEntries(entries))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ImmutableMap.isEmpty()"""
        return bool.__wrap(super(ImmutableMap, self).isEmpty())

    @overload
    def floorKey(self, key: object) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.floorKey(K)"""
        return object.__wrap(super(__ImmutableSortedMap, self).floorKey(key))

    @overload
    def getOrDefault(self, key: object, defaultValue: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__ImmutableMap, self).getOrDefault(key, defaultValue))

    @overload
    def remove(self, key: object, value: object) -> bool:
        """public final boolean com.google.common.collect.ImmutableMap.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ImmutableMap, self).remove(key, value))

    @staticmethod
    @overload
    def toImmutableMap(keyFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,K,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableMap<K, V>> com.google.common.collect.ImmutableSortedMap.toImmutableMap(java.util.function.Function<? super T, ? extends K>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableSortedMap.toImmutableMap(keyFunction, valueFunction))

    @staticmethod
    @overload
    def of() -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of()"""
        return ImmutableMap.__wrap(__ImmutableMap.of())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.builder()"""
        return Builder.__wrap(__ImmutableSortedMap.builder())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2))

    @staticmethod
    @overload
    def ofEntries(*entries: 'Entry.Map$Entry') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.ofEntries(java.util.Map$Entry<? extends K, ? extends V>...)"""
        return ImmutableMap.__wrap(__ImmutableMap.ofEntries(entries))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ImmutableSortedMap.size()"""
        return int.__wrap(super(ImmutableSortedMap, self).size())

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable') -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return ImmutableMap.__wrap(__ImmutableMap.copyOf(entries))

    @staticmethod
    @overload
    def copyOf(entries: 'Iterable', comparator: 'Comparator') -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.copyOf(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>,java.util.Comparator<? super K>)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.copyOf(entries, comparator))

    @overload
    def headMap(self, toKey: object) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.headMap(K)"""
        return 'ImmutableSortedMap'.__wrap(super(__ImmutableSortedMap, self).headMap(toKey))

    @overload
    def putLast(self, arg0: object, arg1: object) -> object:
        """public default V java.util.SortedMap.putLast(K,V)"""
        return object.__wrap(super(__SortedMap, self).putLast(arg0, arg1))

    @overload
    def ceilingEntry(self, key: object) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.ceilingEntry(K)"""
        return 'Entry.Map$Entry'.__wrap(super(__ImmutableSortedMap, self).ceilingEntry(key))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object, k9: object, v9: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @staticmethod
    @overload
    def builderWithExpectedSize(expectedSize: int) -> 'Builder':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap$Builder<K, V> com.google.common.collect.ImmutableSortedMap.builderWithExpectedSize(int)"""
        return Builder.__wrap(__ImmutableSortedMap.builderWithExpectedSize(__int.valueOf(expectedSize)))

    @overload
    def put(self, k: object, v: object) -> object:
        """public final V com.google.common.collect.ImmutableMap.put(K,V)"""
        return object.__wrap(super(__ImmutableMap, self).put(k, v))

    @override
    @overload
    def lastKey(self) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.lastKey()"""
        return object.__wrap(super(ImmutableSortedMap, self).lastKey())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ImmutableMap.toString()"""
        return str.__wrap(super(ImmutableMap, self).toString())

    @override
    @overload
    def putAll(self, map: 'Map'):
        """public final void com.google.common.collect.ImmutableMap.putAll(java.util.Map<? extends K, ? extends V>)"""
        super(__ImmutableMap, self).putAll(map)

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object, k7: 'Comparable', v7: object, k8: 'Comparable', v8: object, k9: 'Comparable', v9: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9))

    @overload
    def higherKey(self, key: object) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.higherKey(K)"""
        return object.__wrap(super(__ImmutableSortedMap, self).higherKey(key))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableMap':
        """public static <K,V> com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableMap.__wrap(__ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @overload
    def ceilingKey(self, key: object) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.ceilingKey(K)"""
        return object.__wrap(super(__ImmutableSortedMap, self).ceilingKey(key))

    @staticmethod
    @overload
    def of(k1: 'Comparable', v1: object, k2: 'Comparable', v2: object, k3: 'Comparable', v3: object, k4: 'Comparable', v4: object, k5: 'Comparable', v5: object, k6: 'Comparable', v6: object, k7: 'Comparable', v7: object) -> 'ImmutableSortedMap':
        """public static <K extends java.lang.Comparable<? super K>,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @staticmethod
    @overload
    def of() -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of()"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of())

    @staticmethod
    @overload
    def of(k1: object, v1: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1))

    @override
    @overload
    def firstKey(self) -> object:
        """public K com.google.common.collect.ImmutableSortedMap.firstKey()"""
        return object.__wrap(super(ImmutableSortedMap, self).firstKey())

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object, k8: object, v8: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8))

    @override
    @overload
    def descendingMap(self) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.descendingMap()"""
        return 'ImmutableSortedMap'.__wrap(super(ImmutableSortedMap, self).descendingMap())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def headMap(self, toKey: object, inclusive: bool) -> 'ImmutableSortedMap':
        """public com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.headMap(K,boolean)"""
        return 'ImmutableSortedMap'.__wrap(super(__ImmutableSortedMap, self).headMap(toKey, __boolean.valueOf(inclusive)))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6))

    @overload
    def computeIfAbsent(self, key: object, mappingFunction: 'Function') -> object:
        """public final V com.google.common.collect.ImmutableMap.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__ImmutableMap, self).computeIfAbsent(key, mappingFunction))

    @staticmethod
    @overload
    def of(k1: object, v1: object, k2: object, v2: object, k3: object, v3: object, k4: object, v4: object, k5: object, v5: object, k6: object, v6: object, k7: object, v7: object) -> 'ImmutableSortedMap':
        """public static <K,V> com.google.common.collect.ImmutableSortedMap<K, V> com.google.common.collect.ImmutableSortedMap.of(K,V,K,V,K,V,K,V,K,V,K,V,K,V)"""
        return ImmutableSortedMap.__wrap(__ImmutableSortedMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7))

    @override
    @overload
    def firstEntry(self) -> 'Entry.Map$Entry':
        """public java.util.Map$Entry<K, V> com.google.common.collect.ImmutableSortedMap.firstEntry()"""
        return 'Entry.Map$Entry'.__wrap(super(ImmutableSortedMap, self).firstEntry()) 
 
 
# CLASS: com.google.common.collect.ImmutableMap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import com.google.common.collect.ImmutableMap as __ImmutableMap_Builder
__Builder = __ImmutableMap_Builder.Builder
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.Map as Map
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableMap.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).put(entry))

    @overload
    def putAll(self, map: 'Map') -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.putAll(java.util.Map<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(map))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(entries))

    @overload
    def build(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap$Builder.build()"""
        return 'ImmutableMap'.__wrap(super(Builder, self).build())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.put(K,V)"""
        return 'Builder'.__wrap(super(__Builder, self).put(key, value))

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableMap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def buildKeepingLast(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap$Builder.buildKeepingLast()"""
        return 'ImmutableMap'.__wrap(super(Builder, self).buildKeepingLast())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def buildOrThrow(self) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<K, V> com.google.common.collect.ImmutableMap$Builder.buildOrThrow()"""
        return 'ImmutableMap'.__wrap(super(Builder, self).buildOrThrow())

    @overload
    def orderEntriesByValue(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableMap$Builder<K, V> com.google.common.collect.ImmutableMap$Builder.orderEntriesByValue(java.util.Comparator<? super V>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderEntriesByValue(valueComparator))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableMap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableSet
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
import java.lang.Boolean as __boolean
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingSet as __ForwardingSet
__ForwardingSet = __ForwardingSet
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.SortedSet as SortedSet
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import com.google.common.collect.ForwardingSortedSet as __ForwardingSortedSet
__ForwardingSortedSet = __ForwardingSortedSet
import java.util.Comparator as Comparator
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import com.google.common.collect.ForwardingNavigableSet as __ForwardingNavigableSet
__ForwardingNavigableSet = __ForwardingNavigableSet
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ForwardingNavigableSet(ABC):
    """com.google.common.collect.ForwardingNavigableSet"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingNavigableSet) -> 'ForwardingNavigableSet':
        return ForwardingNavigableSet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingNavigableSet):
        """
        Dynamic initializer for ForwardingNavigableSet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingNavigableSet.descendingIterator()"""
        return 'Iterator'.__wrap(super(ForwardingNavigableSet, self).descendingIterator())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.headSet(E)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSet, self).headSet(toElement))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingSet.hashCode()"""
        return int.__wrap(super(ForwardingSet, self).hashCode())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(__SortedSet, self).addLast(arg0)

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'.__wrap(super(NavigableSet, self).reversed())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object.__wrap(super(SortedSet, self).getFirst())

    @overload
    def ceiling(self, e: object) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.ceiling(E)"""
        return object.__wrap(super(__ForwardingNavigableSet, self).ceiling(e))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object.__wrap(super(NavigableSet, self).removeFirst())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(__SortedSet, self).addFirst(arg0)

    @overload
    def higher(self, e: object) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.higher(E)"""
        return object.__wrap(super(__ForwardingNavigableSet, self).higher(e))

    @override
    @overload
    def first(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.first()"""
        return object.__wrap(super(ForwardingSortedSet, self).first())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def floor(self, e: object) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.floor(E)"""
        return object.__wrap(super(__ForwardingNavigableSet, self).floor(e))

    @override
    @overload
    def last(self) -> object:
        """public E com.google.common.collect.ForwardingSortedSet.last()"""
        return object.__wrap(super(ForwardingSortedSet, self).last())

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.tailSet(E)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSet, self).tailSet(fromElement))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'.__wrap(super(SortedSet, self).spliterator())

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingNavigableSet.tailSet(E,boolean)"""
        return 'NavigableSet'.__wrap(super(__ForwardingNavigableSet, self).tailSet(fromElement, __boolean.valueOf(inclusive)))

    @overload
    def lower(self, e: object) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.lower(E)"""
        return object.__wrap(super(__ForwardingNavigableSet, self).lower(e))

    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.pollFirst()"""
        return object.__wrap(super(ForwardingNavigableSet, self).pollFirst())

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.ForwardingSortedSet.comparator()"""
        return 'Comparator'.__wrap(super(ForwardingSortedSet, self).comparator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object.__wrap(super(SortedSet, self).getLast())

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingSet, self).equals(object))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<E> com.google.common.collect.ForwardingSortedSet.subSet(E,E)"""
        return 'SortedSet'.__wrap(super(__ForwardingSortedSet, self).subSet(fromElement, toElement))

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingNavigableSet.headSet(E,boolean)"""
        return 'NavigableSet'.__wrap(super(__ForwardingNavigableSet, self).headSet(toElement, __boolean.valueOf(inclusive)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object.__wrap(super(NavigableSet, self).removeLast())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingNavigableSet.subSet(E,boolean,E,boolean)"""
        return 'NavigableSet'.__wrap(super(__ForwardingNavigableSet, self).subSet(fromElement, __boolean.valueOf(fromInclusive), toElement, __boolean.valueOf(toInclusive)))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.ForwardingNavigableSet.pollLast()"""
        return object.__wrap(super(ForwardingNavigableSet, self).pollLast())

    @override
    @overload
    def descendingSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<E> com.google.common.collect.ForwardingNavigableSet.descendingSet()"""
        return 'NavigableSet'.__wrap(super(ForwardingNavigableSet, self).descendingSet())

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.ForwardingNavigableMap$StandardNavigableKeySet
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingNavigableMap as __ForwardingNavigableMap_StandardNavigableKeySet
__StandardNavigableKeySet = __ForwardingNavigableMap_StandardNavigableKeySet.StandardNavigableKeySet
import java.lang.Boolean as __boolean
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.SortedSet as __SortedSet
__SortedSet = __SortedSet
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import com.google.common.collect.Sets as __Sets_ImprovedAbstractSet
__ImprovedAbstractSet = __Sets_ImprovedAbstractSet.ImprovedAbstractSet
from builtins import bool
import java.util.AbstractSet as __AbstractSet
__AbstractSet = __AbstractSet
from builtins import str
import com.google.common.collect.Maps as __Maps_NavigableKeySet
__NavigableKeySet = __Maps_NavigableKeySet.NavigableKeySet
from pyquantum_helper import override
import java.util.NavigableSet as NavigableSet
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.SortedSet as SortedSet
import com.google.common.collect.Maps as __Maps_KeySet
__KeySet = __Maps_KeySet.KeySet
from builtins import object
import java.util.Iterator as Iterator
import com.google.common.collect.Maps as __Maps_SortedKeySet
__SortedKeySet = __Maps_SortedKeySet.SortedKeySet
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.util.NavigableSet as __NavigableSet
__NavigableSet = __NavigableSet
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
 
class StandardNavigableKeySet():
    """com.google.common.collect.ForwardingNavigableMap.StandardNavigableKeySet"""
 
    @staticmethod
    def __wrap(java_value: __StandardNavigableKeySet) -> 'StandardNavigableKeySet':
        return StandardNavigableKeySet(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __StandardNavigableKeySet):
        """
        Dynamic initializer for StandardNavigableKeySet.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def higher(self, e: object) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.higher(K)"""
        return object.__wrap(super(__NavigableKeySet, self).higher(e))

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.google.common.collect.Maps$KeySet.iterator()"""
        return 'Iterator'.__wrap(super(KeySet, self).iterator())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @overload
    def lower(self, e: object) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.lower(K)"""
        return object.__wrap(super(__NavigableKeySet, self).lower(e))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super K> com.google.common.collect.Maps$SortedKeySet.comparator()"""
        return 'Comparator'.__wrap(super(SortedKeySet, self).comparator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def add(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.add(E)"""
        return bool.__wrap(super(__AbstractCollection, self).add(arg0))

    @overload
    def __init__(self, this$0: 'ForwardingNavigableMap'):
        """public com.google.common.collect.ForwardingNavigableMap$StandardNavigableKeySet(com.google.common.collect.ForwardingNavigableMap)"""
        val = __StandardNavigableKeySet(this$0)
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @override
    @overload
    def pollFirst(self) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.pollFirst()"""
        return object.__wrap(super(NavigableKeySet, self).pollFirst())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def addAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractCollection, self).addAll(arg0))

    @overload
    def ceiling(self, e: object) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.ceiling(K)"""
        return object.__wrap(super(__NavigableKeySet, self).ceiling(e))

    @override
    @overload
    def addLast(self, arg0: object):
        """public default void java.util.SortedSet.addLast(E)"""
        super(__SortedSet, self).addLast(arg0)

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def reversed(self) -> 'NavigableSet':
        """public default java.util.NavigableSet<E> java.util.NavigableSet.reversed()"""
        return 'NavigableSet'.__wrap(super(NavigableSet, self).reversed())

    @override
    @overload
    def getFirst(self) -> object:
        """public default E java.util.SortedSet.getFirst()"""
        return object.__wrap(super(SortedSet, self).getFirst())

    @overload
    def retainAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).retainAll(c))

    @override
    @overload
    def removeFirst(self) -> object:
        """public default E java.util.NavigableSet.removeFirst()"""
        return object.__wrap(super(NavigableSet, self).removeFirst())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def addFirst(self, arg0: object):
        """public default void java.util.SortedSet.addFirst(E)"""
        super(__SortedSet, self).addFirst(arg0)

    @overload
    def floor(self, e: object) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.floor(K)"""
        return object.__wrap(super(__NavigableKeySet, self).floor(e))

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<K> com.google.common.collect.Maps$NavigableKeySet.descendingIterator()"""
        return 'Iterator'.__wrap(super(NavigableKeySet, self).descendingIterator())

    @overload
    def subSet(self, fromElement: object, fromInclusive: bool, toElement: object, toInclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$NavigableKeySet.subSet(K,boolean,K,boolean)"""
        return 'NavigableSet'.__wrap(super(__NavigableKeySet, self).subSet(fromElement, __boolean.valueOf(fromInclusive), toElement, __boolean.valueOf(toInclusive)))

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public void com.google.common.collect.Maps$KeySet.forEach(java.util.function.Consumer<? super K>)"""
        super(__KeySet, self).forEach(action)

    @override
    @overload
    def descendingSet(self) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$NavigableKeySet.descendingSet()"""
        return 'NavigableSet'.__wrap(super(NavigableKeySet, self).descendingSet())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.Maps$KeySet.clear()"""
        super(KeySet, self).clear()

    @overload
    def headSet(self, toElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$NavigableKeySet.headSet(K,boolean)"""
        return 'NavigableSet'.__wrap(super(__NavigableKeySet, self).headSet(toElement, __boolean.valueOf(inclusive)))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.SortedSet.spliterator()"""
        return 'Spliterator'.__wrap(super(SortedSet, self).spliterator())

    @overload
    def remove(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.remove(java.lang.Object)"""
        return bool.__wrap(super(__KeySet, self).remove(o))

    @overload
    def contains(self, o: object) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.contains(java.lang.Object)"""
        return bool.__wrap(super(__KeySet, self).contains(o))

    @overload
    def tailSet(self, fromElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$NavigableKeySet.tailSet(K)"""
        return 'SortedSet'.__wrap(super(__NavigableKeySet, self).tailSet(fromElement))

    @overload
    def removeAll(self, c: 'Collection') -> bool:
        """public boolean com.google.common.collect.Sets$ImprovedAbstractSet.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ImprovedAbstractSet, self).removeAll(c))

    @override
    @overload
    def getLast(self) -> object:
        """public default E java.util.SortedSet.getLast()"""
        return object.__wrap(super(SortedSet, self).getLast())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @override
    @overload
    def first(self) -> object:
        """public K com.google.common.collect.Maps$SortedKeySet.first()"""
        return object.__wrap(super(SortedKeySet, self).first())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.Maps$KeySet.isEmpty()"""
        return bool.__wrap(super(KeySet, self).isEmpty())

    @overload
    def tailSet(self, fromElement: object, inclusive: bool) -> 'NavigableSet':
        """public java.util.NavigableSet<K> com.google.common.collect.Maps$NavigableKeySet.tailSet(K,boolean)"""
        return 'NavigableSet'.__wrap(super(__NavigableKeySet, self).tailSet(fromElement, __boolean.valueOf(inclusive)))

    @override
    @overload
    def pollLast(self) -> object:
        """public K com.google.common.collect.Maps$NavigableKeySet.pollLast()"""
        return object.__wrap(super(NavigableKeySet, self).pollLast())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @overload
    def subSet(self, fromElement: object, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$NavigableKeySet.subSet(K,K)"""
        return 'SortedSet'.__wrap(super(__NavigableKeySet, self).subSet(fromElement, toElement))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def removeLast(self) -> object:
        """public default E java.util.NavigableSet.removeLast()"""
        return object.__wrap(super(NavigableSet, self).removeLast())

    @overload
    def headSet(self, toElement: object) -> 'SortedSet':
        """public java.util.SortedSet<K> com.google.common.collect.Maps$NavigableKeySet.headSet(K)"""
        return 'SortedSet'.__wrap(super(__NavigableKeySet, self).headSet(toElement))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.Maps$KeySet.size()"""
        return int.__wrap(super(KeySet, self).size())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @override
    @overload
    def last(self) -> object:
        """public K com.google.common.collect.Maps$SortedKeySet.last()"""
        return object.__wrap(super(SortedKeySet, self).last())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.util.AbstractSet.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractSet, self).equals(arg0))

    @override
    @overload
    def hashCode(self) -> int:
        """public int java.util.AbstractSet.hashCode()"""
        return int.__wrap(super(AbstractSet, self).hashCode()) 
 
 
# CLASS: com.google.common.collect.ImmutableSetMultimap$Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
from builtins import object
import com.google.common.collect.ImmutableSetMultimap as __ImmutableSetMultimap
__ImmutableSetMultimap = __ImmutableSetMultimap
import java.util.Comparator as Comparator
import java.util.Map.Entry as Entry
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ImmutableSetMultimap as __ImmutableSetMultimap_Builder
__Builder = __ImmutableSetMultimap_Builder.Builder
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class Builder():
    """com.google.common.collect.ImmutableSetMultimap.Builder"""
 
    @staticmethod
    def __wrap(java_value: __Builder) -> 'Builder':
        return Builder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Builder):
        """
        Dynamic initializer for Builder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @overload
    def putAll(self, multimap: 'Multimap') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.putAll(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(multimap))

    @overload
    def __init__(self, ):
        """public com.google.common.collect.ImmutableSetMultimap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def put(self, key: object, value: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.put(K,V)"""
        return 'Builder'.__wrap(super(__Builder, self).put(key, value))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @overload
    def __init__(self):
        """public com.google.common.collect.ImmutableSetMultimap$Builder()"""
        val = __Builder()
        self.__dict__ = val.__dict__
        self.__wrapper = val

    @overload
    def orderValuesBy(self, valueComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.orderValuesBy(java.util.Comparator<? super V>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderValuesBy(valueComparator))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def orderKeysBy(self, keyComparator: 'Comparator') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.orderKeysBy(java.util.Comparator<? super K>)"""
        return 'Builder'.__wrap(super(__Builder, self).orderKeysBy(keyComparator))

    @overload
    def putAll(self, entries: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.putAll(java.lang.Iterable<? extends java.util.Map$Entry<? extends K, ? extends V>>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(entries))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def putAll(self, key: object, *values: object) -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.putAll(K,V...)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(key, values))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def put(self, entry: 'Entry') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.put(java.util.Map$Entry<? extends K, ? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).put(entry))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def putAll(self, key: object, values: 'Iterable') -> 'Builder':
        """public com.google.common.collect.ImmutableSetMultimap$Builder<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.putAll(K,java.lang.Iterable<? extends V>)"""
        return 'Builder'.__wrap(super(__Builder, self).putAll(key, values))

    @override
    @overload
    def build(self) -> 'ImmutableSetMultimap':
        """public com.google.common.collect.ImmutableSetMultimap<K, V> com.google.common.collect.ImmutableSetMultimap$Builder.build()"""
        return 'ImmutableSetMultimap'.__wrap(super(Builder, self).build()) 
 
 
# CLASS: com.google.common.collect.MinMaxPriorityQueue
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import com.google.common.collect.MinMaxPriorityQueue as __MinMaxPriorityQueue
__MinMaxPriorityQueue = __MinMaxPriorityQueue
import java.util.function.Consumer as Consumer
import java.util.Comparator as __Comparator
__Comparator = __Comparator
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
import java.util.AbstractQueue as __AbstractQueue
__AbstractQueue = __AbstractQueue
from builtins import bool
import com.google.common.collect.MinMaxPriorityQueue as __MinMaxPriorityQueue_Builder
__Builder = __MinMaxPriorityQueue_Builder.Builder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class MinMaxPriorityQueue():
    """com.google.common.collect.MinMaxPriorityQueue"""
 
    @staticmethod
    def __wrap(java_value: __MinMaxPriorityQueue) -> 'MinMaxPriorityQueue':
        return MinMaxPriorityQueue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __MinMaxPriorityQueue):
        """
        Dynamic initializer for MinMaxPriorityQueue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.util.AbstractCollection.toString()"""
        return str.__wrap(super(AbstractCollection, self).toString())

    @overload
    def offer(self, element: object) -> bool:
        """public boolean com.google.common.collect.MinMaxPriorityQueue.offer(E)"""
        return bool.__wrap(super(__MinMaxPriorityQueue, self).offer(element))

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.peek()"""
        return object.__wrap(super(MinMaxPriorityQueue, self).peek())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def peekFirst(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.peekFirst()"""
        return object.__wrap(super(MinMaxPriorityQueue, self).peekFirst())

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.MinMaxPriorityQueue.toArray()"""
        return List[object].__wrap(super(MinMaxPriorityQueue, self).toArray())

    @overload
    def peekLast(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.peekLast()"""
        return object.__wrap(super(MinMaxPriorityQueue, self).peekLast())

    @staticmethod
    @overload
    def expectedSize(expectedSize: int) -> 'Builder':
        """public static com.google.common.collect.MinMaxPriorityQueue$Builder<java.lang.Comparable> com.google.common.collect.MinMaxPriorityQueue.expectedSize(int)"""
        return Builder.__wrap(__MinMaxPriorityQueue.expectedSize(__int.valueOf(expectedSize)))

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.pollFirst()"""
        return object.__wrap(super(MinMaxPriorityQueue, self).pollFirst())

    @overload
    def retainAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).retainAll(arg0))

    @override
    @overload
    def remove(self) -> object:
        """public E java.util.AbstractQueue.remove()"""
        return object.__wrap(super(AbstractQueue, self).remove())

    @overload
    def removeAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).removeAll(arg0))

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.poll()"""
        return object.__wrap(super(MinMaxPriorityQueue, self).poll())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def removeLast(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.removeLast()"""
        return object.__wrap(super(MinMaxPriorityQueue, self).removeLast())

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.MinMaxPriorityQueue.add(E)"""
        return bool.__wrap(super(__MinMaxPriorityQueue, self).add(element))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'.__wrap(super(Collection, self).spliterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def comparator(self) -> 'Comparator':
        """public java.util.Comparator<? super E> com.google.common.collect.MinMaxPriorityQueue.comparator()"""
        return 'Comparator'.__wrap(super(MinMaxPriorityQueue, self).comparator())

    @staticmethod
    @overload
    def maximumSize(maximumSize: int) -> 'Builder':
        """public static com.google.common.collect.MinMaxPriorityQueue$Builder<java.lang.Comparable> com.google.common.collect.MinMaxPriorityQueue.maximumSize(int)"""
        return Builder.__wrap(__MinMaxPriorityQueue.maximumSize(__int.valueOf(maximumSize)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.pollLast()"""
        return object.__wrap(super(MinMaxPriorityQueue, self).pollLast())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean java.util.AbstractCollection.isEmpty()"""
        return bool.__wrap(super(AbstractCollection, self).isEmpty())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.MinMaxPriorityQueue.clear()"""
        super(MinMaxPriorityQueue, self).clear()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.MinMaxPriorityQueue.size()"""
        return int.__wrap(super(MinMaxPriorityQueue, self).size())

    @overload
    def removeFirst(self) -> object:
        """public E com.google.common.collect.MinMaxPriorityQueue.removeFirst()"""
        return object.__wrap(super(MinMaxPriorityQueue, self).removeFirst())

    @override
    @overload
    def element(self) -> object:
        """public E java.util.AbstractQueue.element()"""
        return object.__wrap(super(AbstractQueue, self).element())

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.MinMaxPriorityQueue.iterator()"""
        return 'Iterator'.__wrap(super(MinMaxPriorityQueue, self).iterator())

    @staticmethod
    @overload
    def create() -> 'MinMaxPriorityQueue':
        """public static <E extends java.lang.Comparable<E>> com.google.common.collect.MinMaxPriorityQueue<E> com.google.common.collect.MinMaxPriorityQueue.create()"""
        return MinMaxPriorityQueue.__wrap(__MinMaxPriorityQueue.create())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def orderedBy(comparator: 'Comparator') -> 'Builder':
        """public static <B> com.google.common.collect.MinMaxPriorityQueue$Builder<B> com.google.common.collect.MinMaxPriorityQueue.orderedBy(java.util.Comparator<B>)"""
        return Builder.__wrap(__MinMaxPriorityQueue.orderedBy(comparator))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @staticmethod
    @overload
    def create(initialContents: 'Iterable') -> 'MinMaxPriorityQueue':
        """public static <E extends java.lang.Comparable<E>> com.google.common.collect.MinMaxPriorityQueue<E> com.google.common.collect.MinMaxPriorityQueue.create(java.lang.Iterable<? extends E>)"""
        return MinMaxPriorityQueue.__wrap(__MinMaxPriorityQueue.create(initialContents))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def remove(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__AbstractCollection, self).remove(arg0))

    @overload
    def addAll(self, newElements: 'Collection') -> bool:
        """public boolean com.google.common.collect.MinMaxPriorityQueue.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__MinMaxPriorityQueue, self).addAll(newElements))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def contains(self, arg0: object) -> bool:
        """public boolean java.util.AbstractCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__AbstractCollection, self).contains(arg0)) 
 
 
# CLASS: com.google.common.collect.Queues
import java.util.concurrent.LinkedBlockingQueue as LinkedBlockingQueue
import java.util.concurrent.PriorityBlockingQueue as PriorityBlockingQueue
import java.util.concurrent.LinkedBlockingDeque as __LinkedBlockingDeque
__LinkedBlockingDeque = __LinkedBlockingDeque
from builtins import type
import java.util.Deque as __Deque
__Deque = __Deque
import java.util.concurrent.LinkedBlockingQueue as __LinkedBlockingQueue
__LinkedBlockingQueue = __LinkedBlockingQueue
import java.util.concurrent.ArrayBlockingQueue as __ArrayBlockingQueue
__ArrayBlockingQueue = __ArrayBlockingQueue
import java.util.Collection as Collection
import java.util.concurrent.SynchronousQueue as __SynchronousQueue
__SynchronousQueue = __SynchronousQueue
import java.util.PriorityQueue as __PriorityQueue
__PriorityQueue = __PriorityQueue
import java.lang.Class as __Class
__Class = __Class
import java.util.concurrent.ArrayBlockingQueue as ArrayBlockingQueue
import java.util.concurrent.ConcurrentLinkedQueue as __ConcurrentLinkedQueue
__ConcurrentLinkedQueue = __ConcurrentLinkedQueue
import java.util.concurrent.ConcurrentLinkedQueue as ConcurrentLinkedQueue
import java.util.concurrent.SynchronousQueue as SynchronousQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import com.google.common.collect.Queues as __Queues
__Queues = __Queues
import java.util.concurrent.PriorityBlockingQueue as __PriorityBlockingQueue
__PriorityBlockingQueue = __PriorityBlockingQueue
import java.util.Deque as Deque
import java.lang.Iterable as Iterable
import java.time.Duration as Duration
import java.util.Queue as Queue
import java.util.Queue as __Queue
__Queue = __Queue
import java.util.concurrent.BlockingQueue as BlockingQueue
import java.lang.Long as __long
import java.util.concurrent.TimeUnit as TimeUnit
import java.lang.String as __String
__String = __String
import java.util.PriorityQueue as PriorityQueue
import java.lang.Object as __Object
__Object = __Object
import java.util.ArrayDeque as ArrayDeque
import java.lang.Integer as __int
import java.util.ArrayDeque as __ArrayDeque
__ArrayDeque = __ArrayDeque
import java.util.concurrent.LinkedBlockingDeque as LinkedBlockingDeque
from builtins import int
 
class Queues():
    """com.google.common.collect.Queues"""
 
    @staticmethod
    def __wrap(java_value: __Queues) -> 'Queues':
        return Queues(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Queues):
        """
        Dynamic initializer for Queues.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def drain(q: 'BlockingQueue', buffer: 'Collection', numElements: int, timeout: int, unit: 'TimeUnit') -> int:
        """public static <E> int com.google.common.collect.Queues.drain(java.util.concurrent.BlockingQueue<E>,java.util.Collection<? super E>,int,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return int.__wrap(__Queues.drain(q, buffer, __int.valueOf(numElements), __long.valueOf(timeout), unit))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def drainUninterruptibly(q: 'BlockingQueue', buffer: 'Collection', numElements: int, timeout: 'Duration') -> int:
        """public static <E> int com.google.common.collect.Queues.drainUninterruptibly(java.util.concurrent.BlockingQueue<E>,java.util.Collection<? super E>,int,java.time.Duration)"""
        return int.__wrap(__Queues.drainUninterruptibly(q, buffer, __int.valueOf(numElements), timeout))

    @staticmethod
    @overload
    def newLinkedBlockingQueue(capacity: int) -> 'LinkedBlockingQueue':
        """public static <E> java.util.concurrent.LinkedBlockingQueue<E> com.google.common.collect.Queues.newLinkedBlockingQueue(int)"""
        return LinkedBlockingQueue.__wrap(__Queues.newLinkedBlockingQueue(__int.valueOf(capacity)))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def drain(q: 'BlockingQueue', buffer: 'Collection', numElements: int, timeout: 'Duration') -> int:
        """public static <E> int com.google.common.collect.Queues.drain(java.util.concurrent.BlockingQueue<E>,java.util.Collection<? super E>,int,java.time.Duration) throws java.lang.InterruptedException"""
        return int.__wrap(__Queues.drain(q, buffer, __int.valueOf(numElements), timeout))

    @staticmethod
    @overload
    def synchronizedQueue(queue: 'Queue') -> 'Queue':
        """public static <E> java.util.Queue<E> com.google.common.collect.Queues.synchronizedQueue(java.util.Queue<E>)"""
        return Queue.__wrap(__Queues.synchronizedQueue(queue))

    @staticmethod
    @overload
    def newPriorityBlockingQueue() -> 'PriorityBlockingQueue':
        """public static <E extends java.lang.Comparable> java.util.concurrent.PriorityBlockingQueue<E> com.google.common.collect.Queues.newPriorityBlockingQueue()"""
        return PriorityBlockingQueue.__wrap(__Queues.newPriorityBlockingQueue())

    @staticmethod
    @overload
    def newArrayDeque(elements: 'Iterable') -> 'ArrayDeque':
        """public static <E> java.util.ArrayDeque<E> com.google.common.collect.Queues.newArrayDeque(java.lang.Iterable<? extends E>)"""
        return ArrayDeque.__wrap(__Queues.newArrayDeque(elements))

    @staticmethod
    @overload
    def newPriorityBlockingQueue(elements: 'Iterable') -> 'PriorityBlockingQueue':
        """public static <E extends java.lang.Comparable> java.util.concurrent.PriorityBlockingQueue<E> com.google.common.collect.Queues.newPriorityBlockingQueue(java.lang.Iterable<? extends E>)"""
        return PriorityBlockingQueue.__wrap(__Queues.newPriorityBlockingQueue(elements))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def newLinkedBlockingDeque(elements: 'Iterable') -> 'LinkedBlockingDeque':
        """public static <E> java.util.concurrent.LinkedBlockingDeque<E> com.google.common.collect.Queues.newLinkedBlockingDeque(java.lang.Iterable<? extends E>)"""
        return LinkedBlockingDeque.__wrap(__Queues.newLinkedBlockingDeque(elements))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def newLinkedBlockingQueue() -> 'LinkedBlockingQueue':
        """public static <E> java.util.concurrent.LinkedBlockingQueue<E> com.google.common.collect.Queues.newLinkedBlockingQueue()"""
        return LinkedBlockingQueue.__wrap(__Queues.newLinkedBlockingQueue())

    @staticmethod
    @overload
    def newArrayBlockingQueue(capacity: int) -> 'ArrayBlockingQueue':
        """public static <E> java.util.concurrent.ArrayBlockingQueue<E> com.google.common.collect.Queues.newArrayBlockingQueue(int)"""
        return ArrayBlockingQueue.__wrap(__Queues.newArrayBlockingQueue(__int.valueOf(capacity)))

    @staticmethod
    @overload
    def newPriorityQueue() -> 'PriorityQueue':
        """public static <E extends java.lang.Comparable> java.util.PriorityQueue<E> com.google.common.collect.Queues.newPriorityQueue()"""
        return PriorityQueue.__wrap(__Queues.newPriorityQueue())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def newLinkedBlockingDeque() -> 'LinkedBlockingDeque':
        """public static <E> java.util.concurrent.LinkedBlockingDeque<E> com.google.common.collect.Queues.newLinkedBlockingDeque()"""
        return LinkedBlockingDeque.__wrap(__Queues.newLinkedBlockingDeque())

    @staticmethod
    @overload
    def newLinkedBlockingQueue(elements: 'Iterable') -> 'LinkedBlockingQueue':
        """public static <E> java.util.concurrent.LinkedBlockingQueue<E> com.google.common.collect.Queues.newLinkedBlockingQueue(java.lang.Iterable<? extends E>)"""
        return LinkedBlockingQueue.__wrap(__Queues.newLinkedBlockingQueue(elements))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def newConcurrentLinkedQueue() -> 'ConcurrentLinkedQueue':
        """public static <E> java.util.concurrent.ConcurrentLinkedQueue<E> com.google.common.collect.Queues.newConcurrentLinkedQueue()"""
        return ConcurrentLinkedQueue.__wrap(__Queues.newConcurrentLinkedQueue())

    @staticmethod
    @overload
    def newArrayDeque() -> 'ArrayDeque':
        """public static <E> java.util.ArrayDeque<E> com.google.common.collect.Queues.newArrayDeque()"""
        return ArrayDeque.__wrap(__Queues.newArrayDeque())

    @staticmethod
    @overload
    def drainUninterruptibly(q: 'BlockingQueue', buffer: 'Collection', numElements: int, timeout: int, unit: 'TimeUnit') -> int:
        """public static <E> int com.google.common.collect.Queues.drainUninterruptibly(java.util.concurrent.BlockingQueue<E>,java.util.Collection<? super E>,int,long,java.util.concurrent.TimeUnit)"""
        return int.__wrap(__Queues.drainUninterruptibly(q, buffer, __int.valueOf(numElements), __long.valueOf(timeout), unit))

    @staticmethod
    @overload
    def newLinkedBlockingDeque(capacity: int) -> 'LinkedBlockingDeque':
        """public static <E> java.util.concurrent.LinkedBlockingDeque<E> com.google.common.collect.Queues.newLinkedBlockingDeque(int)"""
        return LinkedBlockingDeque.__wrap(__Queues.newLinkedBlockingDeque(__int.valueOf(capacity)))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def newConcurrentLinkedQueue(elements: 'Iterable') -> 'ConcurrentLinkedQueue':
        """public static <E> java.util.concurrent.ConcurrentLinkedQueue<E> com.google.common.collect.Queues.newConcurrentLinkedQueue(java.lang.Iterable<? extends E>)"""
        return ConcurrentLinkedQueue.__wrap(__Queues.newConcurrentLinkedQueue(elements))

    @staticmethod
    @overload
    def newPriorityQueue(elements: 'Iterable') -> 'PriorityQueue':
        """public static <E extends java.lang.Comparable> java.util.PriorityQueue<E> com.google.common.collect.Queues.newPriorityQueue(java.lang.Iterable<? extends E>)"""
        return PriorityQueue.__wrap(__Queues.newPriorityQueue(elements))

    @staticmethod
    @overload
    def newSynchronousQueue() -> 'SynchronousQueue':
        """public static <E> java.util.concurrent.SynchronousQueue<E> com.google.common.collect.Queues.newSynchronousQueue()"""
        return SynchronousQueue.__wrap(__Queues.newSynchronousQueue())

    @staticmethod
    @overload
    def synchronizedDeque(deque: 'Deque') -> 'Deque':
        """public static <E> java.util.Deque<E> com.google.common.collect.Queues.synchronizedDeque(java.util.Deque<E>)"""
        return Deque.__wrap(__Queues.synchronizedDeque(deque)) 
 
 
# CLASS: com.google.common.collect.Iterators
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

import java.util.Enumeration as __Enumeration
__Enumeration = __Enumeration
from builtins import type
import java.util.Collection as Collection
import java.lang.Class as __Class
__Class = __Class
import java.util.Enumeration as Enumeration
from builtins import bool
import com.google.common.collect.UnmodifiableIterator as __UnmodifiableIterator
__UnmodifiableIterator = __UnmodifiableIterator
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.lang.Iterable as Iterable
import com.google.common.collect.PeekingIterator as __PeekingIterator
__PeekingIterator = __PeekingIterator
import com.google.common.collect.Iterators as __Iterators
__Iterators = __Iterators
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import com.google.common.base.Optional as __Optional
__Optional = __Optional
from builtins import int
 
class Iterators():
    """com.google.common.collect.Iterators"""
 
    @staticmethod
    def __wrap(java_value: __Iterators) -> 'Iterators':
        return Iterators(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Iterators):
        """
        Dynamic initializer for Iterators.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def getLast(iterator: 'Iterator', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.getLast(java.util.Iterator<? extends T>,T)"""
        return object.__wrap(__Iterators.getLast(iterator, defaultValue))

    @staticmethod
    @overload
    def consumingIterator(iterator: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.consumingIterator(java.util.Iterator<T>)"""
        return Iterator.__wrap(__Iterators.consumingIterator(iterator))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def forEnumeration(enumeration: 'Enumeration') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.forEnumeration(java.util.Enumeration<T>)"""
        return UnmodifiableIterator.__wrap(__Iterators.forEnumeration(enumeration))

    @staticmethod
    @overload
    def size(iterator: 'Iterator') -> int:
        """public static int com.google.common.collect.Iterators.size(java.util.Iterator<?>)"""
        return int.__wrap(__Iterators.size(iterator))

    @staticmethod
    @overload
    def filter(unfiltered: 'Iterator', desiredType: 'Class') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.filter(java.util.Iterator<?>,java.lang.Class<T>)"""
        return UnmodifiableIterator.__wrap(__Iterators.filter(unfiltered, desiredType))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def all(iterator: 'Iterator', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterators.all(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return bool.__wrap(__Iterators.all(iterator, predicate))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def addAll(addTo: 'Collection', iterator: 'Iterator') -> bool:
        """public static <T> boolean com.google.common.collect.Iterators.addAll(java.util.Collection<T>,java.util.Iterator<? extends T>)"""
        return bool.__wrap(__Iterators.addAll(addTo, iterator))

    @staticmethod
    @overload
    def toArray(iterator: 'Iterator', type: 'Class') -> List[object]:
        """public static <T> T[] com.google.common.collect.Iterators.toArray(java.util.Iterator<? extends T>,java.lang.Class<T>)"""
        return List[object].__wrap(__Iterators.toArray(iterator, type))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def cycle(iterable: 'Iterable') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.cycle(java.lang.Iterable<T>)"""
        return Iterator.__wrap(__Iterators.cycle(iterable))

    @staticmethod
    @overload
    def concat(a: 'Iterator', b: 'Iterator', c: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends T>,java.util.Iterator<? extends T>,java.util.Iterator<? extends T>)"""
        return Iterator.__wrap(__Iterators.concat(a, b, c))

    @staticmethod
    @overload
    def unmodifiableIterator(iterator: 'UnmodifiableIterator') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.unmodifiableIterator(com.google.common.collect.UnmodifiableIterator<T>)"""
        return UnmodifiableIterator.__wrap(__Iterators.unmodifiableIterator(iterator))

    @staticmethod
    @overload
    def concat(*inputs: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends T>...)"""
        return Iterator.__wrap(__Iterators.concat(inputs))

    @staticmethod
    @overload
    def transform(fromIterator: 'Iterator', function: 'Function') -> 'Iterator':
        """public static <F,T> java.util.Iterator<T> com.google.common.collect.Iterators.transform(java.util.Iterator<F>,com.google.common.base.Function<? super F, ? extends T>)"""
        return Iterator.__wrap(__Iterators.transform(fromIterator, function))

    @staticmethod
    @overload
    def filter(unfiltered: 'Iterator', retainIfTrue: 'Predicate') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.filter(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return UnmodifiableIterator.__wrap(__Iterators.filter(unfiltered, retainIfTrue))

    @staticmethod
    @overload
    def get(iterator: 'Iterator', position: int) -> object:
        """public static <T> T com.google.common.collect.Iterators.get(java.util.Iterator<T>,int)"""
        return object.__wrap(__Iterators.get(iterator, __int.valueOf(position)))

    @staticmethod
    @overload
    def singletonIterator(value: object) -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.singletonIterator(T)"""
        return UnmodifiableIterator.__wrap(__Iterators.singletonIterator(value))

    @staticmethod
    @overload
    def retainAll(removeFrom: 'Iterator', elementsToRetain: 'Collection') -> bool:
        """public static boolean com.google.common.collect.Iterators.retainAll(java.util.Iterator<?>,java.util.Collection<?>)"""
        return bool.__wrap(__Iterators.retainAll(removeFrom, elementsToRetain))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def removeIf(removeFrom: 'Iterator', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterators.removeIf(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return bool.__wrap(__Iterators.removeIf(removeFrom, predicate))

    @staticmethod
    @overload
    def forArray(*array: object) -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.forArray(T...)"""
        return UnmodifiableIterator.__wrap(__Iterators.forArray(array))

    @staticmethod
    @overload
    def contains(iterator: 'Iterator', element: object) -> bool:
        """public static boolean com.google.common.collect.Iterators.contains(java.util.Iterator<?>,java.lang.Object)"""
        return bool.__wrap(__Iterators.contains(iterator, element))

    @staticmethod
    @overload
    def peekingIterator(iterator: 'PeekingIterator') -> 'PeekingIterator':
        """public static <T> com.google.common.collect.PeekingIterator<T> com.google.common.collect.Iterators.peekingIterator(com.google.common.collect.PeekingIterator<T>)"""
        return PeekingIterator.__wrap(__Iterators.peekingIterator(iterator))

    @staticmethod
    @overload
    def getLast(iterator: 'Iterator') -> object:
        """public static <T> T com.google.common.collect.Iterators.getLast(java.util.Iterator<T>)"""
        return object.__wrap(__Iterators.getLast(iterator))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def getOnlyElement(iterator: 'Iterator', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.getOnlyElement(java.util.Iterator<? extends T>,T)"""
        return object.__wrap(__Iterators.getOnlyElement(iterator, defaultValue))

    @staticmethod
    @overload
    def mergeSorted(iterators: 'Iterable', comparator: 'Comparator') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.mergeSorted(java.lang.Iterable<? extends java.util.Iterator<? extends T>>,java.util.Comparator<? super T>)"""
        return UnmodifiableIterator.__wrap(__Iterators.mergeSorted(iterators, comparator))

    @staticmethod
    @overload
    def tryFind(iterator: 'Iterator', predicate: 'Predicate') -> 'base.Optional':
        """public static <T> com.google.common.base.Optional<T> com.google.common.collect.Iterators.tryFind(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return base.Optional.__wrap(__Iterators.tryFind(iterator, predicate))

    @staticmethod
    @overload
    def concat(a: 'Iterator', b: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends T>,java.util.Iterator<? extends T>)"""
        return Iterator.__wrap(__Iterators.concat(a, b))

    @staticmethod
    @overload
    def paddedPartition(iterator: 'Iterator', size: int) -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<java.util.List<T>> com.google.common.collect.Iterators.paddedPartition(java.util.Iterator<T>,int)"""
        return UnmodifiableIterator.__wrap(__Iterators.paddedPartition(iterator, __int.valueOf(size)))

    @staticmethod
    @overload
    def partition(iterator: 'Iterator', size: int) -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<java.util.List<T>> com.google.common.collect.Iterators.partition(java.util.Iterator<T>,int)"""
        return UnmodifiableIterator.__wrap(__Iterators.partition(iterator, __int.valueOf(size)))

    @staticmethod
    @overload
    def cycle(*elements: object) -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.cycle(T...)"""
        return Iterator.__wrap(__Iterators.cycle(elements))

    @staticmethod
    @overload
    def frequency(iterator: 'Iterator', element: object) -> int:
        """public static int com.google.common.collect.Iterators.frequency(java.util.Iterator<?>,java.lang.Object)"""
        return int.__wrap(__Iterators.frequency(iterator, element))

    @staticmethod
    @overload
    def limit(iterator: 'Iterator', limitSize: int) -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.limit(java.util.Iterator<T>,int)"""
        return Iterator.__wrap(__Iterators.limit(iterator, __int.valueOf(limitSize)))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def toString(iterator: 'Iterator') -> str:
        """public static java.lang.String com.google.common.collect.Iterators.toString(java.util.Iterator<?>)"""
        return str.__wrap(__Iterators.toString(iterator))

    @staticmethod
    @overload
    def get(iterator: 'Iterator', position: int, defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.get(java.util.Iterator<? extends T>,int,T)"""
        return object.__wrap(__Iterators.get(iterator, __int.valueOf(position), defaultValue))

    @staticmethod
    @overload
    def indexOf(iterator: 'Iterator', predicate: 'Predicate') -> int:
        """public static <T> int com.google.common.collect.Iterators.indexOf(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return int.__wrap(__Iterators.indexOf(iterator, predicate))

    @staticmethod
    @overload
    def find(iterator: 'Iterator', predicate: 'Predicate') -> object:
        """public static <T> T com.google.common.collect.Iterators.find(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return object.__wrap(__Iterators.find(iterator, predicate))

    @staticmethod
    @overload
    def any(iterator: 'Iterator', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterators.any(java.util.Iterator<T>,com.google.common.base.Predicate<? super T>)"""
        return bool.__wrap(__Iterators.any(iterator, predicate))

    @staticmethod
    @overload
    def concat(a: 'Iterator', b: 'Iterator', c: 'Iterator', d: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends T>,java.util.Iterator<? extends T>,java.util.Iterator<? extends T>,java.util.Iterator<? extends T>)"""
        return Iterator.__wrap(__Iterators.concat(a, b, c, d))

    @staticmethod
    @overload
    def getNext(iterator: 'Iterator', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.getNext(java.util.Iterator<? extends T>,T)"""
        return object.__wrap(__Iterators.getNext(iterator, defaultValue))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def asEnumeration(iterator: 'Iterator') -> 'Enumeration':
        """public static <T> java.util.Enumeration<T> com.google.common.collect.Iterators.asEnumeration(java.util.Iterator<T>)"""
        return Enumeration.__wrap(__Iterators.asEnumeration(iterator))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def removeAll(removeFrom: 'Iterator', elementsToRemove: 'Collection') -> bool:
        """public static boolean com.google.common.collect.Iterators.removeAll(java.util.Iterator<?>,java.util.Collection<?>)"""
        return bool.__wrap(__Iterators.removeAll(removeFrom, elementsToRemove))

    @staticmethod
    @overload
    def unmodifiableIterator(iterator: 'Iterator') -> 'UnmodifiableIterator':
        """public static <T> com.google.common.collect.UnmodifiableIterator<T> com.google.common.collect.Iterators.unmodifiableIterator(java.util.Iterator<? extends T>)"""
        return UnmodifiableIterator.__wrap(__Iterators.unmodifiableIterator(iterator))

    @staticmethod
    @overload
    def concat(inputs: 'Iterator') -> 'Iterator':
        """public static <T> java.util.Iterator<T> com.google.common.collect.Iterators.concat(java.util.Iterator<? extends java.util.Iterator<? extends T>>)"""
        return Iterator.__wrap(__Iterators.concat(inputs))

    @staticmethod
    @overload
    def elementsEqual(iterator1: 'Iterator', iterator2: 'Iterator') -> bool:
        """public static boolean com.google.common.collect.Iterators.elementsEqual(java.util.Iterator<?>,java.util.Iterator<?>)"""
        return bool.__wrap(__Iterators.elementsEqual(iterator1, iterator2))

    @staticmethod
    @overload
    def advance(iterator: 'Iterator', numberToAdvance: int) -> int:
        """public static int com.google.common.collect.Iterators.advance(java.util.Iterator<?>,int)"""
        return int.__wrap(__Iterators.advance(iterator, __int.valueOf(numberToAdvance)))

    @staticmethod
    @overload
    def getOnlyElement(iterator: 'Iterator') -> object:
        """public static <T> T com.google.common.collect.Iterators.getOnlyElement(java.util.Iterator<T>)"""
        return object.__wrap(__Iterators.getOnlyElement(iterator))

    @staticmethod
    @overload
    def peekingIterator(iterator: 'Iterator') -> 'PeekingIterator':
        """public static <T> com.google.common.collect.PeekingIterator<T> com.google.common.collect.Iterators.peekingIterator(java.util.Iterator<? extends T>)"""
        return PeekingIterator.__wrap(__Iterators.peekingIterator(iterator))

    @staticmethod
    @overload
    def find(iterator: 'Iterator', predicate: 'Predicate', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterators.find(java.util.Iterator<? extends T>,com.google.common.base.Predicate<? super T>,T)"""
        return object.__wrap(__Iterators.find(iterator, predicate, defaultValue)) 
 
 
# CLASS: com.google.common.collect.EvictingQueue
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Collection as Collection
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingQueue as __ForwardingQueue
__ForwardingQueue = __ForwardingQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import com.google.common.collect.EvictingQueue as __EvictingQueue
__EvictingQueue = __EvictingQueue
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class EvictingQueue():
    """com.google.common.collect.EvictingQueue"""
 
    @staticmethod
    def __wrap(java_value: __EvictingQueue) -> 'EvictingQueue':
        return EvictingQueue(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __EvictingQueue):
        """
        Dynamic initializer for EvictingQueue.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.EvictingQueue.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__EvictingQueue, self).addAll(collection))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.poll()"""
        return object.__wrap(super(ForwardingQueue, self).poll())

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.peek()"""
        return object.__wrap(super(ForwardingQueue, self).peek())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def remove(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.remove()"""
        return object.__wrap(super(ForwardingQueue, self).remove())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @overload
    def offer(self, e: object) -> bool:
        """public boolean com.google.common.collect.EvictingQueue.offer(E)"""
        return bool.__wrap(super(__EvictingQueue, self).offer(e))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def remainingCapacity(self) -> int:
        """public int com.google.common.collect.EvictingQueue.remainingCapacity()"""
        return int.__wrap(super(EvictingQueue, self).remainingCapacity())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'.__wrap(super(Collection, self).spliterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @staticmethod
    @overload
    def create(maxSize: int) -> 'EvictingQueue':
        """public static <E> com.google.common.collect.EvictingQueue<E> com.google.common.collect.EvictingQueue.create(int)"""
        return EvictingQueue.__wrap(__EvictingQueue.create(__int.valueOf(maxSize)))

    @override
    @overload
    def element(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.element()"""
        return object.__wrap(super(ForwardingQueue, self).element())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.EvictingQueue.toArray()"""
        return List[object].__wrap(super(EvictingQueue, self).toArray())

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @overload
    def add(self, e: object) -> bool:
        """public boolean com.google.common.collect.EvictingQueue.add(E)"""
        return bool.__wrap(super(__EvictingQueue, self).add(e))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection)) 
 
 
# CLASS: com.google.common.collect.Iterables
from pyquantum_helper import import_once as __import_once__
try:
    from pygcommon import base
except ImportError:
    base = __import_once__("pygcommon.base")

from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.lang.Iterable as Iterable
import java.util.Collection as Collection
from builtins import object
from typing import List
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.Iterables as __Iterables
__Iterables = __Iterables
import java.lang.Integer as __int
from builtins import bool
import com.google.common.base.Optional as __Optional
__Optional = __Optional
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class Iterables():
    """com.google.common.collect.Iterables"""
 
    @staticmethod
    def __wrap(java_value: __Iterables) -> 'Iterables':
        return Iterables(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __Iterables):
        """
        Dynamic initializer for Iterables.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @staticmethod
    @overload
    def frequency(iterable: 'Iterable', element: object) -> int:
        """public static int com.google.common.collect.Iterables.frequency(java.lang.Iterable<?>,java.lang.Object)"""
        return int.__wrap(__Iterables.frequency(iterable, element))

    @staticmethod
    @overload
    def size(iterable: 'Iterable') -> int:
        """public static int com.google.common.collect.Iterables.size(java.lang.Iterable<?>)"""
        return int.__wrap(__Iterables.size(iterable))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def partition(iterable: 'Iterable', size: int) -> 'Iterable':
        """public static <T> java.lang.Iterable<java.util.List<T>> com.google.common.collect.Iterables.partition(java.lang.Iterable<T>,int)"""
        return Iterable.__wrap(__Iterables.partition(iterable, __int.valueOf(size)))

    @staticmethod
    @overload
    def get(iterable: 'Iterable', position: int) -> object:
        """public static <T> T com.google.common.collect.Iterables.get(java.lang.Iterable<T>,int)"""
        return object.__wrap(__Iterables.get(iterable, __int.valueOf(position)))

    @staticmethod
    @overload
    def get(iterable: 'Iterable', position: int, defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.get(java.lang.Iterable<? extends T>,int,T)"""
        return object.__wrap(__Iterables.get(iterable, __int.valueOf(position), defaultValue))

    @staticmethod
    @overload
    def any(iterable: 'Iterable', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterables.any(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return bool.__wrap(__Iterables.any(iterable, predicate))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable', c: 'Iterable', d: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return Iterable.__wrap(__Iterables.concat(a, b, c, d))

    @staticmethod
    @overload
    def skip(iterable: 'Iterable', numberToSkip: int) -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.skip(java.lang.Iterable<T>,int)"""
        return Iterable.__wrap(__Iterables.skip(iterable, __int.valueOf(numberToSkip)))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def getFirst(iterable: 'Iterable', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.getFirst(java.lang.Iterable<? extends T>,T)"""
        return object.__wrap(__Iterables.getFirst(iterable, defaultValue))

    @staticmethod
    @overload
    def concat(inputs: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends java.lang.Iterable<? extends T>>)"""
        return Iterable.__wrap(__Iterables.concat(inputs))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return Iterable.__wrap(__Iterables.concat(a, b))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @staticmethod
    @overload
    def getOnlyElement(iterable: 'Iterable', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.getOnlyElement(java.lang.Iterable<? extends T>,T)"""
        return object.__wrap(__Iterables.getOnlyElement(iterable, defaultValue))

    @staticmethod
    @overload
    def retainAll(removeFrom: 'Iterable', elementsToRetain: 'Collection') -> bool:
        """public static boolean com.google.common.collect.Iterables.retainAll(java.lang.Iterable<?>,java.util.Collection<?>)"""
        return bool.__wrap(__Iterables.retainAll(removeFrom, elementsToRetain))

    @staticmethod
    @overload
    def consumingIterable(iterable: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.consumingIterable(java.lang.Iterable<T>)"""
        return Iterable.__wrap(__Iterables.consumingIterable(iterable))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def limit(iterable: 'Iterable', limitSize: int) -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.limit(java.lang.Iterable<T>,int)"""
        return Iterable.__wrap(__Iterables.limit(iterable, __int.valueOf(limitSize)))

    @staticmethod
    @overload
    def cycle(iterable: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.cycle(java.lang.Iterable<T>)"""
        return Iterable.__wrap(__Iterables.cycle(iterable))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def find(iterable: 'Iterable', predicate: 'Predicate', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.find(java.lang.Iterable<? extends T>,com.google.common.base.Predicate<? super T>,T)"""
        return object.__wrap(__Iterables.find(iterable, predicate, defaultValue))

    @staticmethod
    @overload
    def getOnlyElement(iterable: 'Iterable') -> object:
        """public static <T> T com.google.common.collect.Iterables.getOnlyElement(java.lang.Iterable<T>)"""
        return object.__wrap(__Iterables.getOnlyElement(iterable))

    @staticmethod
    @overload
    def indexOf(iterable: 'Iterable', predicate: 'Predicate') -> int:
        """public static <T> int com.google.common.collect.Iterables.indexOf(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return int.__wrap(__Iterables.indexOf(iterable, predicate))

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def unmodifiableIterable(iterable: 'ImmutableCollection') -> 'Iterable':
        """public static <E> java.lang.Iterable<E> com.google.common.collect.Iterables.unmodifiableIterable(com.google.common.collect.ImmutableCollection<E>)"""
        return Iterable.__wrap(__Iterables.unmodifiableIterable(iterable))

    @staticmethod
    @overload
    def getLast(iterable: 'Iterable', defaultValue: object) -> object:
        """public static <T> T com.google.common.collect.Iterables.getLast(java.lang.Iterable<? extends T>,T)"""
        return object.__wrap(__Iterables.getLast(iterable, defaultValue))

    @staticmethod
    @overload
    def toArray(iterable: 'Iterable', type: 'Class') -> List[object]:
        """public static <T> T[] com.google.common.collect.Iterables.toArray(java.lang.Iterable<? extends T>,java.lang.Class<T>)"""
        return List[object].__wrap(__Iterables.toArray(iterable, type))

    @staticmethod
    @overload
    def filter(unfiltered: 'Iterable', desiredType: 'Class') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.filter(java.lang.Iterable<?>,java.lang.Class<T>)"""
        return Iterable.__wrap(__Iterables.filter(unfiltered, desiredType))

    @staticmethod
    @overload
    def all(iterable: 'Iterable', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterables.all(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return bool.__wrap(__Iterables.all(iterable, predicate))

    @staticmethod
    @overload
    def removeIf(removeFrom: 'Iterable', predicate: 'Predicate') -> bool:
        """public static <T> boolean com.google.common.collect.Iterables.removeIf(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return bool.__wrap(__Iterables.removeIf(removeFrom, predicate))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @staticmethod
    @overload
    def filter(unfiltered: 'Iterable', retainIfTrue: 'Predicate') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.filter(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return Iterable.__wrap(__Iterables.filter(unfiltered, retainIfTrue))

    @staticmethod
    @overload
    def find(iterable: 'Iterable', predicate: 'Predicate') -> object:
        """public static <T> T com.google.common.collect.Iterables.find(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return object.__wrap(__Iterables.find(iterable, predicate))

    @staticmethod
    @overload
    def concat(a: 'Iterable', b: 'Iterable', c: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>,java.lang.Iterable<? extends T>)"""
        return Iterable.__wrap(__Iterables.concat(a, b, c))

    @staticmethod
    @overload
    def getLast(iterable: 'Iterable') -> object:
        """public static <T> T com.google.common.collect.Iterables.getLast(java.lang.Iterable<T>)"""
        return object.__wrap(__Iterables.getLast(iterable))

    @staticmethod
    @overload
    def unmodifiableIterable(iterable: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.unmodifiableIterable(java.lang.Iterable<? extends T>)"""
        return Iterable.__wrap(__Iterables.unmodifiableIterable(iterable))

    @staticmethod
    @overload
    def isEmpty(iterable: 'Iterable') -> bool:
        """public static boolean com.google.common.collect.Iterables.isEmpty(java.lang.Iterable<?>)"""
        return bool.__wrap(__Iterables.isEmpty(iterable))

    @staticmethod
    @overload
    def elementsEqual(iterable1: 'Iterable', iterable2: 'Iterable') -> bool:
        """public static boolean com.google.common.collect.Iterables.elementsEqual(java.lang.Iterable<?>,java.lang.Iterable<?>)"""
        return bool.__wrap(__Iterables.elementsEqual(iterable1, iterable2))

    @staticmethod
    @overload
    def addAll(addTo: 'Collection', elementsToAdd: 'Iterable') -> bool:
        """public static <T> boolean com.google.common.collect.Iterables.addAll(java.util.Collection<T>,java.lang.Iterable<? extends T>)"""
        return bool.__wrap(__Iterables.addAll(addTo, elementsToAdd))

    @staticmethod
    @overload
    def removeAll(removeFrom: 'Iterable', elementsToRemove: 'Collection') -> bool:
        """public static boolean com.google.common.collect.Iterables.removeAll(java.lang.Iterable<?>,java.util.Collection<?>)"""
        return bool.__wrap(__Iterables.removeAll(removeFrom, elementsToRemove))

    @staticmethod
    @overload
    def cycle(*elements: object) -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.cycle(T...)"""
        return Iterable.__wrap(__Iterables.cycle(elements))

    @staticmethod
    @overload
    def tryFind(iterable: 'Iterable', predicate: 'Predicate') -> 'base.Optional':
        """public static <T> com.google.common.base.Optional<T> com.google.common.collect.Iterables.tryFind(java.lang.Iterable<T>,com.google.common.base.Predicate<? super T>)"""
        return base.Optional.__wrap(__Iterables.tryFind(iterable, predicate))

    @staticmethod
    @overload
    def paddedPartition(iterable: 'Iterable', size: int) -> 'Iterable':
        """public static <T> java.lang.Iterable<java.util.List<T>> com.google.common.collect.Iterables.paddedPartition(java.lang.Iterable<T>,int)"""
        return Iterable.__wrap(__Iterables.paddedPartition(iterable, __int.valueOf(size)))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @staticmethod
    @overload
    def concat(*inputs: 'Iterable') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.concat(java.lang.Iterable<? extends T>...)"""
        return Iterable.__wrap(__Iterables.concat(inputs))

    @staticmethod
    @overload
    def transform(fromIterable: 'Iterable', function: 'Function') -> 'Iterable':
        """public static <F,T> java.lang.Iterable<T> com.google.common.collect.Iterables.transform(java.lang.Iterable<F>,com.google.common.base.Function<? super F, ? extends T>)"""
        return Iterable.__wrap(__Iterables.transform(fromIterable, function))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def mergeSorted(iterables: 'Iterable', comparator: 'Comparator') -> 'Iterable':
        """public static <T> java.lang.Iterable<T> com.google.common.collect.Iterables.mergeSorted(java.lang.Iterable<? extends java.lang.Iterable<? extends T>>,java.util.Comparator<? super T>)"""
        return Iterable.__wrap(__Iterables.mergeSorted(iterables, comparator))

    @staticmethod
    @overload
    def contains(iterable: 'Iterable', element: object) -> bool:
        """public static boolean com.google.common.collect.Iterables.contains(java.lang.Iterable<?>,java.lang.Object)"""
        return bool.__wrap(__Iterables.contains(iterable, element))

    @staticmethod
    @overload
    def toString(iterable: 'Iterable') -> str:
        """public static java.lang.String com.google.common.collect.Iterables.toString(java.lang.Iterable<?>)"""
        return str.__wrap(__Iterables.toString(iterable)) 
 
 
# CLASS: com.google.common.collect.EnumHashBiMap
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import com.google.common.collect.EnumHashBiMap as __EnumHashBiMap
__EnumHashBiMap = __EnumHashBiMap
from builtins import type
import java.util.Map as __Map
__Map = __Map
import com.google.common.collect.ForwardingMap as __ForwardingMap
__ForwardingMap = __ForwardingMap
from builtins import object
import java.util.function.BiFunction as BiFunction
import java.lang.Enum as Enum
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.function.BiConsumer as BiConsumer
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
import java.util.function.Function as Function
import java.util.Map as Map
from builtins import bool
from builtins import int
 
class EnumHashBiMap():
    """com.google.common.collect.EnumHashBiMap"""
 
    @staticmethod
    def __wrap(java_value: __EnumHashBiMap) -> 'EnumHashBiMap':
        return EnumHashBiMap(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __EnumHashBiMap):
        """
        Dynamic initializer for EnumHashBiMap.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def hashCode(self) -> int:
        """public int com.google.common.collect.ForwardingMap.hashCode()"""
        return int.__wrap(super(ForwardingMap, self).hashCode())

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.isEmpty()"""
        return bool.__wrap(super(ForwardingMap, self).isEmpty())

    @overload
    def merge(self, arg0: object, arg1: object, arg2: 'BiFunction') -> object:
        """public default V java.util.Map.merge(K,V,java.util.function.BiFunction<? super V, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).merge(arg0, arg1, arg2))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def put(self, key: 'Enum', value: object) -> object:
        """public V com.google.common.collect.EnumHashBiMap.put(K,V)"""
        return object.__wrap(super(__EnumHashBiMap, self).put(key, value))

    @overload
    def getOrDefault(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.getOrDefault(java.lang.Object,V)"""
        return object.__wrap(super(__Map, self).getOrDefault(arg0, arg1))

    @overload
    def replace(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.replace(K,V)"""
        return object.__wrap(super(__Map, self).replace(arg0, arg1))

    @staticmethod
    @overload
    def create(keyType: 'Class') -> 'EnumHashBiMap':
        """public static <K extends java.lang.Enum<K>,V> com.google.common.collect.EnumHashBiMap<K, V> com.google.common.collect.EnumHashBiMap.create(java.lang.Class<K>)"""
        return EnumHashBiMap.__wrap(__EnumHashBiMap.create(keyType))

    @overload
    def equals(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.equals(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).equals(object))

    @overload
    def forcePut(self, key: 'Enum', value: object) -> object:
        """public V com.google.common.collect.EnumHashBiMap.forcePut(K,V)"""
        return object.__wrap(super(__EnumHashBiMap, self).forcePut(key, value))

    @overload
    def putIfAbsent(self, arg0: object, arg1: object) -> object:
        """public default V java.util.Map.putIfAbsent(K,V)"""
        return object.__wrap(super(__Map, self).putIfAbsent(arg0, arg1))

    @override
    @overload
    def forEach(self, arg0: 'BiConsumer'):
        """public default void java.util.Map.forEach(java.util.function.BiConsumer<? super K, ? super V>)"""
        super(__Map, self).forEach(arg0)

    @overload
    def computeIfPresent(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.computeIfPresent(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfPresent(arg0, arg1))

    @staticmethod
    @overload
    def create(map: 'Map') -> 'EnumHashBiMap':
        """public static <K extends java.lang.Enum<K>,V> com.google.common.collect.EnumHashBiMap<K, V> com.google.common.collect.EnumHashBiMap.create(java.util.Map<K, ? extends V>)"""
        return EnumHashBiMap.__wrap(__EnumHashBiMap.create(map))

    @overload
    def compute(self, arg0: object, arg1: 'BiFunction') -> object:
        """public default V java.util.Map.compute(K,java.util.function.BiFunction<? super K, ? super V, ? extends V>)"""
        return object.__wrap(super(__Map, self).compute(arg0, arg1))

    @overload
    def computeIfAbsent(self, arg0: object, arg1: 'Function') -> object:
        """public default V java.util.Map.computeIfAbsent(K,java.util.function.Function<? super K, ? extends V>)"""
        return object.__wrap(super(__Map, self).computeIfAbsent(arg0, arg1))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingMap.size()"""
        return int.__wrap(super(ForwardingMap, self).size())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def keyType(self) -> 'type.Class':
        """public java.lang.Class<K> com.google.common.collect.EnumHashBiMap.keyType()"""
        return 'type.Class'.__wrap(super(EnumHashBiMap, self).keyType())

    @overload
    def remove(self, arg0: object, arg1: object) -> bool:
        """public default boolean java.util.Map.remove(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__Map, self).remove(arg0, arg1))

    @overload
    def get(self, key: object) -> object:
        """public V com.google.common.collect.ForwardingMap.get(java.lang.Object)"""
        return object.__wrap(super(__ForwardingMap, self).get(key))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def replace(self, arg0: object, arg1: object, arg2: object) -> bool:
        """public default boolean java.util.Map.replace(K,V,V)"""
        return bool.__wrap(super(__Map, self).replace(arg0, arg1, arg2))

    @overload
    def containsKey(self, key: object) -> bool:
        """public boolean com.google.common.collect.ForwardingMap.containsKey(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingMap, self).containsKey(key)) 
 
 
# CLASS: com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_SortedSetMultimapBuilder
__SortedSetMultimapBuilder = __MultimapBuilder_SortedSetMultimapBuilder.SortedSetMultimapBuilder
from abc import abstractmethod, ABC
import com.google.common.collect.MultimapBuilder as __MultimapBuilder_MultimapBuilderWithKeys
__MultimapBuilderWithKeys = __MultimapBuilder_MultimapBuilderWithKeys.MultimapBuilderWithKeys
import java.util.Comparator as Comparator
import java.lang.Long as __long
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.MultimapBuilder as __MultimapBuilder
__MultimapBuilder = __MultimapBuilder
import java.lang.String as __String
__String = __String
import com.google.common.collect.SortedSetMultimap as __SortedSetMultimap
__SortedSetMultimap = __SortedSetMultimap
import java.lang.Object as __Object
__Object = __Object
import java.lang.Integer as __int
from builtins import bool
from builtins import int
 
class SortedSetMultimapBuilder(ABC):
    """com.google.common.collect.MultimapBuilder.SortedSetMultimapBuilder"""
 
    @staticmethod
    def __wrap(java_value: __SortedSetMultimapBuilder) -> 'SortedSetMultimapBuilder':
        return SortedSetMultimapBuilder(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __SortedSetMultimapBuilder):
        """
        Dynamic initializer for SortedSetMultimapBuilder.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String java.lang.Object.toString()"""
        return str.__wrap(super(object, self).toString())

    @staticmethod
    @overload
    def hashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys(int)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.hashKeys(__int.valueOf(expectedKeys)))

    @staticmethod
    @overload
    def hashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.hashKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.hashKeys())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @staticmethod
    @overload
    def treeKeys(comparator: 'Comparator') -> 'MultimapBuilderWithKeys':
        """public static <K0> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.treeKeys(java.util.Comparator<K0>)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.treeKeys(comparator))

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @abstractmethod
    def build(self, ):
        """public abstract <K extends K0,V extends V0> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder.build()"""
        pass

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def treeKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Comparable> com.google.common.collect.MultimapBuilder.treeKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.treeKeys())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @staticmethod
    @overload
    def linkedHashKeys() -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys()"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.linkedHashKeys())

    @staticmethod
    @overload
    def enumKeys(keyClass: 'Class') -> 'MultimapBuilderWithKeys':
        """public static <K0 extends java.lang.Enum<K0>> com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<K0> com.google.common.collect.MultimapBuilder.enumKeys(java.lang.Class<K0>)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.enumKeys(keyClass))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @overload
    def build(self, multimap: 'Multimap') -> 'SortedSetMultimap':
        """public <K extends K0,V extends V0> com.google.common.collect.SortedSetMultimap<K, V> com.google.common.collect.MultimapBuilder$SortedSetMultimapBuilder.build(com.google.common.collect.Multimap<? extends K, ? extends V>)"""
        return 'SortedSetMultimap'.__wrap(super(__SortedSetMultimapBuilder, self).build(multimap))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @staticmethod
    @overload
    def linkedHashKeys(expectedKeys: int) -> 'MultimapBuilderWithKeys':
        """public static com.google.common.collect.MultimapBuilder$MultimapBuilderWithKeys<java.lang.Object> com.google.common.collect.MultimapBuilder.linkedHashKeys(int)"""
        return MultimapBuilderWithKeys.__wrap(__MultimapBuilder.linkedHashKeys(__int.valueOf(expectedKeys)))

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0)) 
 
 
# CLASS: com.google.common.collect.ForwardingBlockingDeque
import java.util.function.Predicate as Predicate
import com.google.common.collect.ForwardingCollection as __ForwardingCollection
__ForwardingCollection = __ForwardingCollection
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import java.util.Deque as __Deque
__Deque = __Deque
import java.util.Collection as Collection
import com.google.common.collect.ForwardingDeque as __ForwardingDeque
__ForwardingDeque = __ForwardingDeque
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.ForwardingBlockingDeque as __ForwardingBlockingDeque
__ForwardingBlockingDeque = __ForwardingBlockingDeque
import com.google.common.collect.ForwardingQueue as __ForwardingQueue
__ForwardingQueue = __ForwardingQueue
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.Iterator as __Iterator
__Iterator = __Iterator
import java.util.function.IntFunction as IntFunction
import java.util.Deque as Deque
from builtins import object
import java.util.Iterator as Iterator
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import com.google.common.collect.ForwardingObject as __ForwardingObject
__ForwardingObject = __ForwardingObject
import java.util.concurrent.TimeUnit as TimeUnit
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
import java.lang.Iterable as __Iterable
__Iterable = __Iterable
 
class ForwardingBlockingDeque(ABC):
    """com.google.common.collect.ForwardingBlockingDeque"""
 
    @staticmethod
    def __wrap(java_value: __ForwardingBlockingDeque) -> 'ForwardingBlockingDeque':
        return ForwardingBlockingDeque(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ForwardingBlockingDeque):
        """
        Dynamic initializer for ForwardingBlockingDeque.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def pollFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pollFirst()"""
        return object.__wrap(super(ForwardingDeque, self).pollFirst())

    @overload
    def offerFirst(self, e: object, timeout: int, unit: 'TimeUnit') -> bool:
        """public boolean com.google.common.collect.ForwardingBlockingDeque.offerFirst(E,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return bool.__wrap(super(__ForwardingBlockingDeque, self).offerFirst(e, __long.valueOf(timeout), unit))

    @override
    @overload
    def size(self) -> int:
        """public int com.google.common.collect.ForwardingCollection.size()"""
        return int.__wrap(super(ForwardingCollection, self).size())

    @override
    @overload
    def put(self, e: object):
        """public void com.google.common.collect.ForwardingBlockingDeque.put(E) throws java.lang.InterruptedException"""
        super(__ForwardingBlockingDeque, self).put(e)

    @override
    @overload
    def toString(self) -> str:
        """public java.lang.String com.google.common.collect.ForwardingObject.toString()"""
        return str.__wrap(super(ForwardingObject, self).toString())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @overload
    def drainTo(self, c: 'Collection') -> int:
        """public int com.google.common.collect.ForwardingBlockingDeque.drainTo(java.util.Collection<? super E>)"""
        return int.__wrap(super(__ForwardingBlockingDeque, self).drainTo(c))

    @override
    @overload
    def remove(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.remove()"""
        return object.__wrap(super(ForwardingQueue, self).remove())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @override
    @overload
    def takeFirst(self) -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.takeFirst() throws java.lang.InterruptedException"""
        return object.__wrap(super(ForwardingBlockingDeque, self).takeFirst())

    @override
    @overload
    def addFirst(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.addFirst(E)"""
        super(__ForwardingDeque, self).addFirst(e)

    @overload
    def offer(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingQueue.offer(E)"""
        return bool.__wrap(super(__ForwardingQueue, self).offer(o))

    @overload
    def toArray(self, array: 'Object') -> List[object]:
        """public <T> T[] com.google.common.collect.ForwardingCollection.toArray(T[])"""
        return List[object].__wrap(super(__ForwardingCollection, self).toArray(array))

    @overload
    def contains(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.contains(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).contains(object))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @override
    @overload
    def descendingIterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingDeque.descendingIterator()"""
        return 'Iterator'.__wrap(super(ForwardingDeque, self).descendingIterator())

    @override
    @overload
    def iterator(self) -> 'Iterator':
        """public java.util.Iterator<E> com.google.common.collect.ForwardingCollection.iterator()"""
        return 'Iterator'.__wrap(super(ForwardingCollection, self).iterator())

    @overload
    def equals(self, arg0: object) -> bool:
        """public boolean java.lang.Object.equals(java.lang.Object)"""
        return bool.__wrap(super(__object, self).equals(arg0))

    @override
    @overload
    def isEmpty(self) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.isEmpty()"""
        return bool.__wrap(super(ForwardingCollection, self).isEmpty())

    @overload
    def retainAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).retainAll(collection))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @overload
    def removeAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).removeAll(collection))

    @overload
    def poll(self, timeout: int, unit: 'TimeUnit') -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.poll(long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return object.__wrap(super(__ForwardingBlockingDeque, self).poll(__long.valueOf(timeout), unit))

    @overload
    def offerLast(self, e: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.offerLast(E)"""
        return bool.__wrap(super(__ForwardingDeque, self).offerLast(e))

    @overload
    def pollFirst(self, timeout: int, unit: 'TimeUnit') -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.pollFirst(long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return object.__wrap(super(__ForwardingBlockingDeque, self).pollFirst(__long.valueOf(timeout), unit))

    @override
    @overload
    def push(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.push(E)"""
        super(__ForwardingDeque, self).push(e)

    @override
    @overload
    def pollLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pollLast()"""
        return object.__wrap(super(ForwardingDeque, self).pollLast())

    @override
    @overload
    def peekFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.peekFirst()"""
        return object.__wrap(super(ForwardingDeque, self).peekFirst())

    @override
    @overload
    def remainingCapacity(self) -> int:
        """public int com.google.common.collect.ForwardingBlockingDeque.remainingCapacity()"""
        return int.__wrap(super(ForwardingBlockingDeque, self).remainingCapacity())

    @overload
    def removeLastOccurrence(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.removeLastOccurrence(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingDeque, self).removeLastOccurrence(o))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @override
    @overload
    def reversed(self) -> 'Deque':
        """public default java.util.Deque<E> java.util.Deque.reversed()"""
        return 'Deque'.__wrap(super(Deque, self).reversed())

    @overload
    def pollLast(self, timeout: int, unit: 'TimeUnit') -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.pollLast(long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return object.__wrap(super(__ForwardingBlockingDeque, self).pollLast(__long.valueOf(timeout), unit))

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @overload
    def offer(self, e: object, timeout: int, unit: 'TimeUnit') -> bool:
        """public boolean com.google.common.collect.ForwardingBlockingDeque.offer(E,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return bool.__wrap(super(__ForwardingBlockingDeque, self).offer(e, __long.valueOf(timeout), unit))

    @override
    @overload
    def putLast(self, e: object):
        """public void com.google.common.collect.ForwardingBlockingDeque.putLast(E) throws java.lang.InterruptedException"""
        super(__ForwardingBlockingDeque, self).putLast(e)

    @override
    @overload
    def pop(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.pop()"""
        return object.__wrap(super(ForwardingDeque, self).pop())

    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def poll(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.poll()"""
        return object.__wrap(super(ForwardingQueue, self).poll())

    @override
    @overload
    def peek(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.peek()"""
        return object.__wrap(super(ForwardingQueue, self).peek())

    @override
    @overload
    def clear(self):
        """public void com.google.common.collect.ForwardingCollection.clear()"""
        super(ForwardingCollection, self).clear()

    @overload
    def drainTo(self, c: 'Collection', maxElements: int) -> int:
        """public int com.google.common.collect.ForwardingBlockingDeque.drainTo(java.util.Collection<? super E>,int)"""
        return int.__wrap(super(__ForwardingBlockingDeque, self).drainTo(c, __int.valueOf(maxElements)))

    @override
    @overload
    def hashCode(self) -> int:
        """public native int java.lang.Object.hashCode()"""
        return int.__wrap(super(object, self).hashCode())

    @override
    @overload
    def peekLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.peekLast()"""
        return object.__wrap(super(ForwardingDeque, self).peekLast())

    @overload
    def offerFirst(self, e: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.offerFirst(E)"""
        return bool.__wrap(super(__ForwardingDeque, self).offerFirst(e))

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> java.util.Collection.spliterator()"""
        return 'Spliterator'.__wrap(super(Collection, self).spliterator())

    @override
    @overload
    def forEach(self, arg0: 'Consumer'):
        """public default void java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)"""
        super(__Iterable, self).forEach(arg0)

    @override
    @overload
    def element(self) -> object:
        """public E com.google.common.collect.ForwardingQueue.element()"""
        return object.__wrap(super(ForwardingQueue, self).element())

    @overload
    def addAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__ForwardingCollection, self).addAll(collection))

    @override
    @overload
    def getLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.getLast()"""
        return object.__wrap(super(ForwardingDeque, self).getLast())

    @override
    @overload
    def removeLast(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.removeLast()"""
        return object.__wrap(super(ForwardingDeque, self).removeLast())

    @override
    @overload
    def take(self) -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.take() throws java.lang.InterruptedException"""
        return object.__wrap(super(ForwardingBlockingDeque, self).take())

    @overload
    def offerLast(self, e: object, timeout: int, unit: 'TimeUnit') -> bool:
        """public boolean com.google.common.collect.ForwardingBlockingDeque.offerLast(E,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException"""
        return bool.__wrap(super(__ForwardingBlockingDeque, self).offerLast(e, __long.valueOf(timeout), unit))

    @override
    @overload
    def getFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.getFirst()"""
        return object.__wrap(super(ForwardingDeque, self).getFirst())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] com.google.common.collect.ForwardingCollection.toArray()"""
        return List[object].__wrap(super(ForwardingCollection, self).toArray())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @override
    @overload
    def putFirst(self, e: object):
        """public void com.google.common.collect.ForwardingBlockingDeque.putFirst(E) throws java.lang.InterruptedException"""
        super(__ForwardingBlockingDeque, self).putFirst(e)

    @overload
    def remove(self, object: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.remove(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingCollection, self).remove(object))

    @override
    @overload
    def takeLast(self) -> object:
        """public E com.google.common.collect.ForwardingBlockingDeque.takeLast() throws java.lang.InterruptedException"""
        return object.__wrap(super(ForwardingBlockingDeque, self).takeLast())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def removeFirstOccurrence(self, o: object) -> bool:
        """public boolean com.google.common.collect.ForwardingDeque.removeFirstOccurrence(java.lang.Object)"""
        return bool.__wrap(super(__ForwardingDeque, self).removeFirstOccurrence(o))

    @override
    @overload
    def addLast(self, e: object):
        """public void com.google.common.collect.ForwardingDeque.addLast(E)"""
        super(__ForwardingDeque, self).addLast(e)

    @override
    @overload
    def removeFirst(self) -> object:
        """public E com.google.common.collect.ForwardingDeque.removeFirst()"""
        return object.__wrap(super(ForwardingDeque, self).removeFirst())

    @overload
    def containsAll(self, collection: 'Collection') -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__ForwardingCollection, self).containsAll(collection))

    @overload
    def add(self, element: object) -> bool:
        """public boolean com.google.common.collect.ForwardingCollection.add(E)"""
        return bool.__wrap(super(__ForwardingCollection, self).add(element)) 
 
 
# CLASS: com.google.common.collect.ImmutableTable
from pyquantum_helper import override
import java.lang.Object as __object
from builtins import type
import java.util.stream.Collector as __Collector
__Collector = __Collector
import com.google.common.collect.Table as __Table
__Table = __Table
import com.google.common.collect.ImmutableCollection as __ImmutableCollection
__ImmutableCollection = __ImmutableCollection
import com.google.common.collect.ImmutableSet as __ImmutableSet
__ImmutableSet = __ImmutableSet
import com.google.common.collect.ImmutableTable as __ImmutableTable_Builder
__Builder = __ImmutableTable_Builder.Builder
from builtins import object
from abc import abstractmethod, ABC
import java.util.stream.Collector as Collector
import java.lang.Long as __long
import com.google.common.collect.ImmutableTable as __ImmutableTable
__ImmutableTable = __ImmutableTable
import java.lang.Class as __Class
__Class = __Class
import java.util.function.BinaryOperator as BinaryOperator
import java.lang.Object as __Object
__Object = __Object
import com.google.common.collect.ImmutableMap as __ImmutableMap
__ImmutableMap = __ImmutableMap
import java.util.function.Function as Function
import java.lang.Integer as __int
from builtins import bool
 
class ImmutableTable(ABC):
    """com.google.common.collect.ImmutableTable"""
 
    @staticmethod
    def __wrap(java_value: __ImmutableTable) -> 'ImmutableTable':
        return ImmutableTable(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __ImmutableTable):
        """
        Dynamic initializer for ImmutableTable.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @override
    @overload
    def rowKeySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<R> com.google.common.collect.ImmutableTable.rowKeySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableTable, self).rowKeySet())

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @abstractmethod
    def rowMap(self, ):
        """public abstract com.google.common.collect.ImmutableMap<R, java.util.Map<C, V>> com.google.common.collect.ImmutableTable.rowMap()"""
        pass

    @override
    @overload
    def columnKeySet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<C> com.google.common.collect.ImmutableTable.columnKeySet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableTable, self).columnKeySet())

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @abstractmethod
    def columnMap(self, ):
        """public abstract com.google.common.collect.ImmutableMap<C, java.util.Map<R, V>> com.google.common.collect.ImmutableTable.columnMap()"""
        pass

    @staticmethod
    @overload
    def toImmutableTable(rowFunction: 'Function', columnFunction: 'Function', valueFunction: 'Function', mergeFunction: 'BinaryOperator') -> 'Collector':
        """public static <T,R,C,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableTable<R, C, V>> com.google.common.collect.ImmutableTable.toImmutableTable(java.util.function.Function<? super T, ? extends R>,java.util.function.Function<? super T, ? extends C>,java.util.function.Function<? super T, ? extends V>,java.util.function.BinaryOperator<V>)"""
        return Collector.__wrap(__ImmutableTable.toImmutableTable(rowFunction, columnFunction, valueFunction, mergeFunction))

    @overload
    def row(self, rowKey: object) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<C, V> com.google.common.collect.ImmutableTable.row(R)"""
        return 'ImmutableMap'.__wrap(super(__ImmutableTable, self).row(rowKey))

    @overload
    def contains(self, rowKey: object, columnKey: object) -> bool:
        """public boolean com.google.common.collect.ImmutableTable.contains(java.lang.Object,java.lang.Object)"""
        return bool.__wrap(super(__ImmutableTable, self).contains(rowKey, columnKey))

    @staticmethod
    @overload
    def of() -> 'ImmutableTable':
        """public static <R,C,V> com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable.of()"""
        return ImmutableTable.__wrap(__ImmutableTable.of())

    @staticmethod
    @overload
    def builder() -> 'Builder':
        """public static <R,C,V> com.google.common.collect.ImmutableTable$Builder<R, C, V> com.google.common.collect.ImmutableTable.builder()"""
        return Builder.__wrap(__ImmutableTable.builder())

    @staticmethod
    @overload
    def toImmutableTable(rowFunction: 'Function', columnFunction: 'Function', valueFunction: 'Function') -> 'Collector':
        """public static <T,R,C,V> java.util.stream.Collector<T, ?, com.google.common.collect.ImmutableTable<R, C, V>> com.google.common.collect.ImmutableTable.toImmutableTable(java.util.function.Function<? super T, ? extends R>,java.util.function.Function<? super T, ? extends C>,java.util.function.Function<? super T, ? extends V>)"""
        return Collector.__wrap(__ImmutableTable.toImmutableTable(rowFunction, columnFunction, valueFunction))

    @overload
    def remove(self, rowKey: object, columnKey: object) -> object:
        """public final V com.google.common.collect.ImmutableTable.remove(java.lang.Object,java.lang.Object)"""
        return object.__wrap(super(__ImmutableTable, self).remove(rowKey, columnKey))

    @override
    @overload
    def cellSet(self) -> 'ImmutableSet':
        """public com.google.common.collect.ImmutableSet<com.google.common.collect.Table$Cell<R, C, V>> com.google.common.collect.ImmutableTable.cellSet()"""
        return 'ImmutableSet'.__wrap(super(ImmutableTable, self).cellSet())

    @override
    @overload
    def putAll(self, table: 'Table'):
        """public final void com.google.common.collect.ImmutableTable.putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        super(__ImmutableTable, self).putAll(table)

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def values(self) -> 'ImmutableCollection':
        """public com.google.common.collect.ImmutableCollection<V> com.google.common.collect.ImmutableTable.values()"""
        return 'ImmutableCollection'.__wrap(super(ImmutableTable, self).values())

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @staticmethod
    @overload
    def of(rowKey: object, columnKey: object, value: object) -> 'ImmutableTable':
        """public static <R,C,V> com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable.of(R,C,V)"""
        return ImmutableTable.__wrap(__ImmutableTable.of(rowKey, columnKey, value))

    @overload
    def containsValue(self, value: object) -> bool:
        """public boolean com.google.common.collect.ImmutableTable.containsValue(java.lang.Object)"""
        return bool.__wrap(super(__ImmutableTable, self).containsValue(value))

    @overload
    def column(self, columnKey: object) -> 'ImmutableMap':
        """public com.google.common.collect.ImmutableMap<R, V> com.google.common.collect.ImmutableTable.column(C)"""
        return 'ImmutableMap'.__wrap(super(__ImmutableTable, self).column(columnKey))

    @overload
    def put(self, rowKey: object, columnKey: object, value: object) -> object:
        """public final V com.google.common.collect.ImmutableTable.put(R,C,V)"""
        return object.__wrap(super(__ImmutableTable, self).put(rowKey, columnKey, value))

    @override
    @overload
    def clear(self):
        """public final void com.google.common.collect.ImmutableTable.clear()"""
        super(ImmutableTable, self).clear()

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait()

    @abstractmethod
    def size(self, ):
        """public abstract int com.google.common.collect.Table.size()"""
        pass

    @staticmethod
    @overload
    def copyOf(table: 'Table') -> 'ImmutableTable':
        """public static <R,C,V> com.google.common.collect.ImmutableTable<R, C, V> com.google.common.collect.ImmutableTable.copyOf(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>)"""
        return ImmutableTable.__wrap(__ImmutableTable.copyOf(table)) 
 
 
# CLASS: com.google.common.collect.LinkedHashMultiset
import java.util.function.Predicate as Predicate
from builtins import type
import java.util.stream.Stream as __Stream
__Stream = __Stream
import com.google.common.collect.AbstractMultiset as __AbstractMultiset
__AbstractMultiset = __AbstractMultiset
import java.util.Collection as Collection
import com.google.common.collect.Multiset as __Multiset
__Multiset = __Multiset
import java.util.function.Consumer as Consumer
import java.util.Collection as __Collection
__Collection = __Collection
import java.util.Spliterator as Spliterator
import java.lang.Class as __Class
__Class = __Class
import com.google.common.collect.LinkedHashMultiset as __LinkedHashMultiset
__LinkedHashMultiset = __LinkedHashMultiset
import java.util.AbstractCollection as __AbstractCollection
__AbstractCollection = __AbstractCollection
from builtins import bool
from builtins import str
from pyquantum_helper import override
import java.lang.Object as __object
import java.util.function.IntFunction as IntFunction
import java.lang.Iterable as Iterable
from builtins import object
from typing import List
import java.util.Spliterator as __Spliterator
__Spliterator = __Spliterator
import java.lang.Long as __long
import java.lang.String as __String
__String = __String
import java.lang.Object as __Object
__Object = __Object
import java.util.stream.Stream as Stream
import java.lang.Integer as __int
from builtins import int
 
class LinkedHashMultiset():
    """com.google.common.collect.LinkedHashMultiset"""
 
    @staticmethod
    def __wrap(java_value: __LinkedHashMultiset) -> 'LinkedHashMultiset':
        return LinkedHashMultiset(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __LinkedHashMultiset):
        """
        Dynamic initializer for LinkedHashMultiset.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @override
    @overload
    def wait(self, arg0: int, arg1: int):
        """public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0), __int.valueOf(arg1))

    @staticmethod
    @overload
    def create(elements: 'Iterable') -> 'LinkedHashMultiset':
        """public static <E> com.google.common.collect.LinkedHashMultiset<E> com.google.common.collect.LinkedHashMultiset.create(java.lang.Iterable<? extends E>)"""
        return LinkedHashMultiset.__wrap(__LinkedHashMultiset.create(elements))

    @override
    @overload
    def notifyAll(self):
        """public final native void java.lang.Object.notifyAll()"""
        super(object, self).notifyAll()

    @override
    @overload
    def spliterator(self) -> 'Spliterator':
        """public default java.util.Spliterator<E> com.google.common.collect.Multiset.spliterator()"""
        return 'Spliterator'.__wrap(super(Multiset, self).spliterator())

    @override
    @overload
    def parallelStream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.parallelStream()"""
        return 'Stream'.__wrap(super(Collection, self).parallelStream())

    @overload
    def retainAll(self, elementsToRetain: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.retainAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).retainAll(elementsToRetain))

    @override
    @overload
    def notify(self):
        """public final native void java.lang.Object.notify()"""
        super(object, self).notify()

    @overload
    def equals(self, object: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.equals(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).equals(object))

    @overload
    def containsAll(self, arg0: 'Collection') -> bool:
        """public boolean java.util.AbstractCollection.containsAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractCollection, self).containsAll(arg0))

    @override
    @overload
    def toArray(self) -> List[object]:
        """public java.lang.Object[] java.util.AbstractCollection.toArray()"""
        return List[object].__wrap(super(AbstractCollection, self).toArray())

    @overload
    def add(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.add(E)"""
        return bool.__wrap(super(__AbstractMultiset, self).add(element))

    @overload
    def remove(self, element: object) -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.remove(java.lang.Object)"""
        return bool.__wrap(super(__AbstractMultiset, self).remove(element))

    @overload
    def addAll(self, elementsToAdd: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.addAll(java.util.Collection<? extends E>)"""
        return bool.__wrap(super(__AbstractMultiset, self).addAll(elementsToAdd))

    @overload
    def removeAll(self, elementsToRemove: 'Collection') -> bool:
        """public final boolean com.google.common.collect.AbstractMultiset.removeAll(java.util.Collection<?>)"""
        return bool.__wrap(super(__AbstractMultiset, self).removeAll(elementsToRemove))

    @override
    @overload
    def stream(self) -> 'Stream':
        """public default java.util.stream.Stream<E> java.util.Collection.stream()"""
        return 'Stream'.__wrap(super(Collection, self).stream())

    @override
    @overload
    def forEach(self, action: 'Consumer'):
        """public default void com.google.common.collect.Multiset.forEach(java.util.function.Consumer<? super E>)"""
        super(__Multiset, self).forEach(action)

    @staticmethod
    @overload
    def create(distinctElements: int) -> 'LinkedHashMultiset':
        """public static <E> com.google.common.collect.LinkedHashMultiset<E> com.google.common.collect.LinkedHashMultiset.create(int)"""
        return LinkedHashMultiset.__wrap(__LinkedHashMultiset.create(__int.valueOf(distinctElements)))

    @override
    @overload
    def toString(self) -> str:
        """public final java.lang.String com.google.common.collect.AbstractMultiset.toString()"""
        return str.__wrap(super(AbstractMultiset, self).toString())

    @override
    @overload
    def wait(self, arg0: int):
        """public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"""
        super(__object, self).wait(__long.valueOf(arg0))

    @override
    @overload
    def getClass(self) -> 'type.Class':
        """public final native java.lang.Class<?> java.lang.Object.getClass()"""
        return 'type.Class'.__wrap(super(object, self).getClass())

    @overload
    def toArray(self, arg0: 'IntFunction') -> List[object]:
        """public default <T> T[] java.util.Collection.toArray(java.util.function.IntFunction<T[]>)"""
        return List[object].__wrap(super(__Collection, self).toArray(arg0))

    @overload
    def toArray(self, arg0: 'Object') -> List[object]:
        """public <T> T[] java.util.AbstractCollection.toArray(T[])"""
        return List[object].__wrap(super(__AbstractCollection, self).toArray(arg0))

    @overload
    def removeIf(self, arg0: 'Predicate') -> bool:
        """public default boolean java.util.Collection.removeIf(java.util.function.Predicate<? super E>)"""
        return bool.__wrap(super(__Collection, self).removeIf(arg0))

    @staticmethod
    @overload
    def create() -> 'LinkedHashMultiset':
        """public static <E> com.google.common.collect.LinkedHashMultiset<E> com.google.common.collect.LinkedHashMultiset.create()"""
        return LinkedHashMultiset.__wrap(__LinkedHashMultiset.create())

    @override
    @overload
    def hashCode(self) -> int:
        """public final int com.google.common.collect.AbstractMultiset.hashCode()"""
        return int.__wrap(super(AbstractMultiset, self).hashCode())

    @override
    @overload
    def wait(self):
        """public final void java.lang.Object.wait() throws java.lang.InterruptedException"""
        super(object, self).wait() 
 
 
# CLASS: com.google.common.collect.Streams$FunctionWithIndex
import com.google.common.collect.Streams as __Streams_FunctionWithIndex
__FunctionWithIndex = __Streams_FunctionWithIndex.FunctionWithIndex
from abc import abstractmethod, ABC
 
class FunctionWithIndex(ABC):
    """com.google.common.collect.Streams.FunctionWithIndex"""
 
    @staticmethod
    def __wrap(java_value: __FunctionWithIndex) -> 'FunctionWithIndex':
        return FunctionWithIndex(__dynamic__=java_value)
 
    #
    # DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
    #
    @overload
    def __init__(self, __dynamic__: __FunctionWithIndex):
        """
        Dynamic initializer for FunctionWithIndex.
        WARNING: DO NOT USE THIS. THIS IS FOR THE JAVA WRAPPER ONLY!
 
        :param __dynamic__: The java object to wrap
        """
        self.__dict__ = __dynamic__.__dict__
        self.__wrapper = __dynamic__
 
    def __getattr__(self, name: str):
        return getattr(self.__wrapper, name)
 
    def __setattr__(self, name: str, value: object):
        return setattr(self.__wrapper, name, value)
 
    def __delattr__(self, name: str):
        raise AttributeError("Cannot delete attribute '%s' from %s" % (name, self.__wrapper.__class__.__name__))
 
    @abstractmethod
    def apply(self, from: object, index: int):
        """public abstract R com.google.common.collect.Streams$FunctionWithIndex.apply(T,long)"""
        pass